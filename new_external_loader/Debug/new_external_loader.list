
new_external_loader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000494  24000004  24000004  00010004  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .ARM          00000008  24000498  24000498  00010498  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000004  240004a0  240004a0  000104a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  240004a4  240004a4  000104a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         0000007c  240004a8  240004a8  000104a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000000dc  24000524  24000524  00010524  2**2
                  ALLOC
  6 .text         00020884  24000600  24000600  00010600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .Dev_info     000000c8  24020e84  24020e84  00040e84  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rodata       00000064  24020f4c  24020f4c  00030f4c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 ._user_heap_stack 00000600  24020fb0  24020fb0  00030fb0  2**0
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  00040f4c  2**0
                  CONTENTS, READONLY
 11 .debug_info   0001b68d  00000000  00000000  00040f7a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 00003c55  00000000  00000000  0005c607  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00001728  00000000  00000000  00060260  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_macro  0003a35a  00000000  00000000  00061988  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line   00020fd6  00000000  00000000  0009bce2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    001640fe  00000000  00000000  000bccb8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .comment      00000050  00000000  00000000  00220db6  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 00001538  00000000  00000000  00220e08  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_frame  0000605c  00000000  00000000  00222340  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

24000600 <__do_global_dtors_aux>:
24000600:	b510      	push	{r4, lr}
24000602:	4c05      	ldr	r4, [pc, #20]	; (24000618 <__do_global_dtors_aux+0x18>)
24000604:	7823      	ldrb	r3, [r4, #0]
24000606:	b933      	cbnz	r3, 24000616 <__do_global_dtors_aux+0x16>
24000608:	4b04      	ldr	r3, [pc, #16]	; (2400061c <__do_global_dtors_aux+0x1c>)
2400060a:	b113      	cbz	r3, 24000612 <__do_global_dtors_aux+0x12>
2400060c:	4804      	ldr	r0, [pc, #16]	; (24000620 <__do_global_dtors_aux+0x20>)
2400060e:	f3af 8000 	nop.w
24000612:	2301      	movs	r3, #1
24000614:	7023      	strb	r3, [r4, #0]
24000616:	bd10      	pop	{r4, pc}
24000618:	24000524 	.word	0x24000524
2400061c:	00000000 	.word	0x00000000
24000620:	24020e68 	.word	0x24020e68

24000624 <frame_dummy>:
24000624:	b508      	push	{r3, lr}
24000626:	4b03      	ldr	r3, [pc, #12]	; (24000634 <frame_dummy+0x10>)
24000628:	b11b      	cbz	r3, 24000632 <frame_dummy+0xe>
2400062a:	4903      	ldr	r1, [pc, #12]	; (24000638 <frame_dummy+0x14>)
2400062c:	4803      	ldr	r0, [pc, #12]	; (2400063c <frame_dummy+0x18>)
2400062e:	f3af 8000 	nop.w
24000632:	bd08      	pop	{r3, pc}
24000634:	00000000 	.word	0x00000000
24000638:	24000528 	.word	0x24000528
2400063c:	24020e68 	.word	0x24020e68

24000640 <_stack_init>:
24000640:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
24000644:	4770      	bx	lr
24000646:	bf00      	nop

24000648 <_mainCRTStartup>:
24000648:	4b17      	ldr	r3, [pc, #92]	; (240006a8 <_mainCRTStartup+0x60>)
2400064a:	2b00      	cmp	r3, #0
2400064c:	bf08      	it	eq
2400064e:	4b13      	ldreq	r3, [pc, #76]	; (2400069c <_mainCRTStartup+0x54>)
24000650:	469d      	mov	sp, r3
24000652:	f7ff fff5 	bl	24000640 <_stack_init>
24000656:	2100      	movs	r1, #0
24000658:	468b      	mov	fp, r1
2400065a:	460f      	mov	r7, r1
2400065c:	4813      	ldr	r0, [pc, #76]	; (240006ac <_mainCRTStartup+0x64>)
2400065e:	4a14      	ldr	r2, [pc, #80]	; (240006b0 <_mainCRTStartup+0x68>)
24000660:	1a12      	subs	r2, r2, r0
24000662:	f020 fbf9 	bl	24020e58 <memset>
24000666:	4b0e      	ldr	r3, [pc, #56]	; (240006a0 <_mainCRTStartup+0x58>)
24000668:	2b00      	cmp	r3, #0
2400066a:	d000      	beq.n	2400066e <_mainCRTStartup+0x26>
2400066c:	4798      	blx	r3
2400066e:	4b0d      	ldr	r3, [pc, #52]	; (240006a4 <_mainCRTStartup+0x5c>)
24000670:	2b00      	cmp	r3, #0
24000672:	d000      	beq.n	24000676 <_mainCRTStartup+0x2e>
24000674:	4798      	blx	r3
24000676:	2000      	movs	r0, #0
24000678:	2100      	movs	r1, #0
2400067a:	0004      	movs	r4, r0
2400067c:	000d      	movs	r5, r1
2400067e:	480d      	ldr	r0, [pc, #52]	; (240006b4 <_mainCRTStartup+0x6c>)
24000680:	2800      	cmp	r0, #0
24000682:	d002      	beq.n	2400068a <_mainCRTStartup+0x42>
24000684:	480c      	ldr	r0, [pc, #48]	; (240006b8 <_mainCRTStartup+0x70>)
24000686:	f3af 8000 	nop.w
2400068a:	f020 fbc1 	bl	24020e10 <__libc_init_array>
2400068e:	0020      	movs	r0, r4
24000690:	0029      	movs	r1, r5
24000692:	f000 faaf 	bl	24000bf4 <main>
24000696:	f020 fba7 	bl	24020de8 <exit>
2400069a:	bf00      	nop
2400069c:	00080000 	.word	0x00080000
	...
240006ac:	24000524 	.word	0x24000524
240006b0:	24000600 	.word	0x24000600
	...
240006bc:	240004a8 	.word	0x240004a8
240006c0:	240004a8 	.word	0x240004a8
240006c4:	24000524 	.word	0x24000524
240006c8:	24000524 	.word	0x24000524
240006cc:	24000600 	.word	0x24000600

240006d0 <Init>:
 * @param  None
 * @retval  LOADER_OK = 1   : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int
Init(void) {
240006d0:	b580      	push	{r7, lr}
240006d2:	b086      	sub	sp, #24
240006d4:	af00      	add	r7, sp, #0

    *(uint32_t*)0xE000EDF0 = 0xA05F0000; //enable interrupts in debug
240006d6:	4b26      	ldr	r3, [pc, #152]	; (24000770 <Init+0xa0>)
240006d8:	4a26      	ldr	r2, [pc, #152]	; (24000774 <Init+0xa4>)
240006da:	601a      	str	r2, [r3, #0]


    SystemInit();
240006dc:	f001 f980 	bl	240019e0 <SystemInit>
     * change VTOR setting for other devices
     * SCB->VTOR = 0x20000000 | 0x200;
     *
     * */

    SCB->VTOR = 0x24000000 | 0x200;
240006e0:	4b25      	ldr	r3, [pc, #148]	; (24000778 <Init+0xa8>)
240006e2:	4a26      	ldr	r2, [pc, #152]	; (2400077c <Init+0xac>)
240006e4:	609a      	str	r2, [r3, #8]
240006e6:	2300      	movs	r3, #0
240006e8:	613b      	str	r3, [r7, #16]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240006ea:	693b      	ldr	r3, [r7, #16]
240006ec:	f383 8810 	msr	PRIMASK, r3
}
240006f0:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts

    HAL_Init();
240006f2:	f001 fba1 	bl	24001e38 <HAL_Init>

    SystemClock_Config();
240006f6:	f000 fa91 	bl	24000c1c <SystemClock_Config>

    MX_GPIO_Init();
240006fa:	f000 fa43 	bl	24000b84 <MX_GPIO_Init>

    __HAL_RCC_QSPI_FORCE_RESET();  //completely reset peripheral
240006fe:	4b20      	ldr	r3, [pc, #128]	; (24000780 <Init+0xb0>)
24000700:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24000702:	4a1f      	ldr	r2, [pc, #124]	; (24000780 <Init+0xb0>)
24000704:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
24000708:	67d3      	str	r3, [r2, #124]	; 0x7c
    __HAL_RCC_QSPI_RELEASE_RESET();
2400070a:	4b1d      	ldr	r3, [pc, #116]	; (24000780 <Init+0xb0>)
2400070c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
2400070e:	4a1c      	ldr	r2, [pc, #112]	; (24000780 <Init+0xb0>)
24000710:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
24000714:	67d3      	str	r3, [r2, #124]	; 0x7c

    if (CSP_QUADSPI_Init() != HAL_OK) {
24000716:	f000 fc0f 	bl	24000f38 <CSP_QUADSPI_Init>
2400071a:	4603      	mov	r3, r0
2400071c:	2b00      	cmp	r3, #0
2400071e:	d007      	beq.n	24000730 <Init+0x60>
24000720:	2301      	movs	r3, #1
24000722:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000724:	68fb      	ldr	r3, [r7, #12]
24000726:	f383 8810 	msr	PRIMASK, r3
}
2400072a:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2400072c:	2300      	movs	r3, #0
2400072e:	e01a      	b.n	24000766 <Init+0x96>
    }


    if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK) {
24000730:	f000 fe74 	bl	2400141c <CSP_QSPI_EnableMemoryMappedMode>
24000734:	4603      	mov	r3, r0
24000736:	2b00      	cmp	r3, #0
24000738:	d007      	beq.n	2400074a <Init+0x7a>
2400073a:	2301      	movs	r3, #1
2400073c:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400073e:	68bb      	ldr	r3, [r7, #8]
24000740:	f383 8810 	msr	PRIMASK, r3
}
24000744:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24000746:	2300      	movs	r3, #0
24000748:	e00d      	b.n	24000766 <Init+0x96>
    }

    /*Trigger read access before HAL_QSPI_Abort() otherwise abort functionality gets stuck*/
    uint32_t a = *(uint32_t*) 0x90000000;
2400074a:	f04f 4310 	mov.w	r3, #2415919104	; 0x90000000
2400074e:	681b      	ldr	r3, [r3, #0]
24000750:	617b      	str	r3, [r7, #20]
    a++;
24000752:	697b      	ldr	r3, [r7, #20]
24000754:	3301      	adds	r3, #1
24000756:	617b      	str	r3, [r7, #20]
24000758:	2301      	movs	r3, #1
2400075a:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400075c:	687b      	ldr	r3, [r7, #4]
2400075e:	f383 8810 	msr	PRIMASK, r3
}
24000762:	bf00      	nop

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
24000764:	2301      	movs	r3, #1
}
24000766:	4618      	mov	r0, r3
24000768:	3718      	adds	r7, #24
2400076a:	46bd      	mov	sp, r7
2400076c:	bd80      	pop	{r7, pc}
2400076e:	bf00      	nop
24000770:	e000edf0 	.word	0xe000edf0
24000774:	a05f0000 	.word	0xa05f0000
24000778:	e000ed00 	.word	0xe000ed00
2400077c:	24000200 	.word	0x24000200
24000780:	58024400 	.word	0x58024400

24000784 <Write>:
 * @param   buffer : pointer to data buffer
 * @retval  LOADER_OK = 1       : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int
Write(uint32_t Address, uint32_t Size, uint8_t* buffer) {
24000784:	b580      	push	{r7, lr}
24000786:	b088      	sub	sp, #32
24000788:	af00      	add	r7, sp, #0
2400078a:	60f8      	str	r0, [r7, #12]
2400078c:	60b9      	str	r1, [r7, #8]
2400078e:	607a      	str	r2, [r7, #4]
24000790:	2300      	movs	r3, #0
24000792:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000794:	69fb      	ldr	r3, [r7, #28]
24000796:	f383 8810 	msr	PRIMASK, r3
}
2400079a:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts

    if (HAL_QSPI_Abort(&hqspi) != HAL_OK) {
2400079c:	4815      	ldr	r0, [pc, #84]	; (240007f4 <Write+0x70>)
2400079e:	f012 f968 	bl	24012a72 <HAL_QSPI_Abort>
240007a2:	4603      	mov	r3, r0
240007a4:	2b00      	cmp	r3, #0
240007a6:	d007      	beq.n	240007b8 <Write+0x34>
240007a8:	2301      	movs	r3, #1
240007aa:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240007ac:	69bb      	ldr	r3, [r7, #24]
240007ae:	f383 8810 	msr	PRIMASK, r3
}
240007b2:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240007b4:	2300      	movs	r3, #0
240007b6:	e019      	b.n	240007ec <Write+0x68>
    }


    if (CSP_QSPI_WriteMemory((uint8_t*) buffer, (Address & (0x0fffffff)), Size) != HAL_OK) {
240007b8:	68fb      	ldr	r3, [r7, #12]
240007ba:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
240007be:	68ba      	ldr	r2, [r7, #8]
240007c0:	4619      	mov	r1, r3
240007c2:	6878      	ldr	r0, [r7, #4]
240007c4:	f000 fd9a 	bl	240012fc <CSP_QSPI_WriteMemory>
240007c8:	4603      	mov	r3, r0
240007ca:	2b00      	cmp	r3, #0
240007cc:	d007      	beq.n	240007de <Write+0x5a>
240007ce:	2301      	movs	r3, #1
240007d0:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240007d2:	697b      	ldr	r3, [r7, #20]
240007d4:	f383 8810 	msr	PRIMASK, r3
}
240007d8:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240007da:	2300      	movs	r3, #0
240007dc:	e006      	b.n	240007ec <Write+0x68>
240007de:	2301      	movs	r3, #1
240007e0:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240007e2:	693b      	ldr	r3, [r7, #16]
240007e4:	f383 8810 	msr	PRIMASK, r3
}
240007e8:	bf00      	nop
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
240007ea:	2301      	movs	r3, #1
}
240007ec:	4618      	mov	r0, r3
240007ee:	3720      	adds	r7, #32
240007f0:	46bd      	mov	sp, r7
240007f2:	bd80      	pop	{r7, pc}
240007f4:	24000540 	.word	0x24000540

240007f8 <SectorErase>:
 * @param   EraseEndAddress   :  erase end address
 * @retval  LOADER_OK = 1       : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int
SectorErase(uint32_t EraseStartAddress, uint32_t EraseEndAddress) {
240007f8:	b580      	push	{r7, lr}
240007fa:	b086      	sub	sp, #24
240007fc:	af00      	add	r7, sp, #0
240007fe:	6078      	str	r0, [r7, #4]
24000800:	6039      	str	r1, [r7, #0]
24000802:	2300      	movs	r3, #0
24000804:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000806:	697b      	ldr	r3, [r7, #20]
24000808:	f383 8810 	msr	PRIMASK, r3
}
2400080c:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts

    if (HAL_QSPI_Abort(&hqspi) != HAL_OK) {
2400080e:	4814      	ldr	r0, [pc, #80]	; (24000860 <SectorErase+0x68>)
24000810:	f012 f92f 	bl	24012a72 <HAL_QSPI_Abort>
24000814:	4603      	mov	r3, r0
24000816:	2b00      	cmp	r3, #0
24000818:	d007      	beq.n	2400082a <SectorErase+0x32>
2400081a:	2301      	movs	r3, #1
2400081c:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400081e:	693b      	ldr	r3, [r7, #16]
24000820:	f383 8810 	msr	PRIMASK, r3
}
24000824:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24000826:	2300      	movs	r3, #0
24000828:	e015      	b.n	24000856 <SectorErase+0x5e>
    }


    if (CSP_QSPI_EraseSector(EraseStartAddress, EraseEndAddress) != HAL_OK) {
2400082a:	6839      	ldr	r1, [r7, #0]
2400082c:	6878      	ldr	r0, [r7, #4]
2400082e:	f000 fd13 	bl	24001258 <CSP_QSPI_EraseSector>
24000832:	4603      	mov	r3, r0
24000834:	2b00      	cmp	r3, #0
24000836:	d007      	beq.n	24000848 <SectorErase+0x50>
24000838:	2301      	movs	r3, #1
2400083a:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400083c:	68fb      	ldr	r3, [r7, #12]
2400083e:	f383 8810 	msr	PRIMASK, r3
}
24000842:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24000844:	2300      	movs	r3, #0
24000846:	e006      	b.n	24000856 <SectorErase+0x5e>
24000848:	2301      	movs	r3, #1
2400084a:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400084c:	68bb      	ldr	r3, [r7, #8]
2400084e:	f383 8810 	msr	PRIMASK, r3
}
24000852:	bf00      	nop
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
24000854:	2301      	movs	r3, #1
}
24000856:	4618      	mov	r0, r3
24000858:	3718      	adds	r7, #24
2400085a:	46bd      	mov	sp, r7
2400085c:	bd80      	pop	{r7, pc}
2400085e:	bf00      	nop
24000860:	24000540 	.word	0x24000540

24000864 <MassErase>:
 * outputs   :
 *     none
 * Note: Optional for all types of device
 */
int
MassErase(void) {
24000864:	b580      	push	{r7, lr}
24000866:	b084      	sub	sp, #16
24000868:	af00      	add	r7, sp, #0
2400086a:	2300      	movs	r3, #0
2400086c:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400086e:	68fb      	ldr	r3, [r7, #12]
24000870:	f383 8810 	msr	PRIMASK, r3
}
24000874:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts

    if (HAL_QSPI_Abort(&hqspi) != HAL_OK) {
24000876:	4813      	ldr	r0, [pc, #76]	; (240008c4 <MassErase+0x60>)
24000878:	f012 f8fb 	bl	24012a72 <HAL_QSPI_Abort>
2400087c:	4603      	mov	r3, r0
2400087e:	2b00      	cmp	r3, #0
24000880:	d007      	beq.n	24000892 <MassErase+0x2e>
24000882:	2301      	movs	r3, #1
24000884:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000886:	68bb      	ldr	r3, [r7, #8]
24000888:	f383 8810 	msr	PRIMASK, r3
}
2400088c:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2400088e:	2300      	movs	r3, #0
24000890:	e013      	b.n	240008ba <MassErase+0x56>
    }


    if (CSP_QSPI_Erase_Chip() != HAL_OK) {
24000892:	f000 fb83 	bl	24000f9c <CSP_QSPI_Erase_Chip>
24000896:	4603      	mov	r3, r0
24000898:	2b00      	cmp	r3, #0
2400089a:	d007      	beq.n	240008ac <MassErase+0x48>
2400089c:	2301      	movs	r3, #1
2400089e:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240008a0:	687b      	ldr	r3, [r7, #4]
240008a2:	f383 8810 	msr	PRIMASK, r3
}
240008a6:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240008a8:	2300      	movs	r3, #0
240008aa:	e006      	b.n	240008ba <MassErase+0x56>
240008ac:	2301      	movs	r3, #1
240008ae:	603b      	str	r3, [r7, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240008b0:	683b      	ldr	r3, [r7, #0]
240008b2:	f383 8810 	msr	PRIMASK, r3
}
240008b6:	bf00      	nop
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
240008b8:	2301      	movs	r3, #1
}
240008ba:	4618      	mov	r0, r3
240008bc:	3710      	adds	r7, #16
240008be:	46bd      	mov	sp, r7
240008c0:	bd80      	pop	{r7, pc}
240008c2:	bf00      	nop
240008c4:	24000540 	.word	0x24000540

240008c8 <CheckSum>:
 * outputs   :
 *     R0             : Checksum value
 * Note: Optional for all types of device
 */
uint32_t
CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal) {
240008c8:	b480      	push	{r7}
240008ca:	b089      	sub	sp, #36	; 0x24
240008cc:	af00      	add	r7, sp, #0
240008ce:	60f8      	str	r0, [r7, #12]
240008d0:	60b9      	str	r1, [r7, #8]
240008d2:	607a      	str	r2, [r7, #4]
    uint8_t missalignementAddress = StartAddress % 4;
240008d4:	68fb      	ldr	r3, [r7, #12]
240008d6:	b2db      	uxtb	r3, r3
240008d8:	f003 0303 	and.w	r3, r3, #3
240008dc:	77fb      	strb	r3, [r7, #31]
    uint8_t missalignementSize = Size;
240008de:	68bb      	ldr	r3, [r7, #8]
240008e0:	77bb      	strb	r3, [r7, #30]
    int cnt;
    uint32_t Val;

    StartAddress -= StartAddress % 4;
240008e2:	68fb      	ldr	r3, [r7, #12]
240008e4:	f023 0303 	bic.w	r3, r3, #3
240008e8:	60fb      	str	r3, [r7, #12]
    Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
240008ea:	68bb      	ldr	r3, [r7, #8]
240008ec:	f003 0303 	and.w	r3, r3, #3
240008f0:	2b00      	cmp	r3, #0
240008f2:	d005      	beq.n	24000900 <CheckSum+0x38>
240008f4:	68bb      	ldr	r3, [r7, #8]
240008f6:	f003 0303 	and.w	r3, r3, #3
240008fa:	f1c3 0304 	rsb	r3, r3, #4
240008fe:	e000      	b.n	24000902 <CheckSum+0x3a>
24000900:	2300      	movs	r3, #0
24000902:	68ba      	ldr	r2, [r7, #8]
24000904:	4413      	add	r3, r2
24000906:	60bb      	str	r3, [r7, #8]

    for (cnt = 0; cnt < Size; cnt += 4) {
24000908:	2300      	movs	r3, #0
2400090a:	61bb      	str	r3, [r7, #24]
2400090c:	e0b3      	b.n	24000a76 <CheckSum+0x1ae>
        Val = *(uint32_t*) StartAddress;
2400090e:	68fb      	ldr	r3, [r7, #12]
24000910:	681b      	ldr	r3, [r3, #0]
24000912:	617b      	str	r3, [r7, #20]
        if (missalignementAddress) {
24000914:	7ffb      	ldrb	r3, [r7, #31]
24000916:	2b00      	cmp	r3, #0
24000918:	d040      	beq.n	2400099c <CheckSum+0xd4>
            switch (missalignementAddress) {
2400091a:	7ffb      	ldrb	r3, [r7, #31]
2400091c:	2b03      	cmp	r3, #3
2400091e:	d032      	beq.n	24000986 <CheckSum+0xbe>
24000920:	2b03      	cmp	r3, #3
24000922:	f300 80a2 	bgt.w	24000a6a <CheckSum+0x1a2>
24000926:	2b01      	cmp	r3, #1
24000928:	d002      	beq.n	24000930 <CheckSum+0x68>
2400092a:	2b02      	cmp	r3, #2
2400092c:	d019      	beq.n	24000962 <CheckSum+0x9a>
2400092e:	e09c      	b.n	24000a6a <CheckSum+0x1a2>
                case 1:
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
24000930:	697b      	ldr	r3, [r7, #20]
24000932:	0a1b      	lsrs	r3, r3, #8
24000934:	b2db      	uxtb	r3, r3
24000936:	461a      	mov	r2, r3
24000938:	687b      	ldr	r3, [r7, #4]
2400093a:	4413      	add	r3, r2
2400093c:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
2400093e:	697b      	ldr	r3, [r7, #20]
24000940:	0c1b      	lsrs	r3, r3, #16
24000942:	b2db      	uxtb	r3, r3
24000944:	461a      	mov	r2, r3
24000946:	687b      	ldr	r3, [r7, #4]
24000948:	4413      	add	r3, r2
2400094a:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
2400094c:	697b      	ldr	r3, [r7, #20]
2400094e:	0e1b      	lsrs	r3, r3, #24
24000950:	b2db      	uxtb	r3, r3
24000952:	461a      	mov	r2, r3
24000954:	687b      	ldr	r3, [r7, #4]
24000956:	4413      	add	r3, r2
24000958:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 1;
2400095a:	7ffb      	ldrb	r3, [r7, #31]
2400095c:	3b01      	subs	r3, #1
2400095e:	77fb      	strb	r3, [r7, #31]
                    break;
24000960:	e083      	b.n	24000a6a <CheckSum+0x1a2>
                case 2:
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
24000962:	697b      	ldr	r3, [r7, #20]
24000964:	0c1b      	lsrs	r3, r3, #16
24000966:	b2db      	uxtb	r3, r3
24000968:	461a      	mov	r2, r3
2400096a:	687b      	ldr	r3, [r7, #4]
2400096c:	4413      	add	r3, r2
2400096e:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
24000970:	697b      	ldr	r3, [r7, #20]
24000972:	0e1b      	lsrs	r3, r3, #24
24000974:	b2db      	uxtb	r3, r3
24000976:	461a      	mov	r2, r3
24000978:	687b      	ldr	r3, [r7, #4]
2400097a:	4413      	add	r3, r2
2400097c:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 2;
2400097e:	7ffb      	ldrb	r3, [r7, #31]
24000980:	3b02      	subs	r3, #2
24000982:	77fb      	strb	r3, [r7, #31]
                    break;
24000984:	e071      	b.n	24000a6a <CheckSum+0x1a2>
                case 3:
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
24000986:	697b      	ldr	r3, [r7, #20]
24000988:	0e1b      	lsrs	r3, r3, #24
2400098a:	b2db      	uxtb	r3, r3
2400098c:	461a      	mov	r2, r3
2400098e:	687b      	ldr	r3, [r7, #4]
24000990:	4413      	add	r3, r2
24000992:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 3;
24000994:	7ffb      	ldrb	r3, [r7, #31]
24000996:	3b03      	subs	r3, #3
24000998:	77fb      	strb	r3, [r7, #31]
                    break;
2400099a:	e066      	b.n	24000a6a <CheckSum+0x1a2>
            }
        } else if ((Size - missalignementSize) % 4 && (Size - cnt) <= 4) {
2400099c:	7fbb      	ldrb	r3, [r7, #30]
2400099e:	68ba      	ldr	r2, [r7, #8]
240009a0:	1ad3      	subs	r3, r2, r3
240009a2:	f003 0303 	and.w	r3, r3, #3
240009a6:	2b00      	cmp	r3, #0
240009a8:	d044      	beq.n	24000a34 <CheckSum+0x16c>
240009aa:	69bb      	ldr	r3, [r7, #24]
240009ac:	68ba      	ldr	r2, [r7, #8]
240009ae:	1ad3      	subs	r3, r2, r3
240009b0:	2b04      	cmp	r3, #4
240009b2:	d83f      	bhi.n	24000a34 <CheckSum+0x16c>
            switch (Size - missalignementSize) {
240009b4:	7fbb      	ldrb	r3, [r7, #30]
240009b6:	68ba      	ldr	r2, [r7, #8]
240009b8:	1ad3      	subs	r3, r2, r3
240009ba:	2b03      	cmp	r3, #3
240009bc:	d02f      	beq.n	24000a1e <CheckSum+0x156>
240009be:	2b03      	cmp	r3, #3
240009c0:	d853      	bhi.n	24000a6a <CheckSum+0x1a2>
240009c2:	2b01      	cmp	r3, #1
240009c4:	d002      	beq.n	240009cc <CheckSum+0x104>
240009c6:	2b02      	cmp	r3, #2
240009c8:	d018      	beq.n	240009fc <CheckSum+0x134>
240009ca:	e04e      	b.n	24000a6a <CheckSum+0x1a2>
                case 1:
                    InitVal += (uint8_t) Val;
240009cc:	697b      	ldr	r3, [r7, #20]
240009ce:	b2db      	uxtb	r3, r3
240009d0:	461a      	mov	r2, r3
240009d2:	687b      	ldr	r3, [r7, #4]
240009d4:	4413      	add	r3, r2
240009d6:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
240009d8:	697b      	ldr	r3, [r7, #20]
240009da:	0a1b      	lsrs	r3, r3, #8
240009dc:	b2db      	uxtb	r3, r3
240009de:	461a      	mov	r2, r3
240009e0:	687b      	ldr	r3, [r7, #4]
240009e2:	4413      	add	r3, r2
240009e4:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
240009e6:	697b      	ldr	r3, [r7, #20]
240009e8:	0c1b      	lsrs	r3, r3, #16
240009ea:	b2db      	uxtb	r3, r3
240009ec:	461a      	mov	r2, r3
240009ee:	687b      	ldr	r3, [r7, #4]
240009f0:	4413      	add	r3, r2
240009f2:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 1;
240009f4:	7fbb      	ldrb	r3, [r7, #30]
240009f6:	3b01      	subs	r3, #1
240009f8:	77bb      	strb	r3, [r7, #30]
                    break;
240009fa:	e01a      	b.n	24000a32 <CheckSum+0x16a>
                case 2:
                    InitVal += (uint8_t) Val;
240009fc:	697b      	ldr	r3, [r7, #20]
240009fe:	b2db      	uxtb	r3, r3
24000a00:	461a      	mov	r2, r3
24000a02:	687b      	ldr	r3, [r7, #4]
24000a04:	4413      	add	r3, r2
24000a06:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
24000a08:	697b      	ldr	r3, [r7, #20]
24000a0a:	0a1b      	lsrs	r3, r3, #8
24000a0c:	b2db      	uxtb	r3, r3
24000a0e:	461a      	mov	r2, r3
24000a10:	687b      	ldr	r3, [r7, #4]
24000a12:	4413      	add	r3, r2
24000a14:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 2;
24000a16:	7fbb      	ldrb	r3, [r7, #30]
24000a18:	3b02      	subs	r3, #2
24000a1a:	77bb      	strb	r3, [r7, #30]
                    break;
24000a1c:	e009      	b.n	24000a32 <CheckSum+0x16a>
                case 3:
                    InitVal += (uint8_t) Val;
24000a1e:	697b      	ldr	r3, [r7, #20]
24000a20:	b2db      	uxtb	r3, r3
24000a22:	461a      	mov	r2, r3
24000a24:	687b      	ldr	r3, [r7, #4]
24000a26:	4413      	add	r3, r2
24000a28:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 3;
24000a2a:	7fbb      	ldrb	r3, [r7, #30]
24000a2c:	3b03      	subs	r3, #3
24000a2e:	77bb      	strb	r3, [r7, #30]
                    break;
24000a30:	bf00      	nop
            switch (Size - missalignementSize) {
24000a32:	e01a      	b.n	24000a6a <CheckSum+0x1a2>
            }
        } else {
            InitVal += (uint8_t) Val;
24000a34:	697b      	ldr	r3, [r7, #20]
24000a36:	b2db      	uxtb	r3, r3
24000a38:	461a      	mov	r2, r3
24000a3a:	687b      	ldr	r3, [r7, #4]
24000a3c:	4413      	add	r3, r2
24000a3e:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 8 & 0xff);
24000a40:	697b      	ldr	r3, [r7, #20]
24000a42:	0a1b      	lsrs	r3, r3, #8
24000a44:	b2db      	uxtb	r3, r3
24000a46:	461a      	mov	r2, r3
24000a48:	687b      	ldr	r3, [r7, #4]
24000a4a:	4413      	add	r3, r2
24000a4c:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 16 & 0xff);
24000a4e:	697b      	ldr	r3, [r7, #20]
24000a50:	0c1b      	lsrs	r3, r3, #16
24000a52:	b2db      	uxtb	r3, r3
24000a54:	461a      	mov	r2, r3
24000a56:	687b      	ldr	r3, [r7, #4]
24000a58:	4413      	add	r3, r2
24000a5a:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 24 & 0xff);
24000a5c:	697b      	ldr	r3, [r7, #20]
24000a5e:	0e1b      	lsrs	r3, r3, #24
24000a60:	b2db      	uxtb	r3, r3
24000a62:	461a      	mov	r2, r3
24000a64:	687b      	ldr	r3, [r7, #4]
24000a66:	4413      	add	r3, r2
24000a68:	607b      	str	r3, [r7, #4]
        }
        StartAddress += 4;
24000a6a:	68fb      	ldr	r3, [r7, #12]
24000a6c:	3304      	adds	r3, #4
24000a6e:	60fb      	str	r3, [r7, #12]
    for (cnt = 0; cnt < Size; cnt += 4) {
24000a70:	69bb      	ldr	r3, [r7, #24]
24000a72:	3304      	adds	r3, #4
24000a74:	61bb      	str	r3, [r7, #24]
24000a76:	69bb      	ldr	r3, [r7, #24]
24000a78:	68ba      	ldr	r2, [r7, #8]
24000a7a:	429a      	cmp	r2, r3
24000a7c:	f63f af47 	bhi.w	2400090e <CheckSum+0x46>
    }

    return (InitVal);
24000a80:	687b      	ldr	r3, [r7, #4]
}
24000a82:	4618      	mov	r0, r3
24000a84:	3724      	adds	r7, #36	; 0x24
24000a86:	46bd      	mov	sp, r7
24000a88:	f85d 7b04 	ldr.w	r7, [sp], #4
24000a8c:	4770      	bx	lr

24000a8e <Verify>:
 *     R0             : Operation failed (address of failure)
 *     R1             : Checksum value
 * Note: Optional for all types of device
 */
uint64_t
Verify(uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size, uint32_t missalignement) {
24000a8e:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
24000a92:	b08c      	sub	sp, #48	; 0x30
24000a94:	af00      	add	r7, sp, #0
24000a96:	60f8      	str	r0, [r7, #12]
24000a98:	60b9      	str	r1, [r7, #8]
24000a9a:	607a      	str	r2, [r7, #4]
24000a9c:	603b      	str	r3, [r7, #0]
24000a9e:	2300      	movs	r3, #0
24000aa0:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000aa2:	69fb      	ldr	r3, [r7, #28]
24000aa4:	f383 8810 	msr	PRIMASK, r3
}
24000aa8:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts
    uint32_t VerifiedData = 0, InitVal = 0;
24000aaa:	2300      	movs	r3, #0
24000aac:	62fb      	str	r3, [r7, #44]	; 0x2c
24000aae:	2300      	movs	r3, #0
24000ab0:	62bb      	str	r3, [r7, #40]	; 0x28
    uint64_t checksum;
    Size *= 4;
24000ab2:	687b      	ldr	r3, [r7, #4]
24000ab4:	009b      	lsls	r3, r3, #2
24000ab6:	607b      	str	r3, [r7, #4]

    if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK) {
24000ab8:	f000 fcb0 	bl	2400141c <CSP_QSPI_EnableMemoryMappedMode>
24000abc:	4603      	mov	r3, r0
24000abe:	2b00      	cmp	r3, #0
24000ac0:	d00a      	beq.n	24000ad8 <Verify+0x4a>
24000ac2:	2301      	movs	r3, #1
24000ac4:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000ac6:	69bb      	ldr	r3, [r7, #24]
24000ac8:	f383 8810 	msr	PRIMASK, r3
}
24000acc:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24000ace:	f04f 0400 	mov.w	r4, #0
24000ad2:	f04f 0500 	mov.w	r5, #0
24000ad6:	e04d      	b.n	24000b74 <Verify+0xe6>
    }

    checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf),
24000ad8:	683b      	ldr	r3, [r7, #0]
24000ada:	f003 020f 	and.w	r2, r3, #15
24000ade:	68fb      	ldr	r3, [r7, #12]
24000ae0:	18d0      	adds	r0, r2, r3
                        Size - ((missalignement >> 16) & 0xF), InitVal);
24000ae2:	683b      	ldr	r3, [r7, #0]
24000ae4:	0c1b      	lsrs	r3, r3, #16
24000ae6:	f003 030f 	and.w	r3, r3, #15
    checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf),
24000aea:	687a      	ldr	r2, [r7, #4]
24000aec:	1ad3      	subs	r3, r2, r3
24000aee:	6aba      	ldr	r2, [r7, #40]	; 0x28
24000af0:	4619      	mov	r1, r3
24000af2:	f7ff fee9 	bl	240008c8 <CheckSum>
24000af6:	4603      	mov	r3, r0
24000af8:	2200      	movs	r2, #0
24000afa:	469a      	mov	sl, r3
24000afc:	4693      	mov	fp, r2
24000afe:	e9c7 ab08 	strd	sl, fp, [r7, #32]
    while (Size > VerifiedData) {
24000b02:	e025      	b.n	24000b50 <Verify+0xc2>
        if (*(uint8_t*) MemoryAddr++
24000b04:	68fb      	ldr	r3, [r7, #12]
24000b06:	1c5a      	adds	r2, r3, #1
24000b08:	60fa      	str	r2, [r7, #12]
24000b0a:	781a      	ldrb	r2, [r3, #0]
            != *((uint8_t*) RAMBufferAddr + VerifiedData)) {
24000b0c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
24000b0e:	68bb      	ldr	r3, [r7, #8]
24000b10:	440b      	add	r3, r1
24000b12:	781b      	ldrb	r3, [r3, #0]
        if (*(uint8_t*) MemoryAddr++
24000b14:	429a      	cmp	r2, r3
24000b16:	d018      	beq.n	24000b4a <Verify+0xbc>
24000b18:	2301      	movs	r3, #1
24000b1a:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000b1c:	697b      	ldr	r3, [r7, #20]
24000b1e:	f383 8810 	msr	PRIMASK, r3
}
24000b22:	bf00      	nop
            __set_PRIMASK(1); //disable interrupts
            return ((checksum << 32) + (MemoryAddr + VerifiedData));
24000b24:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
24000b28:	f04f 0200 	mov.w	r2, #0
24000b2c:	f04f 0300 	mov.w	r3, #0
24000b30:	0003      	movs	r3, r0
24000b32:	2200      	movs	r2, #0
24000b34:	68f8      	ldr	r0, [r7, #12]
24000b36:	6af9      	ldr	r1, [r7, #44]	; 0x2c
24000b38:	4401      	add	r1, r0
24000b3a:	2000      	movs	r0, #0
24000b3c:	4688      	mov	r8, r1
24000b3e:	4681      	mov	r9, r0
24000b40:	eb12 0408 	adds.w	r4, r2, r8
24000b44:	eb43 0509 	adc.w	r5, r3, r9
24000b48:	e014      	b.n	24000b74 <Verify+0xe6>
        }
        VerifiedData++;
24000b4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24000b4c:	3301      	adds	r3, #1
24000b4e:	62fb      	str	r3, [r7, #44]	; 0x2c
    while (Size > VerifiedData) {
24000b50:	687a      	ldr	r2, [r7, #4]
24000b52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24000b54:	429a      	cmp	r2, r3
24000b56:	d8d5      	bhi.n	24000b04 <Verify+0x76>
24000b58:	2301      	movs	r3, #1
24000b5a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000b5c:	693b      	ldr	r3, [r7, #16]
24000b5e:	f383 8810 	msr	PRIMASK, r3
}
24000b62:	bf00      	nop
    }

    __set_PRIMASK(1); //disable interrupts
    return (checksum << 32);
24000b64:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
24000b68:	f04f 0400 	mov.w	r4, #0
24000b6c:	f04f 0500 	mov.w	r5, #0
24000b70:	0015      	movs	r5, r2
24000b72:	2400      	movs	r4, #0
}
24000b74:	4622      	mov	r2, r4
24000b76:	462b      	mov	r3, r5
24000b78:	4610      	mov	r0, r2
24000b7a:	4619      	mov	r1, r3
24000b7c:	3730      	adds	r7, #48	; 0x30
24000b7e:	46bd      	mov	sp, r7
24000b80:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

24000b84 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Pinout Configuration
*/
void MX_GPIO_Init(void)
{
24000b84:	b480      	push	{r7}
24000b86:	b085      	sub	sp, #20
24000b88:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
24000b8a:	4b19      	ldr	r3, [pc, #100]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000b8c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000b90:	4a17      	ldr	r2, [pc, #92]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000b92:	f043 0302 	orr.w	r3, r3, #2
24000b96:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000b9a:	4b15      	ldr	r3, [pc, #84]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000b9c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000ba0:	f003 0302 	and.w	r3, r3, #2
24000ba4:	60fb      	str	r3, [r7, #12]
24000ba6:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
24000ba8:	4b11      	ldr	r3, [pc, #68]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000baa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000bae:	4a10      	ldr	r2, [pc, #64]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000bb0:	f043 0310 	orr.w	r3, r3, #16
24000bb4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000bb8:	4b0d      	ldr	r3, [pc, #52]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000bba:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000bbe:	f003 0310 	and.w	r3, r3, #16
24000bc2:	60bb      	str	r3, [r7, #8]
24000bc4:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
24000bc6:	4b0a      	ldr	r3, [pc, #40]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000bc8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000bcc:	4a08      	ldr	r2, [pc, #32]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000bce:	f043 0304 	orr.w	r3, r3, #4
24000bd2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000bd6:	4b06      	ldr	r3, [pc, #24]	; (24000bf0 <MX_GPIO_Init+0x6c>)
24000bd8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000bdc:	f003 0304 	and.w	r3, r3, #4
24000be0:	607b      	str	r3, [r7, #4]
24000be2:	687b      	ldr	r3, [r7, #4]

}
24000be4:	bf00      	nop
24000be6:	3714      	adds	r7, #20
24000be8:	46bd      	mov	sp, r7
24000bea:	f85d 7b04 	ldr.w	r7, [sp], #4
24000bee:	4770      	bx	lr
24000bf0:	58024400 	.word	0x58024400

24000bf4 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
24000bf4:	b580      	push	{r7, lr}
24000bf6:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
24000bf8:	f001 f91e 	bl	24001e38 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
24000bfc:	f000 f80e 	bl	24000c1c <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
24000c00:	f7ff ffc0 	bl	24000b84 <MX_GPIO_Init>
  MX_QUADSPI_Init();
24000c04:	f000 f888 	bl	24000d18 <MX_QUADSPI_Init>
  /* USER CODE BEGIN 2 */

  /* USER CODE BEGIN 2 */
CSP_QUADSPI_Init();
24000c08:	f000 f996 	bl	24000f38 <CSP_QUADSPI_Init>

      if (CSP_QSPI_EnableMemoryMappedMode()!= HAL_OK) {
24000c0c:	f000 fc06 	bl	2400141c <CSP_QSPI_EnableMemoryMappedMode>
24000c10:	4603      	mov	r3, r0
24000c12:	2b00      	cmp	r3, #0
24000c14:	d000      	beq.n	24000c18 <main+0x24>

          while (1)
24000c16:	e7fe      	b.n	24000c16 <main+0x22>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
24000c18:	e7fe      	b.n	24000c18 <main+0x24>
	...

24000c1c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
24000c1c:	b580      	push	{r7, lr}
24000c1e:	b09c      	sub	sp, #112	; 0x70
24000c20:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
24000c22:	f107 0324 	add.w	r3, r7, #36	; 0x24
24000c26:	224c      	movs	r2, #76	; 0x4c
24000c28:	2100      	movs	r1, #0
24000c2a:	4618      	mov	r0, r3
24000c2c:	f020 f914 	bl	24020e58 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
24000c30:	1d3b      	adds	r3, r7, #4
24000c32:	2220      	movs	r2, #32
24000c34:	2100      	movs	r1, #0
24000c36:	4618      	mov	r0, r3
24000c38:	f020 f90e 	bl	24020e58 <memset>

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_EXTERNAL_SOURCE_SUPPLY);
24000c3c:	2001      	movs	r0, #1
24000c3e:	f010 f91b 	bl	24010e78 <HAL_PWREx_ConfigSupply>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
24000c42:	2300      	movs	r3, #0
24000c44:	603b      	str	r3, [r7, #0]
24000c46:	4b28      	ldr	r3, [pc, #160]	; (24000ce8 <SystemClock_Config+0xcc>)
24000c48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24000c4a:	4a27      	ldr	r2, [pc, #156]	; (24000ce8 <SystemClock_Config+0xcc>)
24000c4c:	f023 0301 	bic.w	r3, r3, #1
24000c50:	62d3      	str	r3, [r2, #44]	; 0x2c
24000c52:	4b25      	ldr	r3, [pc, #148]	; (24000ce8 <SystemClock_Config+0xcc>)
24000c54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24000c56:	f003 0301 	and.w	r3, r3, #1
24000c5a:	603b      	str	r3, [r7, #0]
24000c5c:	4b23      	ldr	r3, [pc, #140]	; (24000cec <SystemClock_Config+0xd0>)
24000c5e:	699b      	ldr	r3, [r3, #24]
24000c60:	4a22      	ldr	r2, [pc, #136]	; (24000cec <SystemClock_Config+0xd0>)
24000c62:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
24000c66:	6193      	str	r3, [r2, #24]
24000c68:	4b20      	ldr	r3, [pc, #128]	; (24000cec <SystemClock_Config+0xd0>)
24000c6a:	699b      	ldr	r3, [r3, #24]
24000c6c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
24000c70:	603b      	str	r3, [r7, #0]
24000c72:	683b      	ldr	r3, [r7, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
24000c74:	bf00      	nop
24000c76:	4b1d      	ldr	r3, [pc, #116]	; (24000cec <SystemClock_Config+0xd0>)
24000c78:	699b      	ldr	r3, [r3, #24]
24000c7a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24000c7e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24000c82:	d1f8      	bne.n	24000c76 <SystemClock_Config+0x5a>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
24000c84:	2302      	movs	r3, #2
24000c86:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
24000c88:	2301      	movs	r3, #1
24000c8a:	633b      	str	r3, [r7, #48]	; 0x30
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
24000c8c:	2340      	movs	r3, #64	; 0x40
24000c8e:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
24000c90:	2300      	movs	r3, #0
24000c92:	64bb      	str	r3, [r7, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
24000c94:	f107 0324 	add.w	r3, r7, #36	; 0x24
24000c98:	4618      	mov	r0, r3
24000c9a:	f012 fbc1 	bl	24013420 <HAL_RCC_OscConfig>
24000c9e:	4603      	mov	r3, r0
24000ca0:	2b00      	cmp	r3, #0
24000ca2:	d001      	beq.n	24000ca8 <SystemClock_Config+0x8c>
  {
    Error_Handler();
24000ca4:	f000 f833 	bl	24000d0e <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
24000ca8:	233f      	movs	r3, #63	; 0x3f
24000caa:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
24000cac:	2300      	movs	r3, #0
24000cae:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
24000cb0:	2300      	movs	r3, #0
24000cb2:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
24000cb4:	2300      	movs	r3, #0
24000cb6:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
24000cb8:	2340      	movs	r3, #64	; 0x40
24000cba:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
24000cbc:	2340      	movs	r3, #64	; 0x40
24000cbe:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
24000cc0:	f44f 6380 	mov.w	r3, #1024	; 0x400
24000cc4:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
24000cc6:	2300      	movs	r3, #0
24000cc8:	623b      	str	r3, [r7, #32]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
24000cca:	1d3b      	adds	r3, r7, #4
24000ccc:	2100      	movs	r1, #0
24000cce:	4618      	mov	r0, r3
24000cd0:	f013 f800 	bl	24013cd4 <HAL_RCC_ClockConfig>
24000cd4:	4603      	mov	r3, r0
24000cd6:	2b00      	cmp	r3, #0
24000cd8:	d001      	beq.n	24000cde <SystemClock_Config+0xc2>
  {
    Error_Handler();
24000cda:	f000 f818 	bl	24000d0e <Error_Handler>
  }
}
24000cde:	bf00      	nop
24000ce0:	3770      	adds	r7, #112	; 0x70
24000ce2:	46bd      	mov	sp, r7
24000ce4:	bd80      	pop	{r7, pc}
24000ce6:	bf00      	nop
24000ce8:	58000400 	.word	0x58000400
24000cec:	58024800 	.word	0x58024800

24000cf0 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
24000cf0:	b580      	push	{r7, lr}
24000cf2:	b082      	sub	sp, #8
24000cf4:	af00      	add	r7, sp, #0
24000cf6:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM2) {
24000cf8:	687b      	ldr	r3, [r7, #4]
24000cfa:	681b      	ldr	r3, [r3, #0]
24000cfc:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24000d00:	d101      	bne.n	24000d06 <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
24000d02:	f001 f977 	bl	24001ff4 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
24000d06:	bf00      	nop
24000d08:	3708      	adds	r7, #8
24000d0a:	46bd      	mov	sp, r7
24000d0c:	bd80      	pop	{r7, pc}

24000d0e <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
24000d0e:	b480      	push	{r7}
24000d10:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
24000d12:	b672      	cpsid	i
}
24000d14:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
24000d16:	e7fe      	b.n	24000d16 <Error_Handler+0x8>

24000d18 <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
24000d18:	b580      	push	{r7, lr}
24000d1a:	af00      	add	r7, sp, #0
  /* USER CODE END QUADSPI_Init 0 */

  /* USER CODE BEGIN QUADSPI_Init 1 */

  /* USER CODE END QUADSPI_Init 1 */
  hqspi.Instance = QUADSPI;
24000d1c:	4b12      	ldr	r3, [pc, #72]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d1e:	4a13      	ldr	r2, [pc, #76]	; (24000d6c <MX_QUADSPI_Init+0x54>)
24000d20:	601a      	str	r2, [r3, #0]
  hqspi.Init.ClockPrescaler = 1;
24000d22:	4b11      	ldr	r3, [pc, #68]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d24:	2201      	movs	r2, #1
24000d26:	605a      	str	r2, [r3, #4]
  hqspi.Init.FifoThreshold = 4;
24000d28:	4b0f      	ldr	r3, [pc, #60]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d2a:	2204      	movs	r2, #4
24000d2c:	609a      	str	r2, [r3, #8]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
24000d2e:	4b0e      	ldr	r3, [pc, #56]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d30:	2210      	movs	r2, #16
24000d32:	60da      	str	r2, [r3, #12]
  hqspi.Init.FlashSize = 24;
24000d34:	4b0c      	ldr	r3, [pc, #48]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d36:	2218      	movs	r2, #24
24000d38:	611a      	str	r2, [r3, #16]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
24000d3a:	4b0b      	ldr	r3, [pc, #44]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d3c:	2200      	movs	r2, #0
24000d3e:	615a      	str	r2, [r3, #20]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
24000d40:	4b09      	ldr	r3, [pc, #36]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d42:	2200      	movs	r2, #0
24000d44:	619a      	str	r2, [r3, #24]
  hqspi.Init.FlashID = QSPI_FLASH_ID_2;
24000d46:	4b08      	ldr	r3, [pc, #32]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d48:	2280      	movs	r2, #128	; 0x80
24000d4a:	61da      	str	r2, [r3, #28]
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
24000d4c:	4b06      	ldr	r3, [pc, #24]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d4e:	2200      	movs	r2, #0
24000d50:	621a      	str	r2, [r3, #32]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
24000d52:	4805      	ldr	r0, [pc, #20]	; (24000d68 <MX_QUADSPI_Init+0x50>)
24000d54:	f010 fdc6 	bl	240118e4 <HAL_QSPI_Init>
24000d58:	4603      	mov	r3, r0
24000d5a:	2b00      	cmp	r3, #0
24000d5c:	d001      	beq.n	24000d62 <MX_QUADSPI_Init+0x4a>
  {
    Error_Handler();
24000d5e:	f7ff ffd6 	bl	24000d0e <Error_Handler>
  }
  /* USER CODE BEGIN QUADSPI_Init 2 */

  /* USER CODE END QUADSPI_Init 2 */

}
24000d62:	bf00      	nop
24000d64:	bd80      	pop	{r7, pc}
24000d66:	bf00      	nop
24000d68:	24000540 	.word	0x24000540
24000d6c:	52005000 	.word	0x52005000

24000d70 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
24000d70:	b580      	push	{r7, lr}
24000d72:	b0bc      	sub	sp, #240	; 0xf0
24000d74:	af00      	add	r7, sp, #0
24000d76:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
24000d78:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
24000d7c:	2200      	movs	r2, #0
24000d7e:	601a      	str	r2, [r3, #0]
24000d80:	605a      	str	r2, [r3, #4]
24000d82:	609a      	str	r2, [r3, #8]
24000d84:	60da      	str	r2, [r3, #12]
24000d86:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
24000d88:	f107 0318 	add.w	r3, r7, #24
24000d8c:	22c0      	movs	r2, #192	; 0xc0
24000d8e:	2100      	movs	r1, #0
24000d90:	4618      	mov	r0, r3
24000d92:	f020 f861 	bl	24020e58 <memset>
  if(qspiHandle->Instance==QUADSPI)
24000d96:	687b      	ldr	r3, [r7, #4]
24000d98:	681b      	ldr	r3, [r3, #0]
24000d9a:	4a4b      	ldr	r2, [pc, #300]	; (24000ec8 <HAL_QSPI_MspInit+0x158>)
24000d9c:	4293      	cmp	r3, r2
24000d9e:	f040 808f 	bne.w	24000ec0 <HAL_QSPI_MspInit+0x150>

  /* USER CODE END QUADSPI_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
24000da2:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
24000da6:	f04f 0300 	mov.w	r3, #0
24000daa:	e9c7 2306 	strd	r2, r3, [r7, #24]
    PeriphClkInitStruct.QspiClockSelection = RCC_QSPICLKSOURCE_D1HCLK;
24000dae:	2300      	movs	r3, #0
24000db0:	667b      	str	r3, [r7, #100]	; 0x64
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
24000db2:	f107 0318 	add.w	r3, r7, #24
24000db6:	4618      	mov	r0, r3
24000db8:	f013 fcee 	bl	24014798 <HAL_RCCEx_PeriphCLKConfig>
24000dbc:	4603      	mov	r3, r0
24000dbe:	2b00      	cmp	r3, #0
24000dc0:	d001      	beq.n	24000dc6 <HAL_QSPI_MspInit+0x56>
    {
      Error_Handler();
24000dc2:	f7ff ffa4 	bl	24000d0e <Error_Handler>
    }

    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
24000dc6:	4b41      	ldr	r3, [pc, #260]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000dc8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
24000dcc:	4a3f      	ldr	r2, [pc, #252]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000dce:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
24000dd2:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
24000dd6:	4b3d      	ldr	r3, [pc, #244]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000dd8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
24000ddc:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
24000de0:	617b      	str	r3, [r7, #20]
24000de2:	697b      	ldr	r3, [r7, #20]

    __HAL_RCC_GPIOB_CLK_ENABLE();
24000de4:	4b39      	ldr	r3, [pc, #228]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000de6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000dea:	4a38      	ldr	r2, [pc, #224]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000dec:	f043 0302 	orr.w	r3, r3, #2
24000df0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000df4:	4b35      	ldr	r3, [pc, #212]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000df6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000dfa:	f003 0302 	and.w	r3, r3, #2
24000dfe:	613b      	str	r3, [r7, #16]
24000e00:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOE_CLK_ENABLE();
24000e02:	4b32      	ldr	r3, [pc, #200]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000e04:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000e08:	4a30      	ldr	r2, [pc, #192]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000e0a:	f043 0310 	orr.w	r3, r3, #16
24000e0e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000e12:	4b2e      	ldr	r3, [pc, #184]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000e14:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000e18:	f003 0310 	and.w	r3, r3, #16
24000e1c:	60fb      	str	r3, [r7, #12]
24000e1e:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
24000e20:	4b2a      	ldr	r3, [pc, #168]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000e22:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000e26:	4a29      	ldr	r2, [pc, #164]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000e28:	f043 0304 	orr.w	r3, r3, #4
24000e2c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000e30:	4b26      	ldr	r3, [pc, #152]	; (24000ecc <HAL_QSPI_MspInit+0x15c>)
24000e32:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000e36:	f003 0304 	and.w	r3, r3, #4
24000e3a:	60bb      	str	r3, [r7, #8]
24000e3c:	68bb      	ldr	r3, [r7, #8]
    PE8     ------> QUADSPI_BK2_IO1
    PE9     ------> QUADSPI_BK2_IO2
    PE10     ------> QUADSPI_BK2_IO3
    PC11     ------> QUADSPI_BK2_NCS
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2;
24000e3e:	2304      	movs	r3, #4
24000e40:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24000e44:	2302      	movs	r3, #2
24000e46:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24000e4a:	2300      	movs	r3, #0
24000e4c:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
24000e50:	2300      	movs	r3, #0
24000e52:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24000e56:	2309      	movs	r3, #9
24000e58:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
24000e5c:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
24000e60:	4619      	mov	r1, r3
24000e62:	481b      	ldr	r0, [pc, #108]	; (24000ed0 <HAL_QSPI_MspInit+0x160>)
24000e64:	f008 fae0 	bl	24009428 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
24000e68:	f44f 63f0 	mov.w	r3, #1920	; 0x780
24000e6c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24000e70:	2302      	movs	r3, #2
24000e72:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24000e76:	2300      	movs	r3, #0
24000e78:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
24000e7c:	2300      	movs	r3, #0
24000e7e:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
24000e82:	230a      	movs	r3, #10
24000e84:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
24000e88:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
24000e8c:	4619      	mov	r1, r3
24000e8e:	4811      	ldr	r0, [pc, #68]	; (24000ed4 <HAL_QSPI_MspInit+0x164>)
24000e90:	f008 faca 	bl	24009428 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
24000e94:	f44f 6300 	mov.w	r3, #2048	; 0x800
24000e98:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24000e9c:	2302      	movs	r3, #2
24000e9e:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24000ea2:	2300      	movs	r3, #0
24000ea4:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
24000ea8:	2300      	movs	r3, #0
24000eaa:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24000eae:	2309      	movs	r3, #9
24000eb0:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
24000eb4:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
24000eb8:	4619      	mov	r1, r3
24000eba:	4807      	ldr	r0, [pc, #28]	; (24000ed8 <HAL_QSPI_MspInit+0x168>)
24000ebc:	f008 fab4 	bl	24009428 <HAL_GPIO_Init>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
24000ec0:	bf00      	nop
24000ec2:	37f0      	adds	r7, #240	; 0xf0
24000ec4:	46bd      	mov	sp, r7
24000ec6:	bd80      	pop	{r7, pc}
24000ec8:	52005000 	.word	0x52005000
24000ecc:	58024400 	.word	0x58024400
24000ed0:	58020400 	.word	0x58020400
24000ed4:	58021000 	.word	0x58021000
24000ed8:	58020800 	.word	0x58020800

24000edc <HAL_QSPI_MspDeInit>:

void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* qspiHandle)
{
24000edc:	b580      	push	{r7, lr}
24000ede:	b082      	sub	sp, #8
24000ee0:	af00      	add	r7, sp, #0
24000ee2:	6078      	str	r0, [r7, #4]

  if(qspiHandle->Instance==QUADSPI)
24000ee4:	687b      	ldr	r3, [r7, #4]
24000ee6:	681b      	ldr	r3, [r3, #0]
24000ee8:	4a0e      	ldr	r2, [pc, #56]	; (24000f24 <HAL_QSPI_MspDeInit+0x48>)
24000eea:	4293      	cmp	r3, r2
24000eec:	d115      	bne.n	24000f1a <HAL_QSPI_MspDeInit+0x3e>
  {
  /* USER CODE BEGIN QUADSPI_MspDeInit 0 */

  /* USER CODE END QUADSPI_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_QSPI_CLK_DISABLE();
24000eee:	4b0e      	ldr	r3, [pc, #56]	; (24000f28 <HAL_QSPI_MspDeInit+0x4c>)
24000ef0:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
24000ef4:	4a0c      	ldr	r2, [pc, #48]	; (24000f28 <HAL_QSPI_MspDeInit+0x4c>)
24000ef6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
24000efa:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
    PE8     ------> QUADSPI_BK2_IO1
    PE9     ------> QUADSPI_BK2_IO2
    PE10     ------> QUADSPI_BK2_IO3
    PC11     ------> QUADSPI_BK2_NCS
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_2);
24000efe:	2104      	movs	r1, #4
24000f00:	480a      	ldr	r0, [pc, #40]	; (24000f2c <HAL_QSPI_MspDeInit+0x50>)
24000f02:	f008 fc41 	bl	24009788 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOE, GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10);
24000f06:	f44f 61f0 	mov.w	r1, #1920	; 0x780
24000f0a:	4809      	ldr	r0, [pc, #36]	; (24000f30 <HAL_QSPI_MspDeInit+0x54>)
24000f0c:	f008 fc3c 	bl	24009788 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_11);
24000f10:	f44f 6100 	mov.w	r1, #2048	; 0x800
24000f14:	4807      	ldr	r0, [pc, #28]	; (24000f34 <HAL_QSPI_MspDeInit+0x58>)
24000f16:	f008 fc37 	bl	24009788 <HAL_GPIO_DeInit>

  /* USER CODE BEGIN QUADSPI_MspDeInit 1 */

  /* USER CODE END QUADSPI_MspDeInit 1 */
  }
}
24000f1a:	bf00      	nop
24000f1c:	3708      	adds	r7, #8
24000f1e:	46bd      	mov	sp, r7
24000f20:	bd80      	pop	{r7, pc}
24000f22:	bf00      	nop
24000f24:	52005000 	.word	0x52005000
24000f28:	58024400 	.word	0x58024400
24000f2c:	58020400 	.word	0x58020400
24000f30:	58021000 	.word	0x58021000
24000f34:	58020800 	.word	0x58020800

24000f38 <CSP_QUADSPI_Init>:

/* USER CODE BEGIN 1 */

/* QUADSPI init function */
uint8_t
CSP_QUADSPI_Init(void) {
24000f38:	b580      	push	{r7, lr}
24000f3a:	af00      	add	r7, sp, #0
    //prepare QSPI peripheral for ST-Link Utility operations
	hqspi.Instance = QUADSPI;
24000f3c:	4b15      	ldr	r3, [pc, #84]	; (24000f94 <CSP_QUADSPI_Init+0x5c>)
24000f3e:	4a16      	ldr	r2, [pc, #88]	; (24000f98 <CSP_QUADSPI_Init+0x60>)
24000f40:	601a      	str	r2, [r3, #0]
    if (HAL_QSPI_DeInit(&hqspi) != HAL_OK) {
24000f42:	4814      	ldr	r0, [pc, #80]	; (24000f94 <CSP_QUADSPI_Init+0x5c>)
24000f44:	f010 fd42 	bl	240119cc <HAL_QSPI_DeInit>
24000f48:	4603      	mov	r3, r0
24000f4a:	2b00      	cmp	r3, #0
24000f4c:	d001      	beq.n	24000f52 <CSP_QUADSPI_Init+0x1a>
        return HAL_ERROR;
24000f4e:	2301      	movs	r3, #1
24000f50:	e01e      	b.n	24000f90 <CSP_QUADSPI_Init+0x58>
    }

    MX_QUADSPI_Init();
24000f52:	f7ff fee1 	bl	24000d18 <MX_QUADSPI_Init>

    if (QSPI_ResetChip() != HAL_OK) {
24000f56:	f000 fa9d 	bl	24001494 <QSPI_ResetChip>
24000f5a:	4603      	mov	r3, r0
24000f5c:	2b00      	cmp	r3, #0
24000f5e:	d001      	beq.n	24000f64 <CSP_QUADSPI_Init+0x2c>
        return HAL_ERROR;
24000f60:	2301      	movs	r3, #1
24000f62:	e015      	b.n	24000f90 <CSP_QUADSPI_Init+0x58>
    }



    if (QSPI_AutoPollingMemReady() != HAL_OK) {
24000f64:	f000 f856 	bl	24001014 <QSPI_AutoPollingMemReady>
24000f68:	4603      	mov	r3, r0
24000f6a:	2b00      	cmp	r3, #0
24000f6c:	d001      	beq.n	24000f72 <CSP_QUADSPI_Init+0x3a>
        return HAL_ERROR;
24000f6e:	2301      	movs	r3, #1
24000f70:	e00e      	b.n	24000f90 <CSP_QUADSPI_Init+0x58>
    }

    if (QSPI_WriteEnable() != HAL_OK) {
24000f72:	f000 f887 	bl	24001084 <QSPI_WriteEnable>
24000f76:	4603      	mov	r3, r0
24000f78:	2b00      	cmp	r3, #0
24000f7a:	d001      	beq.n	24000f80 <CSP_QUADSPI_Init+0x48>

        return HAL_ERROR;
24000f7c:	2301      	movs	r3, #1
24000f7e:	e007      	b.n	24000f90 <CSP_QUADSPI_Init+0x58>
    }

    if (QSPI_Configuration() != HAL_OK) {
24000f80:	f000 f8ca 	bl	24001118 <QSPI_Configuration>
24000f84:	4603      	mov	r3, r0
24000f86:	2b00      	cmp	r3, #0
24000f88:	d001      	beq.n	24000f8e <CSP_QUADSPI_Init+0x56>
        return HAL_ERROR;
24000f8a:	2301      	movs	r3, #1
24000f8c:	e000      	b.n	24000f90 <CSP_QUADSPI_Init+0x58>
    }

    return HAL_OK;
24000f8e:	2300      	movs	r3, #0
}
24000f90:	4618      	mov	r0, r3
24000f92:	bd80      	pop	{r7, pc}
24000f94:	24000540 	.word	0x24000540
24000f98:	52005000 	.word	0x52005000

24000f9c <CSP_QSPI_Erase_Chip>:


uint8_t
CSP_QSPI_Erase_Chip(void) {
24000f9c:	b580      	push	{r7, lr}
24000f9e:	b08e      	sub	sp, #56	; 0x38
24000fa0:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;


    if (QSPI_WriteEnable() != HAL_OK) {
24000fa2:	f000 f86f 	bl	24001084 <QSPI_WriteEnable>
24000fa6:	4603      	mov	r3, r0
24000fa8:	2b00      	cmp	r3, #0
24000faa:	d001      	beq.n	24000fb0 <CSP_QSPI_Erase_Chip+0x14>
        return HAL_ERROR;
24000fac:	2301      	movs	r3, #1
24000fae:	e02b      	b.n	24001008 <CSP_QSPI_Erase_Chip+0x6c>
    }


    /* Erasing Sequence --------------------------------- */
    sCommand.Instruction = CHIP_ERASE_CMD;
24000fb0:	23c7      	movs	r3, #199	; 0xc7
24000fb2:	603b      	str	r3, [r7, #0]
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24000fb4:	f44f 7380 	mov.w	r3, #256	; 0x100
24000fb8:	61bb      	str	r3, [r7, #24]
    sCommand.AddressSize = QSPI_ADDRESS_32_BITS;
24000fba:	f44f 5340 	mov.w	r3, #12288	; 0x3000
24000fbe:	60fb      	str	r3, [r7, #12]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24000fc0:	2300      	movs	r3, #0
24000fc2:	623b      	str	r3, [r7, #32]
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24000fc4:	2300      	movs	r3, #0
24000fc6:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24000fc8:	2300      	movs	r3, #0
24000fca:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24000fcc:	2300      	movs	r3, #0
24000fce:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24000fd0:	2300      	movs	r3, #0
24000fd2:	61fb      	str	r3, [r7, #28]
    sCommand.Address = 0;
24000fd4:	2300      	movs	r3, #0
24000fd6:	607b      	str	r3, [r7, #4]
    sCommand.DataMode = QSPI_DATA_NONE;
24000fd8:	2300      	movs	r3, #0
24000fda:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DummyCycles = 0;
24000fdc:	2300      	movs	r3, #0
24000fde:	617b      	str	r3, [r7, #20]


    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24000fe0:	463b      	mov	r3, r7
24000fe2:	f241 3288 	movw	r2, #5000	; 0x1388
24000fe6:	4619      	mov	r1, r3
24000fe8:	4809      	ldr	r0, [pc, #36]	; (24001010 <CSP_QSPI_Erase_Chip+0x74>)
24000fea:	f010 fedd 	bl	24011da8 <HAL_QSPI_Command>
24000fee:	4603      	mov	r3, r0
24000ff0:	2b00      	cmp	r3, #0
24000ff2:	d001      	beq.n	24000ff8 <CSP_QSPI_Erase_Chip+0x5c>
        != HAL_OK) {
        return HAL_ERROR;
24000ff4:	2301      	movs	r3, #1
24000ff6:	e007      	b.n	24001008 <CSP_QSPI_Erase_Chip+0x6c>
    }

    if (QSPI_AutoPollingMemReady() != HAL_OK) {
24000ff8:	f000 f80c 	bl	24001014 <QSPI_AutoPollingMemReady>
24000ffc:	4603      	mov	r3, r0
24000ffe:	2b00      	cmp	r3, #0
24001000:	d001      	beq.n	24001006 <CSP_QSPI_Erase_Chip+0x6a>
        return HAL_ERROR;
24001002:	2301      	movs	r3, #1
24001004:	e000      	b.n	24001008 <CSP_QSPI_Erase_Chip+0x6c>
    }

    return HAL_OK;
24001006:	2300      	movs	r3, #0
}
24001008:	4618      	mov	r0, r3
2400100a:	3738      	adds	r7, #56	; 0x38
2400100c:	46bd      	mov	sp, r7
2400100e:	bd80      	pop	{r7, pc}
24001010:	24000540 	.word	0x24000540

24001014 <QSPI_AutoPollingMemReady>:

uint8_t
QSPI_AutoPollingMemReady(void) {
24001014:	b580      	push	{r7, lr}
24001016:	b094      	sub	sp, #80	; 0x50
24001018:	af00      	add	r7, sp, #0

    QSPI_CommandTypeDef sCommand;
    QSPI_AutoPollingTypeDef sConfig;

    /* Configure automatic polling mode to wait for memory ready ------ */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2400101a:	f44f 7380 	mov.w	r3, #256	; 0x100
2400101e:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.Instruction = READ_STATUS_REG_CMD;
24001020:	2305      	movs	r3, #5
24001022:	61bb      	str	r3, [r7, #24]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24001024:	2300      	movs	r3, #0
24001026:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001028:	2300      	movs	r3, #0
2400102a:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.DataMode = QSPI_DATA_1_LINE;
2400102c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24001030:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.DummyCycles = 0;
24001032:	2300      	movs	r3, #0
24001034:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001036:	2300      	movs	r3, #0
24001038:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400103a:	2300      	movs	r3, #0
2400103c:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2400103e:	2300      	movs	r3, #0
24001040:	64fb      	str	r3, [r7, #76]	; 0x4c

    sConfig.Match = 0x00;
24001042:	2300      	movs	r3, #0
24001044:	603b      	str	r3, [r7, #0]
    sConfig.Mask = 0x01;
24001046:	2301      	movs	r3, #1
24001048:	607b      	str	r3, [r7, #4]
    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
2400104a:	2300      	movs	r3, #0
2400104c:	613b      	str	r3, [r7, #16]
    sConfig.StatusBytesSize = 1;
2400104e:	2301      	movs	r3, #1
24001050:	60fb      	str	r3, [r7, #12]
    sConfig.Interval = 0x10;
24001052:	2310      	movs	r3, #16
24001054:	60bb      	str	r3, [r7, #8]
    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
24001056:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2400105a:	617b      	str	r3, [r7, #20]

    if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig,
2400105c:	463a      	mov	r2, r7
2400105e:	f107 0118 	add.w	r1, r7, #24
24001062:	f241 3388 	movw	r3, #5000	; 0x1388
24001066:	4806      	ldr	r0, [pc, #24]	; (24001080 <QSPI_AutoPollingMemReady+0x6c>)
24001068:	f011 fb48 	bl	240126fc <HAL_QSPI_AutoPolling>
2400106c:	4603      	mov	r3, r0
2400106e:	2b00      	cmp	r3, #0
24001070:	d001      	beq.n	24001076 <QSPI_AutoPollingMemReady+0x62>
                             HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
        return HAL_ERROR;
24001072:	2301      	movs	r3, #1
24001074:	e000      	b.n	24001078 <QSPI_AutoPollingMemReady+0x64>
    }

    return HAL_OK;
24001076:	2300      	movs	r3, #0
}
24001078:	4618      	mov	r0, r3
2400107a:	3750      	adds	r7, #80	; 0x50
2400107c:	46bd      	mov	sp, r7
2400107e:	bd80      	pop	{r7, pc}
24001080:	24000540 	.word	0x24000540

24001084 <QSPI_WriteEnable>:

static
uint8_t QSPI_WriteEnable(void) {
24001084:	b580      	push	{r7, lr}
24001086:	b094      	sub	sp, #80	; 0x50
24001088:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    QSPI_AutoPollingTypeDef sConfig;

    /* Enable write operations ------------------------------------------ */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2400108a:	f44f 7380 	mov.w	r3, #256	; 0x100
2400108e:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.Instruction = WRITE_ENABLE_CMD;
24001090:	2306      	movs	r3, #6
24001092:	61bb      	str	r3, [r7, #24]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24001094:	2300      	movs	r3, #0
24001096:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001098:	2300      	movs	r3, #0
2400109a:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.DataMode = QSPI_DATA_NONE;
2400109c:	2300      	movs	r3, #0
2400109e:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.DummyCycles = 0;
240010a0:	2300      	movs	r3, #0
240010a2:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240010a4:	2300      	movs	r3, #0
240010a6:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240010a8:	2300      	movs	r3, #0
240010aa:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240010ac:	2300      	movs	r3, #0
240010ae:	64fb      	str	r3, [r7, #76]	; 0x4c

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
240010b0:	f107 0318 	add.w	r3, r7, #24
240010b4:	f241 3288 	movw	r2, #5000	; 0x1388
240010b8:	4619      	mov	r1, r3
240010ba:	4816      	ldr	r0, [pc, #88]	; (24001114 <QSPI_WriteEnable+0x90>)
240010bc:	f010 fe74 	bl	24011da8 <HAL_QSPI_Command>
240010c0:	4603      	mov	r3, r0
240010c2:	2b00      	cmp	r3, #0
240010c4:	d001      	beq.n	240010ca <QSPI_WriteEnable+0x46>
        != HAL_OK) {
        return HAL_ERROR;
240010c6:	2301      	movs	r3, #1
240010c8:	e01f      	b.n	2400110a <QSPI_WriteEnable+0x86>
    }

    /* Configure automatic polling mode to wait for write enabling ---- */
    sConfig.Match = 0x02;
240010ca:	2302      	movs	r3, #2
240010cc:	603b      	str	r3, [r7, #0]
    sConfig.Mask = 0x02;
240010ce:	2302      	movs	r3, #2
240010d0:	607b      	str	r3, [r7, #4]
    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
240010d2:	2300      	movs	r3, #0
240010d4:	613b      	str	r3, [r7, #16]
    sConfig.StatusBytesSize = 1;
240010d6:	2301      	movs	r3, #1
240010d8:	60fb      	str	r3, [r7, #12]
    sConfig.Interval = 0x10;
240010da:	2310      	movs	r3, #16
240010dc:	60bb      	str	r3, [r7, #8]
    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
240010de:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
240010e2:	617b      	str	r3, [r7, #20]

    sCommand.Instruction = READ_STATUS_REG_CMD;
240010e4:	2305      	movs	r3, #5
240010e6:	61bb      	str	r3, [r7, #24]
    sCommand.DataMode = QSPI_DATA_1_LINE;
240010e8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
240010ec:	63fb      	str	r3, [r7, #60]	; 0x3c
    if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig,
240010ee:	463a      	mov	r2, r7
240010f0:	f107 0118 	add.w	r1, r7, #24
240010f4:	f241 3388 	movw	r3, #5000	; 0x1388
240010f8:	4806      	ldr	r0, [pc, #24]	; (24001114 <QSPI_WriteEnable+0x90>)
240010fa:	f011 faff 	bl	240126fc <HAL_QSPI_AutoPolling>
240010fe:	4603      	mov	r3, r0
24001100:	2b00      	cmp	r3, #0
24001102:	d001      	beq.n	24001108 <QSPI_WriteEnable+0x84>
                             HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
        return HAL_ERROR;
24001104:	2301      	movs	r3, #1
24001106:	e000      	b.n	2400110a <QSPI_WriteEnable+0x86>
    }

    return HAL_OK;
24001108:	2300      	movs	r3, #0
}
2400110a:	4618      	mov	r0, r3
2400110c:	3750      	adds	r7, #80	; 0x50
2400110e:	46bd      	mov	sp, r7
24001110:	bd80      	pop	{r7, pc}
24001112:	bf00      	nop
24001114:	24000540 	.word	0x24000540

24001118 <QSPI_Configuration>:
/*Enable quad mode and set dummy cycles count*/
uint8_t
QSPI_Configuration(void) {
24001118:	b580      	push	{r7, lr}
2400111a:	b092      	sub	sp, #72	; 0x48
2400111c:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    uint8_t reg;


    /*enter 4 byte address*/
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2400111e:	f44f 7380 	mov.w	r3, #256	; 0x100
24001122:	61fb      	str	r3, [r7, #28]
    sCommand.Instruction = ENTER_4_BYTE_ADD_CMD;
24001124:	23b7      	movs	r3, #183	; 0xb7
24001126:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24001128:	2300      	movs	r3, #0
2400112a:	623b      	str	r3, [r7, #32]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2400112c:	2300      	movs	r3, #0
2400112e:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DataMode = QSPI_DATA_NONE;
24001130:	2300      	movs	r3, #0
24001132:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
24001134:	2300      	movs	r3, #0
24001136:	61bb      	str	r3, [r7, #24]
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001138:	2300      	movs	r3, #0
2400113a:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400113c:	2300      	movs	r3, #0
2400113e:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001140:	2300      	movs	r3, #0
24001142:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.NbData = 0;
24001144:	2300      	movs	r3, #0
24001146:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001148:	1d3b      	adds	r3, r7, #4
2400114a:	f241 3288 	movw	r2, #5000	; 0x1388
2400114e:	4619      	mov	r1, r3
24001150:	4840      	ldr	r0, [pc, #256]	; (24001254 <QSPI_Configuration+0x13c>)
24001152:	f010 fe29 	bl	24011da8 <HAL_QSPI_Command>
24001156:	4603      	mov	r3, r0
24001158:	2b00      	cmp	r3, #0
2400115a:	d001      	beq.n	24001160 <QSPI_Configuration+0x48>
        != HAL_OK) {
        return HAL_ERROR;
2400115c:	2301      	movs	r3, #1
2400115e:	e075      	b.n	2400124c <QSPI_Configuration+0x134>




    /*read configuration register*/
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24001160:	f44f 7380 	mov.w	r3, #256	; 0x100
24001164:	61fb      	str	r3, [r7, #28]
    sCommand.Instruction = READ_CONFIGURATION_REG_CMD;
24001166:	2385      	movs	r3, #133	; 0x85
24001168:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
2400116a:	2300      	movs	r3, #0
2400116c:	623b      	str	r3, [r7, #32]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2400116e:	2300      	movs	r3, #0
24001170:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DataMode = QSPI_DATA_1_LINE;
24001172:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24001176:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
24001178:	2300      	movs	r3, #0
2400117a:	61bb      	str	r3, [r7, #24]
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400117c:	2300      	movs	r3, #0
2400117e:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24001180:	2300      	movs	r3, #0
24001182:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001184:	2300      	movs	r3, #0
24001186:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.NbData = 1;
24001188:	2301      	movs	r3, #1
2400118a:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2400118c:	1d3b      	adds	r3, r7, #4
2400118e:	f241 3288 	movw	r2, #5000	; 0x1388
24001192:	4619      	mov	r1, r3
24001194:	482f      	ldr	r0, [pc, #188]	; (24001254 <QSPI_Configuration+0x13c>)
24001196:	f010 fe07 	bl	24011da8 <HAL_QSPI_Command>
2400119a:	4603      	mov	r3, r0
2400119c:	2b00      	cmp	r3, #0
2400119e:	d001      	beq.n	240011a4 <QSPI_Configuration+0x8c>
        != HAL_OK) {
        return HAL_ERROR;
240011a0:	2301      	movs	r3, #1
240011a2:	e053      	b.n	2400124c <QSPI_Configuration+0x134>
    }


    if (HAL_QSPI_Receive(&hqspi, &reg,
240011a4:	1cfb      	adds	r3, r7, #3
240011a6:	f241 3288 	movw	r2, #5000	; 0x1388
240011aa:	4619      	mov	r1, r3
240011ac:	4829      	ldr	r0, [pc, #164]	; (24001254 <QSPI_Configuration+0x13c>)
240011ae:	f010 ff51 	bl	24012054 <HAL_QSPI_Receive>
240011b2:	4603      	mov	r3, r0
240011b4:	2b00      	cmp	r3, #0
240011b6:	d001      	beq.n	240011bc <QSPI_Configuration+0xa4>
                         HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
        return HAL_ERROR;
240011b8:	2301      	movs	r3, #1
240011ba:	e047      	b.n	2400124c <QSPI_Configuration+0x134>
    }



    if (QSPI_WriteEnable() != HAL_OK) {
240011bc:	f7ff ff62 	bl	24001084 <QSPI_WriteEnable>
240011c0:	4603      	mov	r3, r0
240011c2:	2b00      	cmp	r3, #0
240011c4:	d001      	beq.n	240011ca <QSPI_Configuration+0xb2>

        return HAL_ERROR;
240011c6:	2301      	movs	r3, #1
240011c8:	e040      	b.n	2400124c <QSPI_Configuration+0x134>
240011ca:	23f0      	movs	r3, #240	; 0xf0
240011cc:	643b      	str	r3, [r7, #64]	; 0x40
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
240011ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
240011d0:	fa93 f3a3 	rbit	r3, r3
240011d4:	63fb      	str	r3, [r7, #60]	; 0x3c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
240011d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
240011d8:	647b      	str	r3, [r7, #68]	; 0x44
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
240011da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
240011dc:	2b00      	cmp	r3, #0
  {
    return 32U;
240011de:	bf00      	nop
    }


    /*set dummy cycles*/
    MODIFY_REG(reg, 0xF0, (DUMMY_CLOCK_CYCLES_READ_QUAD << POSITION_VAL(0xF0)));
240011e0:	78fb      	ldrb	r3, [r7, #3]
240011e2:	f003 030f 	and.w	r3, r3, #15
240011e6:	b2db      	uxtb	r3, r3
240011e8:	70fb      	strb	r3, [r7, #3]

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240011ea:	f44f 7380 	mov.w	r3, #256	; 0x100
240011ee:	61fb      	str	r3, [r7, #28]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240011f0:	2300      	movs	r3, #0
240011f2:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240011f4:	2300      	movs	r3, #0
240011f6:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240011f8:	2300      	movs	r3, #0
240011fa:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240011fc:	2300      	movs	r3, #0
240011fe:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = WRITE_VOL_CFG_REG_CMD;
24001200:	2381      	movs	r3, #129	; 0x81
24001202:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24001204:	2300      	movs	r3, #0
24001206:	623b      	str	r3, [r7, #32]
    sCommand.DataMode = QSPI_DATA_1_LINE;
24001208:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400120c:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
2400120e:	2300      	movs	r3, #0
24001210:	61bb      	str	r3, [r7, #24]
    sCommand.NbData = 1;
24001212:	2301      	movs	r3, #1
24001214:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001216:	1d3b      	adds	r3, r7, #4
24001218:	f241 3288 	movw	r2, #5000	; 0x1388
2400121c:	4619      	mov	r1, r3
2400121e:	480d      	ldr	r0, [pc, #52]	; (24001254 <QSPI_Configuration+0x13c>)
24001220:	f010 fdc2 	bl	24011da8 <HAL_QSPI_Command>
24001224:	4603      	mov	r3, r0
24001226:	2b00      	cmp	r3, #0
24001228:	d001      	beq.n	2400122e <QSPI_Configuration+0x116>
        != HAL_OK) {
        return HAL_ERROR;
2400122a:	2301      	movs	r3, #1
2400122c:	e00e      	b.n	2400124c <QSPI_Configuration+0x134>
    }

    if (HAL_QSPI_Transmit(&hqspi, &reg,
2400122e:	1cfb      	adds	r3, r7, #3
24001230:	f241 3288 	movw	r2, #5000	; 0x1388
24001234:	4619      	mov	r1, r3
24001236:	4807      	ldr	r0, [pc, #28]	; (24001254 <QSPI_Configuration+0x13c>)
24001238:	f010 fe7a 	bl	24011f30 <HAL_QSPI_Transmit>
2400123c:	4603      	mov	r3, r0
2400123e:	2b00      	cmp	r3, #0
24001240:	d003      	beq.n	2400124a <QSPI_Configuration+0x132>
                          HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
        Error_Handler();
24001242:	f7ff fd64 	bl	24000d0e <Error_Handler>
        return HAL_ERROR;
24001246:	2301      	movs	r3, #1
24001248:	e000      	b.n	2400124c <QSPI_Configuration+0x134>
    }
    return HAL_OK;
2400124a:	2300      	movs	r3, #0
}
2400124c:	4618      	mov	r0, r3
2400124e:	3748      	adds	r7, #72	; 0x48
24001250:	46bd      	mov	sp, r7
24001252:	bd80      	pop	{r7, pc}
24001254:	24000540 	.word	0x24000540

24001258 <CSP_QSPI_EraseSector>:

uint8_t
CSP_QSPI_EraseSector(uint32_t EraseStartAddress, uint32_t EraseEndAddress) {
24001258:	b580      	push	{r7, lr}
2400125a:	b090      	sub	sp, #64	; 0x40
2400125c:	af00      	add	r7, sp, #0
2400125e:	6078      	str	r0, [r7, #4]
24001260:	6039      	str	r1, [r7, #0]

    QSPI_CommandTypeDef sCommand;

    EraseStartAddress = EraseStartAddress
24001262:	687a      	ldr	r2, [r7, #4]
24001264:	4b23      	ldr	r3, [pc, #140]	; (240012f4 <CSP_QSPI_EraseSector+0x9c>)
24001266:	4013      	ands	r3, r2
24001268:	607b      	str	r3, [r7, #4]
                        - EraseStartAddress % MEMORY_SECTOR_SIZE;

    /* Erasing Sequence -------------------------------------------------- */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2400126a:	f44f 7380 	mov.w	r3, #256	; 0x100
2400126e:	623b      	str	r3, [r7, #32]
    sCommand.AddressSize = QSPI_ADDRESS_32_BITS;
24001270:	f44f 5340 	mov.w	r3, #12288	; 0x3000
24001274:	617b      	str	r3, [r7, #20]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001276:	2300      	movs	r3, #0
24001278:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400127a:	2300      	movs	r3, #0
2400127c:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400127e:	2300      	movs	r3, #0
24001280:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001282:	2300      	movs	r3, #0
24001284:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.Instruction = SECTOR_ERASE_CMD;
24001286:	2320      	movs	r3, #32
24001288:	60bb      	str	r3, [r7, #8]
    sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
2400128a:	f44f 6380 	mov.w	r3, #1024	; 0x400
2400128e:	627b      	str	r3, [r7, #36]	; 0x24

    sCommand.DataMode = QSPI_DATA_NONE;
24001290:	2300      	movs	r3, #0
24001292:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DummyCycles = 0;
24001294:	2300      	movs	r3, #0
24001296:	61fb      	str	r3, [r7, #28]

    while (EraseEndAddress >= EraseStartAddress) {
24001298:	e022      	b.n	240012e0 <CSP_QSPI_EraseSector+0x88>
        sCommand.Address = (EraseStartAddress & 0x0FFFFFFF);
2400129a:	687b      	ldr	r3, [r7, #4]
2400129c:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
240012a0:	60fb      	str	r3, [r7, #12]

        if (QSPI_WriteEnable() != HAL_OK) {
240012a2:	f7ff feef 	bl	24001084 <QSPI_WriteEnable>
240012a6:	4603      	mov	r3, r0
240012a8:	2b00      	cmp	r3, #0
240012aa:	d001      	beq.n	240012b0 <CSP_QSPI_EraseSector+0x58>
            return HAL_ERROR;
240012ac:	2301      	movs	r3, #1
240012ae:	e01c      	b.n	240012ea <CSP_QSPI_EraseSector+0x92>
        }

        if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
240012b0:	f107 0308 	add.w	r3, r7, #8
240012b4:	f241 3288 	movw	r2, #5000	; 0x1388
240012b8:	4619      	mov	r1, r3
240012ba:	480f      	ldr	r0, [pc, #60]	; (240012f8 <CSP_QSPI_EraseSector+0xa0>)
240012bc:	f010 fd74 	bl	24011da8 <HAL_QSPI_Command>
240012c0:	4603      	mov	r3, r0
240012c2:	2b00      	cmp	r3, #0
240012c4:	d001      	beq.n	240012ca <CSP_QSPI_EraseSector+0x72>
            != HAL_OK) {
            return HAL_ERROR;
240012c6:	2301      	movs	r3, #1
240012c8:	e00f      	b.n	240012ea <CSP_QSPI_EraseSector+0x92>
        }
        EraseStartAddress += MEMORY_SECTOR_SIZE;
240012ca:	687b      	ldr	r3, [r7, #4]
240012cc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
240012d0:	607b      	str	r3, [r7, #4]

        if (QSPI_AutoPollingMemReady() != HAL_OK) {
240012d2:	f7ff fe9f 	bl	24001014 <QSPI_AutoPollingMemReady>
240012d6:	4603      	mov	r3, r0
240012d8:	2b00      	cmp	r3, #0
240012da:	d001      	beq.n	240012e0 <CSP_QSPI_EraseSector+0x88>
            return HAL_ERROR;
240012dc:	2301      	movs	r3, #1
240012de:	e004      	b.n	240012ea <CSP_QSPI_EraseSector+0x92>
    while (EraseEndAddress >= EraseStartAddress) {
240012e0:	683a      	ldr	r2, [r7, #0]
240012e2:	687b      	ldr	r3, [r7, #4]
240012e4:	429a      	cmp	r2, r3
240012e6:	d2d8      	bcs.n	2400129a <CSP_QSPI_EraseSector+0x42>
        }
    }

    return HAL_OK;
240012e8:	2300      	movs	r3, #0
}
240012ea:	4618      	mov	r0, r3
240012ec:	3740      	adds	r7, #64	; 0x40
240012ee:	46bd      	mov	sp, r7
240012f0:	bd80      	pop	{r7, pc}
240012f2:	bf00      	nop
240012f4:	fffff000 	.word	0xfffff000
240012f8:	24000540 	.word	0x24000540

240012fc <CSP_QSPI_WriteMemory>:
////original
uint8_t
CSP_QSPI_WriteMemory(uint8_t* buffer, uint32_t address, uint32_t buffer_size) {
240012fc:	b580      	push	{r7, lr}
240012fe:	b096      	sub	sp, #88	; 0x58
24001300:	af00      	add	r7, sp, #0
24001302:	60f8      	str	r0, [r7, #12]
24001304:	60b9      	str	r1, [r7, #8]
24001306:	607a      	str	r2, [r7, #4]

    QSPI_CommandTypeDef sCommand;
    uint32_t end_addr, current_size, current_addr;

    while (current_addr <= address) {
24001308:	e003      	b.n	24001312 <CSP_QSPI_WriteMemory+0x16>
        current_addr += MEMORY_PAGE_SIZE;
2400130a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
2400130c:	f503 7380 	add.w	r3, r3, #256	; 0x100
24001310:	653b      	str	r3, [r7, #80]	; 0x50
    while (current_addr <= address) {
24001312:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24001314:	68bb      	ldr	r3, [r7, #8]
24001316:	429a      	cmp	r2, r3
24001318:	d9f7      	bls.n	2400130a <CSP_QSPI_WriteMemory+0xe>
    }
    current_size = current_addr - address;
2400131a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
2400131c:	68bb      	ldr	r3, [r7, #8]
2400131e:	1ad3      	subs	r3, r2, r3
24001320:	657b      	str	r3, [r7, #84]	; 0x54

    if (current_size > buffer_size) {
24001322:	6d7a      	ldr	r2, [r7, #84]	; 0x54
24001324:	687b      	ldr	r3, [r7, #4]
24001326:	429a      	cmp	r2, r3
24001328:	d901      	bls.n	2400132e <CSP_QSPI_WriteMemory+0x32>
        current_size = buffer_size;
2400132a:	687b      	ldr	r3, [r7, #4]
2400132c:	657b      	str	r3, [r7, #84]	; 0x54
    }

    current_addr = address;
2400132e:	68bb      	ldr	r3, [r7, #8]
24001330:	653b      	str	r3, [r7, #80]	; 0x50
    end_addr = address + buffer_size;
24001332:	68ba      	ldr	r2, [r7, #8]
24001334:	687b      	ldr	r3, [r7, #4]
24001336:	4413      	add	r3, r2
24001338:	64fb      	str	r3, [r7, #76]	; 0x4c
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2400133a:	f44f 7380 	mov.w	r3, #256	; 0x100
2400133e:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.AddressSize = QSPI_ADDRESS_32_BITS;
24001340:	f44f 5340 	mov.w	r3, #12288	; 0x3000
24001344:	623b      	str	r3, [r7, #32]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001346:	2300      	movs	r3, #0
24001348:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400134a:	2300      	movs	r3, #0
2400134c:	643b      	str	r3, [r7, #64]	; 0x40
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400134e:	2300      	movs	r3, #0
24001350:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001352:	2300      	movs	r3, #0
24001354:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.Instruction = QUAD_IN_FAST_PROG_CMD;
24001356:	2332      	movs	r3, #50	; 0x32
24001358:	617b      	str	r3, [r7, #20]
    sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
2400135a:	f44f 6380 	mov.w	r3, #1024	; 0x400
2400135e:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DataMode = QSPI_DATA_4_LINES;
24001360:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
24001364:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.NbData = buffer_size;
24001366:	687b      	ldr	r3, [r7, #4]
24001368:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.Address = address;
2400136a:	68bb      	ldr	r3, [r7, #8]
2400136c:	61bb      	str	r3, [r7, #24]
    sCommand.DummyCycles = 0;
2400136e:	2300      	movs	r3, #0
24001370:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001372:	2300      	movs	r3, #0
24001374:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AlternateBytes = QSPI_ALTERNATE_BYTES_NONE;
24001376:	2300      	movs	r3, #0
24001378:	61fb      	str	r3, [r7, #28]
    sCommand.AlternateBytesSize = QSPI_ALTERNATE_BYTES_NONE;
2400137a:	2300      	movs	r3, #0
2400137c:	627b      	str	r3, [r7, #36]	; 0x24
    do {
        sCommand.Address = current_addr;
2400137e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
24001380:	61bb      	str	r3, [r7, #24]
        sCommand.NbData = current_size;
24001382:	6d7b      	ldr	r3, [r7, #84]	; 0x54
24001384:	63fb      	str	r3, [r7, #60]	; 0x3c
        if (current_size == 0) {
24001386:	6d7b      	ldr	r3, [r7, #84]	; 0x54
24001388:	2b00      	cmp	r3, #0
2400138a:	d101      	bne.n	24001390 <CSP_QSPI_WriteMemory+0x94>
            return HAL_OK;
2400138c:	2300      	movs	r3, #0
2400138e:	e03f      	b.n	24001410 <CSP_QSPI_WriteMemory+0x114>
        }
        if (QSPI_WriteEnable() != HAL_OK) {
24001390:	f7ff fe78 	bl	24001084 <QSPI_WriteEnable>
24001394:	4603      	mov	r3, r0
24001396:	2b00      	cmp	r3, #0
24001398:	d001      	beq.n	2400139e <CSP_QSPI_WriteMemory+0xa2>
            return HAL_ERROR;
2400139a:	2301      	movs	r3, #1
2400139c:	e038      	b.n	24001410 <CSP_QSPI_WriteMemory+0x114>
        }
        if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2400139e:	f107 0314 	add.w	r3, r7, #20
240013a2:	f241 3288 	movw	r2, #5000	; 0x1388
240013a6:	4619      	mov	r1, r3
240013a8:	481b      	ldr	r0, [pc, #108]	; (24001418 <CSP_QSPI_WriteMemory+0x11c>)
240013aa:	f010 fcfd 	bl	24011da8 <HAL_QSPI_Command>
240013ae:	4603      	mov	r3, r0
240013b0:	2b00      	cmp	r3, #0
240013b2:	d001      	beq.n	240013b8 <CSP_QSPI_WriteMemory+0xbc>
            != HAL_OK) {

            return HAL_ERROR;
240013b4:	2301      	movs	r3, #1
240013b6:	e02b      	b.n	24001410 <CSP_QSPI_WriteMemory+0x114>
        }

        if (HAL_QSPI_Transmit(&hqspi, buffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
240013b8:	f241 3288 	movw	r2, #5000	; 0x1388
240013bc:	68f9      	ldr	r1, [r7, #12]
240013be:	4816      	ldr	r0, [pc, #88]	; (24001418 <CSP_QSPI_WriteMemory+0x11c>)
240013c0:	f010 fdb6 	bl	24011f30 <HAL_QSPI_Transmit>
240013c4:	4603      	mov	r3, r0
240013c6:	2b00      	cmp	r3, #0
240013c8:	d001      	beq.n	240013ce <CSP_QSPI_WriteMemory+0xd2>

            return HAL_ERROR;
240013ca:	2301      	movs	r3, #1
240013cc:	e020      	b.n	24001410 <CSP_QSPI_WriteMemory+0x114>
        }
        if (QSPI_AutoPollingMemReady() != HAL_OK) {
240013ce:	f7ff fe21 	bl	24001014 <QSPI_AutoPollingMemReady>
240013d2:	4603      	mov	r3, r0
240013d4:	2b00      	cmp	r3, #0
240013d6:	d001      	beq.n	240013dc <CSP_QSPI_WriteMemory+0xe0>
            return HAL_ERROR;
240013d8:	2301      	movs	r3, #1
240013da:	e019      	b.n	24001410 <CSP_QSPI_WriteMemory+0x114>
        }

        current_addr += current_size;
240013dc:	6d3a      	ldr	r2, [r7, #80]	; 0x50
240013de:	6d7b      	ldr	r3, [r7, #84]	; 0x54
240013e0:	4413      	add	r3, r2
240013e2:	653b      	str	r3, [r7, #80]	; 0x50
        buffer += current_size;
240013e4:	68fa      	ldr	r2, [r7, #12]
240013e6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
240013e8:	4413      	add	r3, r2
240013ea:	60fb      	str	r3, [r7, #12]
        current_size =
            ((current_addr + MEMORY_PAGE_SIZE) > end_addr) ?
240013ec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
240013ee:	f503 7380 	add.w	r3, r3, #256	; 0x100
            (end_addr - current_addr) : MEMORY_PAGE_SIZE;
240013f2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
240013f4:	429a      	cmp	r2, r3
240013f6:	d203      	bcs.n	24001400 <CSP_QSPI_WriteMemory+0x104>
240013f8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
240013fa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
240013fc:	1ad3      	subs	r3, r2, r3
240013fe:	e001      	b.n	24001404 <CSP_QSPI_WriteMemory+0x108>
24001400:	f44f 7380 	mov.w	r3, #256	; 0x100
        current_size =
24001404:	657b      	str	r3, [r7, #84]	; 0x54
    } while (current_addr <= end_addr);
24001406:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24001408:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
2400140a:	429a      	cmp	r2, r3
2400140c:	d9b7      	bls.n	2400137e <CSP_QSPI_WriteMemory+0x82>

    return HAL_OK;
2400140e:	2300      	movs	r3, #0

}
24001410:	4618      	mov	r0, r3
24001412:	3758      	adds	r7, #88	; 0x58
24001414:	46bd      	mov	sp, r7
24001416:	bd80      	pop	{r7, pc}
24001418:	24000540 	.word	0x24000540

2400141c <CSP_QSPI_EnableMemoryMappedMode>:
//    return HAL_OK;
//}

//original
uint8_t
CSP_QSPI_EnableMemoryMappedMode(void) {
2400141c:	b580      	push	{r7, lr}
2400141e:	b090      	sub	sp, #64	; 0x40
24001420:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    QSPI_MemoryMappedTypeDef sMemMappedCfg;

    /* Enable Memory-Mapped mode-------------------------------------------------- */

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24001422:	f44f 7380 	mov.w	r3, #256	; 0x100
24001426:	623b      	str	r3, [r7, #32]
    sCommand.AddressSize = QSPI_ADDRESS_32_BITS;
24001428:	f44f 5340 	mov.w	r3, #12288	; 0x3000
2400142c:	617b      	str	r3, [r7, #20]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2400142e:	2300      	movs	r3, #0
24001430:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001432:	2300      	movs	r3, #0
24001434:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24001436:	2300      	movs	r3, #0
24001438:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.SIOOMode = QSPI_DDR_HHC_HALF_CLK_DELAY;
2400143a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
2400143e:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.AddressMode = QSPI_ADDRESS_4_LINES;
24001440:	f44f 6340 	mov.w	r3, #3072	; 0xc00
24001444:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DataMode = QSPI_DATA_4_LINES;
24001446:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
2400144a:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.NbData = 0;
2400144c:	2300      	movs	r3, #0
2400144e:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.Address = 0;
24001450:	2300      	movs	r3, #0
24001452:	60fb      	str	r3, [r7, #12]
    sCommand.Instruction = 0xEC;
24001454:	23ec      	movs	r3, #236	; 0xec
24001456:	60bb      	str	r3, [r7, #8]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001458:	2300      	movs	r3, #0
2400145a:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.AlternateBytes = QSPI_ALTERNATE_BYTES_NONE;
2400145c:	2300      	movs	r3, #0
2400145e:	613b      	str	r3, [r7, #16]
    sCommand.AlternateBytesSize = QSPI_ALTERNATE_BYTES_NONE;
24001460:	2300      	movs	r3, #0
24001462:	61bb      	str	r3, [r7, #24]
    sCommand.DummyCycles = 6;
24001464:	2306      	movs	r3, #6
24001466:	61fb      	str	r3, [r7, #28]

    sMemMappedCfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_ENABLE;
24001468:	2308      	movs	r3, #8
2400146a:	607b      	str	r3, [r7, #4]

    if (HAL_QSPI_MemoryMapped(&hqspi, &sCommand, &sMemMappedCfg) != HAL_OK) {
2400146c:	463a      	mov	r2, r7
2400146e:	f107 0308 	add.w	r3, r7, #8
24001472:	4619      	mov	r1, r3
24001474:	4806      	ldr	r0, [pc, #24]	; (24001490 <CSP_QSPI_EnableMemoryMappedMode+0x74>)
24001476:	f011 fa30 	bl	240128da <HAL_QSPI_MemoryMapped>
2400147a:	4603      	mov	r3, r0
2400147c:	2b00      	cmp	r3, #0
2400147e:	d001      	beq.n	24001484 <CSP_QSPI_EnableMemoryMappedMode+0x68>
        return HAL_ERROR;
24001480:	2301      	movs	r3, #1
24001482:	e000      	b.n	24001486 <CSP_QSPI_EnableMemoryMappedMode+0x6a>
    }
    return HAL_OK;
24001484:	2300      	movs	r3, #0
}
24001486:	4618      	mov	r0, r3
24001488:	3740      	adds	r7, #64	; 0x40
2400148a:	46bd      	mov	sp, r7
2400148c:	bd80      	pop	{r7, pc}
2400148e:	bf00      	nop
24001490:	24000540 	.word	0x24000540

24001494 <QSPI_ResetChip>:



uint8_t
QSPI_ResetChip() {
24001494:	b580      	push	{r7, lr}
24001496:	b090      	sub	sp, #64	; 0x40
24001498:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    uint32_t temp = 0;
2400149a:	2300      	movs	r3, #0
2400149c:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* Erasing Sequence -------------------------------------------------- */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2400149e:	f44f 7380 	mov.w	r3, #256	; 0x100
240014a2:	61fb      	str	r3, [r7, #28]
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
240014a4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240014a8:	613b      	str	r3, [r7, #16]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240014aa:	2300      	movs	r3, #0
240014ac:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240014ae:	2300      	movs	r3, #0
240014b0:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240014b2:	2300      	movs	r3, #0
240014b4:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240014b6:	2300      	movs	r3, #0
240014b8:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = RESET_ENABLE_CMD;
240014ba:	2366      	movs	r3, #102	; 0x66
240014bc:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
240014be:	2300      	movs	r3, #0
240014c0:	623b      	str	r3, [r7, #32]
    sCommand.Address = 0;
240014c2:	2300      	movs	r3, #0
240014c4:	60bb      	str	r3, [r7, #8]
    sCommand.DataMode = QSPI_DATA_NONE;
240014c6:	2300      	movs	r3, #0
240014c8:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
240014ca:	2300      	movs	r3, #0
240014cc:	61bb      	str	r3, [r7, #24]

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
240014ce:	1d3b      	adds	r3, r7, #4
240014d0:	f241 3288 	movw	r2, #5000	; 0x1388
240014d4:	4619      	mov	r1, r3
240014d6:	481d      	ldr	r0, [pc, #116]	; (2400154c <QSPI_ResetChip+0xb8>)
240014d8:	f010 fc66 	bl	24011da8 <HAL_QSPI_Command>
240014dc:	4603      	mov	r3, r0
240014de:	2b00      	cmp	r3, #0
240014e0:	d001      	beq.n	240014e6 <QSPI_ResetChip+0x52>
        != HAL_OK) {
        return HAL_ERROR;
240014e2:	2301      	movs	r3, #1
240014e4:	e02e      	b.n	24001544 <QSPI_ResetChip+0xb0>
    }
    for (temp = 0; temp < 0x2f; temp++) {
240014e6:	2300      	movs	r3, #0
240014e8:	63fb      	str	r3, [r7, #60]	; 0x3c
240014ea:	e003      	b.n	240014f4 <QSPI_ResetChip+0x60>
        __NOP();
240014ec:	bf00      	nop
    for (temp = 0; temp < 0x2f; temp++) {
240014ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
240014f0:	3301      	adds	r3, #1
240014f2:	63fb      	str	r3, [r7, #60]	; 0x3c
240014f4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
240014f6:	2b2e      	cmp	r3, #46	; 0x2e
240014f8:	d9f8      	bls.n	240014ec <QSPI_ResetChip+0x58>
    }

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240014fa:	f44f 7380 	mov.w	r3, #256	; 0x100
240014fe:	61fb      	str	r3, [r7, #28]
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
24001500:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24001504:	613b      	str	r3, [r7, #16]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001506:	2300      	movs	r3, #0
24001508:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400150a:	2300      	movs	r3, #0
2400150c:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400150e:	2300      	movs	r3, #0
24001510:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001512:	2300      	movs	r3, #0
24001514:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = RESET_EXECUTE_CMD;
24001516:	2399      	movs	r3, #153	; 0x99
24001518:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
2400151a:	2300      	movs	r3, #0
2400151c:	623b      	str	r3, [r7, #32]
    sCommand.Address = 0;
2400151e:	2300      	movs	r3, #0
24001520:	60bb      	str	r3, [r7, #8]
    sCommand.DataMode = QSPI_DATA_NONE;
24001522:	2300      	movs	r3, #0
24001524:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
24001526:	2300      	movs	r3, #0
24001528:	61bb      	str	r3, [r7, #24]

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2400152a:	1d3b      	adds	r3, r7, #4
2400152c:	f241 3288 	movw	r2, #5000	; 0x1388
24001530:	4619      	mov	r1, r3
24001532:	4806      	ldr	r0, [pc, #24]	; (2400154c <QSPI_ResetChip+0xb8>)
24001534:	f010 fc38 	bl	24011da8 <HAL_QSPI_Command>
24001538:	4603      	mov	r3, r0
2400153a:	2b00      	cmp	r3, #0
2400153c:	d001      	beq.n	24001542 <QSPI_ResetChip+0xae>
        != HAL_OK) {
        return HAL_ERROR;
2400153e:	2301      	movs	r3, #1
24001540:	e000      	b.n	24001544 <QSPI_ResetChip+0xb0>
    }
    return HAL_OK;
24001542:	2300      	movs	r3, #0
}
24001544:	4618      	mov	r0, r3
24001546:	3740      	adds	r7, #64	; 0x40
24001548:	46bd      	mov	sp, r7
2400154a:	bd80      	pop	{r7, pc}
2400154c:	24000540 	.word	0x24000540

24001550 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
24001550:	b480      	push	{r7}
24001552:	b083      	sub	sp, #12
24001554:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
24001556:	4b0a      	ldr	r3, [pc, #40]	; (24001580 <HAL_MspInit+0x30>)
24001558:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400155c:	4a08      	ldr	r2, [pc, #32]	; (24001580 <HAL_MspInit+0x30>)
2400155e:	f043 0302 	orr.w	r3, r3, #2
24001562:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
24001566:	4b06      	ldr	r3, [pc, #24]	; (24001580 <HAL_MspInit+0x30>)
24001568:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400156c:	f003 0302 	and.w	r3, r3, #2
24001570:	607b      	str	r3, [r7, #4]
24001572:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
24001574:	bf00      	nop
24001576:	370c      	adds	r7, #12
24001578:	46bd      	mov	sp, r7
2400157a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400157e:	4770      	bx	lr
24001580:	58024400 	.word	0x58024400

24001584 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
24001584:	b580      	push	{r7, lr}
24001586:	b090      	sub	sp, #64	; 0x40
24001588:	af00      	add	r7, sp, #0
2400158a:	6078      	str	r0, [r7, #4]
  uint32_t              uwTimclock, uwAPB1Prescaler;

  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;
/*Configure the TIM2 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
2400158c:	687b      	ldr	r3, [r7, #4]
2400158e:	2b0f      	cmp	r3, #15
24001590:	d827      	bhi.n	240015e2 <HAL_InitTick+0x5e>
  {
  HAL_NVIC_SetPriority(TIM2_IRQn, TickPriority ,0U);
24001592:	2200      	movs	r2, #0
24001594:	6879      	ldr	r1, [r7, #4]
24001596:	201c      	movs	r0, #28
24001598:	f001 fb5b 	bl	24002c52 <HAL_NVIC_SetPriority>

  /* Enable the TIM2 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM2_IRQn);
2400159c:	201c      	movs	r0, #28
2400159e:	f001 fb72 	bl	24002c86 <HAL_NVIC_EnableIRQ>
    uwTickPrio = TickPriority;
240015a2:	4a29      	ldr	r2, [pc, #164]	; (24001648 <HAL_InitTick+0xc4>)
240015a4:	687b      	ldr	r3, [r7, #4]
240015a6:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Enable TIM2 clock */
  __HAL_RCC_TIM2_CLK_ENABLE();
240015a8:	4b28      	ldr	r3, [pc, #160]	; (2400164c <HAL_InitTick+0xc8>)
240015aa:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
240015ae:	4a27      	ldr	r2, [pc, #156]	; (2400164c <HAL_InitTick+0xc8>)
240015b0:	f043 0301 	orr.w	r3, r3, #1
240015b4:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
240015b8:	4b24      	ldr	r3, [pc, #144]	; (2400164c <HAL_InitTick+0xc8>)
240015ba:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
240015be:	f003 0301 	and.w	r3, r3, #1
240015c2:	60fb      	str	r3, [r7, #12]
240015c4:	68fb      	ldr	r3, [r7, #12]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
240015c6:	f107 0210 	add.w	r2, r7, #16
240015ca:	f107 0314 	add.w	r3, r7, #20
240015ce:	4611      	mov	r1, r2
240015d0:	4618      	mov	r0, r3
240015d2:	f013 f883 	bl	240146dc <HAL_RCC_GetClockConfig>

  /* Get APB1 prescaler */
  uwAPB1Prescaler = clkconfig.APB1CLKDivider;
240015d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
240015d8:	63bb      	str	r3, [r7, #56]	; 0x38
  /* Compute TIM2 clock */
  if (uwAPB1Prescaler == RCC_HCLK_DIV1)
240015da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240015dc:	2b00      	cmp	r3, #0
240015de:	d106      	bne.n	240015ee <HAL_InitTick+0x6a>
240015e0:	e001      	b.n	240015e6 <HAL_InitTick+0x62>
    return HAL_ERROR;
240015e2:	2301      	movs	r3, #1
240015e4:	e02c      	b.n	24001640 <HAL_InitTick+0xbc>
  {
    uwTimclock = HAL_RCC_GetPCLK1Freq();
240015e6:	f012 ff5f 	bl	240144a8 <HAL_RCC_GetPCLK1Freq>
240015ea:	63f8      	str	r0, [r7, #60]	; 0x3c
240015ec:	e004      	b.n	240015f8 <HAL_InitTick+0x74>
  }
  else
  {
    uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
240015ee:	f012 ff5b 	bl	240144a8 <HAL_RCC_GetPCLK1Freq>
240015f2:	4603      	mov	r3, r0
240015f4:	005b      	lsls	r3, r3, #1
240015f6:	63fb      	str	r3, [r7, #60]	; 0x3c
  }

  /* Compute the prescaler value to have TIM2 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
240015f8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
240015fa:	4a15      	ldr	r2, [pc, #84]	; (24001650 <HAL_InitTick+0xcc>)
240015fc:	fba2 2303 	umull	r2, r3, r2, r3
24001600:	0c9b      	lsrs	r3, r3, #18
24001602:	3b01      	subs	r3, #1
24001604:	637b      	str	r3, [r7, #52]	; 0x34

  /* Initialize TIM2 */
  htim2.Instance = TIM2;
24001606:	4b13      	ldr	r3, [pc, #76]	; (24001654 <HAL_InitTick+0xd0>)
24001608:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
2400160c:	601a      	str	r2, [r3, #0]
  + Period = [(TIM2CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim2.Init.Period = (1000000U / 1000U) - 1U;
2400160e:	4b11      	ldr	r3, [pc, #68]	; (24001654 <HAL_InitTick+0xd0>)
24001610:	f240 32e7 	movw	r2, #999	; 0x3e7
24001614:	60da      	str	r2, [r3, #12]
  htim2.Init.Prescaler = uwPrescalerValue;
24001616:	4a0f      	ldr	r2, [pc, #60]	; (24001654 <HAL_InitTick+0xd0>)
24001618:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2400161a:	6053      	str	r3, [r2, #4]
  htim2.Init.ClockDivision = 0;
2400161c:	4b0d      	ldr	r3, [pc, #52]	; (24001654 <HAL_InitTick+0xd0>)
2400161e:	2200      	movs	r2, #0
24001620:	611a      	str	r2, [r3, #16]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
24001622:	4b0c      	ldr	r3, [pc, #48]	; (24001654 <HAL_InitTick+0xd0>)
24001624:	2200      	movs	r2, #0
24001626:	609a      	str	r2, [r3, #8]

  if(HAL_TIM_Base_Init(&htim2) == HAL_OK)
24001628:	480a      	ldr	r0, [pc, #40]	; (24001654 <HAL_InitTick+0xd0>)
2400162a:	f016 f9ba 	bl	240179a2 <HAL_TIM_Base_Init>
2400162e:	4603      	mov	r3, r0
24001630:	2b00      	cmp	r3, #0
24001632:	d104      	bne.n	2400163e <HAL_InitTick+0xba>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim2);
24001634:	4807      	ldr	r0, [pc, #28]	; (24001654 <HAL_InitTick+0xd0>)
24001636:	f016 fb13 	bl	24017c60 <HAL_TIM_Base_Start_IT>
2400163a:	4603      	mov	r3, r0
2400163c:	e000      	b.n	24001640 <HAL_InitTick+0xbc>
  }

  /* Return function status */
  return HAL_ERROR;
2400163e:	2301      	movs	r3, #1
}
24001640:	4618      	mov	r0, r3
24001642:	3740      	adds	r7, #64	; 0x40
24001644:	46bd      	mov	sp, r7
24001646:	bd80      	pop	{r7, pc}
24001648:	240004b8 	.word	0x240004b8
2400164c:	58024400 	.word	0x58024400
24001650:	431bde83 	.word	0x431bde83
24001654:	2400058c 	.word	0x2400058c

24001658 <HAL_SuspendTick>:
  * @note   Disable the tick increment by disabling TIM2 update interrupt.
  * @param  None
  * @retval None
  */
void HAL_SuspendTick(void)
{
24001658:	b480      	push	{r7}
2400165a:	af00      	add	r7, sp, #0
  /* Disable TIM2 update Interrupt */
  __HAL_TIM_DISABLE_IT(&htim2, TIM_IT_UPDATE);
2400165c:	4b06      	ldr	r3, [pc, #24]	; (24001678 <HAL_SuspendTick+0x20>)
2400165e:	681b      	ldr	r3, [r3, #0]
24001660:	68da      	ldr	r2, [r3, #12]
24001662:	4b05      	ldr	r3, [pc, #20]	; (24001678 <HAL_SuspendTick+0x20>)
24001664:	681b      	ldr	r3, [r3, #0]
24001666:	f022 0201 	bic.w	r2, r2, #1
2400166a:	60da      	str	r2, [r3, #12]
}
2400166c:	bf00      	nop
2400166e:	46bd      	mov	sp, r7
24001670:	f85d 7b04 	ldr.w	r7, [sp], #4
24001674:	4770      	bx	lr
24001676:	bf00      	nop
24001678:	2400058c 	.word	0x2400058c

2400167c <HAL_ResumeTick>:
  * @note   Enable the tick increment by Enabling TIM2 update interrupt.
  * @param  None
  * @retval None
  */
void HAL_ResumeTick(void)
{
2400167c:	b480      	push	{r7}
2400167e:	af00      	add	r7, sp, #0
  /* Enable TIM2 Update interrupt */
  __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);
24001680:	4b06      	ldr	r3, [pc, #24]	; (2400169c <HAL_ResumeTick+0x20>)
24001682:	681b      	ldr	r3, [r3, #0]
24001684:	68da      	ldr	r2, [r3, #12]
24001686:	4b05      	ldr	r3, [pc, #20]	; (2400169c <HAL_ResumeTick+0x20>)
24001688:	681b      	ldr	r3, [r3, #0]
2400168a:	f042 0201 	orr.w	r2, r2, #1
2400168e:	60da      	str	r2, [r3, #12]
}
24001690:	bf00      	nop
24001692:	46bd      	mov	sp, r7
24001694:	f85d 7b04 	ldr.w	r7, [sp], #4
24001698:	4770      	bx	lr
2400169a:	bf00      	nop
2400169c:	2400058c 	.word	0x2400058c

240016a0 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
240016a0:	b480      	push	{r7}
240016a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
240016a4:	e7fe      	b.n	240016a4 <NMI_Handler+0x4>

240016a6 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
240016a6:	b480      	push	{r7}
240016a8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
240016aa:	e7fe      	b.n	240016aa <HardFault_Handler+0x4>

240016ac <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
240016ac:	b480      	push	{r7}
240016ae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
240016b0:	e7fe      	b.n	240016b0 <MemManage_Handler+0x4>

240016b2 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
240016b2:	b480      	push	{r7}
240016b4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
240016b6:	e7fe      	b.n	240016b6 <BusFault_Handler+0x4>

240016b8 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
240016b8:	b480      	push	{r7}
240016ba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
240016bc:	e7fe      	b.n	240016bc <UsageFault_Handler+0x4>

240016be <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
240016be:	b480      	push	{r7}
240016c0:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
240016c2:	bf00      	nop
240016c4:	46bd      	mov	sp, r7
240016c6:	f85d 7b04 	ldr.w	r7, [sp], #4
240016ca:	4770      	bx	lr

240016cc <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
240016cc:	b480      	push	{r7}
240016ce:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
240016d0:	bf00      	nop
240016d2:	46bd      	mov	sp, r7
240016d4:	f85d 7b04 	ldr.w	r7, [sp], #4
240016d8:	4770      	bx	lr

240016da <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
240016da:	b480      	push	{r7}
240016dc:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
240016de:	bf00      	nop
240016e0:	46bd      	mov	sp, r7
240016e2:	f85d 7b04 	ldr.w	r7, [sp], #4
240016e6:	4770      	bx	lr

240016e8 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
240016e8:	b480      	push	{r7}
240016ea:	af00      	add	r7, sp, #0
  /* USER CODE END SysTick_IRQn 0 */

  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
240016ec:	bf00      	nop
240016ee:	46bd      	mov	sp, r7
240016f0:	f85d 7b04 	ldr.w	r7, [sp], #4
240016f4:	4770      	bx	lr
	...

240016f8 <TIM2_IRQHandler>:

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
240016f8:	b580      	push	{r7, lr}
240016fa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
240016fc:	4802      	ldr	r0, [pc, #8]	; (24001708 <TIM2_IRQHandler+0x10>)
240016fe:	f01a fb52 	bl	2401bda6 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}
24001702:	bf00      	nop
24001704:	bd80      	pop	{r7, pc}
24001706:	bf00      	nop
24001708:	2400058c 	.word	0x2400058c

2400170c <Custome_ITM_SendChar_ch0>:
#include <sys/times.h>

#include "stm32h7xx.h"

void Custome_ITM_SendChar_ch0(uint8_t data)
{
2400170c:	b480      	push	{r7}
2400170e:	b083      	sub	sp, #12
24001710:	af00      	add	r7, sp, #0
24001712:	4603      	mov	r3, r0
24001714:	71fb      	strb	r3, [r7, #7]
    // Enable DWT and ITM units by setting the TRCENA bit in the DEMCR register
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
24001716:	4b11      	ldr	r3, [pc, #68]	; (2400175c <Custome_ITM_SendChar_ch0+0x50>)
24001718:	68db      	ldr	r3, [r3, #12]
2400171a:	4a10      	ldr	r2, [pc, #64]	; (2400175c <Custome_ITM_SendChar_ch0+0x50>)
2400171c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
24001720:	60d3      	str	r3, [r2, #12]
    // Enable Stimulus Port 0 by setting the corresponding bit in the ITM Trace Enable Register
    ITM->TER |= (1UL << 0);
24001722:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
24001726:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
2400172a:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
2400172e:	f043 0301 	orr.w	r3, r3, #1
24001732:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
    // Wait until the FIFO is ready to accept data
    while (!(ITM->PORT[0].u32 & 1U));
24001736:	bf00      	nop
24001738:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
2400173c:	681b      	ldr	r3, [r3, #0]
2400173e:	f003 0301 	and.w	r3, r3, #1
24001742:	2b00      	cmp	r3, #0
24001744:	d0f8      	beq.n	24001738 <Custome_ITM_SendChar_ch0+0x2c>

    // Write data to the ITM Stimulus Port 0
    ITM->PORT[0].u8 = data;
24001746:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
2400174a:	79fb      	ldrb	r3, [r7, #7]
2400174c:	7013      	strb	r3, [r2, #0]
}
2400174e:	bf00      	nop
24001750:	370c      	adds	r7, #12
24001752:	46bd      	mov	sp, r7
24001754:	f85d 7b04 	ldr.w	r7, [sp], #4
24001758:	4770      	bx	lr
2400175a:	bf00      	nop
2400175c:	e000edf0 	.word	0xe000edf0

24001760 <initialise_monitor_handles>:
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
24001760:	b480      	push	{r7}
24001762:	af00      	add	r7, sp, #0
}
24001764:	bf00      	nop
24001766:	46bd      	mov	sp, r7
24001768:	f85d 7b04 	ldr.w	r7, [sp], #4
2400176c:	4770      	bx	lr

2400176e <_getpid>:

int _getpid(void)
{
2400176e:	b480      	push	{r7}
24001770:	af00      	add	r7, sp, #0
  return 1;
24001772:	2301      	movs	r3, #1
}
24001774:	4618      	mov	r0, r3
24001776:	46bd      	mov	sp, r7
24001778:	f85d 7b04 	ldr.w	r7, [sp], #4
2400177c:	4770      	bx	lr

2400177e <_kill>:

int _kill(int pid, int sig)
{
2400177e:	b580      	push	{r7, lr}
24001780:	b082      	sub	sp, #8
24001782:	af00      	add	r7, sp, #0
24001784:	6078      	str	r0, [r7, #4]
24001786:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
24001788:	f01f fb28 	bl	24020ddc <__errno>
2400178c:	4603      	mov	r3, r0
2400178e:	2216      	movs	r2, #22
24001790:	601a      	str	r2, [r3, #0]
  return -1;
24001792:	f04f 33ff 	mov.w	r3, #4294967295
}
24001796:	4618      	mov	r0, r3
24001798:	3708      	adds	r7, #8
2400179a:	46bd      	mov	sp, r7
2400179c:	bd80      	pop	{r7, pc}

2400179e <_exit>:

void _exit (int status)
{
2400179e:	b580      	push	{r7, lr}
240017a0:	b082      	sub	sp, #8
240017a2:	af00      	add	r7, sp, #0
240017a4:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
240017a6:	f04f 31ff 	mov.w	r1, #4294967295
240017aa:	6878      	ldr	r0, [r7, #4]
240017ac:	f7ff ffe7 	bl	2400177e <_kill>
  while (1) {}    /* Make sure we hang here */
240017b0:	e7fe      	b.n	240017b0 <_exit+0x12>

240017b2 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
240017b2:	b580      	push	{r7, lr}
240017b4:	b086      	sub	sp, #24
240017b6:	af00      	add	r7, sp, #0
240017b8:	60f8      	str	r0, [r7, #12]
240017ba:	60b9      	str	r1, [r7, #8]
240017bc:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
240017be:	2300      	movs	r3, #0
240017c0:	617b      	str	r3, [r7, #20]
240017c2:	e00a      	b.n	240017da <_read+0x28>
  {
    *ptr++ = __io_getchar();
240017c4:	f3af 8000 	nop.w
240017c8:	4601      	mov	r1, r0
240017ca:	68bb      	ldr	r3, [r7, #8]
240017cc:	1c5a      	adds	r2, r3, #1
240017ce:	60ba      	str	r2, [r7, #8]
240017d0:	b2ca      	uxtb	r2, r1
240017d2:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
240017d4:	697b      	ldr	r3, [r7, #20]
240017d6:	3301      	adds	r3, #1
240017d8:	617b      	str	r3, [r7, #20]
240017da:	697a      	ldr	r2, [r7, #20]
240017dc:	687b      	ldr	r3, [r7, #4]
240017de:	429a      	cmp	r2, r3
240017e0:	dbf0      	blt.n	240017c4 <_read+0x12>
  }

  return len;
240017e2:	687b      	ldr	r3, [r7, #4]
}
240017e4:	4618      	mov	r0, r3
240017e6:	3718      	adds	r7, #24
240017e8:	46bd      	mov	sp, r7
240017ea:	bd80      	pop	{r7, pc}

240017ec <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
240017ec:	b580      	push	{r7, lr}
240017ee:	b086      	sub	sp, #24
240017f0:	af00      	add	r7, sp, #0
240017f2:	60f8      	str	r0, [r7, #12]
240017f4:	60b9      	str	r1, [r7, #8]
240017f6:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
240017f8:	2300      	movs	r3, #0
240017fa:	617b      	str	r3, [r7, #20]
240017fc:	e009      	b.n	24001812 <_write+0x26>
  {
	  Custome_ITM_SendChar_ch0(*ptr++);
240017fe:	68bb      	ldr	r3, [r7, #8]
24001800:	1c5a      	adds	r2, r3, #1
24001802:	60ba      	str	r2, [r7, #8]
24001804:	781b      	ldrb	r3, [r3, #0]
24001806:	4618      	mov	r0, r3
24001808:	f7ff ff80 	bl	2400170c <Custome_ITM_SendChar_ch0>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
2400180c:	697b      	ldr	r3, [r7, #20]
2400180e:	3301      	adds	r3, #1
24001810:	617b      	str	r3, [r7, #20]
24001812:	697a      	ldr	r2, [r7, #20]
24001814:	687b      	ldr	r3, [r7, #4]
24001816:	429a      	cmp	r2, r3
24001818:	dbf1      	blt.n	240017fe <_write+0x12>
  }
  return len;
2400181a:	687b      	ldr	r3, [r7, #4]
}
2400181c:	4618      	mov	r0, r3
2400181e:	3718      	adds	r7, #24
24001820:	46bd      	mov	sp, r7
24001822:	bd80      	pop	{r7, pc}

24001824 <_close>:

int _close(int file)
{
24001824:	b480      	push	{r7}
24001826:	b083      	sub	sp, #12
24001828:	af00      	add	r7, sp, #0
2400182a:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
2400182c:	f04f 33ff 	mov.w	r3, #4294967295
}
24001830:	4618      	mov	r0, r3
24001832:	370c      	adds	r7, #12
24001834:	46bd      	mov	sp, r7
24001836:	f85d 7b04 	ldr.w	r7, [sp], #4
2400183a:	4770      	bx	lr

2400183c <_fstat>:


int _fstat(int file, struct stat *st)
{
2400183c:	b480      	push	{r7}
2400183e:	b083      	sub	sp, #12
24001840:	af00      	add	r7, sp, #0
24001842:	6078      	str	r0, [r7, #4]
24001844:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
24001846:	683b      	ldr	r3, [r7, #0]
24001848:	f44f 5200 	mov.w	r2, #8192	; 0x2000
2400184c:	605a      	str	r2, [r3, #4]
  return 0;
2400184e:	2300      	movs	r3, #0
}
24001850:	4618      	mov	r0, r3
24001852:	370c      	adds	r7, #12
24001854:	46bd      	mov	sp, r7
24001856:	f85d 7b04 	ldr.w	r7, [sp], #4
2400185a:	4770      	bx	lr

2400185c <_isatty>:

int _isatty(int file)
{
2400185c:	b480      	push	{r7}
2400185e:	b083      	sub	sp, #12
24001860:	af00      	add	r7, sp, #0
24001862:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
24001864:	2301      	movs	r3, #1
}
24001866:	4618      	mov	r0, r3
24001868:	370c      	adds	r7, #12
2400186a:	46bd      	mov	sp, r7
2400186c:	f85d 7b04 	ldr.w	r7, [sp], #4
24001870:	4770      	bx	lr

24001872 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
24001872:	b480      	push	{r7}
24001874:	b085      	sub	sp, #20
24001876:	af00      	add	r7, sp, #0
24001878:	60f8      	str	r0, [r7, #12]
2400187a:	60b9      	str	r1, [r7, #8]
2400187c:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
2400187e:	2300      	movs	r3, #0
}
24001880:	4618      	mov	r0, r3
24001882:	3714      	adds	r7, #20
24001884:	46bd      	mov	sp, r7
24001886:	f85d 7b04 	ldr.w	r7, [sp], #4
2400188a:	4770      	bx	lr

2400188c <_open>:

int _open(char *path, int flags, ...)
{
2400188c:	b40e      	push	{r1, r2, r3}
2400188e:	b480      	push	{r7}
24001890:	b082      	sub	sp, #8
24001892:	af00      	add	r7, sp, #0
24001894:	6078      	str	r0, [r7, #4]
  (void)path;
  (void)flags;
  /* Pretend like we always fail */
  return -1;
24001896:	f04f 33ff 	mov.w	r3, #4294967295
}
2400189a:	4618      	mov	r0, r3
2400189c:	3708      	adds	r7, #8
2400189e:	46bd      	mov	sp, r7
240018a0:	f85d 7b04 	ldr.w	r7, [sp], #4
240018a4:	b003      	add	sp, #12
240018a6:	4770      	bx	lr

240018a8 <_wait>:

int _wait(int *status)
{
240018a8:	b580      	push	{r7, lr}
240018aa:	b082      	sub	sp, #8
240018ac:	af00      	add	r7, sp, #0
240018ae:	6078      	str	r0, [r7, #4]
  (void)status;
  errno = ECHILD;
240018b0:	f01f fa94 	bl	24020ddc <__errno>
240018b4:	4603      	mov	r3, r0
240018b6:	220a      	movs	r2, #10
240018b8:	601a      	str	r2, [r3, #0]
  return -1;
240018ba:	f04f 33ff 	mov.w	r3, #4294967295
}
240018be:	4618      	mov	r0, r3
240018c0:	3708      	adds	r7, #8
240018c2:	46bd      	mov	sp, r7
240018c4:	bd80      	pop	{r7, pc}

240018c6 <_unlink>:

int _unlink(char *name)
{
240018c6:	b580      	push	{r7, lr}
240018c8:	b082      	sub	sp, #8
240018ca:	af00      	add	r7, sp, #0
240018cc:	6078      	str	r0, [r7, #4]
  (void)name;
  errno = ENOENT;
240018ce:	f01f fa85 	bl	24020ddc <__errno>
240018d2:	4603      	mov	r3, r0
240018d4:	2202      	movs	r2, #2
240018d6:	601a      	str	r2, [r3, #0]
  return -1;
240018d8:	f04f 33ff 	mov.w	r3, #4294967295
}
240018dc:	4618      	mov	r0, r3
240018de:	3708      	adds	r7, #8
240018e0:	46bd      	mov	sp, r7
240018e2:	bd80      	pop	{r7, pc}

240018e4 <_times>:

int _times(struct tms *buf)
{
240018e4:	b480      	push	{r7}
240018e6:	b083      	sub	sp, #12
240018e8:	af00      	add	r7, sp, #0
240018ea:	6078      	str	r0, [r7, #4]
  (void)buf;
  return -1;
240018ec:	f04f 33ff 	mov.w	r3, #4294967295
}
240018f0:	4618      	mov	r0, r3
240018f2:	370c      	adds	r7, #12
240018f4:	46bd      	mov	sp, r7
240018f6:	f85d 7b04 	ldr.w	r7, [sp], #4
240018fa:	4770      	bx	lr

240018fc <_stat>:

int _stat(char *file, struct stat *st)
{
240018fc:	b480      	push	{r7}
240018fe:	b083      	sub	sp, #12
24001900:	af00      	add	r7, sp, #0
24001902:	6078      	str	r0, [r7, #4]
24001904:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
24001906:	683b      	ldr	r3, [r7, #0]
24001908:	f44f 5200 	mov.w	r2, #8192	; 0x2000
2400190c:	605a      	str	r2, [r3, #4]
  return 0;
2400190e:	2300      	movs	r3, #0
}
24001910:	4618      	mov	r0, r3
24001912:	370c      	adds	r7, #12
24001914:	46bd      	mov	sp, r7
24001916:	f85d 7b04 	ldr.w	r7, [sp], #4
2400191a:	4770      	bx	lr

2400191c <_link>:

int _link(char *old, char *new)
{
2400191c:	b580      	push	{r7, lr}
2400191e:	b082      	sub	sp, #8
24001920:	af00      	add	r7, sp, #0
24001922:	6078      	str	r0, [r7, #4]
24001924:	6039      	str	r1, [r7, #0]
  (void)old;
  (void)new;
  errno = EMLINK;
24001926:	f01f fa59 	bl	24020ddc <__errno>
2400192a:	4603      	mov	r3, r0
2400192c:	221f      	movs	r2, #31
2400192e:	601a      	str	r2, [r3, #0]
  return -1;
24001930:	f04f 33ff 	mov.w	r3, #4294967295
}
24001934:	4618      	mov	r0, r3
24001936:	3708      	adds	r7, #8
24001938:	46bd      	mov	sp, r7
2400193a:	bd80      	pop	{r7, pc}

2400193c <_fork>:

int _fork(void)
{
2400193c:	b580      	push	{r7, lr}
2400193e:	af00      	add	r7, sp, #0
  errno = EAGAIN;
24001940:	f01f fa4c 	bl	24020ddc <__errno>
24001944:	4603      	mov	r3, r0
24001946:	220b      	movs	r2, #11
24001948:	601a      	str	r2, [r3, #0]
  return -1;
2400194a:	f04f 33ff 	mov.w	r3, #4294967295
}
2400194e:	4618      	mov	r0, r3
24001950:	bd80      	pop	{r7, pc}

24001952 <_execve>:

int _execve(char *name, char **argv, char **env)
{
24001952:	b580      	push	{r7, lr}
24001954:	b084      	sub	sp, #16
24001956:	af00      	add	r7, sp, #0
24001958:	60f8      	str	r0, [r7, #12]
2400195a:	60b9      	str	r1, [r7, #8]
2400195c:	607a      	str	r2, [r7, #4]
  (void)name;
  (void)argv;
  (void)env;
  errno = ENOMEM;
2400195e:	f01f fa3d 	bl	24020ddc <__errno>
24001962:	4603      	mov	r3, r0
24001964:	220c      	movs	r2, #12
24001966:	601a      	str	r2, [r3, #0]
  return -1;
24001968:	f04f 33ff 	mov.w	r3, #4294967295
}
2400196c:	4618      	mov	r0, r3
2400196e:	3710      	adds	r7, #16
24001970:	46bd      	mov	sp, r7
24001972:	bd80      	pop	{r7, pc}

24001974 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
24001974:	b580      	push	{r7, lr}
24001976:	b086      	sub	sp, #24
24001978:	af00      	add	r7, sp, #0
2400197a:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
2400197c:	4a14      	ldr	r2, [pc, #80]	; (240019d0 <_sbrk+0x5c>)
2400197e:	4b15      	ldr	r3, [pc, #84]	; (240019d4 <_sbrk+0x60>)
24001980:	1ad3      	subs	r3, r2, r3
24001982:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
24001984:	697b      	ldr	r3, [r7, #20]
24001986:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
24001988:	4b13      	ldr	r3, [pc, #76]	; (240019d8 <_sbrk+0x64>)
2400198a:	681b      	ldr	r3, [r3, #0]
2400198c:	2b00      	cmp	r3, #0
2400198e:	d102      	bne.n	24001996 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
24001990:	4b11      	ldr	r3, [pc, #68]	; (240019d8 <_sbrk+0x64>)
24001992:	4a12      	ldr	r2, [pc, #72]	; (240019dc <_sbrk+0x68>)
24001994:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
24001996:	4b10      	ldr	r3, [pc, #64]	; (240019d8 <_sbrk+0x64>)
24001998:	681a      	ldr	r2, [r3, #0]
2400199a:	687b      	ldr	r3, [r7, #4]
2400199c:	4413      	add	r3, r2
2400199e:	693a      	ldr	r2, [r7, #16]
240019a0:	429a      	cmp	r2, r3
240019a2:	d207      	bcs.n	240019b4 <_sbrk+0x40>
  {
    errno = ENOMEM;
240019a4:	f01f fa1a 	bl	24020ddc <__errno>
240019a8:	4603      	mov	r3, r0
240019aa:	220c      	movs	r2, #12
240019ac:	601a      	str	r2, [r3, #0]
    return (void *)-1;
240019ae:	f04f 33ff 	mov.w	r3, #4294967295
240019b2:	e009      	b.n	240019c8 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
240019b4:	4b08      	ldr	r3, [pc, #32]	; (240019d8 <_sbrk+0x64>)
240019b6:	681b      	ldr	r3, [r3, #0]
240019b8:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
240019ba:	4b07      	ldr	r3, [pc, #28]	; (240019d8 <_sbrk+0x64>)
240019bc:	681a      	ldr	r2, [r3, #0]
240019be:	687b      	ldr	r3, [r7, #4]
240019c0:	4413      	add	r3, r2
240019c2:	4a05      	ldr	r2, [pc, #20]	; (240019d8 <_sbrk+0x64>)
240019c4:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
240019c6:	68fb      	ldr	r3, [r7, #12]
}
240019c8:	4618      	mov	r0, r3
240019ca:	3718      	adds	r7, #24
240019cc:	46bd      	mov	sp, r7
240019ce:	bd80      	pop	{r7, pc}
240019d0:	24080004 	.word	0x24080004
240019d4:	00000400 	.word	0x00000400
240019d8:	240005dc 	.word	0x240005dc
240019dc:	24020fb0 	.word	0x24020fb0

240019e0 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
240019e0:	b480      	push	{r7}
240019e2:	af00      	add	r7, sp, #0
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
240019e4:	4b37      	ldr	r3, [pc, #220]	; (24001ac4 <SystemInit+0xe4>)
240019e6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
240019ea:	4a36      	ldr	r2, [pc, #216]	; (24001ac4 <SystemInit+0xe4>)
240019ec:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
240019f0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
240019f4:	4b34      	ldr	r3, [pc, #208]	; (24001ac8 <SystemInit+0xe8>)
240019f6:	681b      	ldr	r3, [r3, #0]
240019f8:	f003 030f 	and.w	r3, r3, #15
240019fc:	2b06      	cmp	r3, #6
240019fe:	d807      	bhi.n	24001a10 <SystemInit+0x30>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
24001a00:	4b31      	ldr	r3, [pc, #196]	; (24001ac8 <SystemInit+0xe8>)
24001a02:	681b      	ldr	r3, [r3, #0]
24001a04:	f023 030f 	bic.w	r3, r3, #15
24001a08:	4a2f      	ldr	r2, [pc, #188]	; (24001ac8 <SystemInit+0xe8>)
24001a0a:	f043 0307 	orr.w	r3, r3, #7
24001a0e:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
24001a10:	4b2e      	ldr	r3, [pc, #184]	; (24001acc <SystemInit+0xec>)
24001a12:	681b      	ldr	r3, [r3, #0]
24001a14:	4a2d      	ldr	r2, [pc, #180]	; (24001acc <SystemInit+0xec>)
24001a16:	f043 0301 	orr.w	r3, r3, #1
24001a1a:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
24001a1c:	4b2b      	ldr	r3, [pc, #172]	; (24001acc <SystemInit+0xec>)
24001a1e:	2200      	movs	r2, #0
24001a20:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
24001a22:	4b2a      	ldr	r3, [pc, #168]	; (24001acc <SystemInit+0xec>)
24001a24:	681a      	ldr	r2, [r3, #0]
24001a26:	4929      	ldr	r1, [pc, #164]	; (24001acc <SystemInit+0xec>)
24001a28:	4b29      	ldr	r3, [pc, #164]	; (24001ad0 <SystemInit+0xf0>)
24001a2a:	4013      	ands	r3, r2
24001a2c:	600b      	str	r3, [r1, #0]

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
24001a2e:	4b26      	ldr	r3, [pc, #152]	; (24001ac8 <SystemInit+0xe8>)
24001a30:	681b      	ldr	r3, [r3, #0]
24001a32:	f003 0308 	and.w	r3, r3, #8
24001a36:	2b00      	cmp	r3, #0
24001a38:	d007      	beq.n	24001a4a <SystemInit+0x6a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
24001a3a:	4b23      	ldr	r3, [pc, #140]	; (24001ac8 <SystemInit+0xe8>)
24001a3c:	681b      	ldr	r3, [r3, #0]
24001a3e:	f023 030f 	bic.w	r3, r3, #15
24001a42:	4a21      	ldr	r2, [pc, #132]	; (24001ac8 <SystemInit+0xe8>)
24001a44:	f043 0307 	orr.w	r3, r3, #7
24001a48:	6013      	str	r3, [r2, #0]
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
24001a4a:	4b20      	ldr	r3, [pc, #128]	; (24001acc <SystemInit+0xec>)
24001a4c:	2200      	movs	r2, #0
24001a4e:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
24001a50:	4b1e      	ldr	r3, [pc, #120]	; (24001acc <SystemInit+0xec>)
24001a52:	2200      	movs	r2, #0
24001a54:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
24001a56:	4b1d      	ldr	r3, [pc, #116]	; (24001acc <SystemInit+0xec>)
24001a58:	2200      	movs	r2, #0
24001a5a:	621a      	str	r2, [r3, #32]

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
24001a5c:	4b1b      	ldr	r3, [pc, #108]	; (24001acc <SystemInit+0xec>)
24001a5e:	4a1d      	ldr	r2, [pc, #116]	; (24001ad4 <SystemInit+0xf4>)
24001a60:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
24001a62:	4b1a      	ldr	r3, [pc, #104]	; (24001acc <SystemInit+0xec>)
24001a64:	4a1c      	ldr	r2, [pc, #112]	; (24001ad8 <SystemInit+0xf8>)
24001a66:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
24001a68:	4b18      	ldr	r3, [pc, #96]	; (24001acc <SystemInit+0xec>)
24001a6a:	4a1c      	ldr	r2, [pc, #112]	; (24001adc <SystemInit+0xfc>)
24001a6c:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
24001a6e:	4b17      	ldr	r3, [pc, #92]	; (24001acc <SystemInit+0xec>)
24001a70:	2200      	movs	r2, #0
24001a72:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
24001a74:	4b15      	ldr	r3, [pc, #84]	; (24001acc <SystemInit+0xec>)
24001a76:	4a19      	ldr	r2, [pc, #100]	; (24001adc <SystemInit+0xfc>)
24001a78:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
24001a7a:	4b14      	ldr	r3, [pc, #80]	; (24001acc <SystemInit+0xec>)
24001a7c:	2200      	movs	r2, #0
24001a7e:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
24001a80:	4b12      	ldr	r3, [pc, #72]	; (24001acc <SystemInit+0xec>)
24001a82:	4a16      	ldr	r2, [pc, #88]	; (24001adc <SystemInit+0xfc>)
24001a84:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
24001a86:	4b11      	ldr	r3, [pc, #68]	; (24001acc <SystemInit+0xec>)
24001a88:	2200      	movs	r2, #0
24001a8a:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
24001a8c:	4b0f      	ldr	r3, [pc, #60]	; (24001acc <SystemInit+0xec>)
24001a8e:	681b      	ldr	r3, [r3, #0]
24001a90:	4a0e      	ldr	r2, [pc, #56]	; (24001acc <SystemInit+0xec>)
24001a92:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24001a96:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
24001a98:	4b0c      	ldr	r3, [pc, #48]	; (24001acc <SystemInit+0xec>)
24001a9a:	2200      	movs	r2, #0
24001a9c:	661a      	str	r2, [r3, #96]	; 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
24001a9e:	4b10      	ldr	r3, [pc, #64]	; (24001ae0 <SystemInit+0x100>)
24001aa0:	681a      	ldr	r2, [r3, #0]
24001aa2:	4b10      	ldr	r3, [pc, #64]	; (24001ae4 <SystemInit+0x104>)
24001aa4:	4013      	ands	r3, r2
24001aa6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24001aaa:	d202      	bcs.n	24001ab2 <SystemInit+0xd2>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
24001aac:	4b0e      	ldr	r3, [pc, #56]	; (24001ae8 <SystemInit+0x108>)
24001aae:	2201      	movs	r2, #1
24001ab0:	601a      	str	r2, [r3, #0]
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
24001ab2:	4b0e      	ldr	r3, [pc, #56]	; (24001aec <SystemInit+0x10c>)
24001ab4:	f243 02d2 	movw	r2, #12498	; 0x30d2
24001ab8:	601a      	str	r2, [r3, #0]
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}
24001aba:	bf00      	nop
24001abc:	46bd      	mov	sp, r7
24001abe:	f85d 7b04 	ldr.w	r7, [sp], #4
24001ac2:	4770      	bx	lr
24001ac4:	e000ed00 	.word	0xe000ed00
24001ac8:	52002000 	.word	0x52002000
24001acc:	58024400 	.word	0x58024400
24001ad0:	eaf6ed7f 	.word	0xeaf6ed7f
24001ad4:	02020200 	.word	0x02020200
24001ad8:	01ff0000 	.word	0x01ff0000
24001adc:	01010280 	.word	0x01010280
24001ae0:	5c001000 	.word	0x5c001000
24001ae4:	ffff0000 	.word	0xffff0000
24001ae8:	51008108 	.word	0x51008108
24001aec:	52004000 	.word	0x52004000

24001af0 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
24001af0:	b480      	push	{r7}
24001af2:	b08b      	sub	sp, #44	; 0x2c
24001af4:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;


  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
24001af6:	4bb1      	ldr	r3, [pc, #708]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001af8:	691b      	ldr	r3, [r3, #16]
24001afa:	f003 0338 	and.w	r3, r3, #56	; 0x38
24001afe:	2b18      	cmp	r3, #24
24001b00:	f200 812e 	bhi.w	24001d60 <SystemCoreClockUpdate+0x270>
24001b04:	a201      	add	r2, pc, #4	; (adr r2, 24001b0c <SystemCoreClockUpdate+0x1c>)
24001b06:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24001b0a:	bf00      	nop
24001b0c:	24001b71 	.word	0x24001b71
24001b10:	24001d61 	.word	0x24001d61
24001b14:	24001d61 	.word	0x24001d61
24001b18:	24001d61 	.word	0x24001d61
24001b1c:	24001d61 	.word	0x24001d61
24001b20:	24001d61 	.word	0x24001d61
24001b24:	24001d61 	.word	0x24001d61
24001b28:	24001d61 	.word	0x24001d61
24001b2c:	24001b85 	.word	0x24001b85
24001b30:	24001d61 	.word	0x24001d61
24001b34:	24001d61 	.word	0x24001d61
24001b38:	24001d61 	.word	0x24001d61
24001b3c:	24001d61 	.word	0x24001d61
24001b40:	24001d61 	.word	0x24001d61
24001b44:	24001d61 	.word	0x24001d61
24001b48:	24001d61 	.word	0x24001d61
24001b4c:	24001b8b 	.word	0x24001b8b
24001b50:	24001d61 	.word	0x24001d61
24001b54:	24001d61 	.word	0x24001d61
24001b58:	24001d61 	.word	0x24001d61
24001b5c:	24001d61 	.word	0x24001d61
24001b60:	24001d61 	.word	0x24001d61
24001b64:	24001d61 	.word	0x24001d61
24001b68:	24001d61 	.word	0x24001d61
24001b6c:	24001b91 	.word	0x24001b91
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
24001b70:	4b92      	ldr	r3, [pc, #584]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001b72:	681b      	ldr	r3, [r3, #0]
24001b74:	08db      	lsrs	r3, r3, #3
24001b76:	f003 0303 	and.w	r3, r3, #3
24001b7a:	4a91      	ldr	r2, [pc, #580]	; (24001dc0 <SystemCoreClockUpdate+0x2d0>)
24001b7c:	fa22 f303 	lsr.w	r3, r2, r3
24001b80:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24001b82:	e0f7      	b.n	24001d74 <SystemCoreClockUpdate+0x284>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    common_system_clock = CSI_VALUE;
24001b84:	4b8f      	ldr	r3, [pc, #572]	; (24001dc4 <SystemCoreClockUpdate+0x2d4>)
24001b86:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24001b88:	e0f4      	b.n	24001d74 <SystemCoreClockUpdate+0x284>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    common_system_clock = HSE_VALUE;
24001b8a:	4b8f      	ldr	r3, [pc, #572]	; (24001dc8 <SystemCoreClockUpdate+0x2d8>)
24001b8c:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24001b8e:	e0f1      	b.n	24001d74 <SystemCoreClockUpdate+0x284>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24001b90:	4b8a      	ldr	r3, [pc, #552]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001b92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24001b94:	f003 0303 	and.w	r3, r3, #3
24001b98:	61fb      	str	r3, [r7, #28]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24001b9a:	4b88      	ldr	r3, [pc, #544]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001b9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24001b9e:	091b      	lsrs	r3, r3, #4
24001ba0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24001ba4:	61bb      	str	r3, [r7, #24]
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24001ba6:	4b85      	ldr	r3, [pc, #532]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001ba8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24001baa:	f003 0301 	and.w	r3, r3, #1
24001bae:	617b      	str	r3, [r7, #20]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24001bb0:	4b82      	ldr	r3, [pc, #520]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001bb2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24001bb4:	08db      	lsrs	r3, r3, #3
24001bb6:	f3c3 030c 	ubfx	r3, r3, #0, #13
24001bba:	697a      	ldr	r2, [r7, #20]
24001bbc:	fb02 f303 	mul.w	r3, r2, r3
24001bc0:	ee07 3a90 	vmov	s15, r3
24001bc4:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001bc8:	edc7 7a04 	vstr	s15, [r7, #16]

    if (pllm != 0U)
24001bcc:	69bb      	ldr	r3, [r7, #24]
24001bce:	2b00      	cmp	r3, #0
24001bd0:	f000 80c3 	beq.w	24001d5a <SystemCoreClockUpdate+0x26a>
24001bd4:	69fb      	ldr	r3, [r7, #28]
24001bd6:	2b02      	cmp	r3, #2
24001bd8:	d059      	beq.n	24001c8e <SystemCoreClockUpdate+0x19e>
24001bda:	69fb      	ldr	r3, [r7, #28]
24001bdc:	2b02      	cmp	r3, #2
24001bde:	d878      	bhi.n	24001cd2 <SystemCoreClockUpdate+0x1e2>
24001be0:	69fb      	ldr	r3, [r7, #28]
24001be2:	2b00      	cmp	r3, #0
24001be4:	d003      	beq.n	24001bee <SystemCoreClockUpdate+0xfe>
24001be6:	69fb      	ldr	r3, [r7, #28]
24001be8:	2b01      	cmp	r3, #1
24001bea:	d02e      	beq.n	24001c4a <SystemCoreClockUpdate+0x15a>
24001bec:	e071      	b.n	24001cd2 <SystemCoreClockUpdate+0x1e2>
    {
      switch (pllsource)
      {
        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */

        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
24001bee:	4b73      	ldr	r3, [pc, #460]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001bf0:	681b      	ldr	r3, [r3, #0]
24001bf2:	08db      	lsrs	r3, r3, #3
24001bf4:	f003 0303 	and.w	r3, r3, #3
24001bf8:	4a71      	ldr	r2, [pc, #452]	; (24001dc0 <SystemCoreClockUpdate+0x2d0>)
24001bfa:	fa22 f303 	lsr.w	r3, r2, r3
24001bfe:	60fb      	str	r3, [r7, #12]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24001c00:	68fb      	ldr	r3, [r7, #12]
24001c02:	ee07 3a90 	vmov	s15, r3
24001c06:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001c0a:	69bb      	ldr	r3, [r7, #24]
24001c0c:	ee07 3a90 	vmov	s15, r3
24001c10:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001c14:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24001c18:	4b68      	ldr	r3, [pc, #416]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001c1a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24001c1c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24001c20:	ee07 3a90 	vmov	s15, r3
24001c24:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001c28:	ed97 6a04 	vldr	s12, [r7, #16]
24001c2c:	eddf 5a67 	vldr	s11, [pc, #412]	; 24001dcc <SystemCoreClockUpdate+0x2dc>
24001c30:	eec6 7a25 	vdiv.f32	s15, s12, s11
24001c34:	ee76 7aa7 	vadd.f32	s15, s13, s15
24001c38:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24001c3c:	ee77 7aa6 	vadd.f32	s15, s15, s13
24001c40:	ee67 7a27 	vmul.f32	s15, s14, s15
24001c44:	edc7 7a08 	vstr	s15, [r7, #32]

        break;
24001c48:	e071      	b.n	24001d2e <SystemCoreClockUpdate+0x23e>

        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24001c4a:	69bb      	ldr	r3, [r7, #24]
24001c4c:	ee07 3a90 	vmov	s15, r3
24001c50:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001c54:	eddf 6a5e 	vldr	s13, [pc, #376]	; 24001dd0 <SystemCoreClockUpdate+0x2e0>
24001c58:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24001c5c:	4b57      	ldr	r3, [pc, #348]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001c5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24001c60:	f3c3 0308 	ubfx	r3, r3, #0, #9
24001c64:	ee07 3a90 	vmov	s15, r3
24001c68:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001c6c:	ed97 6a04 	vldr	s12, [r7, #16]
24001c70:	eddf 5a56 	vldr	s11, [pc, #344]	; 24001dcc <SystemCoreClockUpdate+0x2dc>
24001c74:	eec6 7a25 	vdiv.f32	s15, s12, s11
24001c78:	ee76 7aa7 	vadd.f32	s15, s13, s15
24001c7c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24001c80:	ee77 7aa6 	vadd.f32	s15, s15, s13
24001c84:	ee67 7a27 	vmul.f32	s15, s14, s15
24001c88:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24001c8c:	e04f      	b.n	24001d2e <SystemCoreClockUpdate+0x23e>

        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24001c8e:	69bb      	ldr	r3, [r7, #24]
24001c90:	ee07 3a90 	vmov	s15, r3
24001c94:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001c98:	eddf 6a4e 	vldr	s13, [pc, #312]	; 24001dd4 <SystemCoreClockUpdate+0x2e4>
24001c9c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24001ca0:	4b46      	ldr	r3, [pc, #280]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001ca2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24001ca4:	f3c3 0308 	ubfx	r3, r3, #0, #9
24001ca8:	ee07 3a90 	vmov	s15, r3
24001cac:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001cb0:	ed97 6a04 	vldr	s12, [r7, #16]
24001cb4:	eddf 5a45 	vldr	s11, [pc, #276]	; 24001dcc <SystemCoreClockUpdate+0x2dc>
24001cb8:	eec6 7a25 	vdiv.f32	s15, s12, s11
24001cbc:	ee76 7aa7 	vadd.f32	s15, s13, s15
24001cc0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24001cc4:	ee77 7aa6 	vadd.f32	s15, s15, s13
24001cc8:	ee67 7a27 	vmul.f32	s15, s14, s15
24001ccc:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24001cd0:	e02d      	b.n	24001d2e <SystemCoreClockUpdate+0x23e>

      default:
          hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
24001cd2:	4b3a      	ldr	r3, [pc, #232]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001cd4:	681b      	ldr	r3, [r3, #0]
24001cd6:	08db      	lsrs	r3, r3, #3
24001cd8:	f003 0303 	and.w	r3, r3, #3
24001cdc:	4a38      	ldr	r2, [pc, #224]	; (24001dc0 <SystemCoreClockUpdate+0x2d0>)
24001cde:	fa22 f303 	lsr.w	r3, r2, r3
24001ce2:	60fb      	str	r3, [r7, #12]
          pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24001ce4:	68fb      	ldr	r3, [r7, #12]
24001ce6:	ee07 3a90 	vmov	s15, r3
24001cea:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001cee:	69bb      	ldr	r3, [r7, #24]
24001cf0:	ee07 3a90 	vmov	s15, r3
24001cf4:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001cf8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24001cfc:	4b2f      	ldr	r3, [pc, #188]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001cfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24001d00:	f3c3 0308 	ubfx	r3, r3, #0, #9
24001d04:	ee07 3a90 	vmov	s15, r3
24001d08:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001d0c:	ed97 6a04 	vldr	s12, [r7, #16]
24001d10:	eddf 5a2e 	vldr	s11, [pc, #184]	; 24001dcc <SystemCoreClockUpdate+0x2dc>
24001d14:	eec6 7a25 	vdiv.f32	s15, s12, s11
24001d18:	ee76 7aa7 	vadd.f32	s15, s13, s15
24001d1c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24001d20:	ee77 7aa6 	vadd.f32	s15, s15, s13
24001d24:	ee67 7a27 	vmul.f32	s15, s14, s15
24001d28:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24001d2c:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
24001d2e:	4b23      	ldr	r3, [pc, #140]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001d30:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24001d32:	0a5b      	lsrs	r3, r3, #9
24001d34:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24001d38:	3301      	adds	r3, #1
24001d3a:	60bb      	str	r3, [r7, #8]
      common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
24001d3c:	68bb      	ldr	r3, [r7, #8]
24001d3e:	ee07 3a90 	vmov	s15, r3
24001d42:	eeb8 7a67 	vcvt.f32.u32	s14, s15
24001d46:	edd7 6a08 	vldr	s13, [r7, #32]
24001d4a:	eec6 7a87 	vdiv.f32	s15, s13, s14
24001d4e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24001d52:	ee17 3a90 	vmov	r3, s15
24001d56:	627b      	str	r3, [r7, #36]	; 0x24
    }
    else
    {
      common_system_clock = 0U;
    }
    break;
24001d58:	e00c      	b.n	24001d74 <SystemCoreClockUpdate+0x284>
      common_system_clock = 0U;
24001d5a:	2300      	movs	r3, #0
24001d5c:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24001d5e:	e009      	b.n	24001d74 <SystemCoreClockUpdate+0x284>

  default:
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
24001d60:	4b16      	ldr	r3, [pc, #88]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001d62:	681b      	ldr	r3, [r3, #0]
24001d64:	08db      	lsrs	r3, r3, #3
24001d66:	f003 0303 	and.w	r3, r3, #3
24001d6a:	4a15      	ldr	r2, [pc, #84]	; (24001dc0 <SystemCoreClockUpdate+0x2d0>)
24001d6c:	fa22 f303 	lsr.w	r3, r2, r3
24001d70:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24001d72:	bf00      	nop
  }

  /* Compute SystemClock frequency --------------------------------------------------*/
#if defined (RCC_D1CFGR_D1CPRE)
  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];
24001d74:	4b11      	ldr	r3, [pc, #68]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001d76:	699b      	ldr	r3, [r3, #24]
24001d78:	0a1b      	lsrs	r3, r3, #8
24001d7a:	f003 030f 	and.w	r3, r3, #15
24001d7e:	4a16      	ldr	r2, [pc, #88]	; (24001dd8 <SystemCoreClockUpdate+0x2e8>)
24001d80:	5cd3      	ldrb	r3, [r2, r3]
24001d82:	607b      	str	r3, [r7, #4]

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;
24001d84:	6a7a      	ldr	r2, [r7, #36]	; 0x24
24001d86:	687b      	ldr	r3, [r7, #4]
24001d88:	fa22 f303 	lsr.w	r3, r2, r3
24001d8c:	627b      	str	r3, [r7, #36]	; 0x24

  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24001d8e:	4b0b      	ldr	r3, [pc, #44]	; (24001dbc <SystemCoreClockUpdate+0x2cc>)
24001d90:	699b      	ldr	r3, [r3, #24]
24001d92:	f003 030f 	and.w	r3, r3, #15
24001d96:	4a10      	ldr	r2, [pc, #64]	; (24001dd8 <SystemCoreClockUpdate+0x2e8>)
24001d98:	5cd3      	ldrb	r3, [r2, r3]
24001d9a:	f003 031f 	and.w	r3, r3, #31
24001d9e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
24001da0:	fa22 f303 	lsr.w	r3, r2, r3
24001da4:	4a0d      	ldr	r2, [pc, #52]	; (24001ddc <SystemCoreClockUpdate+0x2ec>)
24001da6:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24001da8:	4a0d      	ldr	r2, [pc, #52]	; (24001de0 <SystemCoreClockUpdate+0x2f0>)
24001daa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24001dac:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */
}
24001dae:	bf00      	nop
24001db0:	372c      	adds	r7, #44	; 0x2c
24001db2:	46bd      	mov	sp, r7
24001db4:	f85d 7b04 	ldr.w	r7, [sp], #4
24001db8:	4770      	bx	lr
24001dba:	bf00      	nop
24001dbc:	58024400 	.word	0x58024400
24001dc0:	03d09000 	.word	0x03d09000
24001dc4:	003d0900 	.word	0x003d0900
24001dc8:	017d7840 	.word	0x017d7840
24001dcc:	46000000 	.word	0x46000000
24001dd0:	4a742400 	.word	0x4a742400
24001dd4:	4bbebc20 	.word	0x4bbebc20
24001dd8:	24020f94 	.word	0x24020f94
24001ddc:	240004b4 	.word	0x240004b4
24001de0:	240004b0 	.word	0x240004b0

24001de4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
24001de4:	f8df d034 	ldr.w	sp, [pc, #52]	; 24001e1c <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
24001de8:	f7ff fdfa 	bl	240019e0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
24001dec:	480c      	ldr	r0, [pc, #48]	; (24001e20 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
24001dee:	490d      	ldr	r1, [pc, #52]	; (24001e24 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
24001df0:	4a0d      	ldr	r2, [pc, #52]	; (24001e28 <LoopFillZerobss+0x1a>)
  movs r3, #0
24001df2:	2300      	movs	r3, #0
  b LoopCopyDataInit
24001df4:	e002      	b.n	24001dfc <LoopCopyDataInit>

24001df6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
24001df6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
24001df8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
24001dfa:	3304      	adds	r3, #4

24001dfc <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
24001dfc:	18c4      	adds	r4, r0, r3
  cmp r4, r1
24001dfe:	428c      	cmp	r4, r1
  bcc CopyDataInit
24001e00:	d3f9      	bcc.n	24001df6 <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
24001e02:	4a0a      	ldr	r2, [pc, #40]	; (24001e2c <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
24001e04:	4c0a      	ldr	r4, [pc, #40]	; (24001e30 <LoopFillZerobss+0x22>)
  movs r3, #0
24001e06:	2300      	movs	r3, #0
  b LoopFillZerobss
24001e08:	e001      	b.n	24001e0e <LoopFillZerobss>

24001e0a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
24001e0a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
24001e0c:	3204      	adds	r2, #4

24001e0e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
24001e0e:	42a2      	cmp	r2, r4
  bcc FillZerobss
24001e10:	d3fb      	bcc.n	24001e0a <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
24001e12:	f01e fffd 	bl	24020e10 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
24001e16:	f7fe feed 	bl	24000bf4 <main>
  bx  lr
24001e1a:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
24001e1c:	24080004 	.word	0x24080004
  ldr r0, =_sdata
24001e20:	240004a8 	.word	0x240004a8
  ldr r1, =_edata
24001e24:	24000524 	.word	0x24000524
  ldr r2, =_sidata
24001e28:	240004a8 	.word	0x240004a8
  ldr r2, =_sbss
24001e2c:	24000524 	.word	0x24000524
  ldr r4, =_ebss
24001e30:	24000600 	.word	0x24000600

24001e34 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
24001e34:	e7fe      	b.n	24001e34 <ADC3_IRQHandler>
	...

24001e38 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
24001e38:	b580      	push	{r7, lr}
24001e3a:	b082      	sub	sp, #8
24001e3c:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
24001e3e:	2003      	movs	r0, #3
24001e40:	f000 fefc 	bl	24002c3c <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
24001e44:	f012 f986 	bl	24014154 <HAL_RCC_GetSysClockFreq>
24001e48:	4602      	mov	r2, r0
24001e4a:	4b15      	ldr	r3, [pc, #84]	; (24001ea0 <HAL_Init+0x68>)
24001e4c:	699b      	ldr	r3, [r3, #24]
24001e4e:	0a1b      	lsrs	r3, r3, #8
24001e50:	f003 030f 	and.w	r3, r3, #15
24001e54:	4913      	ldr	r1, [pc, #76]	; (24001ea4 <HAL_Init+0x6c>)
24001e56:	5ccb      	ldrb	r3, [r1, r3]
24001e58:	f003 031f 	and.w	r3, r3, #31
24001e5c:	fa22 f303 	lsr.w	r3, r2, r3
24001e60:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24001e62:	4b0f      	ldr	r3, [pc, #60]	; (24001ea0 <HAL_Init+0x68>)
24001e64:	699b      	ldr	r3, [r3, #24]
24001e66:	f003 030f 	and.w	r3, r3, #15
24001e6a:	4a0e      	ldr	r2, [pc, #56]	; (24001ea4 <HAL_Init+0x6c>)
24001e6c:	5cd3      	ldrb	r3, [r2, r3]
24001e6e:	f003 031f 	and.w	r3, r3, #31
24001e72:	687a      	ldr	r2, [r7, #4]
24001e74:	fa22 f303 	lsr.w	r3, r2, r3
24001e78:	4a0b      	ldr	r2, [pc, #44]	; (24001ea8 <HAL_Init+0x70>)
24001e7a:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24001e7c:	4a0b      	ldr	r2, [pc, #44]	; (24001eac <HAL_Init+0x74>)
24001e7e:	687b      	ldr	r3, [r7, #4]
24001e80:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
24001e82:	200f      	movs	r0, #15
24001e84:	f7ff fb7e 	bl	24001584 <HAL_InitTick>
24001e88:	4603      	mov	r3, r0
24001e8a:	2b00      	cmp	r3, #0
24001e8c:	d001      	beq.n	24001e92 <HAL_Init+0x5a>
  {
    return HAL_ERROR;
24001e8e:	2301      	movs	r3, #1
24001e90:	e002      	b.n	24001e98 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
24001e92:	f7ff fb5d 	bl	24001550 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
24001e96:	2300      	movs	r3, #0
}
24001e98:	4618      	mov	r0, r3
24001e9a:	3708      	adds	r7, #8
24001e9c:	46bd      	mov	sp, r7
24001e9e:	bd80      	pop	{r7, pc}
24001ea0:	58024400 	.word	0x58024400
24001ea4:	24020f94 	.word	0x24020f94
24001ea8:	240004b4 	.word	0x240004b4
24001eac:	240004b0 	.word	0x240004b0

24001eb0 <HAL_DeInit>:
  * @brief  This function de-Initializes common part of the HAL and stops the systick.
  *         This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
24001eb0:	b580      	push	{r7, lr}
24001eb2:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_AHB3_FORCE_RESET();
24001eb4:	4b26      	ldr	r3, [pc, #152]	; (24001f50 <HAL_DeInit+0xa0>)
24001eb6:	4a27      	ldr	r2, [pc, #156]	; (24001f54 <HAL_DeInit+0xa4>)
24001eb8:	67da      	str	r2, [r3, #124]	; 0x7c
  __HAL_RCC_AHB3_RELEASE_RESET();
24001eba:	4b25      	ldr	r3, [pc, #148]	; (24001f50 <HAL_DeInit+0xa0>)
24001ebc:	2200      	movs	r2, #0
24001ebe:	67da      	str	r2, [r3, #124]	; 0x7c

  __HAL_RCC_AHB1_FORCE_RESET();
24001ec0:	4b23      	ldr	r3, [pc, #140]	; (24001f50 <HAL_DeInit+0xa0>)
24001ec2:	4a25      	ldr	r2, [pc, #148]	; (24001f58 <HAL_DeInit+0xa8>)
24001ec4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __HAL_RCC_AHB1_RELEASE_RESET();
24001ec8:	4b21      	ldr	r3, [pc, #132]	; (24001f50 <HAL_DeInit+0xa0>)
24001eca:	2200      	movs	r2, #0
24001ecc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  __HAL_RCC_AHB2_FORCE_RESET();
24001ed0:	4b1f      	ldr	r3, [pc, #124]	; (24001f50 <HAL_DeInit+0xa0>)
24001ed2:	f240 2271 	movw	r2, #625	; 0x271
24001ed6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __HAL_RCC_AHB2_RELEASE_RESET();
24001eda:	4b1d      	ldr	r3, [pc, #116]	; (24001f50 <HAL_DeInit+0xa0>)
24001edc:	2200      	movs	r2, #0
24001ede:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  __HAL_RCC_AHB4_FORCE_RESET();
24001ee2:	4b1b      	ldr	r3, [pc, #108]	; (24001f50 <HAL_DeInit+0xa0>)
24001ee4:	4a1d      	ldr	r2, [pc, #116]	; (24001f5c <HAL_DeInit+0xac>)
24001ee6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 __HAL_RCC_AHB4_RELEASE_RESET();
24001eea:	4b19      	ldr	r3, [pc, #100]	; (24001f50 <HAL_DeInit+0xa0>)
24001eec:	2200      	movs	r2, #0
24001eee:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  __HAL_RCC_APB3_FORCE_RESET();
24001ef2:	4b17      	ldr	r3, [pc, #92]	; (24001f50 <HAL_DeInit+0xa0>)
24001ef4:	2218      	movs	r2, #24
24001ef6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  __HAL_RCC_APB3_RELEASE_RESET();
24001efa:	4b15      	ldr	r3, [pc, #84]	; (24001f50 <HAL_DeInit+0xa0>)
24001efc:	2200      	movs	r2, #0
24001efe:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  __HAL_RCC_APB1L_FORCE_RESET();
24001f02:	4b13      	ldr	r3, [pc, #76]	; (24001f50 <HAL_DeInit+0xa0>)
24001f04:	4a16      	ldr	r2, [pc, #88]	; (24001f60 <HAL_DeInit+0xb0>)
24001f06:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  __HAL_RCC_APB1L_RELEASE_RESET();
24001f0a:	4b11      	ldr	r3, [pc, #68]	; (24001f50 <HAL_DeInit+0xa0>)
24001f0c:	2200      	movs	r2, #0
24001f0e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  __HAL_RCC_APB1H_FORCE_RESET();
24001f12:	4b0f      	ldr	r3, [pc, #60]	; (24001f50 <HAL_DeInit+0xa0>)
24001f14:	f44f 729b 	mov.w	r2, #310	; 0x136
24001f18:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __HAL_RCC_APB1H_RELEASE_RESET();
24001f1c:	4b0c      	ldr	r3, [pc, #48]	; (24001f50 <HAL_DeInit+0xa0>)
24001f1e:	2200      	movs	r2, #0
24001f20:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

   __HAL_RCC_APB2_FORCE_RESET();
24001f24:	4b0a      	ldr	r3, [pc, #40]	; (24001f50 <HAL_DeInit+0xa0>)
24001f26:	4a0f      	ldr	r2, [pc, #60]	; (24001f64 <HAL_DeInit+0xb4>)
24001f28:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
   __HAL_RCC_APB2_RELEASE_RESET();
24001f2c:	4b08      	ldr	r3, [pc, #32]	; (24001f50 <HAL_DeInit+0xa0>)
24001f2e:	2200      	movs	r2, #0
24001f30:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

  __HAL_RCC_APB4_FORCE_RESET();
24001f34:	4b06      	ldr	r3, [pc, #24]	; (24001f50 <HAL_DeInit+0xa0>)
24001f36:	4a0c      	ldr	r2, [pc, #48]	; (24001f68 <HAL_DeInit+0xb8>)
24001f38:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  __HAL_RCC_APB4_RELEASE_RESET();
24001f3c:	4b04      	ldr	r3, [pc, #16]	; (24001f50 <HAL_DeInit+0xa0>)
24001f3e:	2200      	movs	r2, #0
24001f40:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

  /* De-Init the low level hardware */
  HAL_MspDeInit();
24001f44:	f000 f819 	bl	24001f7a <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
24001f48:	2300      	movs	r3, #0
}
24001f4a:	4618      	mov	r0, r3
24001f4c:	bd80      	pop	{r7, pc}
24001f4e:	bf00      	nop
24001f50:	58024400 	.word	0x58024400
24001f54:	00015031 	.word	0x00015031
24001f58:	0a00c023 	.word	0x0a00c023
24001f5c:	032807ff 	.word	0x032807ff
24001f60:	e8ffc3ff 	.word	0xe8ffc3ff
24001f64:	31d73033 	.word	0x31d73033
24001f68:	0020deaa 	.word	0x0020deaa
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
24001f6c:	b480      	push	{r7}
24001f6e:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
24001f70:	bf00      	nop
24001f72:	46bd      	mov	sp, r7
24001f74:	f85d 7b04 	ldr.w	r7, [sp], #4
24001f78:	4770      	bx	lr

24001f7a <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
24001f7a:	b480      	push	{r7}
24001f7c:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */
}
24001f7e:	bf00      	nop
24001f80:	46bd      	mov	sp, r7
24001f82:	f85d 7b04 	ldr.w	r7, [sp], #4
24001f86:	4770      	bx	lr
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
24001f88:	b580      	push	{r7, lr}
24001f8a:	b082      	sub	sp, #8
24001f8c:	af00      	add	r7, sp, #0
24001f8e:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
24001f90:	4b15      	ldr	r3, [pc, #84]	; (24001fe8 <HAL_MspDeInit+0x6e>)
24001f92:	781b      	ldrb	r3, [r3, #0]
24001f94:	2b00      	cmp	r3, #0
24001f96:	d101      	bne.n	24001f9c <HAL_MspDeInit+0x22>
  {
    return HAL_ERROR;
24001f98:	2301      	movs	r3, #1
24001f9a:	e021      	b.n	24001fe0 <HAL_MspDeInit+0x66>
  }

    /* Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
24001f9c:	4b13      	ldr	r3, [pc, #76]	; (24001fec <HAL_MspDeInit+0x72>)
24001f9e:	681a      	ldr	r2, [r3, #0]
24001fa0:	4b11      	ldr	r3, [pc, #68]	; (24001fe8 <HAL_MspDeInit+0x6e>)
24001fa2:	781b      	ldrb	r3, [r3, #0]
24001fa4:	4619      	mov	r1, r3
24001fa6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
24001faa:	fbb3 f3f1 	udiv	r3, r3, r1
24001fae:	fbb2 f3f3 	udiv	r3, r2, r3
24001fb2:	4618      	mov	r0, r3
24001fb4:	f000 fe87 	bl	24002cc6 <HAL_SYSTICK_Config>
24001fb8:	4603      	mov	r3, r0
24001fba:	2b00      	cmp	r3, #0
24001fbc:	d001      	beq.n	24001fc2 <HAL_MspDeInit+0x48>
    {
      return HAL_ERROR;
24001fbe:	2301      	movs	r3, #1
24001fc0:	e00e      	b.n	24001fe0 <HAL_MspDeInit+0x66>
    }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
24001fc2:	687b      	ldr	r3, [r7, #4]
24001fc4:	2b0f      	cmp	r3, #15
24001fc6:	d80a      	bhi.n	24001fde <HAL_MspDeInit+0x64>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
24001fc8:	2200      	movs	r2, #0
24001fca:	6879      	ldr	r1, [r7, #4]
24001fcc:	f04f 30ff 	mov.w	r0, #4294967295
24001fd0:	f000 fe3f 	bl	24002c52 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
24001fd4:	4a06      	ldr	r2, [pc, #24]	; (24001ff0 <HAL_MspDeInit+0x76>)
24001fd6:	687b      	ldr	r3, [r7, #4]
24001fd8:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
24001fda:	2300      	movs	r3, #0
24001fdc:	e000      	b.n	24001fe0 <HAL_MspDeInit+0x66>
    return HAL_ERROR;
24001fde:	2301      	movs	r3, #1
}
24001fe0:	4618      	mov	r0, r3
24001fe2:	3708      	adds	r7, #8
24001fe4:	46bd      	mov	sp, r7
24001fe6:	bd80      	pop	{r7, pc}
24001fe8:	240004bc 	.word	0x240004bc
24001fec:	240004b0 	.word	0x240004b0
24001ff0:	240004b8 	.word	0x240004b8

24001ff4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
24001ff4:	b480      	push	{r7}
24001ff6:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
24001ff8:	4b06      	ldr	r3, [pc, #24]	; (24002014 <HAL_IncTick+0x20>)
24001ffa:	781b      	ldrb	r3, [r3, #0]
24001ffc:	461a      	mov	r2, r3
24001ffe:	4b06      	ldr	r3, [pc, #24]	; (24002018 <HAL_IncTick+0x24>)
24002000:	681b      	ldr	r3, [r3, #0]
24002002:	4413      	add	r3, r2
24002004:	4a04      	ldr	r2, [pc, #16]	; (24002018 <HAL_IncTick+0x24>)
24002006:	6013      	str	r3, [r2, #0]
}
24002008:	bf00      	nop
2400200a:	46bd      	mov	sp, r7
2400200c:	f85d 7b04 	ldr.w	r7, [sp], #4
24002010:	4770      	bx	lr
24002012:	bf00      	nop
24002014:	240004bc 	.word	0x240004bc
24002018:	240005e0 	.word	0x240005e0

2400201c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
2400201c:	b480      	push	{r7}
2400201e:	af00      	add	r7, sp, #0
  return uwTick;
24002020:	4b03      	ldr	r3, [pc, #12]	; (24002030 <HAL_GetTick+0x14>)
24002022:	681b      	ldr	r3, [r3, #0]
}
24002024:	4618      	mov	r0, r3
24002026:	46bd      	mov	sp, r7
24002028:	f85d 7b04 	ldr.w	r7, [sp], #4
2400202c:	4770      	bx	lr
2400202e:	bf00      	nop
24002030:	240005e0 	.word	0x240005e0

24002034 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
24002034:	b480      	push	{r7}
24002036:	af00      	add	r7, sp, #0
  return uwTickPrio;
24002038:	4b03      	ldr	r3, [pc, #12]	; (24002048 <HAL_GetTickPrio+0x14>)
2400203a:	681b      	ldr	r3, [r3, #0]
}
2400203c:	4618      	mov	r0, r3
2400203e:	46bd      	mov	sp, r7
24002040:	f85d 7b04 	ldr.w	r7, [sp], #4
24002044:	4770      	bx	lr
24002046:	bf00      	nop
24002048:	240004b8 	.word	0x240004b8

2400204c <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval Status
  */
HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
2400204c:	b580      	push	{r7, lr}
2400204e:	b084      	sub	sp, #16
24002050:	af00      	add	r7, sp, #0
24002052:	4603      	mov	r3, r0
24002054:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status  = HAL_OK;
24002056:	2300      	movs	r3, #0
24002058:	73fb      	strb	r3, [r7, #15]
  HAL_TickFreqTypeDef prevTickFreq;

  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
2400205a:	4b0e      	ldr	r3, [pc, #56]	; (24002094 <HAL_SetTickFreq+0x48>)
2400205c:	781b      	ldrb	r3, [r3, #0]
2400205e:	79fa      	ldrb	r2, [r7, #7]
24002060:	429a      	cmp	r2, r3
24002062:	d012      	beq.n	2400208a <HAL_SetTickFreq+0x3e>
  {

    /* Back up uwTickFreq frequency */
    prevTickFreq = uwTickFreq;
24002064:	4b0b      	ldr	r3, [pc, #44]	; (24002094 <HAL_SetTickFreq+0x48>)
24002066:	781b      	ldrb	r3, [r3, #0]
24002068:	73bb      	strb	r3, [r7, #14]

    /* Update uwTickFreq global variable used by HAL_InitTick() */
    uwTickFreq = Freq;
2400206a:	4a0a      	ldr	r2, [pc, #40]	; (24002094 <HAL_SetTickFreq+0x48>)
2400206c:	79fb      	ldrb	r3, [r7, #7]
2400206e:	7013      	strb	r3, [r2, #0]

    /* Apply the new tick Freq  */
    status = HAL_InitTick(uwTickPrio);
24002070:	4b09      	ldr	r3, [pc, #36]	; (24002098 <HAL_SetTickFreq+0x4c>)
24002072:	681b      	ldr	r3, [r3, #0]
24002074:	4618      	mov	r0, r3
24002076:	f7ff fa85 	bl	24001584 <HAL_InitTick>
2400207a:	4603      	mov	r3, r0
2400207c:	73fb      	strb	r3, [r7, #15]
    if (status != HAL_OK)
2400207e:	7bfb      	ldrb	r3, [r7, #15]
24002080:	2b00      	cmp	r3, #0
24002082:	d002      	beq.n	2400208a <HAL_SetTickFreq+0x3e>
    {
      /* Restore previous tick frequency */
      uwTickFreq = prevTickFreq;
24002084:	4a03      	ldr	r2, [pc, #12]	; (24002094 <HAL_SetTickFreq+0x48>)
24002086:	7bbb      	ldrb	r3, [r7, #14]
24002088:	7013      	strb	r3, [r2, #0]
    }
  }

  return status;
2400208a:	7bfb      	ldrb	r3, [r7, #15]
}
2400208c:	4618      	mov	r0, r3
2400208e:	3710      	adds	r7, #16
24002090:	46bd      	mov	sp, r7
24002092:	bd80      	pop	{r7, pc}
24002094:	240004bc 	.word	0x240004bc
24002098:	240004b8 	.word	0x240004b8

2400209c <HAL_GetTickFreq>:
/**
  * @brief Return tick frequency.
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
2400209c:	b480      	push	{r7}
2400209e:	af00      	add	r7, sp, #0
  return uwTickFreq;
240020a0:	4b03      	ldr	r3, [pc, #12]	; (240020b0 <HAL_GetTickFreq+0x14>)
240020a2:	781b      	ldrb	r3, [r3, #0]
}
240020a4:	4618      	mov	r0, r3
240020a6:	46bd      	mov	sp, r7
240020a8:	f85d 7b04 	ldr.w	r7, [sp], #4
240020ac:	4770      	bx	lr
240020ae:	bf00      	nop
240020b0:	240004bc 	.word	0x240004bc

240020b4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
240020b4:	b580      	push	{r7, lr}
240020b6:	b084      	sub	sp, #16
240020b8:	af00      	add	r7, sp, #0
240020ba:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
240020bc:	f7ff ffae 	bl	2400201c <HAL_GetTick>
240020c0:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
240020c2:	687b      	ldr	r3, [r7, #4]
240020c4:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
240020c6:	68fb      	ldr	r3, [r7, #12]
240020c8:	f1b3 3fff 	cmp.w	r3, #4294967295
240020cc:	d005      	beq.n	240020da <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
240020ce:	4b0a      	ldr	r3, [pc, #40]	; (240020f8 <HAL_Delay+0x44>)
240020d0:	781b      	ldrb	r3, [r3, #0]
240020d2:	461a      	mov	r2, r3
240020d4:	68fb      	ldr	r3, [r7, #12]
240020d6:	4413      	add	r3, r2
240020d8:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
240020da:	bf00      	nop
240020dc:	f7ff ff9e 	bl	2400201c <HAL_GetTick>
240020e0:	4602      	mov	r2, r0
240020e2:	68bb      	ldr	r3, [r7, #8]
240020e4:	1ad3      	subs	r3, r2, r3
240020e6:	68fa      	ldr	r2, [r7, #12]
240020e8:	429a      	cmp	r2, r3
240020ea:	d8f7      	bhi.n	240020dc <HAL_Delay+0x28>
  {
  }
}
240020ec:	bf00      	nop
240020ee:	bf00      	nop
240020f0:	3710      	adds	r7, #16
240020f2:	46bd      	mov	sp, r7
240020f4:	bd80      	pop	{r7, pc}
240020f6:	bf00      	nop
240020f8:	240004bc 	.word	0x240004bc
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
240020fc:	b480      	push	{r7}
240020fe:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
24002100:	4b05      	ldr	r3, [pc, #20]	; (24002118 <HAL_Delay+0x64>)
24002102:	681b      	ldr	r3, [r3, #0]
24002104:	4a04      	ldr	r2, [pc, #16]	; (24002118 <HAL_Delay+0x64>)
24002106:	f023 0302 	bic.w	r3, r3, #2
2400210a:	6013      	str	r3, [r2, #0]
}
2400210c:	bf00      	nop
2400210e:	46bd      	mov	sp, r7
24002110:	f85d 7b04 	ldr.w	r7, [sp], #4
24002114:	4770      	bx	lr
24002116:	bf00      	nop
24002118:	e000e010 	.word	0xe000e010
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
2400211c:	b480      	push	{r7}
2400211e:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
24002120:	4b05      	ldr	r3, [pc, #20]	; (24002138 <HAL_Delay+0x84>)
24002122:	681b      	ldr	r3, [r3, #0]
24002124:	4a04      	ldr	r2, [pc, #16]	; (24002138 <HAL_Delay+0x84>)
24002126:	f043 0302 	orr.w	r3, r3, #2
2400212a:	6013      	str	r3, [r2, #0]
}
2400212c:	bf00      	nop
2400212e:	46bd      	mov	sp, r7
24002130:	f85d 7b04 	ldr.w	r7, [sp], #4
24002134:	4770      	bx	lr
24002136:	bf00      	nop
24002138:	e000e010 	.word	0xe000e010

2400213c <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
2400213c:	b480      	push	{r7}
2400213e:	af00      	add	r7, sp, #0
 return __STM32H7xx_HAL_VERSION;
24002140:	4b02      	ldr	r3, [pc, #8]	; (2400214c <HAL_GetHalVersion+0x10>)
}
24002142:	4618      	mov	r0, r3
24002144:	46bd      	mov	sp, r7
24002146:	f85d 7b04 	ldr.w	r7, [sp], #4
2400214a:	4770      	bx	lr
2400214c:	010b0100 	.word	0x010b0100

24002150 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
24002150:	b480      	push	{r7}
24002152:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
24002154:	4b03      	ldr	r3, [pc, #12]	; (24002164 <HAL_GetREVID+0x14>)
24002156:	681b      	ldr	r3, [r3, #0]
24002158:	0c1b      	lsrs	r3, r3, #16
}
2400215a:	4618      	mov	r0, r3
2400215c:	46bd      	mov	sp, r7
2400215e:	f85d 7b04 	ldr.w	r7, [sp], #4
24002162:	4770      	bx	lr
24002164:	5c001000 	.word	0x5c001000

24002168 <HAL_GetDEVID>:
/**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
24002168:	b480      	push	{r7}
2400216a:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
2400216c:	4b04      	ldr	r3, [pc, #16]	; (24002180 <HAL_GetDEVID+0x18>)
2400216e:	681b      	ldr	r3, [r3, #0]
24002170:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
24002174:	4618      	mov	r0, r3
24002176:	46bd      	mov	sp, r7
24002178:	f85d 7b04 	ldr.w	r7, [sp], #4
2400217c:	4770      	bx	lr
2400217e:	bf00      	nop
24002180:	5c001000 	.word	0x5c001000

24002184 <HAL_GetUIDw0>:
/**
  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
24002184:	b480      	push	{r7}
24002186:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)UID_BASE)));
24002188:	4b03      	ldr	r3, [pc, #12]	; (24002198 <HAL_GetUIDw0+0x14>)
2400218a:	681b      	ldr	r3, [r3, #0]
}
2400218c:	4618      	mov	r0, r3
2400218e:	46bd      	mov	sp, r7
24002190:	f85d 7b04 	ldr.w	r7, [sp], #4
24002194:	4770      	bx	lr
24002196:	bf00      	nop
24002198:	1ff1e800 	.word	0x1ff1e800

2400219c <HAL_GetUIDw1>:
/**
  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
2400219c:	b480      	push	{r7}
2400219e:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
240021a0:	4b03      	ldr	r3, [pc, #12]	; (240021b0 <HAL_GetUIDw1+0x14>)
240021a2:	681b      	ldr	r3, [r3, #0]
}
240021a4:	4618      	mov	r0, r3
240021a6:	46bd      	mov	sp, r7
240021a8:	f85d 7b04 	ldr.w	r7, [sp], #4
240021ac:	4770      	bx	lr
240021ae:	bf00      	nop
240021b0:	1ff1e804 	.word	0x1ff1e804

240021b4 <HAL_GetUIDw2>:
/**
  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
240021b4:	b480      	push	{r7}
240021b6:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
240021b8:	4b03      	ldr	r3, [pc, #12]	; (240021c8 <HAL_GetUIDw2+0x14>)
240021ba:	681b      	ldr	r3, [r3, #0]
}
240021bc:	4618      	mov	r0, r3
240021be:	46bd      	mov	sp, r7
240021c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240021c4:	4770      	bx	lr
240021c6:	bf00      	nop
240021c8:	1ff1e808 	.word	0x1ff1e808

240021cc <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE3: VREF_OUT4 around 1.5 V.
  *                                                This requires VDDA equal to or higher than 1.8 V.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
240021cc:	b480      	push	{r7}
240021ce:	b083      	sub	sp, #12
240021d0:	af00      	add	r7, sp, #0
240021d2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
240021d4:	4b06      	ldr	r3, [pc, #24]	; (240021f0 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
240021d6:	681b      	ldr	r3, [r3, #0]
240021d8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240021dc:	4904      	ldr	r1, [pc, #16]	; (240021f0 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
240021de:	687b      	ldr	r3, [r7, #4]
240021e0:	4313      	orrs	r3, r2
240021e2:	600b      	str	r3, [r1, #0]
}
240021e4:	bf00      	nop
240021e6:	370c      	adds	r7, #12
240021e8:	46bd      	mov	sp, r7
240021ea:	f85d 7b04 	ldr.w	r7, [sp], #4
240021ee:	4770      	bx	lr
240021f0:	58003c00 	.word	0x58003c00

240021f4 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
240021f4:	b480      	push	{r7}
240021f6:	b083      	sub	sp, #12
240021f8:	af00      	add	r7, sp, #0
240021fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
240021fc:	4b06      	ldr	r3, [pc, #24]	; (24002218 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
240021fe:	681b      	ldr	r3, [r3, #0]
24002200:	f023 0202 	bic.w	r2, r3, #2
24002204:	4904      	ldr	r1, [pc, #16]	; (24002218 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
24002206:	687b      	ldr	r3, [r7, #4]
24002208:	4313      	orrs	r3, r2
2400220a:	600b      	str	r3, [r1, #0]
}
2400220c:	bf00      	nop
2400220e:	370c      	adds	r7, #12
24002210:	46bd      	mov	sp, r7
24002212:	f85d 7b04 	ldr.w	r7, [sp], #4
24002216:	4770      	bx	lr
24002218:	58003c00 	.word	0x58003c00

2400221c <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
/**
  * @brief  Tune the Internal Voltage Reference buffer (VREFBUF).
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
2400221c:	b480      	push	{r7}
2400221e:	b083      	sub	sp, #12
24002220:	af00      	add	r7, sp, #0
24002222:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));

  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
24002224:	4b06      	ldr	r3, [pc, #24]	; (24002240 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
24002226:	685b      	ldr	r3, [r3, #4]
24002228:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
2400222c:	4904      	ldr	r1, [pc, #16]	; (24002240 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
2400222e:	687b      	ldr	r3, [r7, #4]
24002230:	4313      	orrs	r3, r2
24002232:	604b      	str	r3, [r1, #4]
}
24002234:	bf00      	nop
24002236:	370c      	adds	r7, #12
24002238:	46bd      	mov	sp, r7
2400223a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400223e:	4770      	bx	lr
24002240:	58003c00 	.word	0x58003c00

24002244 <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
24002244:	b580      	push	{r7, lr}
24002246:	b082      	sub	sp, #8
24002248:	af00      	add	r7, sp, #0
  uint32_t  tickstart;

  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
2400224a:	4b0f      	ldr	r3, [pc, #60]	; (24002288 <HAL_SYSCFG_EnableVREFBUF+0x44>)
2400224c:	681b      	ldr	r3, [r3, #0]
2400224e:	4a0e      	ldr	r2, [pc, #56]	; (24002288 <HAL_SYSCFG_EnableVREFBUF+0x44>)
24002250:	f043 0301 	orr.w	r3, r3, #1
24002254:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
24002256:	f7ff fee1 	bl	2400201c <HAL_GetTick>
2400225a:	6078      	str	r0, [r7, #4]

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
2400225c:	e008      	b.n	24002270 <HAL_SYSCFG_EnableVREFBUF+0x2c>
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
2400225e:	f7ff fedd 	bl	2400201c <HAL_GetTick>
24002262:	4602      	mov	r2, r0
24002264:	687b      	ldr	r3, [r7, #4]
24002266:	1ad3      	subs	r3, r2, r3
24002268:	2b0a      	cmp	r3, #10
2400226a:	d901      	bls.n	24002270 <HAL_SYSCFG_EnableVREFBUF+0x2c>
    {
      return HAL_TIMEOUT;
2400226c:	2303      	movs	r3, #3
2400226e:	e006      	b.n	2400227e <HAL_SYSCFG_EnableVREFBUF+0x3a>
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
24002270:	4b05      	ldr	r3, [pc, #20]	; (24002288 <HAL_SYSCFG_EnableVREFBUF+0x44>)
24002272:	681b      	ldr	r3, [r3, #0]
24002274:	f003 0308 	and.w	r3, r3, #8
24002278:	2b00      	cmp	r3, #0
2400227a:	d0f0      	beq.n	2400225e <HAL_SYSCFG_EnableVREFBUF+0x1a>
    }
  }

  return HAL_OK;
2400227c:	2300      	movs	r3, #0
}
2400227e:	4618      	mov	r0, r3
24002280:	3708      	adds	r7, #8
24002282:	46bd      	mov	sp, r7
24002284:	bd80      	pop	{r7, pc}
24002286:	bf00      	nop
24002288:	58003c00 	.word	0x58003c00

2400228c <HAL_SYSCFG_DisableVREFBUF>:
  * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
2400228c:	b480      	push	{r7}
2400228e:	af00      	add	r7, sp, #0
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
24002290:	4b05      	ldr	r3, [pc, #20]	; (240022a8 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
24002292:	681b      	ldr	r3, [r3, #0]
24002294:	4a04      	ldr	r2, [pc, #16]	; (240022a8 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
24002296:	f023 0301 	bic.w	r3, r3, #1
2400229a:	6013      	str	r3, [r2, #0]
}
2400229c:	bf00      	nop
2400229e:	46bd      	mov	sp, r7
240022a0:	f85d 7b04 	ldr.w	r7, [sp], #4
240022a4:	4770      	bx	lr
240022a6:	bf00      	nop
240022a8:	58003c00 	.word	0x58003c00

240022ac <HAL_SYSCFG_ETHInterfaceSelect>:
  *   @arg SYSCFG_ETH_MII : Select the Media Independent Interface
  *   @arg SYSCFG_ETH_RMII: Select the Reduced Media Independent Interface
  * @retval None
  */
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
240022ac:	b480      	push	{r7}
240022ae:	b083      	sub	sp, #12
240022b0:	af00      	add	r7, sp, #0
240022b2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
240022b4:	4b06      	ldr	r3, [pc, #24]	; (240022d0 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
240022b6:	685b      	ldr	r3, [r3, #4]
240022b8:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
240022bc:	4904      	ldr	r1, [pc, #16]	; (240022d0 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
240022be:	687b      	ldr	r3, [r7, #4]
240022c0:	4313      	orrs	r3, r2
240022c2:	604b      	str	r3, [r1, #4]
}
240022c4:	bf00      	nop
240022c6:	370c      	adds	r7, #12
240022c8:	46bd      	mov	sp, r7
240022ca:	f85d 7b04 	ldr.w	r7, [sp], #4
240022ce:	4770      	bx	lr
240022d0:	58000400 	.word	0x58000400

240022d4 <HAL_SYSCFG_AnalogSwitchConfig>:
  *   @arg SYSCFG_SWITCH_PC3_CLOSE
  * @retval None
  */

void HAL_SYSCFG_AnalogSwitchConfig(uint32_t SYSCFG_AnalogSwitch , uint32_t SYSCFG_SwitchState )
{
240022d4:	b480      	push	{r7}
240022d6:	b083      	sub	sp, #12
240022d8:	af00      	add	r7, sp, #0
240022da:	6078      	str	r0, [r7, #4]
240022dc:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ANALOG_SWITCH(SYSCFG_AnalogSwitch));
  assert_param(IS_SYSCFG_SWITCH_STATE(SYSCFG_SwitchState));

  MODIFY_REG(SYSCFG->PMCR, (uint32_t) SYSCFG_AnalogSwitch, (uint32_t)(SYSCFG_SwitchState));
240022de:	4b07      	ldr	r3, [pc, #28]	; (240022fc <HAL_SYSCFG_AnalogSwitchConfig+0x28>)
240022e0:	685a      	ldr	r2, [r3, #4]
240022e2:	687b      	ldr	r3, [r7, #4]
240022e4:	43db      	mvns	r3, r3
240022e6:	401a      	ands	r2, r3
240022e8:	4904      	ldr	r1, [pc, #16]	; (240022fc <HAL_SYSCFG_AnalogSwitchConfig+0x28>)
240022ea:	683b      	ldr	r3, [r7, #0]
240022ec:	4313      	orrs	r3, r2
240022ee:	604b      	str	r3, [r1, #4]
}
240022f0:	bf00      	nop
240022f2:	370c      	adds	r7, #12
240022f4:	46bd      	mov	sp, r7
240022f6:	f85d 7b04 	ldr.w	r7, [sp], #4
240022fa:	4770      	bx	lr
240022fc:	58000400 	.word	0x58000400

24002300 <HAL_SYSCFG_EnableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_EnableBOOST(void)
{
24002300:	b480      	push	{r7}
24002302:	af00      	add	r7, sp, #0
 SET_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
24002304:	4b05      	ldr	r3, [pc, #20]	; (2400231c <HAL_SYSCFG_EnableBOOST+0x1c>)
24002306:	685b      	ldr	r3, [r3, #4]
24002308:	4a04      	ldr	r2, [pc, #16]	; (2400231c <HAL_SYSCFG_EnableBOOST+0x1c>)
2400230a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2400230e:	6053      	str	r3, [r2, #4]
}
24002310:	bf00      	nop
24002312:	46bd      	mov	sp, r7
24002314:	f85d 7b04 	ldr.w	r7, [sp], #4
24002318:	4770      	bx	lr
2400231a:	bf00      	nop
2400231c:	58000400 	.word	0x58000400

24002320 <HAL_SYSCFG_DisableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_DisableBOOST(void)
{
24002320:	b480      	push	{r7}
24002322:	af00      	add	r7, sp, #0
 CLEAR_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
24002324:	4b05      	ldr	r3, [pc, #20]	; (2400233c <HAL_SYSCFG_DisableBOOST+0x1c>)
24002326:	685b      	ldr	r3, [r3, #4]
24002328:	4a04      	ldr	r2, [pc, #16]	; (2400233c <HAL_SYSCFG_DisableBOOST+0x1c>)
2400232a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2400232e:	6053      	str	r3, [r2, #4]
}
24002330:	bf00      	nop
24002332:	46bd      	mov	sp, r7
24002334:	f85d 7b04 	ldr.w	r7, [sp], #4
24002338:	4770      	bx	lr
2400233a:	bf00      	nop
2400233c:	58000400 	.word	0x58000400

24002340 <HAL_SYSCFG_CM7BootAddConfig>:
  *   @arg SYSCFG_BOOT_ADDR1:  Select the boot address1
  * @param  BootAddress :Specifies the CM7 Boot Address to be loaded in Address0 or Address1
  * @retval None
  */
void HAL_SYSCFG_CM7BootAddConfig(uint32_t BootRegister, uint32_t BootAddress)
{
24002340:	b480      	push	{r7}
24002342:	b083      	sub	sp, #12
24002344:	af00      	add	r7, sp, #0
24002346:	6078      	str	r0, [r7, #4]
24002348:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_SYSCFG_BOOT_REGISTER(BootRegister));
  assert_param(IS_SYSCFG_BOOT_ADDRESS(BootAddress));
  if ( BootRegister == SYSCFG_BOOT_ADDR0 )
2400234a:	687b      	ldr	r3, [r7, #4]
2400234c:	2b00      	cmp	r3, #0
2400234e:	d10b      	bne.n	24002368 <HAL_SYSCFG_CM7BootAddConfig+0x28>
  {
    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BCM7_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BCM7_ADD0_Pos));
#else
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BOOT_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BOOT_ADD0_Pos));
24002350:	4b0e      	ldr	r3, [pc, #56]	; (2400238c <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24002352:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
24002356:	b29a      	uxth	r2, r3
24002358:	683b      	ldr	r3, [r7, #0]
2400235a:	0c1b      	lsrs	r3, r3, #16
2400235c:	041b      	lsls	r3, r3, #16
2400235e:	490b      	ldr	r1, [pc, #44]	; (2400238c <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24002360:	4313      	orrs	r3, r2
24002362:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BCM7_ADD1, (BootAddress >> 16));
#else
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
#endif /*DUAL_CORE*/
  }
}
24002366:	e00a      	b.n	2400237e <HAL_SYSCFG_CM7BootAddConfig+0x3e>
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
24002368:	4b08      	ldr	r3, [pc, #32]	; (2400238c <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
2400236a:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
2400236e:	4b08      	ldr	r3, [pc, #32]	; (24002390 <HAL_SYSCFG_CM7BootAddConfig+0x50>)
24002370:	4013      	ands	r3, r2
24002372:	683a      	ldr	r2, [r7, #0]
24002374:	0c12      	lsrs	r2, r2, #16
24002376:	4905      	ldr	r1, [pc, #20]	; (2400238c <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24002378:	4313      	orrs	r3, r2
2400237a:	f8c1 330c 	str.w	r3, [r1, #780]	; 0x30c
}
2400237e:	bf00      	nop
24002380:	370c      	adds	r7, #12
24002382:	46bd      	mov	sp, r7
24002384:	f85d 7b04 	ldr.w	r7, [sp], #4
24002388:	4770      	bx	lr
2400238a:	bf00      	nop
2400238c:	58000400 	.word	0x58000400
24002390:	ffff0000 	.word	0xffff0000

24002394 <HAL_EnableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 1.62 to 2.0 V and from 2.7 to 3.6 V.
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
24002394:	b480      	push	{r7}
24002396:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN) ;
24002398:	4b05      	ldr	r3, [pc, #20]	; (240023b0 <HAL_EnableCompensationCell+0x1c>)
2400239a:	6a1b      	ldr	r3, [r3, #32]
2400239c:	4a04      	ldr	r2, [pc, #16]	; (240023b0 <HAL_EnableCompensationCell+0x1c>)
2400239e:	f043 0301 	orr.w	r3, r3, #1
240023a2:	6213      	str	r3, [r2, #32]
}
240023a4:	bf00      	nop
240023a6:	46bd      	mov	sp, r7
240023a8:	f85d 7b04 	ldr.w	r7, [sp], #4
240023ac:	4770      	bx	lr
240023ae:	bf00      	nop
240023b0:	58000400 	.word	0x58000400

240023b4 <HAL_DisableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 1.62 to 2.0 V and from 2.7 to 3.6 V.
  * @retval None
  */
void HAL_DisableCompensationCell(void)
{
240023b4:	b480      	push	{r7}
240023b6:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN);
240023b8:	4b05      	ldr	r3, [pc, #20]	; (240023d0 <HAL_DisableCompensationCell+0x1c>)
240023ba:	6a1b      	ldr	r3, [r3, #32]
240023bc:	4a04      	ldr	r2, [pc, #16]	; (240023d0 <HAL_DisableCompensationCell+0x1c>)
240023be:	f023 0301 	bic.w	r3, r3, #1
240023c2:	6213      	str	r3, [r2, #32]
}
240023c4:	bf00      	nop
240023c6:	46bd      	mov	sp, r7
240023c8:	f85d 7b04 	ldr.w	r7, [sp], #4
240023cc:	4770      	bx	lr
240023ce:	bf00      	nop
240023d0:	58000400 	.word	0x58000400

240023d4 <HAL_SYSCFG_EnableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_EnableIOSpeedOptimize(void)
{
240023d4:	b480      	push	{r7}
240023d6:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
240023d8:	4b05      	ldr	r3, [pc, #20]	; (240023f0 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
240023da:	6a1b      	ldr	r3, [r3, #32]
240023dc:	4a04      	ldr	r2, [pc, #16]	; (240023f0 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
240023de:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240023e2:	6213      	str	r3, [r2, #32]
#else
  SET_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
240023e4:	bf00      	nop
240023e6:	46bd      	mov	sp, r7
240023e8:	f85d 7b04 	ldr.w	r7, [sp], #4
240023ec:	4770      	bx	lr
240023ee:	bf00      	nop
240023f0:	58000400 	.word	0x58000400

240023f4 <HAL_SYSCFG_DisableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_DisableIOSpeedOptimize(void)
{
240023f4:	b480      	push	{r7}
240023f6:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
240023f8:	4b05      	ldr	r3, [pc, #20]	; (24002410 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
240023fa:	6a1b      	ldr	r3, [r3, #32]
240023fc:	4a04      	ldr	r2, [pc, #16]	; (24002410 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
240023fe:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24002402:	6213      	str	r3, [r2, #32]
#else
  CLEAR_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
24002404:	bf00      	nop
24002406:	46bd      	mov	sp, r7
24002408:	f85d 7b04 	ldr.w	r7, [sp], #4
2400240c:	4770      	bx	lr
2400240e:	bf00      	nop
24002410:	58000400 	.word	0x58000400

24002414 <HAL_SYSCFG_CompensationCodeSelect>:
  *   @arg SYSCFG_CELL_CODE : Select Code from the cell (available in the SYSCFG_CCVR)
  *   @arg SYSCFG_REGISTER_CODE: Select Code from the SYSCFG compensation cell code register (SYSCFG_CCCR)
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeSelect(uint32_t SYSCFG_CompCode)
{
24002414:	b480      	push	{r7}
24002416:	b083      	sub	sp, #12
24002418:	af00      	add	r7, sp, #0
2400241a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_SELECT(SYSCFG_CompCode));
  MODIFY_REG(SYSCFG->CCCSR, SYSCFG_CCCSR_CS, (uint32_t)(SYSCFG_CompCode));
2400241c:	4b06      	ldr	r3, [pc, #24]	; (24002438 <HAL_SYSCFG_CompensationCodeSelect+0x24>)
2400241e:	6a1b      	ldr	r3, [r3, #32]
24002420:	f023 0202 	bic.w	r2, r3, #2
24002424:	4904      	ldr	r1, [pc, #16]	; (24002438 <HAL_SYSCFG_CompensationCodeSelect+0x24>)
24002426:	687b      	ldr	r3, [r7, #4]
24002428:	4313      	orrs	r3, r2
2400242a:	620b      	str	r3, [r1, #32]
}
2400242c:	bf00      	nop
2400242e:	370c      	adds	r7, #12
24002430:	46bd      	mov	sp, r7
24002432:	f85d 7b04 	ldr.w	r7, [sp], #4
24002436:	4770      	bx	lr
24002438:	58000400 	.word	0x58000400

2400243c <HAL_SYSCFG_CompensationCodeConfig>:
  *         This code is applied to the I/O compensation cell when the CS bit of the
  *          SYSCFG_CMPCR is set
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeConfig(uint32_t SYSCFG_PMOSCode, uint32_t SYSCFG_NMOSCode )
{
2400243c:	b480      	push	{r7}
2400243e:	b083      	sub	sp, #12
24002440:	af00      	add	r7, sp, #0
24002442:	6078      	str	r0, [r7, #4]
24002444:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_PMOSCode));
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_NMOSCode));
  MODIFY_REG(SYSCFG->CCCR, SYSCFG_CCCR_NCC|SYSCFG_CCCR_PCC, (((uint32_t)(SYSCFG_PMOSCode)<< 4)|(uint32_t)(SYSCFG_NMOSCode)) );
24002446:	4b08      	ldr	r3, [pc, #32]	; (24002468 <HAL_SYSCFG_CompensationCodeConfig+0x2c>)
24002448:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2400244a:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
2400244e:	687b      	ldr	r3, [r7, #4]
24002450:	0119      	lsls	r1, r3, #4
24002452:	683b      	ldr	r3, [r7, #0]
24002454:	430b      	orrs	r3, r1
24002456:	4904      	ldr	r1, [pc, #16]	; (24002468 <HAL_SYSCFG_CompensationCodeConfig+0x2c>)
24002458:	4313      	orrs	r3, r2
2400245a:	628b      	str	r3, [r1, #40]	; 0x28
}
2400245c:	bf00      	nop
2400245e:	370c      	adds	r7, #12
24002460:	46bd      	mov	sp, r7
24002462:	f85d 7b04 	ldr.w	r7, [sp], #4
24002466:	4770      	bx	lr
24002468:	58000400 	.word	0x58000400

2400246c <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
2400246c:	b480      	push	{r7}
2400246e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24002470:	4b05      	ldr	r3, [pc, #20]	; (24002488 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
24002472:	685b      	ldr	r3, [r3, #4]
24002474:	4a04      	ldr	r2, [pc, #16]	; (24002488 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
24002476:	f043 0301 	orr.w	r3, r3, #1
2400247a:	6053      	str	r3, [r2, #4]
}
2400247c:	bf00      	nop
2400247e:	46bd      	mov	sp, r7
24002480:	f85d 7b04 	ldr.w	r7, [sp], #4
24002484:	4770      	bx	lr
24002486:	bf00      	nop
24002488:	5c001000 	.word	0x5c001000

2400248c <HAL_DBGMCU_DisableDBGSleepMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
2400248c:	b480      	push	{r7}
2400248e:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24002490:	4b05      	ldr	r3, [pc, #20]	; (240024a8 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
24002492:	685b      	ldr	r3, [r3, #4]
24002494:	4a04      	ldr	r2, [pc, #16]	; (240024a8 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
24002496:	f023 0301 	bic.w	r3, r3, #1
2400249a:	6053      	str	r3, [r2, #4]
}
2400249c:	bf00      	nop
2400249e:	46bd      	mov	sp, r7
240024a0:	f85d 7b04 	ldr.w	r7, [sp], #4
240024a4:	4770      	bx	lr
240024a6:	bf00      	nop
240024a8:	5c001000 	.word	0x5c001000

240024ac <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
240024ac:	b480      	push	{r7}
240024ae:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
240024b0:	4b05      	ldr	r3, [pc, #20]	; (240024c8 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
240024b2:	685b      	ldr	r3, [r3, #4]
240024b4:	4a04      	ldr	r2, [pc, #16]	; (240024c8 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
240024b6:	f043 0302 	orr.w	r3, r3, #2
240024ba:	6053      	str	r3, [r2, #4]
}
240024bc:	bf00      	nop
240024be:	46bd      	mov	sp, r7
240024c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240024c4:	4770      	bx	lr
240024c6:	bf00      	nop
240024c8:	5c001000 	.word	0x5c001000

240024cc <HAL_DBGMCU_DisableDBGStopMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
240024cc:	b480      	push	{r7}
240024ce:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
240024d0:	4b05      	ldr	r3, [pc, #20]	; (240024e8 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
240024d2:	685b      	ldr	r3, [r3, #4]
240024d4:	4a04      	ldr	r2, [pc, #16]	; (240024e8 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
240024d6:	f023 0302 	bic.w	r3, r3, #2
240024da:	6053      	str	r3, [r2, #4]
}
240024dc:	bf00      	nop
240024de:	46bd      	mov	sp, r7
240024e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240024e4:	4770      	bx	lr
240024e6:	bf00      	nop
240024e8:	5c001000 	.word	0x5c001000

240024ec <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
240024ec:	b480      	push	{r7}
240024ee:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
240024f0:	4b05      	ldr	r3, [pc, #20]	; (24002508 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
240024f2:	685b      	ldr	r3, [r3, #4]
240024f4:	4a04      	ldr	r2, [pc, #16]	; (24002508 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
240024f6:	f043 0304 	orr.w	r3, r3, #4
240024fa:	6053      	str	r3, [r2, #4]
}
240024fc:	bf00      	nop
240024fe:	46bd      	mov	sp, r7
24002500:	f85d 7b04 	ldr.w	r7, [sp], #4
24002504:	4770      	bx	lr
24002506:	bf00      	nop
24002508:	5c001000 	.word	0x5c001000

2400250c <HAL_DBGMCU_DisableDBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
2400250c:	b480      	push	{r7}
2400250e:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24002510:	4b05      	ldr	r3, [pc, #20]	; (24002528 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
24002512:	685b      	ldr	r3, [r3, #4]
24002514:	4a04      	ldr	r2, [pc, #16]	; (24002528 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
24002516:	f023 0304 	bic.w	r3, r3, #4
2400251a:	6053      	str	r3, [r2, #4]
}
2400251c:	bf00      	nop
2400251e:	46bd      	mov	sp, r7
24002520:	f85d 7b04 	ldr.w	r7, [sp], #4
24002524:	4770      	bx	lr
24002526:	bf00      	nop
24002528:	5c001000 	.word	0x5c001000

2400252c <HAL_SetFMCMemorySwappingConfig>:
  * @param  BankMapConfig: Defines the FMC Bank mapping configuration. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
2400252c:	b480      	push	{r7}
2400252e:	b083      	sub	sp, #12
24002530:	af00      	add	r7, sp, #0
24002532:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
24002534:	4b06      	ldr	r3, [pc, #24]	; (24002550 <HAL_SetFMCMemorySwappingConfig+0x24>)
24002536:	681b      	ldr	r3, [r3, #0]
24002538:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
2400253c:	4904      	ldr	r1, [pc, #16]	; (24002550 <HAL_SetFMCMemorySwappingConfig+0x24>)
2400253e:	687b      	ldr	r3, [r7, #4]
24002540:	4313      	orrs	r3, r2
24002542:	600b      	str	r3, [r1, #0]
}
24002544:	bf00      	nop
24002546:	370c      	adds	r7, #12
24002548:	46bd      	mov	sp, r7
2400254a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400254e:	4770      	bx	lr
24002550:	52004000 	.word	0x52004000

24002554 <HAL_GetFMCMemorySwappingConfig>:
  * @brief  Get FMC Bank mapping mode.
  * @retval The FMC Bank mapping mode. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
*/
uint32_t HAL_GetFMCMemorySwappingConfig(void)
{
24002554:	b480      	push	{r7}
24002556:	af00      	add	r7, sp, #0
  return READ_BIT(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP);
24002558:	4b04      	ldr	r3, [pc, #16]	; (2400256c <HAL_GetFMCMemorySwappingConfig+0x18>)
2400255a:	681b      	ldr	r3, [r3, #0]
2400255c:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
}
24002560:	4618      	mov	r0, r3
24002562:	46bd      	mov	sp, r7
24002564:	f85d 7b04 	ldr.w	r7, [sp], #4
24002568:	4770      	bx	lr
2400256a:	bf00      	nop
2400256c:	52004000 	.word	0x52004000

24002570 <HAL_EXTI_EdgeConfig>:
  *   @arg EXTI_RISING_EDGE : Configurable line, with Rising edge trigger detection
  *   @arg EXTI_FALLING_EDGE: Configurable line, with Falling edge trigger detection
  * @retval None
  */
void HAL_EXTI_EdgeConfig(uint32_t EXTI_Line , uint32_t EXTI_Edge )
{
24002570:	b480      	push	{r7}
24002572:	b083      	sub	sp, #12
24002574:	af00      	add	r7, sp, #0
24002576:	6078      	str	r0, [r7, #4]
24002578:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));
  assert_param(IS_EXTI_EDGE_LINE(EXTI_Edge));

  /* Clear Rising Falling edge configuration */
  CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
2400257a:	687b      	ldr	r3, [r7, #4]
2400257c:	095b      	lsrs	r3, r3, #5
2400257e:	015a      	lsls	r2, r3, #5
24002580:	4b2e      	ldr	r3, [pc, #184]	; (2400263c <HAL_EXTI_EdgeConfig+0xcc>)
24002582:	4413      	add	r3, r2
24002584:	6819      	ldr	r1, [r3, #0]
24002586:	687b      	ldr	r3, [r7, #4]
24002588:	f003 031f 	and.w	r3, r3, #31
2400258c:	2201      	movs	r2, #1
2400258e:	fa02 f303 	lsl.w	r3, r2, r3
24002592:	43da      	mvns	r2, r3
24002594:	687b      	ldr	r3, [r7, #4]
24002596:	095b      	lsrs	r3, r3, #5
24002598:	0158      	lsls	r0, r3, #5
2400259a:	4b28      	ldr	r3, [pc, #160]	; (2400263c <HAL_EXTI_EdgeConfig+0xcc>)
2400259c:	4403      	add	r3, r0
2400259e:	4618      	mov	r0, r3
240025a0:	ea01 0302 	and.w	r3, r1, r2
240025a4:	6003      	str	r3, [r0, #0]
  CLEAR_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
240025a6:	687b      	ldr	r3, [r7, #4]
240025a8:	095b      	lsrs	r3, r3, #5
240025aa:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
240025ae:	015b      	lsls	r3, r3, #5
240025b0:	681a      	ldr	r2, [r3, #0]
240025b2:	687b      	ldr	r3, [r7, #4]
240025b4:	f003 031f 	and.w	r3, r3, #31
240025b8:	2101      	movs	r1, #1
240025ba:	fa01 f303 	lsl.w	r3, r1, r3
240025be:	43db      	mvns	r3, r3
240025c0:	6879      	ldr	r1, [r7, #4]
240025c2:	0949      	lsrs	r1, r1, #5
240025c4:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
240025c8:	0149      	lsls	r1, r1, #5
240025ca:	4013      	ands	r3, r2
240025cc:	600b      	str	r3, [r1, #0]

  if( (EXTI_Edge & EXTI_RISING_EDGE) == EXTI_RISING_EDGE)
240025ce:	683b      	ldr	r3, [r7, #0]
240025d0:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
240025d4:	2b00      	cmp	r3, #0
240025d6:	d012      	beq.n	240025fe <HAL_EXTI_EdgeConfig+0x8e>
  {
   SET_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
240025d8:	687b      	ldr	r3, [r7, #4]
240025da:	095b      	lsrs	r3, r3, #5
240025dc:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
240025e0:	015b      	lsls	r3, r3, #5
240025e2:	681a      	ldr	r2, [r3, #0]
240025e4:	687b      	ldr	r3, [r7, #4]
240025e6:	f003 031f 	and.w	r3, r3, #31
240025ea:	2101      	movs	r1, #1
240025ec:	fa01 f303 	lsl.w	r3, r1, r3
240025f0:	6879      	ldr	r1, [r7, #4]
240025f2:	0949      	lsrs	r1, r1, #5
240025f4:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
240025f8:	0149      	lsls	r1, r1, #5
240025fa:	4313      	orrs	r3, r2
240025fc:	600b      	str	r3, [r1, #0]
  }
  if( (EXTI_Edge & EXTI_FALLING_EDGE) == EXTI_FALLING_EDGE)
240025fe:	683b      	ldr	r3, [r7, #0]
24002600:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24002604:	2b00      	cmp	r3, #0
24002606:	d013      	beq.n	24002630 <HAL_EXTI_EdgeConfig+0xc0>
  {
   SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002608:	687b      	ldr	r3, [r7, #4]
2400260a:	095b      	lsrs	r3, r3, #5
2400260c:	015a      	lsls	r2, r3, #5
2400260e:	4b0b      	ldr	r3, [pc, #44]	; (2400263c <HAL_EXTI_EdgeConfig+0xcc>)
24002610:	4413      	add	r3, r2
24002612:	6819      	ldr	r1, [r3, #0]
24002614:	687b      	ldr	r3, [r7, #4]
24002616:	f003 031f 	and.w	r3, r3, #31
2400261a:	2201      	movs	r2, #1
2400261c:	409a      	lsls	r2, r3
2400261e:	687b      	ldr	r3, [r7, #4]
24002620:	095b      	lsrs	r3, r3, #5
24002622:	0158      	lsls	r0, r3, #5
24002624:	4b05      	ldr	r3, [pc, #20]	; (2400263c <HAL_EXTI_EdgeConfig+0xcc>)
24002626:	4403      	add	r3, r0
24002628:	4618      	mov	r0, r3
2400262a:	ea41 0302 	orr.w	r3, r1, r2
2400262e:	6003      	str	r3, [r0, #0]
  }
}
24002630:	bf00      	nop
24002632:	370c      	adds	r7, #12
24002634:	46bd      	mov	sp, r7
24002636:	f85d 7b04 	ldr.w	r7, [sp], #4
2400263a:	4770      	bx	lr
2400263c:	58000004 	.word	0x58000004

24002640 <HAL_EXTI_GenerateSWInterrupt>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *          (EXTI_LINE0..EXTI_LINE21),EXTI_LINE49,EXTI_LINE51,EXTI_LINE82,EXTI_LINE84,EXTI_LINE85 and EXTI_LINE86.
  * @retval None
  */
void HAL_EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
24002640:	b480      	push	{r7}
24002642:	b083      	sub	sp, #12
24002644:	af00      	add	r7, sp, #0
24002646:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));

  SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002648:	687b      	ldr	r3, [r7, #4]
2400264a:	095b      	lsrs	r3, r3, #5
2400264c:	015a      	lsls	r2, r3, #5
2400264e:	4b0b      	ldr	r3, [pc, #44]	; (2400267c <HAL_EXTI_GenerateSWInterrupt+0x3c>)
24002650:	4413      	add	r3, r2
24002652:	6819      	ldr	r1, [r3, #0]
24002654:	687b      	ldr	r3, [r7, #4]
24002656:	f003 031f 	and.w	r3, r3, #31
2400265a:	2201      	movs	r2, #1
2400265c:	409a      	lsls	r2, r3
2400265e:	687b      	ldr	r3, [r7, #4]
24002660:	095b      	lsrs	r3, r3, #5
24002662:	0158      	lsls	r0, r3, #5
24002664:	4b05      	ldr	r3, [pc, #20]	; (2400267c <HAL_EXTI_GenerateSWInterrupt+0x3c>)
24002666:	4403      	add	r3, r0
24002668:	4618      	mov	r0, r3
2400266a:	ea41 0302 	orr.w	r3, r1, r2
2400266e:	6003      	str	r3, [r0, #0]
}
24002670:	bf00      	nop
24002672:	370c      	adds	r7, #12
24002674:	46bd      	mov	sp, r7
24002676:	f85d 7b04 	ldr.w	r7, [sp], #4
2400267a:	4770      	bx	lr
2400267c:	58000008 	.word	0x58000008

24002680 <HAL_EXTI_D1_ClearFlag>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved
  * @retval None
  */
void HAL_EXTI_D1_ClearFlag(uint32_t EXTI_Line)
{
24002680:	b480      	push	{r7}
24002682:	b083      	sub	sp, #12
24002684:	af00      	add	r7, sp, #0
24002686:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
 assert_param(IS_EXTI_D1_LINE(EXTI_Line));
 WRITE_REG(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->PR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002688:	687b      	ldr	r3, [r7, #4]
2400268a:	f003 021f 	and.w	r2, r3, #31
2400268e:	687b      	ldr	r3, [r7, #4]
24002690:	095b      	lsrs	r3, r3, #5
24002692:	0119      	lsls	r1, r3, #4
24002694:	4b05      	ldr	r3, [pc, #20]	; (240026ac <HAL_EXTI_D1_ClearFlag+0x2c>)
24002696:	440b      	add	r3, r1
24002698:	4619      	mov	r1, r3
2400269a:	2301      	movs	r3, #1
2400269c:	4093      	lsls	r3, r2
2400269e:	600b      	str	r3, [r1, #0]

}
240026a0:	bf00      	nop
240026a2:	370c      	adds	r7, #12
240026a4:	46bd      	mov	sp, r7
240026a6:	f85d 7b04 	ldr.w	r7, [sp], #4
240026aa:	4770      	bx	lr
240026ac:	58000088 	.word	0x58000088

240026b0 <HAL_EXTI_D1_EventInputConfig>:
  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.

  * @retval None
  */
void HAL_EXTI_D1_EventInputConfig(uint32_t EXTI_Line , uint32_t EXTI_Mode,  uint32_t EXTI_LineCmd )
{
240026b0:	b480      	push	{r7}
240026b2:	b085      	sub	sp, #20
240026b4:	af00      	add	r7, sp, #0
240026b6:	60f8      	str	r0, [r7, #12]
240026b8:	60b9      	str	r1, [r7, #8]
240026ba:	607a      	str	r2, [r7, #4]
  /* Check the parameter */
  assert_param(IS_EXTI_D1_LINE(EXTI_Line));
  assert_param(IS_EXTI_MODE_LINE(EXTI_Mode));

  if( (EXTI_Mode & EXTI_MODE_IT) == EXTI_MODE_IT)
240026bc:	68bb      	ldr	r3, [r7, #8]
240026be:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240026c2:	2b00      	cmp	r3, #0
240026c4:	d02d      	beq.n	24002722 <HAL_EXTI_D1_EventInputConfig+0x72>
  {
     if( EXTI_LineCmd == 0UL)
240026c6:	687b      	ldr	r3, [r7, #4]
240026c8:	2b00      	cmp	r3, #0
240026ca:	d116      	bne.n	240026fa <HAL_EXTI_D1_EventInputConfig+0x4a>
     {
       /* Clear EXTI line configuration */
        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
240026cc:	68fb      	ldr	r3, [r7, #12]
240026ce:	095a      	lsrs	r2, r3, #5
240026d0:	4b30      	ldr	r3, [pc, #192]	; (24002794 <HAL_EXTI_D1_EventInputConfig+0xe4>)
240026d2:	4413      	add	r3, r2
240026d4:	011b      	lsls	r3, r3, #4
240026d6:	6819      	ldr	r1, [r3, #0]
240026d8:	68fb      	ldr	r3, [r7, #12]
240026da:	f003 031f 	and.w	r3, r3, #31
240026de:	2201      	movs	r2, #1
240026e0:	fa02 f303 	lsl.w	r3, r2, r3
240026e4:	43da      	mvns	r2, r3
240026e6:	68fb      	ldr	r3, [r7, #12]
240026e8:	0958      	lsrs	r0, r3, #5
240026ea:	4b2a      	ldr	r3, [pc, #168]	; (24002794 <HAL_EXTI_D1_EventInputConfig+0xe4>)
240026ec:	4403      	add	r3, r0
240026ee:	011b      	lsls	r3, r3, #4
240026f0:	4618      	mov	r0, r3
240026f2:	ea01 0302 	and.w	r3, r1, r2
240026f6:	6003      	str	r3, [r0, #0]
240026f8:	e013      	b.n	24002722 <HAL_EXTI_D1_EventInputConfig+0x72>
     }
     else
     {
        SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
240026fa:	68fb      	ldr	r3, [r7, #12]
240026fc:	095a      	lsrs	r2, r3, #5
240026fe:	4b25      	ldr	r3, [pc, #148]	; (24002794 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24002700:	4413      	add	r3, r2
24002702:	011b      	lsls	r3, r3, #4
24002704:	6819      	ldr	r1, [r3, #0]
24002706:	68fb      	ldr	r3, [r7, #12]
24002708:	f003 031f 	and.w	r3, r3, #31
2400270c:	2201      	movs	r2, #1
2400270e:	409a      	lsls	r2, r3
24002710:	68fb      	ldr	r3, [r7, #12]
24002712:	0958      	lsrs	r0, r3, #5
24002714:	4b1f      	ldr	r3, [pc, #124]	; (24002794 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24002716:	4403      	add	r3, r0
24002718:	011b      	lsls	r3, r3, #4
2400271a:	4618      	mov	r0, r3
2400271c:	ea41 0302 	orr.w	r3, r1, r2
24002720:	6003      	str	r3, [r0, #0]
     }
  }

  if( (EXTI_Mode & EXTI_MODE_EVT) == EXTI_MODE_EVT)
24002722:	68bb      	ldr	r3, [r7, #8]
24002724:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24002728:	2b00      	cmp	r3, #0
2400272a:	d02d      	beq.n	24002788 <HAL_EXTI_D1_EventInputConfig+0xd8>
  {
    if( EXTI_LineCmd == 0UL)
2400272c:	687b      	ldr	r3, [r7, #4]
2400272e:	2b00      	cmp	r3, #0
24002730:	d116      	bne.n	24002760 <HAL_EXTI_D1_EventInputConfig+0xb0>
    {
      /* Clear EXTI line configuration */
      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002732:	68fb      	ldr	r3, [r7, #12]
24002734:	095b      	lsrs	r3, r3, #5
24002736:	011a      	lsls	r2, r3, #4
24002738:	4b17      	ldr	r3, [pc, #92]	; (24002798 <HAL_EXTI_D1_EventInputConfig+0xe8>)
2400273a:	4413      	add	r3, r2
2400273c:	6819      	ldr	r1, [r3, #0]
2400273e:	68fb      	ldr	r3, [r7, #12]
24002740:	f003 031f 	and.w	r3, r3, #31
24002744:	2201      	movs	r2, #1
24002746:	fa02 f303 	lsl.w	r3, r2, r3
2400274a:	43da      	mvns	r2, r3
2400274c:	68fb      	ldr	r3, [r7, #12]
2400274e:	095b      	lsrs	r3, r3, #5
24002750:	0118      	lsls	r0, r3, #4
24002752:	4b11      	ldr	r3, [pc, #68]	; (24002798 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24002754:	4403      	add	r3, r0
24002756:	4618      	mov	r0, r3
24002758:	ea01 0302 	and.w	r3, r1, r2
2400275c:	6003      	str	r3, [r0, #0]
    else
    {
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
    }
  }
}
2400275e:	e013      	b.n	24002788 <HAL_EXTI_D1_EventInputConfig+0xd8>
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002760:	68fb      	ldr	r3, [r7, #12]
24002762:	095b      	lsrs	r3, r3, #5
24002764:	011a      	lsls	r2, r3, #4
24002766:	4b0c      	ldr	r3, [pc, #48]	; (24002798 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24002768:	4413      	add	r3, r2
2400276a:	6819      	ldr	r1, [r3, #0]
2400276c:	68fb      	ldr	r3, [r7, #12]
2400276e:	f003 031f 	and.w	r3, r3, #31
24002772:	2201      	movs	r2, #1
24002774:	409a      	lsls	r2, r3
24002776:	68fb      	ldr	r3, [r7, #12]
24002778:	095b      	lsrs	r3, r3, #5
2400277a:	0118      	lsls	r0, r3, #4
2400277c:	4b06      	ldr	r3, [pc, #24]	; (24002798 <HAL_EXTI_D1_EventInputConfig+0xe8>)
2400277e:	4403      	add	r3, r0
24002780:	4618      	mov	r0, r3
24002782:	ea41 0302 	orr.w	r3, r1, r2
24002786:	6003      	str	r3, [r0, #0]
}
24002788:	bf00      	nop
2400278a:	3714      	adds	r7, #20
2400278c:	46bd      	mov	sp, r7
2400278e:	f85d 7b04 	ldr.w	r7, [sp], #4
24002792:	4770      	bx	lr
24002794:	05800008 	.word	0x05800008
24002798:	58000084 	.word	0x58000084

2400279c <HAL_EXTI_D3_EventInputConfig>:
  *   @arg LPTIM4_OUT_CLEAR : LPTIM4 out selected as D3 domain pendclear source
  *   @arg LPTIM5_OUT_CLEAR : LPTIM5 out selected as D3 domain pendclear source
  * @retval None
  */
void HAL_EXTI_D3_EventInputConfig(uint32_t EXTI_Line, uint32_t EXTI_LineCmd , uint32_t EXTI_ClearSrc  )
{
2400279c:	b480      	push	{r7}
2400279e:	b087      	sub	sp, #28
240027a0:	af00      	add	r7, sp, #0
240027a2:	60f8      	str	r0, [r7, #12]
240027a4:	60b9      	str	r1, [r7, #8]
240027a6:	607a      	str	r2, [r7, #4]

  /* Check the parameter */
  assert_param(IS_EXTI_D3_LINE(EXTI_Line));
  assert_param(IS_EXTI_D3_CLEAR(EXTI_ClearSrc));

  if( EXTI_LineCmd == 0UL)
240027a8:	68bb      	ldr	r3, [r7, #8]
240027aa:	2b00      	cmp	r3, #0
240027ac:	d116      	bne.n	240027dc <HAL_EXTI_D3_EventInputConfig+0x40>
  {
    /* Clear EXTI line configuration */
    CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) + ((EXTI_Line >> 5 ) * 0x20UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
240027ae:	68fb      	ldr	r3, [r7, #12]
240027b0:	095b      	lsrs	r3, r3, #5
240027b2:	015a      	lsls	r2, r3, #5
240027b4:	4b2a      	ldr	r3, [pc, #168]	; (24002860 <HAL_EXTI_D3_EventInputConfig+0xc4>)
240027b6:	4413      	add	r3, r2
240027b8:	6819      	ldr	r1, [r3, #0]
240027ba:	68fb      	ldr	r3, [r7, #12]
240027bc:	f003 031f 	and.w	r3, r3, #31
240027c0:	2201      	movs	r2, #1
240027c2:	fa02 f303 	lsl.w	r3, r2, r3
240027c6:	43da      	mvns	r2, r3
240027c8:	68fb      	ldr	r3, [r7, #12]
240027ca:	095b      	lsrs	r3, r3, #5
240027cc:	0158      	lsls	r0, r3, #5
240027ce:	4b24      	ldr	r3, [pc, #144]	; (24002860 <HAL_EXTI_D3_EventInputConfig+0xc4>)
240027d0:	4403      	add	r3, r0
240027d2:	4618      	mov	r0, r3
240027d4:	ea01 0302 	and.w	r3, r1, r2
240027d8:	6003      	str	r3, [r0, #0]
240027da:	e013      	b.n	24002804 <HAL_EXTI_D3_EventInputConfig+0x68>
  }
  else
  {
    SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) +((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
240027dc:	68fb      	ldr	r3, [r7, #12]
240027de:	095b      	lsrs	r3, r3, #5
240027e0:	015a      	lsls	r2, r3, #5
240027e2:	4b1f      	ldr	r3, [pc, #124]	; (24002860 <HAL_EXTI_D3_EventInputConfig+0xc4>)
240027e4:	4413      	add	r3, r2
240027e6:	6819      	ldr	r1, [r3, #0]
240027e8:	68fb      	ldr	r3, [r7, #12]
240027ea:	f003 031f 	and.w	r3, r3, #31
240027ee:	2201      	movs	r2, #1
240027f0:	409a      	lsls	r2, r3
240027f2:	68fb      	ldr	r3, [r7, #12]
240027f4:	095b      	lsrs	r3, r3, #5
240027f6:	0158      	lsls	r0, r3, #5
240027f8:	4b19      	ldr	r3, [pc, #100]	; (24002860 <HAL_EXTI_D3_EventInputConfig+0xc4>)
240027fa:	4403      	add	r3, r0
240027fc:	4618      	mov	r0, r3
240027fe:	ea41 0302 	orr.w	r3, r1, r2
24002802:	6003      	str	r3, [r0, #0]
  }

  if(((EXTI_Line>>4)%2UL) == 0UL)
24002804:	68fb      	ldr	r3, [r7, #12]
24002806:	091b      	lsrs	r3, r3, #4
24002808:	f003 0301 	and.w	r3, r3, #1
2400280c:	2b00      	cmp	r3, #0
2400280e:	d106      	bne.n	2400281e <HAL_EXTI_D3_EventInputConfig+0x82>
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1L)) + ((EXTI_Line >> 5 ) * 0x20UL));
24002810:	68fb      	ldr	r3, [r7, #12]
24002812:	095b      	lsrs	r3, r3, #5
24002814:	015a      	lsls	r2, r3, #5
24002816:	4b13      	ldr	r3, [pc, #76]	; (24002864 <HAL_EXTI_D3_EventInputConfig+0xc8>)
24002818:	4413      	add	r3, r2
2400281a:	617b      	str	r3, [r7, #20]
2400281c:	e005      	b.n	2400282a <HAL_EXTI_D3_EventInputConfig+0x8e>
  }
  else
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1H)) + ((EXTI_Line >> 5 ) * 0x20UL));
2400281e:	68fb      	ldr	r3, [r7, #12]
24002820:	095b      	lsrs	r3, r3, #5
24002822:	015a      	lsls	r2, r3, #5
24002824:	4b10      	ldr	r3, [pc, #64]	; (24002868 <HAL_EXTI_D3_EventInputConfig+0xcc>)
24002826:	4413      	add	r3, r2
24002828:	617b      	str	r3, [r7, #20]
  }
  MODIFY_REG(*pRegv, (uint32_t)(3UL << ((EXTI_Line*2UL) & 0x1FUL)), (uint32_t)(EXTI_ClearSrc << ((EXTI_Line*2UL) & 0x1FUL)));
2400282a:	697b      	ldr	r3, [r7, #20]
2400282c:	681a      	ldr	r2, [r3, #0]
2400282e:	68fb      	ldr	r3, [r7, #12]
24002830:	005b      	lsls	r3, r3, #1
24002832:	f003 031e 	and.w	r3, r3, #30
24002836:	2103      	movs	r1, #3
24002838:	fa01 f303 	lsl.w	r3, r1, r3
2400283c:	43db      	mvns	r3, r3
2400283e:	401a      	ands	r2, r3
24002840:	68fb      	ldr	r3, [r7, #12]
24002842:	005b      	lsls	r3, r3, #1
24002844:	f003 031e 	and.w	r3, r3, #30
24002848:	6879      	ldr	r1, [r7, #4]
2400284a:	fa01 f303 	lsl.w	r3, r1, r3
2400284e:	431a      	orrs	r2, r3
24002850:	697b      	ldr	r3, [r7, #20]
24002852:	601a      	str	r2, [r3, #0]

}
24002854:	bf00      	nop
24002856:	371c      	adds	r7, #28
24002858:	46bd      	mov	sp, r7
2400285a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400285e:	4770      	bx	lr
24002860:	5800000c 	.word	0x5800000c
24002864:	58000010 	.word	0x58000010
24002868:	58000014 	.word	0x58000014

2400286c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
2400286c:	b480      	push	{r7}
2400286e:	b085      	sub	sp, #20
24002870:	af00      	add	r7, sp, #0
24002872:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
24002874:	687b      	ldr	r3, [r7, #4]
24002876:	f003 0307 	and.w	r3, r3, #7
2400287a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
2400287c:	4b0b      	ldr	r3, [pc, #44]	; (240028ac <__NVIC_SetPriorityGrouping+0x40>)
2400287e:	68db      	ldr	r3, [r3, #12]
24002880:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
24002882:	68ba      	ldr	r2, [r7, #8]
24002884:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
24002888:	4013      	ands	r3, r2
2400288a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
2400288c:	68fb      	ldr	r3, [r7, #12]
2400288e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
24002890:	68bb      	ldr	r3, [r7, #8]
24002892:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
24002894:	4b06      	ldr	r3, [pc, #24]	; (240028b0 <__NVIC_SetPriorityGrouping+0x44>)
24002896:	4313      	orrs	r3, r2
24002898:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
2400289a:	4a04      	ldr	r2, [pc, #16]	; (240028ac <__NVIC_SetPriorityGrouping+0x40>)
2400289c:	68bb      	ldr	r3, [r7, #8]
2400289e:	60d3      	str	r3, [r2, #12]
}
240028a0:	bf00      	nop
240028a2:	3714      	adds	r7, #20
240028a4:	46bd      	mov	sp, r7
240028a6:	f85d 7b04 	ldr.w	r7, [sp], #4
240028aa:	4770      	bx	lr
240028ac:	e000ed00 	.word	0xe000ed00
240028b0:	05fa0000 	.word	0x05fa0000

240028b4 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
240028b4:	b480      	push	{r7}
240028b6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
240028b8:	4b04      	ldr	r3, [pc, #16]	; (240028cc <__NVIC_GetPriorityGrouping+0x18>)
240028ba:	68db      	ldr	r3, [r3, #12]
240028bc:	0a1b      	lsrs	r3, r3, #8
240028be:	f003 0307 	and.w	r3, r3, #7
}
240028c2:	4618      	mov	r0, r3
240028c4:	46bd      	mov	sp, r7
240028c6:	f85d 7b04 	ldr.w	r7, [sp], #4
240028ca:	4770      	bx	lr
240028cc:	e000ed00 	.word	0xe000ed00

240028d0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
240028d0:	b480      	push	{r7}
240028d2:	b083      	sub	sp, #12
240028d4:	af00      	add	r7, sp, #0
240028d6:	4603      	mov	r3, r0
240028d8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
240028da:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240028de:	2b00      	cmp	r3, #0
240028e0:	db0b      	blt.n	240028fa <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
240028e2:	88fb      	ldrh	r3, [r7, #6]
240028e4:	f003 021f 	and.w	r2, r3, #31
240028e8:	4907      	ldr	r1, [pc, #28]	; (24002908 <__NVIC_EnableIRQ+0x38>)
240028ea:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240028ee:	095b      	lsrs	r3, r3, #5
240028f0:	2001      	movs	r0, #1
240028f2:	fa00 f202 	lsl.w	r2, r0, r2
240028f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
240028fa:	bf00      	nop
240028fc:	370c      	adds	r7, #12
240028fe:	46bd      	mov	sp, r7
24002900:	f85d 7b04 	ldr.w	r7, [sp], #4
24002904:	4770      	bx	lr
24002906:	bf00      	nop
24002908:	e000e100 	.word	0xe000e100

2400290c <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
2400290c:	b480      	push	{r7}
2400290e:	b083      	sub	sp, #12
24002910:	af00      	add	r7, sp, #0
24002912:	4603      	mov	r3, r0
24002914:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002916:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400291a:	2b00      	cmp	r3, #0
2400291c:	db12      	blt.n	24002944 <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
2400291e:	88fb      	ldrh	r3, [r7, #6]
24002920:	f003 021f 	and.w	r2, r3, #31
24002924:	490a      	ldr	r1, [pc, #40]	; (24002950 <__NVIC_DisableIRQ+0x44>)
24002926:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400292a:	095b      	lsrs	r3, r3, #5
2400292c:	2001      	movs	r0, #1
2400292e:	fa00 f202 	lsl.w	r2, r0, r2
24002932:	3320      	adds	r3, #32
24002934:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
24002938:	f3bf 8f4f 	dsb	sy
}
2400293c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
2400293e:	f3bf 8f6f 	isb	sy
}
24002942:	bf00      	nop
    __DSB();
    __ISB();
  }
}
24002944:	bf00      	nop
24002946:	370c      	adds	r7, #12
24002948:	46bd      	mov	sp, r7
2400294a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400294e:	4770      	bx	lr
24002950:	e000e100 	.word	0xe000e100

24002954 <__NVIC_GetPendingIRQ>:
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
24002954:	b480      	push	{r7}
24002956:	b083      	sub	sp, #12
24002958:	af00      	add	r7, sp, #0
2400295a:	4603      	mov	r3, r0
2400295c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400295e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002962:	2b00      	cmp	r3, #0
24002964:	db0e      	blt.n	24002984 <__NVIC_GetPendingIRQ+0x30>
  {
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
24002966:	4a0b      	ldr	r2, [pc, #44]	; (24002994 <__NVIC_GetPendingIRQ+0x40>)
24002968:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400296c:	095b      	lsrs	r3, r3, #5
2400296e:	3340      	adds	r3, #64	; 0x40
24002970:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24002974:	88fb      	ldrh	r3, [r7, #6]
24002976:	f003 031f 	and.w	r3, r3, #31
2400297a:	fa22 f303 	lsr.w	r3, r2, r3
2400297e:	f003 0301 	and.w	r3, r3, #1
24002982:	e000      	b.n	24002986 <__NVIC_GetPendingIRQ+0x32>
  }
  else
  {
    return(0U);
24002984:	2300      	movs	r3, #0
  }
}
24002986:	4618      	mov	r0, r3
24002988:	370c      	adds	r7, #12
2400298a:	46bd      	mov	sp, r7
2400298c:	f85d 7b04 	ldr.w	r7, [sp], #4
24002990:	4770      	bx	lr
24002992:	bf00      	nop
24002994:	e000e100 	.word	0xe000e100

24002998 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
24002998:	b480      	push	{r7}
2400299a:	b083      	sub	sp, #12
2400299c:	af00      	add	r7, sp, #0
2400299e:	4603      	mov	r3, r0
240029a0:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
240029a2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240029a6:	2b00      	cmp	r3, #0
240029a8:	db0c      	blt.n	240029c4 <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
240029aa:	88fb      	ldrh	r3, [r7, #6]
240029ac:	f003 021f 	and.w	r2, r3, #31
240029b0:	4907      	ldr	r1, [pc, #28]	; (240029d0 <__NVIC_SetPendingIRQ+0x38>)
240029b2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240029b6:	095b      	lsrs	r3, r3, #5
240029b8:	2001      	movs	r0, #1
240029ba:	fa00 f202 	lsl.w	r2, r0, r2
240029be:	3340      	adds	r3, #64	; 0x40
240029c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
240029c4:	bf00      	nop
240029c6:	370c      	adds	r7, #12
240029c8:	46bd      	mov	sp, r7
240029ca:	f85d 7b04 	ldr.w	r7, [sp], #4
240029ce:	4770      	bx	lr
240029d0:	e000e100 	.word	0xe000e100

240029d4 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
240029d4:	b480      	push	{r7}
240029d6:	b083      	sub	sp, #12
240029d8:	af00      	add	r7, sp, #0
240029da:	4603      	mov	r3, r0
240029dc:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
240029de:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240029e2:	2b00      	cmp	r3, #0
240029e4:	db0c      	blt.n	24002a00 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
240029e6:	88fb      	ldrh	r3, [r7, #6]
240029e8:	f003 021f 	and.w	r2, r3, #31
240029ec:	4907      	ldr	r1, [pc, #28]	; (24002a0c <__NVIC_ClearPendingIRQ+0x38>)
240029ee:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240029f2:	095b      	lsrs	r3, r3, #5
240029f4:	2001      	movs	r0, #1
240029f6:	fa00 f202 	lsl.w	r2, r0, r2
240029fa:	3360      	adds	r3, #96	; 0x60
240029fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
24002a00:	bf00      	nop
24002a02:	370c      	adds	r7, #12
24002a04:	46bd      	mov	sp, r7
24002a06:	f85d 7b04 	ldr.w	r7, [sp], #4
24002a0a:	4770      	bx	lr
24002a0c:	e000e100 	.word	0xe000e100

24002a10 <__NVIC_GetActive>:
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
{
24002a10:	b480      	push	{r7}
24002a12:	b083      	sub	sp, #12
24002a14:	af00      	add	r7, sp, #0
24002a16:	4603      	mov	r3, r0
24002a18:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002a1a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002a1e:	2b00      	cmp	r3, #0
24002a20:	db0e      	blt.n	24002a40 <__NVIC_GetActive+0x30>
  {
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
24002a22:	4a0b      	ldr	r2, [pc, #44]	; (24002a50 <__NVIC_GetActive+0x40>)
24002a24:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002a28:	095b      	lsrs	r3, r3, #5
24002a2a:	3380      	adds	r3, #128	; 0x80
24002a2c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24002a30:	88fb      	ldrh	r3, [r7, #6]
24002a32:	f003 031f 	and.w	r3, r3, #31
24002a36:	fa22 f303 	lsr.w	r3, r2, r3
24002a3a:	f003 0301 	and.w	r3, r3, #1
24002a3e:	e000      	b.n	24002a42 <__NVIC_GetActive+0x32>
  }
  else
  {
    return(0U);
24002a40:	2300      	movs	r3, #0
  }
}
24002a42:	4618      	mov	r0, r3
24002a44:	370c      	adds	r7, #12
24002a46:	46bd      	mov	sp, r7
24002a48:	f85d 7b04 	ldr.w	r7, [sp], #4
24002a4c:	4770      	bx	lr
24002a4e:	bf00      	nop
24002a50:	e000e100 	.word	0xe000e100

24002a54 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
24002a54:	b480      	push	{r7}
24002a56:	b083      	sub	sp, #12
24002a58:	af00      	add	r7, sp, #0
24002a5a:	4603      	mov	r3, r0
24002a5c:	6039      	str	r1, [r7, #0]
24002a5e:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002a60:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002a64:	2b00      	cmp	r3, #0
24002a66:	db0a      	blt.n	24002a7e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24002a68:	683b      	ldr	r3, [r7, #0]
24002a6a:	b2da      	uxtb	r2, r3
24002a6c:	490c      	ldr	r1, [pc, #48]	; (24002aa0 <__NVIC_SetPriority+0x4c>)
24002a6e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002a72:	0112      	lsls	r2, r2, #4
24002a74:	b2d2      	uxtb	r2, r2
24002a76:	440b      	add	r3, r1
24002a78:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
24002a7c:	e00a      	b.n	24002a94 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24002a7e:	683b      	ldr	r3, [r7, #0]
24002a80:	b2da      	uxtb	r2, r3
24002a82:	4908      	ldr	r1, [pc, #32]	; (24002aa4 <__NVIC_SetPriority+0x50>)
24002a84:	88fb      	ldrh	r3, [r7, #6]
24002a86:	f003 030f 	and.w	r3, r3, #15
24002a8a:	3b04      	subs	r3, #4
24002a8c:	0112      	lsls	r2, r2, #4
24002a8e:	b2d2      	uxtb	r2, r2
24002a90:	440b      	add	r3, r1
24002a92:	761a      	strb	r2, [r3, #24]
}
24002a94:	bf00      	nop
24002a96:	370c      	adds	r7, #12
24002a98:	46bd      	mov	sp, r7
24002a9a:	f85d 7b04 	ldr.w	r7, [sp], #4
24002a9e:	4770      	bx	lr
24002aa0:	e000e100 	.word	0xe000e100
24002aa4:	e000ed00 	.word	0xe000ed00

24002aa8 <__NVIC_GetPriority>:
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{
24002aa8:	b480      	push	{r7}
24002aaa:	b083      	sub	sp, #12
24002aac:	af00      	add	r7, sp, #0
24002aae:	4603      	mov	r3, r0
24002ab0:	80fb      	strh	r3, [r7, #6]

  if ((int32_t)(IRQn) >= 0)
24002ab2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002ab6:	2b00      	cmp	r3, #0
24002ab8:	db09      	blt.n	24002ace <__NVIC_GetPriority+0x26>
  {
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
24002aba:	4a0d      	ldr	r2, [pc, #52]	; (24002af0 <__NVIC_GetPriority+0x48>)
24002abc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002ac0:	4413      	add	r3, r2
24002ac2:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
24002ac6:	b2db      	uxtb	r3, r3
24002ac8:	091b      	lsrs	r3, r3, #4
24002aca:	b2db      	uxtb	r3, r3
24002acc:	e009      	b.n	24002ae2 <__NVIC_GetPriority+0x3a>
  }
  else
  {
    return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
24002ace:	4a09      	ldr	r2, [pc, #36]	; (24002af4 <__NVIC_GetPriority+0x4c>)
24002ad0:	88fb      	ldrh	r3, [r7, #6]
24002ad2:	f003 030f 	and.w	r3, r3, #15
24002ad6:	3b04      	subs	r3, #4
24002ad8:	4413      	add	r3, r2
24002ada:	7e1b      	ldrb	r3, [r3, #24]
24002adc:	b2db      	uxtb	r3, r3
24002ade:	091b      	lsrs	r3, r3, #4
24002ae0:	b2db      	uxtb	r3, r3
  }
}
24002ae2:	4618      	mov	r0, r3
24002ae4:	370c      	adds	r7, #12
24002ae6:	46bd      	mov	sp, r7
24002ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
24002aec:	4770      	bx	lr
24002aee:	bf00      	nop
24002af0:	e000e100 	.word	0xe000e100
24002af4:	e000ed00 	.word	0xe000ed00

24002af8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
24002af8:	b480      	push	{r7}
24002afa:	b089      	sub	sp, #36	; 0x24
24002afc:	af00      	add	r7, sp, #0
24002afe:	60f8      	str	r0, [r7, #12]
24002b00:	60b9      	str	r1, [r7, #8]
24002b02:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
24002b04:	68fb      	ldr	r3, [r7, #12]
24002b06:	f003 0307 	and.w	r3, r3, #7
24002b0a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24002b0c:	69fb      	ldr	r3, [r7, #28]
24002b0e:	f1c3 0307 	rsb	r3, r3, #7
24002b12:	2b04      	cmp	r3, #4
24002b14:	bf28      	it	cs
24002b16:	2304      	movcs	r3, #4
24002b18:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24002b1a:	69fb      	ldr	r3, [r7, #28]
24002b1c:	3304      	adds	r3, #4
24002b1e:	2b06      	cmp	r3, #6
24002b20:	d902      	bls.n	24002b28 <NVIC_EncodePriority+0x30>
24002b22:	69fb      	ldr	r3, [r7, #28]
24002b24:	3b03      	subs	r3, #3
24002b26:	e000      	b.n	24002b2a <NVIC_EncodePriority+0x32>
24002b28:	2300      	movs	r3, #0
24002b2a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24002b2c:	f04f 32ff 	mov.w	r2, #4294967295
24002b30:	69bb      	ldr	r3, [r7, #24]
24002b32:	fa02 f303 	lsl.w	r3, r2, r3
24002b36:	43da      	mvns	r2, r3
24002b38:	68bb      	ldr	r3, [r7, #8]
24002b3a:	401a      	ands	r2, r3
24002b3c:	697b      	ldr	r3, [r7, #20]
24002b3e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
24002b40:	f04f 31ff 	mov.w	r1, #4294967295
24002b44:	697b      	ldr	r3, [r7, #20]
24002b46:	fa01 f303 	lsl.w	r3, r1, r3
24002b4a:	43d9      	mvns	r1, r3
24002b4c:	687b      	ldr	r3, [r7, #4]
24002b4e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24002b50:	4313      	orrs	r3, r2
         );
}
24002b52:	4618      	mov	r0, r3
24002b54:	3724      	adds	r7, #36	; 0x24
24002b56:	46bd      	mov	sp, r7
24002b58:	f85d 7b04 	ldr.w	r7, [sp], #4
24002b5c:	4770      	bx	lr

24002b5e <NVIC_DecodePriority>:
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
24002b5e:	b480      	push	{r7}
24002b60:	b089      	sub	sp, #36	; 0x24
24002b62:	af00      	add	r7, sp, #0
24002b64:	60f8      	str	r0, [r7, #12]
24002b66:	60b9      	str	r1, [r7, #8]
24002b68:	607a      	str	r2, [r7, #4]
24002b6a:	603b      	str	r3, [r7, #0]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
24002b6c:	68bb      	ldr	r3, [r7, #8]
24002b6e:	f003 0307 	and.w	r3, r3, #7
24002b72:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24002b74:	69fb      	ldr	r3, [r7, #28]
24002b76:	f1c3 0307 	rsb	r3, r3, #7
24002b7a:	2b04      	cmp	r3, #4
24002b7c:	bf28      	it	cs
24002b7e:	2304      	movcs	r3, #4
24002b80:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24002b82:	69fb      	ldr	r3, [r7, #28]
24002b84:	3304      	adds	r3, #4
24002b86:	2b06      	cmp	r3, #6
24002b88:	d902      	bls.n	24002b90 <NVIC_DecodePriority+0x32>
24002b8a:	69fb      	ldr	r3, [r7, #28]
24002b8c:	3b03      	subs	r3, #3
24002b8e:	e000      	b.n	24002b92 <NVIC_DecodePriority+0x34>
24002b90:	2300      	movs	r3, #0
24002b92:	617b      	str	r3, [r7, #20]

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
24002b94:	68fa      	ldr	r2, [r7, #12]
24002b96:	697b      	ldr	r3, [r7, #20]
24002b98:	40da      	lsrs	r2, r3
24002b9a:	f04f 31ff 	mov.w	r1, #4294967295
24002b9e:	69bb      	ldr	r3, [r7, #24]
24002ba0:	fa01 f303 	lsl.w	r3, r1, r3
24002ba4:	43db      	mvns	r3, r3
24002ba6:	401a      	ands	r2, r3
24002ba8:	687b      	ldr	r3, [r7, #4]
24002baa:	601a      	str	r2, [r3, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
24002bac:	f04f 32ff 	mov.w	r2, #4294967295
24002bb0:	697b      	ldr	r3, [r7, #20]
24002bb2:	fa02 f303 	lsl.w	r3, r2, r3
24002bb6:	43da      	mvns	r2, r3
24002bb8:	68fb      	ldr	r3, [r7, #12]
24002bba:	401a      	ands	r2, r3
24002bbc:	683b      	ldr	r3, [r7, #0]
24002bbe:	601a      	str	r2, [r3, #0]
}
24002bc0:	bf00      	nop
24002bc2:	3724      	adds	r7, #36	; 0x24
24002bc4:	46bd      	mov	sp, r7
24002bc6:	f85d 7b04 	ldr.w	r7, [sp], #4
24002bca:	4770      	bx	lr

24002bcc <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
24002bcc:	b480      	push	{r7}
24002bce:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
24002bd0:	f3bf 8f4f 	dsb	sy
}
24002bd4:	bf00      	nop
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
24002bd6:	4b06      	ldr	r3, [pc, #24]	; (24002bf0 <__NVIC_SystemReset+0x24>)
24002bd8:	68db      	ldr	r3, [r3, #12]
24002bda:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
24002bde:	4904      	ldr	r1, [pc, #16]	; (24002bf0 <__NVIC_SystemReset+0x24>)
24002be0:	4b04      	ldr	r3, [pc, #16]	; (24002bf4 <__NVIC_SystemReset+0x28>)
24002be2:	4313      	orrs	r3, r2
24002be4:	60cb      	str	r3, [r1, #12]
  __ASM volatile ("dsb 0xF":::"memory");
24002be6:	f3bf 8f4f 	dsb	sy
}
24002bea:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
24002bec:	bf00      	nop
24002bee:	e7fd      	b.n	24002bec <__NVIC_SystemReset+0x20>
24002bf0:	e000ed00 	.word	0xe000ed00
24002bf4:	05fa0004 	.word	0x05fa0004

24002bf8 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
24002bf8:	b580      	push	{r7, lr}
24002bfa:	b082      	sub	sp, #8
24002bfc:	af00      	add	r7, sp, #0
24002bfe:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
24002c00:	687b      	ldr	r3, [r7, #4]
24002c02:	3b01      	subs	r3, #1
24002c04:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
24002c08:	d301      	bcc.n	24002c0e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
24002c0a:	2301      	movs	r3, #1
24002c0c:	e00f      	b.n	24002c2e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
24002c0e:	4a0a      	ldr	r2, [pc, #40]	; (24002c38 <SysTick_Config+0x40>)
24002c10:	687b      	ldr	r3, [r7, #4]
24002c12:	3b01      	subs	r3, #1
24002c14:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
24002c16:	210f      	movs	r1, #15
24002c18:	f04f 30ff 	mov.w	r0, #4294967295
24002c1c:	f7ff ff1a 	bl	24002a54 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
24002c20:	4b05      	ldr	r3, [pc, #20]	; (24002c38 <SysTick_Config+0x40>)
24002c22:	2200      	movs	r2, #0
24002c24:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
24002c26:	4b04      	ldr	r3, [pc, #16]	; (24002c38 <SysTick_Config+0x40>)
24002c28:	2207      	movs	r2, #7
24002c2a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
24002c2c:	2300      	movs	r3, #0
}
24002c2e:	4618      	mov	r0, r3
24002c30:	3708      	adds	r7, #8
24002c32:	46bd      	mov	sp, r7
24002c34:	bd80      	pop	{r7, pc}
24002c36:	bf00      	nop
24002c38:	e000e010 	.word	0xe000e010

24002c3c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
24002c3c:	b580      	push	{r7, lr}
24002c3e:	b082      	sub	sp, #8
24002c40:	af00      	add	r7, sp, #0
24002c42:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
24002c44:	6878      	ldr	r0, [r7, #4]
24002c46:	f7ff fe11 	bl	2400286c <__NVIC_SetPriorityGrouping>
}
24002c4a:	bf00      	nop
24002c4c:	3708      	adds	r7, #8
24002c4e:	46bd      	mov	sp, r7
24002c50:	bd80      	pop	{r7, pc}

24002c52 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
24002c52:	b580      	push	{r7, lr}
24002c54:	b086      	sub	sp, #24
24002c56:	af00      	add	r7, sp, #0
24002c58:	4603      	mov	r3, r0
24002c5a:	60b9      	str	r1, [r7, #8]
24002c5c:	607a      	str	r2, [r7, #4]
24002c5e:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
24002c60:	f7ff fe28 	bl	240028b4 <__NVIC_GetPriorityGrouping>
24002c64:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
24002c66:	687a      	ldr	r2, [r7, #4]
24002c68:	68b9      	ldr	r1, [r7, #8]
24002c6a:	6978      	ldr	r0, [r7, #20]
24002c6c:	f7ff ff44 	bl	24002af8 <NVIC_EncodePriority>
24002c70:	4602      	mov	r2, r0
24002c72:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
24002c76:	4611      	mov	r1, r2
24002c78:	4618      	mov	r0, r3
24002c7a:	f7ff feeb 	bl	24002a54 <__NVIC_SetPriority>
}
24002c7e:	bf00      	nop
24002c80:	3718      	adds	r7, #24
24002c82:	46bd      	mov	sp, r7
24002c84:	bd80      	pop	{r7, pc}

24002c86 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
24002c86:	b580      	push	{r7, lr}
24002c88:	b082      	sub	sp, #8
24002c8a:	af00      	add	r7, sp, #0
24002c8c:	4603      	mov	r3, r0
24002c8e:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
24002c90:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002c94:	4618      	mov	r0, r3
24002c96:	f7ff fe1b 	bl	240028d0 <__NVIC_EnableIRQ>
}
24002c9a:	bf00      	nop
24002c9c:	3708      	adds	r7, #8
24002c9e:	46bd      	mov	sp, r7
24002ca0:	bd80      	pop	{r7, pc}

24002ca2 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
24002ca2:	b580      	push	{r7, lr}
24002ca4:	b082      	sub	sp, #8
24002ca6:	af00      	add	r7, sp, #0
24002ca8:	4603      	mov	r3, r0
24002caa:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
24002cac:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002cb0:	4618      	mov	r0, r3
24002cb2:	f7ff fe2b 	bl	2400290c <__NVIC_DisableIRQ>
}
24002cb6:	bf00      	nop
24002cb8:	3708      	adds	r7, #8
24002cba:	46bd      	mov	sp, r7
24002cbc:	bd80      	pop	{r7, pc}

24002cbe <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
24002cbe:	b580      	push	{r7, lr}
24002cc0:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
24002cc2:	f7ff ff83 	bl	24002bcc <__NVIC_SystemReset>

24002cc6 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
24002cc6:	b580      	push	{r7, lr}
24002cc8:	b082      	sub	sp, #8
24002cca:	af00      	add	r7, sp, #0
24002ccc:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
24002cce:	6878      	ldr	r0, [r7, #4]
24002cd0:	f7ff ff92 	bl	24002bf8 <SysTick_Config>
24002cd4:	4603      	mov	r3, r0
}
24002cd6:	4618      	mov	r0, r3
24002cd8:	3708      	adds	r7, #8
24002cda:	46bd      	mov	sp, r7
24002cdc:	bd80      	pop	{r7, pc}
	...

24002ce0 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
24002ce0:	b480      	push	{r7}
24002ce2:	af00      	add	r7, sp, #0
  __ASM volatile ("dmb 0xF":::"memory");
24002ce4:	f3bf 8f5f 	dmb	sy
}
24002ce8:	bf00      	nop
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
24002cea:	4b07      	ldr	r3, [pc, #28]	; (24002d08 <HAL_MPU_Disable+0x28>)
24002cec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24002cee:	4a06      	ldr	r2, [pc, #24]	; (24002d08 <HAL_MPU_Disable+0x28>)
24002cf0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24002cf4:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
24002cf6:	4b05      	ldr	r3, [pc, #20]	; (24002d0c <HAL_MPU_Disable+0x2c>)
24002cf8:	2200      	movs	r2, #0
24002cfa:	605a      	str	r2, [r3, #4]
}
24002cfc:	bf00      	nop
24002cfe:	46bd      	mov	sp, r7
24002d00:	f85d 7b04 	ldr.w	r7, [sp], #4
24002d04:	4770      	bx	lr
24002d06:	bf00      	nop
24002d08:	e000ed00 	.word	0xe000ed00
24002d0c:	e000ed90 	.word	0xe000ed90

24002d10 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
24002d10:	b480      	push	{r7}
24002d12:	b083      	sub	sp, #12
24002d14:	af00      	add	r7, sp, #0
24002d16:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
24002d18:	4a0b      	ldr	r2, [pc, #44]	; (24002d48 <HAL_MPU_Enable+0x38>)
24002d1a:	687b      	ldr	r3, [r7, #4]
24002d1c:	f043 0301 	orr.w	r3, r3, #1
24002d20:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
24002d22:	4b0a      	ldr	r3, [pc, #40]	; (24002d4c <HAL_MPU_Enable+0x3c>)
24002d24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24002d26:	4a09      	ldr	r2, [pc, #36]	; (24002d4c <HAL_MPU_Enable+0x3c>)
24002d28:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24002d2c:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
24002d2e:	f3bf 8f4f 	dsb	sy
}
24002d32:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
24002d34:	f3bf 8f6f 	isb	sy
}
24002d38:	bf00      	nop

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
24002d3a:	bf00      	nop
24002d3c:	370c      	adds	r7, #12
24002d3e:	46bd      	mov	sp, r7
24002d40:	f85d 7b04 	ldr.w	r7, [sp], #4
24002d44:	4770      	bx	lr
24002d46:	bf00      	nop
24002d48:	e000ed90 	.word	0xe000ed90
24002d4c:	e000ed00 	.word	0xe000ed00

24002d50 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
24002d50:	b480      	push	{r7}
24002d52:	b083      	sub	sp, #12
24002d54:	af00      	add	r7, sp, #0
24002d56:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
24002d58:	687b      	ldr	r3, [r7, #4]
24002d5a:	785a      	ldrb	r2, [r3, #1]
24002d5c:	4b1d      	ldr	r3, [pc, #116]	; (24002dd4 <HAL_MPU_ConfigRegion+0x84>)
24002d5e:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
24002d60:	687b      	ldr	r3, [r7, #4]
24002d62:	781b      	ldrb	r3, [r3, #0]
24002d64:	2b00      	cmp	r3, #0
24002d66:	d029      	beq.n	24002dbc <HAL_MPU_ConfigRegion+0x6c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
24002d68:	4a1a      	ldr	r2, [pc, #104]	; (24002dd4 <HAL_MPU_ConfigRegion+0x84>)
24002d6a:	687b      	ldr	r3, [r7, #4]
24002d6c:	685b      	ldr	r3, [r3, #4]
24002d6e:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24002d70:	687b      	ldr	r3, [r7, #4]
24002d72:	7b1b      	ldrb	r3, [r3, #12]
24002d74:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
24002d76:	687b      	ldr	r3, [r7, #4]
24002d78:	7adb      	ldrb	r3, [r3, #11]
24002d7a:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24002d7c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
24002d7e:	687b      	ldr	r3, [r7, #4]
24002d80:	7a9b      	ldrb	r3, [r3, #10]
24002d82:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
24002d84:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
24002d86:	687b      	ldr	r3, [r7, #4]
24002d88:	7b5b      	ldrb	r3, [r3, #13]
24002d8a:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
24002d8c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
24002d8e:	687b      	ldr	r3, [r7, #4]
24002d90:	7b9b      	ldrb	r3, [r3, #14]
24002d92:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
24002d94:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
24002d96:	687b      	ldr	r3, [r7, #4]
24002d98:	7bdb      	ldrb	r3, [r3, #15]
24002d9a:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
24002d9c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
24002d9e:	687b      	ldr	r3, [r7, #4]
24002da0:	7a5b      	ldrb	r3, [r3, #9]
24002da2:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
24002da4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24002da6:	687b      	ldr	r3, [r7, #4]
24002da8:	7a1b      	ldrb	r3, [r3, #8]
24002daa:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
24002dac:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
24002dae:	687a      	ldr	r2, [r7, #4]
24002db0:	7812      	ldrb	r2, [r2, #0]
24002db2:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24002db4:	4a07      	ldr	r2, [pc, #28]	; (24002dd4 <HAL_MPU_ConfigRegion+0x84>)
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24002db6:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24002db8:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
24002dba:	e005      	b.n	24002dc8 <HAL_MPU_ConfigRegion+0x78>
    MPU->RBAR = 0x00;
24002dbc:	4b05      	ldr	r3, [pc, #20]	; (24002dd4 <HAL_MPU_ConfigRegion+0x84>)
24002dbe:	2200      	movs	r2, #0
24002dc0:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
24002dc2:	4b04      	ldr	r3, [pc, #16]	; (24002dd4 <HAL_MPU_ConfigRegion+0x84>)
24002dc4:	2200      	movs	r2, #0
24002dc6:	611a      	str	r2, [r3, #16]
}
24002dc8:	bf00      	nop
24002dca:	370c      	adds	r7, #12
24002dcc:	46bd      	mov	sp, r7
24002dce:	f85d 7b04 	ldr.w	r7, [sp], #4
24002dd2:	4770      	bx	lr
24002dd4:	e000ed90 	.word	0xe000ed90

24002dd8 <HAL_NVIC_GetPriorityGrouping>:
/**
  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
24002dd8:	b580      	push	{r7, lr}
24002dda:	af00      	add	r7, sp, #0
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
24002ddc:	f7ff fd6a 	bl	240028b4 <__NVIC_GetPriorityGrouping>
24002de0:	4603      	mov	r3, r0
}
24002de2:	4618      	mov	r0, r3
24002de4:	bd80      	pop	{r7, pc}

24002de6 <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
24002de6:	b580      	push	{r7, lr}
24002de8:	b084      	sub	sp, #16
24002dea:	af00      	add	r7, sp, #0
24002dec:	60b9      	str	r1, [r7, #8]
24002dee:	607a      	str	r2, [r7, #4]
24002df0:	603b      	str	r3, [r7, #0]
24002df2:	4603      	mov	r3, r0
24002df4:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
24002df6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
24002dfa:	4618      	mov	r0, r3
24002dfc:	f7ff fe54 	bl	24002aa8 <__NVIC_GetPriority>
24002e00:	683b      	ldr	r3, [r7, #0]
24002e02:	687a      	ldr	r2, [r7, #4]
24002e04:	68b9      	ldr	r1, [r7, #8]
24002e06:	f7ff feaa 	bl	24002b5e <NVIC_DecodePriority>
}
24002e0a:	bf00      	nop
24002e0c:	3710      	adds	r7, #16
24002e0e:	46bd      	mov	sp, r7
24002e10:	bd80      	pop	{r7, pc}

24002e12 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
24002e12:	b580      	push	{r7, lr}
24002e14:	b082      	sub	sp, #8
24002e16:	af00      	add	r7, sp, #0
24002e18:	4603      	mov	r3, r0
24002e1a:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
24002e1c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002e20:	4618      	mov	r0, r3
24002e22:	f7ff fdb9 	bl	24002998 <__NVIC_SetPendingIRQ>
}
24002e26:	bf00      	nop
24002e28:	3708      	adds	r7, #8
24002e2a:	46bd      	mov	sp, r7
24002e2c:	bd80      	pop	{r7, pc}

24002e2e <HAL_NVIC_GetPendingIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
24002e2e:	b580      	push	{r7, lr}
24002e30:	b082      	sub	sp, #8
24002e32:	af00      	add	r7, sp, #0
24002e34:	4603      	mov	r3, r0
24002e36:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
24002e38:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002e3c:	4618      	mov	r0, r3
24002e3e:	f7ff fd89 	bl	24002954 <__NVIC_GetPendingIRQ>
24002e42:	4603      	mov	r3, r0
}
24002e44:	4618      	mov	r0, r3
24002e46:	3708      	adds	r7, #8
24002e48:	46bd      	mov	sp, r7
24002e4a:	bd80      	pop	{r7, pc}

24002e4c <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
24002e4c:	b580      	push	{r7, lr}
24002e4e:	b082      	sub	sp, #8
24002e50:	af00      	add	r7, sp, #0
24002e52:	4603      	mov	r3, r0
24002e54:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
24002e56:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002e5a:	4618      	mov	r0, r3
24002e5c:	f7ff fdba 	bl	240029d4 <__NVIC_ClearPendingIRQ>
}
24002e60:	bf00      	nop
24002e62:	3708      	adds	r7, #8
24002e64:	46bd      	mov	sp, r7
24002e66:	bd80      	pop	{r7, pc}

24002e68 <HAL_NVIC_GetActive>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
24002e68:	b580      	push	{r7, lr}
24002e6a:	b082      	sub	sp, #8
24002e6c:	af00      	add	r7, sp, #0
24002e6e:	4603      	mov	r3, r0
24002e70:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
24002e72:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002e76:	4618      	mov	r0, r3
24002e78:	f7ff fdca 	bl	24002a10 <__NVIC_GetActive>
24002e7c:	4603      	mov	r3, r0
}
24002e7e:	4618      	mov	r0, r3
24002e80:	3708      	adds	r7, #8
24002e82:	46bd      	mov	sp, r7
24002e84:	bd80      	pop	{r7, pc}
	...

24002e88 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
24002e88:	b480      	push	{r7}
24002e8a:	b083      	sub	sp, #12
24002e8c:	af00      	add	r7, sp, #0
24002e8e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
24002e90:	687b      	ldr	r3, [r7, #4]
24002e92:	2b04      	cmp	r3, #4
24002e94:	d106      	bne.n	24002ea4 <HAL_SYSTICK_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
24002e96:	4b09      	ldr	r3, [pc, #36]	; (24002ebc <HAL_SYSTICK_CLKSourceConfig+0x34>)
24002e98:	681b      	ldr	r3, [r3, #0]
24002e9a:	4a08      	ldr	r2, [pc, #32]	; (24002ebc <HAL_SYSTICK_CLKSourceConfig+0x34>)
24002e9c:	f043 0304 	orr.w	r3, r3, #4
24002ea0:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
24002ea2:	e005      	b.n	24002eb0 <HAL_SYSTICK_CLKSourceConfig+0x28>
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
24002ea4:	4b05      	ldr	r3, [pc, #20]	; (24002ebc <HAL_SYSTICK_CLKSourceConfig+0x34>)
24002ea6:	681b      	ldr	r3, [r3, #0]
24002ea8:	4a04      	ldr	r2, [pc, #16]	; (24002ebc <HAL_SYSTICK_CLKSourceConfig+0x34>)
24002eaa:	f023 0304 	bic.w	r3, r3, #4
24002eae:	6013      	str	r3, [r2, #0]
}
24002eb0:	bf00      	nop
24002eb2:	370c      	adds	r7, #12
24002eb4:	46bd      	mov	sp, r7
24002eb6:	f85d 7b04 	ldr.w	r7, [sp], #4
24002eba:	4770      	bx	lr
24002ebc:	e000e010 	.word	0xe000e010

24002ec0 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
24002ec0:	b580      	push	{r7, lr}
24002ec2:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
24002ec4:	f000 f802 	bl	24002ecc <HAL_SYSTICK_Callback>
}
24002ec8:	bf00      	nop
24002eca:	bd80      	pop	{r7, pc}

24002ecc <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
24002ecc:	b480      	push	{r7}
24002ece:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
24002ed0:	bf00      	nop
24002ed2:	46bd      	mov	sp, r7
24002ed4:	f85d 7b04 	ldr.w	r7, [sp], #4
24002ed8:	4770      	bx	lr

24002eda <HAL_GetCurrentCPUID>:
/**
* @brief  Returns the current CPU ID.
* @retval CPU identifier
*/
uint32_t HAL_GetCurrentCPUID(void)
{
24002eda:	b480      	push	{r7}
24002edc:	af00      	add	r7, sp, #0
  return  CM7_CPUID;
24002ede:	2303      	movs	r3, #3
}
24002ee0:	4618      	mov	r0, r3
24002ee2:	46bd      	mov	sp, r7
24002ee4:	f85d 7b04 	ldr.w	r7, [sp], #4
24002ee8:	4770      	bx	lr
	...

24002eec <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
24002eec:	b580      	push	{r7, lr}
24002eee:	b086      	sub	sp, #24
24002ef0:	af00      	add	r7, sp, #0
24002ef2:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
24002ef4:	f7ff f892 	bl	2400201c <HAL_GetTick>
24002ef8:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24002efa:	687b      	ldr	r3, [r7, #4]
24002efc:	2b00      	cmp	r3, #0
24002efe:	d101      	bne.n	24002f04 <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
24002f00:	2301      	movs	r3, #1
24002f02:	e316      	b.n	24003532 <HAL_DMA_Init+0x646>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002f04:	687b      	ldr	r3, [r7, #4]
24002f06:	681b      	ldr	r3, [r3, #0]
24002f08:	4a66      	ldr	r2, [pc, #408]	; (240030a4 <HAL_DMA_Init+0x1b8>)
24002f0a:	4293      	cmp	r3, r2
24002f0c:	d04a      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f0e:	687b      	ldr	r3, [r7, #4]
24002f10:	681b      	ldr	r3, [r3, #0]
24002f12:	4a65      	ldr	r2, [pc, #404]	; (240030a8 <HAL_DMA_Init+0x1bc>)
24002f14:	4293      	cmp	r3, r2
24002f16:	d045      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f18:	687b      	ldr	r3, [r7, #4]
24002f1a:	681b      	ldr	r3, [r3, #0]
24002f1c:	4a63      	ldr	r2, [pc, #396]	; (240030ac <HAL_DMA_Init+0x1c0>)
24002f1e:	4293      	cmp	r3, r2
24002f20:	d040      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f22:	687b      	ldr	r3, [r7, #4]
24002f24:	681b      	ldr	r3, [r3, #0]
24002f26:	4a62      	ldr	r2, [pc, #392]	; (240030b0 <HAL_DMA_Init+0x1c4>)
24002f28:	4293      	cmp	r3, r2
24002f2a:	d03b      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f2c:	687b      	ldr	r3, [r7, #4]
24002f2e:	681b      	ldr	r3, [r3, #0]
24002f30:	4a60      	ldr	r2, [pc, #384]	; (240030b4 <HAL_DMA_Init+0x1c8>)
24002f32:	4293      	cmp	r3, r2
24002f34:	d036      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f36:	687b      	ldr	r3, [r7, #4]
24002f38:	681b      	ldr	r3, [r3, #0]
24002f3a:	4a5f      	ldr	r2, [pc, #380]	; (240030b8 <HAL_DMA_Init+0x1cc>)
24002f3c:	4293      	cmp	r3, r2
24002f3e:	d031      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f40:	687b      	ldr	r3, [r7, #4]
24002f42:	681b      	ldr	r3, [r3, #0]
24002f44:	4a5d      	ldr	r2, [pc, #372]	; (240030bc <HAL_DMA_Init+0x1d0>)
24002f46:	4293      	cmp	r3, r2
24002f48:	d02c      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f4a:	687b      	ldr	r3, [r7, #4]
24002f4c:	681b      	ldr	r3, [r3, #0]
24002f4e:	4a5c      	ldr	r2, [pc, #368]	; (240030c0 <HAL_DMA_Init+0x1d4>)
24002f50:	4293      	cmp	r3, r2
24002f52:	d027      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f54:	687b      	ldr	r3, [r7, #4]
24002f56:	681b      	ldr	r3, [r3, #0]
24002f58:	4a5a      	ldr	r2, [pc, #360]	; (240030c4 <HAL_DMA_Init+0x1d8>)
24002f5a:	4293      	cmp	r3, r2
24002f5c:	d022      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f5e:	687b      	ldr	r3, [r7, #4]
24002f60:	681b      	ldr	r3, [r3, #0]
24002f62:	4a59      	ldr	r2, [pc, #356]	; (240030c8 <HAL_DMA_Init+0x1dc>)
24002f64:	4293      	cmp	r3, r2
24002f66:	d01d      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f68:	687b      	ldr	r3, [r7, #4]
24002f6a:	681b      	ldr	r3, [r3, #0]
24002f6c:	4a57      	ldr	r2, [pc, #348]	; (240030cc <HAL_DMA_Init+0x1e0>)
24002f6e:	4293      	cmp	r3, r2
24002f70:	d018      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f72:	687b      	ldr	r3, [r7, #4]
24002f74:	681b      	ldr	r3, [r3, #0]
24002f76:	4a56      	ldr	r2, [pc, #344]	; (240030d0 <HAL_DMA_Init+0x1e4>)
24002f78:	4293      	cmp	r3, r2
24002f7a:	d013      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f7c:	687b      	ldr	r3, [r7, #4]
24002f7e:	681b      	ldr	r3, [r3, #0]
24002f80:	4a54      	ldr	r2, [pc, #336]	; (240030d4 <HAL_DMA_Init+0x1e8>)
24002f82:	4293      	cmp	r3, r2
24002f84:	d00e      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f86:	687b      	ldr	r3, [r7, #4]
24002f88:	681b      	ldr	r3, [r3, #0]
24002f8a:	4a53      	ldr	r2, [pc, #332]	; (240030d8 <HAL_DMA_Init+0x1ec>)
24002f8c:	4293      	cmp	r3, r2
24002f8e:	d009      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f90:	687b      	ldr	r3, [r7, #4]
24002f92:	681b      	ldr	r3, [r3, #0]
24002f94:	4a51      	ldr	r2, [pc, #324]	; (240030dc <HAL_DMA_Init+0x1f0>)
24002f96:	4293      	cmp	r3, r2
24002f98:	d004      	beq.n	24002fa4 <HAL_DMA_Init+0xb8>
24002f9a:	687b      	ldr	r3, [r7, #4]
24002f9c:	681b      	ldr	r3, [r3, #0]
24002f9e:	4a50      	ldr	r2, [pc, #320]	; (240030e0 <HAL_DMA_Init+0x1f4>)
24002fa0:	4293      	cmp	r3, r2
24002fa2:	d101      	bne.n	24002fa8 <HAL_DMA_Init+0xbc>
24002fa4:	2301      	movs	r3, #1
24002fa6:	e000      	b.n	24002faa <HAL_DMA_Init+0xbe>
24002fa8:	2300      	movs	r3, #0
24002faa:	2b00      	cmp	r3, #0
24002fac:	f000 813b 	beq.w	24003226 <HAL_DMA_Init+0x33a>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24002fb0:	687b      	ldr	r3, [r7, #4]
24002fb2:	2202      	movs	r2, #2
24002fb4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
24002fb8:	687b      	ldr	r3, [r7, #4]
24002fba:	2200      	movs	r2, #0
24002fbc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
24002fc0:	687b      	ldr	r3, [r7, #4]
24002fc2:	681b      	ldr	r3, [r3, #0]
24002fc4:	4a37      	ldr	r2, [pc, #220]	; (240030a4 <HAL_DMA_Init+0x1b8>)
24002fc6:	4293      	cmp	r3, r2
24002fc8:	d04a      	beq.n	24003060 <HAL_DMA_Init+0x174>
24002fca:	687b      	ldr	r3, [r7, #4]
24002fcc:	681b      	ldr	r3, [r3, #0]
24002fce:	4a36      	ldr	r2, [pc, #216]	; (240030a8 <HAL_DMA_Init+0x1bc>)
24002fd0:	4293      	cmp	r3, r2
24002fd2:	d045      	beq.n	24003060 <HAL_DMA_Init+0x174>
24002fd4:	687b      	ldr	r3, [r7, #4]
24002fd6:	681b      	ldr	r3, [r3, #0]
24002fd8:	4a34      	ldr	r2, [pc, #208]	; (240030ac <HAL_DMA_Init+0x1c0>)
24002fda:	4293      	cmp	r3, r2
24002fdc:	d040      	beq.n	24003060 <HAL_DMA_Init+0x174>
24002fde:	687b      	ldr	r3, [r7, #4]
24002fe0:	681b      	ldr	r3, [r3, #0]
24002fe2:	4a33      	ldr	r2, [pc, #204]	; (240030b0 <HAL_DMA_Init+0x1c4>)
24002fe4:	4293      	cmp	r3, r2
24002fe6:	d03b      	beq.n	24003060 <HAL_DMA_Init+0x174>
24002fe8:	687b      	ldr	r3, [r7, #4]
24002fea:	681b      	ldr	r3, [r3, #0]
24002fec:	4a31      	ldr	r2, [pc, #196]	; (240030b4 <HAL_DMA_Init+0x1c8>)
24002fee:	4293      	cmp	r3, r2
24002ff0:	d036      	beq.n	24003060 <HAL_DMA_Init+0x174>
24002ff2:	687b      	ldr	r3, [r7, #4]
24002ff4:	681b      	ldr	r3, [r3, #0]
24002ff6:	4a30      	ldr	r2, [pc, #192]	; (240030b8 <HAL_DMA_Init+0x1cc>)
24002ff8:	4293      	cmp	r3, r2
24002ffa:	d031      	beq.n	24003060 <HAL_DMA_Init+0x174>
24002ffc:	687b      	ldr	r3, [r7, #4]
24002ffe:	681b      	ldr	r3, [r3, #0]
24003000:	4a2e      	ldr	r2, [pc, #184]	; (240030bc <HAL_DMA_Init+0x1d0>)
24003002:	4293      	cmp	r3, r2
24003004:	d02c      	beq.n	24003060 <HAL_DMA_Init+0x174>
24003006:	687b      	ldr	r3, [r7, #4]
24003008:	681b      	ldr	r3, [r3, #0]
2400300a:	4a2d      	ldr	r2, [pc, #180]	; (240030c0 <HAL_DMA_Init+0x1d4>)
2400300c:	4293      	cmp	r3, r2
2400300e:	d027      	beq.n	24003060 <HAL_DMA_Init+0x174>
24003010:	687b      	ldr	r3, [r7, #4]
24003012:	681b      	ldr	r3, [r3, #0]
24003014:	4a2b      	ldr	r2, [pc, #172]	; (240030c4 <HAL_DMA_Init+0x1d8>)
24003016:	4293      	cmp	r3, r2
24003018:	d022      	beq.n	24003060 <HAL_DMA_Init+0x174>
2400301a:	687b      	ldr	r3, [r7, #4]
2400301c:	681b      	ldr	r3, [r3, #0]
2400301e:	4a2a      	ldr	r2, [pc, #168]	; (240030c8 <HAL_DMA_Init+0x1dc>)
24003020:	4293      	cmp	r3, r2
24003022:	d01d      	beq.n	24003060 <HAL_DMA_Init+0x174>
24003024:	687b      	ldr	r3, [r7, #4]
24003026:	681b      	ldr	r3, [r3, #0]
24003028:	4a28      	ldr	r2, [pc, #160]	; (240030cc <HAL_DMA_Init+0x1e0>)
2400302a:	4293      	cmp	r3, r2
2400302c:	d018      	beq.n	24003060 <HAL_DMA_Init+0x174>
2400302e:	687b      	ldr	r3, [r7, #4]
24003030:	681b      	ldr	r3, [r3, #0]
24003032:	4a27      	ldr	r2, [pc, #156]	; (240030d0 <HAL_DMA_Init+0x1e4>)
24003034:	4293      	cmp	r3, r2
24003036:	d013      	beq.n	24003060 <HAL_DMA_Init+0x174>
24003038:	687b      	ldr	r3, [r7, #4]
2400303a:	681b      	ldr	r3, [r3, #0]
2400303c:	4a25      	ldr	r2, [pc, #148]	; (240030d4 <HAL_DMA_Init+0x1e8>)
2400303e:	4293      	cmp	r3, r2
24003040:	d00e      	beq.n	24003060 <HAL_DMA_Init+0x174>
24003042:	687b      	ldr	r3, [r7, #4]
24003044:	681b      	ldr	r3, [r3, #0]
24003046:	4a24      	ldr	r2, [pc, #144]	; (240030d8 <HAL_DMA_Init+0x1ec>)
24003048:	4293      	cmp	r3, r2
2400304a:	d009      	beq.n	24003060 <HAL_DMA_Init+0x174>
2400304c:	687b      	ldr	r3, [r7, #4]
2400304e:	681b      	ldr	r3, [r3, #0]
24003050:	4a22      	ldr	r2, [pc, #136]	; (240030dc <HAL_DMA_Init+0x1f0>)
24003052:	4293      	cmp	r3, r2
24003054:	d004      	beq.n	24003060 <HAL_DMA_Init+0x174>
24003056:	687b      	ldr	r3, [r7, #4]
24003058:	681b      	ldr	r3, [r3, #0]
2400305a:	4a21      	ldr	r2, [pc, #132]	; (240030e0 <HAL_DMA_Init+0x1f4>)
2400305c:	4293      	cmp	r3, r2
2400305e:	d108      	bne.n	24003072 <HAL_DMA_Init+0x186>
24003060:	687b      	ldr	r3, [r7, #4]
24003062:	681b      	ldr	r3, [r3, #0]
24003064:	681a      	ldr	r2, [r3, #0]
24003066:	687b      	ldr	r3, [r7, #4]
24003068:	681b      	ldr	r3, [r3, #0]
2400306a:	f022 0201 	bic.w	r2, r2, #1
2400306e:	601a      	str	r2, [r3, #0]
24003070:	e007      	b.n	24003082 <HAL_DMA_Init+0x196>
24003072:	687b      	ldr	r3, [r7, #4]
24003074:	681b      	ldr	r3, [r3, #0]
24003076:	681a      	ldr	r2, [r3, #0]
24003078:	687b      	ldr	r3, [r7, #4]
2400307a:	681b      	ldr	r3, [r3, #0]
2400307c:	f022 0201 	bic.w	r2, r2, #1
24003080:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24003082:	e02f      	b.n	240030e4 <HAL_DMA_Init+0x1f8>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
24003084:	f7fe ffca 	bl	2400201c <HAL_GetTick>
24003088:	4602      	mov	r2, r0
2400308a:	693b      	ldr	r3, [r7, #16]
2400308c:	1ad3      	subs	r3, r2, r3
2400308e:	2b05      	cmp	r3, #5
24003090:	d928      	bls.n	240030e4 <HAL_DMA_Init+0x1f8>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24003092:	687b      	ldr	r3, [r7, #4]
24003094:	2220      	movs	r2, #32
24003096:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
24003098:	687b      	ldr	r3, [r7, #4]
2400309a:	2203      	movs	r2, #3
2400309c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
240030a0:	2301      	movs	r3, #1
240030a2:	e246      	b.n	24003532 <HAL_DMA_Init+0x646>
240030a4:	40020010 	.word	0x40020010
240030a8:	40020028 	.word	0x40020028
240030ac:	40020040 	.word	0x40020040
240030b0:	40020058 	.word	0x40020058
240030b4:	40020070 	.word	0x40020070
240030b8:	40020088 	.word	0x40020088
240030bc:	400200a0 	.word	0x400200a0
240030c0:	400200b8 	.word	0x400200b8
240030c4:	40020410 	.word	0x40020410
240030c8:	40020428 	.word	0x40020428
240030cc:	40020440 	.word	0x40020440
240030d0:	40020458 	.word	0x40020458
240030d4:	40020470 	.word	0x40020470
240030d8:	40020488 	.word	0x40020488
240030dc:	400204a0 	.word	0x400204a0
240030e0:	400204b8 	.word	0x400204b8
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
240030e4:	687b      	ldr	r3, [r7, #4]
240030e6:	681b      	ldr	r3, [r3, #0]
240030e8:	681b      	ldr	r3, [r3, #0]
240030ea:	f003 0301 	and.w	r3, r3, #1
240030ee:	2b00      	cmp	r3, #0
240030f0:	d1c8      	bne.n	24003084 <HAL_DMA_Init+0x198>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
240030f2:	687b      	ldr	r3, [r7, #4]
240030f4:	681b      	ldr	r3, [r3, #0]
240030f6:	681b      	ldr	r3, [r3, #0]
240030f8:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
240030fa:	697a      	ldr	r2, [r7, #20]
240030fc:	4b83      	ldr	r3, [pc, #524]	; (2400330c <HAL_DMA_Init+0x420>)
240030fe:	4013      	ands	r3, r2
24003100:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
24003102:	687b      	ldr	r3, [r7, #4]
24003104:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
24003106:	687b      	ldr	r3, [r7, #4]
24003108:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
2400310a:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
2400310c:	687b      	ldr	r3, [r7, #4]
2400310e:	691b      	ldr	r3, [r3, #16]
24003110:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
24003112:	687b      	ldr	r3, [r7, #4]
24003114:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
24003116:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
24003118:	687b      	ldr	r3, [r7, #4]
2400311a:	699b      	ldr	r3, [r3, #24]
2400311c:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
2400311e:	687b      	ldr	r3, [r7, #4]
24003120:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
24003122:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
24003124:	687b      	ldr	r3, [r7, #4]
24003126:	6a1b      	ldr	r3, [r3, #32]
24003128:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
2400312a:	697a      	ldr	r2, [r7, #20]
2400312c:	4313      	orrs	r3, r2
2400312e:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
24003130:	687b      	ldr	r3, [r7, #4]
24003132:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24003134:	2b04      	cmp	r3, #4
24003136:	d107      	bne.n	24003148 <HAL_DMA_Init+0x25c>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
24003138:	687b      	ldr	r3, [r7, #4]
2400313a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2400313c:	687b      	ldr	r3, [r7, #4]
2400313e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24003140:	4313      	orrs	r3, r2
24003142:	697a      	ldr	r2, [r7, #20]
24003144:	4313      	orrs	r3, r2
24003146:	617b      	str	r3, [r7, #20]
    }

    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                                    lock when transferring data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
24003148:	4b71      	ldr	r3, [pc, #452]	; (24003310 <HAL_DMA_Init+0x424>)
2400314a:	681a      	ldr	r2, [r3, #0]
2400314c:	4b71      	ldr	r3, [pc, #452]	; (24003314 <HAL_DMA_Init+0x428>)
2400314e:	4013      	ands	r3, r2
24003150:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24003154:	d328      	bcc.n	240031a8 <HAL_DMA_Init+0x2bc>
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
24003156:	687b      	ldr	r3, [r7, #4]
24003158:	685b      	ldr	r3, [r3, #4]
2400315a:	2b28      	cmp	r3, #40	; 0x28
2400315c:	d903      	bls.n	24003166 <HAL_DMA_Init+0x27a>
2400315e:	687b      	ldr	r3, [r7, #4]
24003160:	685b      	ldr	r3, [r3, #4]
24003162:	2b2e      	cmp	r3, #46	; 0x2e
24003164:	d917      	bls.n	24003196 <HAL_DMA_Init+0x2aa>
24003166:	687b      	ldr	r3, [r7, #4]
24003168:	685b      	ldr	r3, [r3, #4]
2400316a:	2b3e      	cmp	r3, #62	; 0x3e
2400316c:	d903      	bls.n	24003176 <HAL_DMA_Init+0x28a>
2400316e:	687b      	ldr	r3, [r7, #4]
24003170:	685b      	ldr	r3, [r3, #4]
24003172:	2b42      	cmp	r3, #66	; 0x42
24003174:	d90f      	bls.n	24003196 <HAL_DMA_Init+0x2aa>
24003176:	687b      	ldr	r3, [r7, #4]
24003178:	685b      	ldr	r3, [r3, #4]
2400317a:	2b46      	cmp	r3, #70	; 0x46
2400317c:	d903      	bls.n	24003186 <HAL_DMA_Init+0x29a>
2400317e:	687b      	ldr	r3, [r7, #4]
24003180:	685b      	ldr	r3, [r3, #4]
24003182:	2b48      	cmp	r3, #72	; 0x48
24003184:	d907      	bls.n	24003196 <HAL_DMA_Init+0x2aa>
24003186:	687b      	ldr	r3, [r7, #4]
24003188:	685b      	ldr	r3, [r3, #4]
2400318a:	2b4e      	cmp	r3, #78	; 0x4e
2400318c:	d905      	bls.n	2400319a <HAL_DMA_Init+0x2ae>
2400318e:	687b      	ldr	r3, [r7, #4]
24003190:	685b      	ldr	r3, [r3, #4]
24003192:	2b52      	cmp	r3, #82	; 0x52
24003194:	d801      	bhi.n	2400319a <HAL_DMA_Init+0x2ae>
24003196:	2301      	movs	r3, #1
24003198:	e000      	b.n	2400319c <HAL_DMA_Init+0x2b0>
2400319a:	2300      	movs	r3, #0
2400319c:	2b00      	cmp	r3, #0
2400319e:	d003      	beq.n	240031a8 <HAL_DMA_Init+0x2bc>
      {
        registerValue |= DMA_SxCR_TRBUFF;
240031a0:	697b      	ldr	r3, [r7, #20]
240031a2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
240031a6:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
240031a8:	687b      	ldr	r3, [r7, #4]
240031aa:	681b      	ldr	r3, [r3, #0]
240031ac:	697a      	ldr	r2, [r7, #20]
240031ae:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
240031b0:	687b      	ldr	r3, [r7, #4]
240031b2:	681b      	ldr	r3, [r3, #0]
240031b4:	695b      	ldr	r3, [r3, #20]
240031b6:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
240031b8:	697b      	ldr	r3, [r7, #20]
240031ba:	f023 0307 	bic.w	r3, r3, #7
240031be:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
240031c0:	687b      	ldr	r3, [r7, #4]
240031c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240031c4:	697a      	ldr	r2, [r7, #20]
240031c6:	4313      	orrs	r3, r2
240031c8:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
240031ca:	687b      	ldr	r3, [r7, #4]
240031cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240031ce:	2b04      	cmp	r3, #4
240031d0:	d117      	bne.n	24003202 <HAL_DMA_Init+0x316>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
240031d2:	687b      	ldr	r3, [r7, #4]
240031d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240031d6:	697a      	ldr	r2, [r7, #20]
240031d8:	4313      	orrs	r3, r2
240031da:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
240031dc:	687b      	ldr	r3, [r7, #4]
240031de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240031e0:	2b00      	cmp	r3, #0
240031e2:	d00e      	beq.n	24003202 <HAL_DMA_Init+0x316>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
240031e4:	6878      	ldr	r0, [r7, #4]
240031e6:	f003 fa95 	bl	24006714 <DMA_CheckFifoParam>
240031ea:	4603      	mov	r3, r0
240031ec:	2b00      	cmp	r3, #0
240031ee:	d008      	beq.n	24003202 <HAL_DMA_Init+0x316>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
240031f0:	687b      	ldr	r3, [r7, #4]
240031f2:	2240      	movs	r2, #64	; 0x40
240031f4:	655a      	str	r2, [r3, #84]	; 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
240031f6:	687b      	ldr	r3, [r7, #4]
240031f8:	2201      	movs	r2, #1
240031fa:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          return HAL_ERROR;
240031fe:	2301      	movs	r3, #1
24003200:	e197      	b.n	24003532 <HAL_DMA_Init+0x646>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
24003202:	687b      	ldr	r3, [r7, #4]
24003204:	681b      	ldr	r3, [r3, #0]
24003206:	697a      	ldr	r2, [r7, #20]
24003208:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
2400320a:	6878      	ldr	r0, [r7, #4]
2400320c:	f003 f9d0 	bl	240065b0 <DMA_CalcBaseAndBitshift>
24003210:	4603      	mov	r3, r0
24003212:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24003214:	687b      	ldr	r3, [r7, #4]
24003216:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003218:	f003 031f 	and.w	r3, r3, #31
2400321c:	223f      	movs	r2, #63	; 0x3f
2400321e:	409a      	lsls	r2, r3
24003220:	68bb      	ldr	r3, [r7, #8]
24003222:	609a      	str	r2, [r3, #8]
24003224:	e0cd      	b.n	240033c2 <HAL_DMA_Init+0x4d6>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24003226:	687b      	ldr	r3, [r7, #4]
24003228:	681b      	ldr	r3, [r3, #0]
2400322a:	4a3b      	ldr	r2, [pc, #236]	; (24003318 <HAL_DMA_Init+0x42c>)
2400322c:	4293      	cmp	r3, r2
2400322e:	d022      	beq.n	24003276 <HAL_DMA_Init+0x38a>
24003230:	687b      	ldr	r3, [r7, #4]
24003232:	681b      	ldr	r3, [r3, #0]
24003234:	4a39      	ldr	r2, [pc, #228]	; (2400331c <HAL_DMA_Init+0x430>)
24003236:	4293      	cmp	r3, r2
24003238:	d01d      	beq.n	24003276 <HAL_DMA_Init+0x38a>
2400323a:	687b      	ldr	r3, [r7, #4]
2400323c:	681b      	ldr	r3, [r3, #0]
2400323e:	4a38      	ldr	r2, [pc, #224]	; (24003320 <HAL_DMA_Init+0x434>)
24003240:	4293      	cmp	r3, r2
24003242:	d018      	beq.n	24003276 <HAL_DMA_Init+0x38a>
24003244:	687b      	ldr	r3, [r7, #4]
24003246:	681b      	ldr	r3, [r3, #0]
24003248:	4a36      	ldr	r2, [pc, #216]	; (24003324 <HAL_DMA_Init+0x438>)
2400324a:	4293      	cmp	r3, r2
2400324c:	d013      	beq.n	24003276 <HAL_DMA_Init+0x38a>
2400324e:	687b      	ldr	r3, [r7, #4]
24003250:	681b      	ldr	r3, [r3, #0]
24003252:	4a35      	ldr	r2, [pc, #212]	; (24003328 <HAL_DMA_Init+0x43c>)
24003254:	4293      	cmp	r3, r2
24003256:	d00e      	beq.n	24003276 <HAL_DMA_Init+0x38a>
24003258:	687b      	ldr	r3, [r7, #4]
2400325a:	681b      	ldr	r3, [r3, #0]
2400325c:	4a33      	ldr	r2, [pc, #204]	; (2400332c <HAL_DMA_Init+0x440>)
2400325e:	4293      	cmp	r3, r2
24003260:	d009      	beq.n	24003276 <HAL_DMA_Init+0x38a>
24003262:	687b      	ldr	r3, [r7, #4]
24003264:	681b      	ldr	r3, [r3, #0]
24003266:	4a32      	ldr	r2, [pc, #200]	; (24003330 <HAL_DMA_Init+0x444>)
24003268:	4293      	cmp	r3, r2
2400326a:	d004      	beq.n	24003276 <HAL_DMA_Init+0x38a>
2400326c:	687b      	ldr	r3, [r7, #4]
2400326e:	681b      	ldr	r3, [r3, #0]
24003270:	4a30      	ldr	r2, [pc, #192]	; (24003334 <HAL_DMA_Init+0x448>)
24003272:	4293      	cmp	r3, r2
24003274:	d101      	bne.n	2400327a <HAL_DMA_Init+0x38e>
24003276:	2301      	movs	r3, #1
24003278:	e000      	b.n	2400327c <HAL_DMA_Init+0x390>
2400327a:	2300      	movs	r3, #0
2400327c:	2b00      	cmp	r3, #0
2400327e:	f000 8097 	beq.w	240033b0 <HAL_DMA_Init+0x4c4>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24003282:	687b      	ldr	r3, [r7, #4]
24003284:	681b      	ldr	r3, [r3, #0]
24003286:	4a24      	ldr	r2, [pc, #144]	; (24003318 <HAL_DMA_Init+0x42c>)
24003288:	4293      	cmp	r3, r2
2400328a:	d021      	beq.n	240032d0 <HAL_DMA_Init+0x3e4>
2400328c:	687b      	ldr	r3, [r7, #4]
2400328e:	681b      	ldr	r3, [r3, #0]
24003290:	4a22      	ldr	r2, [pc, #136]	; (2400331c <HAL_DMA_Init+0x430>)
24003292:	4293      	cmp	r3, r2
24003294:	d01c      	beq.n	240032d0 <HAL_DMA_Init+0x3e4>
24003296:	687b      	ldr	r3, [r7, #4]
24003298:	681b      	ldr	r3, [r3, #0]
2400329a:	4a21      	ldr	r2, [pc, #132]	; (24003320 <HAL_DMA_Init+0x434>)
2400329c:	4293      	cmp	r3, r2
2400329e:	d017      	beq.n	240032d0 <HAL_DMA_Init+0x3e4>
240032a0:	687b      	ldr	r3, [r7, #4]
240032a2:	681b      	ldr	r3, [r3, #0]
240032a4:	4a1f      	ldr	r2, [pc, #124]	; (24003324 <HAL_DMA_Init+0x438>)
240032a6:	4293      	cmp	r3, r2
240032a8:	d012      	beq.n	240032d0 <HAL_DMA_Init+0x3e4>
240032aa:	687b      	ldr	r3, [r7, #4]
240032ac:	681b      	ldr	r3, [r3, #0]
240032ae:	4a1e      	ldr	r2, [pc, #120]	; (24003328 <HAL_DMA_Init+0x43c>)
240032b0:	4293      	cmp	r3, r2
240032b2:	d00d      	beq.n	240032d0 <HAL_DMA_Init+0x3e4>
240032b4:	687b      	ldr	r3, [r7, #4]
240032b6:	681b      	ldr	r3, [r3, #0]
240032b8:	4a1c      	ldr	r2, [pc, #112]	; (2400332c <HAL_DMA_Init+0x440>)
240032ba:	4293      	cmp	r3, r2
240032bc:	d008      	beq.n	240032d0 <HAL_DMA_Init+0x3e4>
240032be:	687b      	ldr	r3, [r7, #4]
240032c0:	681b      	ldr	r3, [r3, #0]
240032c2:	4a1b      	ldr	r2, [pc, #108]	; (24003330 <HAL_DMA_Init+0x444>)
240032c4:	4293      	cmp	r3, r2
240032c6:	d003      	beq.n	240032d0 <HAL_DMA_Init+0x3e4>
240032c8:	687b      	ldr	r3, [r7, #4]
240032ca:	681b      	ldr	r3, [r3, #0]
240032cc:	4a19      	ldr	r2, [pc, #100]	; (24003334 <HAL_DMA_Init+0x448>)
240032ce:	4293      	cmp	r3, r2
240032d0:	bf00      	nop
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
240032d2:	687b      	ldr	r3, [r7, #4]
240032d4:	2202      	movs	r2, #2
240032d6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
240032da:	687b      	ldr	r3, [r7, #4]
240032dc:	2200      	movs	r2, #0
240032de:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
240032e2:	687b      	ldr	r3, [r7, #4]
240032e4:	681b      	ldr	r3, [r3, #0]
240032e6:	681b      	ldr	r3, [r3, #0]
240032e8:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
240032ea:	697a      	ldr	r2, [r7, #20]
240032ec:	4b12      	ldr	r3, [pc, #72]	; (24003338 <HAL_DMA_Init+0x44c>)
240032ee:	4013      	ands	r3, r2
240032f0:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
240032f2:	687b      	ldr	r3, [r7, #4]
240032f4:	689b      	ldr	r3, [r3, #8]
240032f6:	2b40      	cmp	r3, #64	; 0x40
240032f8:	d020      	beq.n	2400333c <HAL_DMA_Init+0x450>
240032fa:	687b      	ldr	r3, [r7, #4]
240032fc:	689b      	ldr	r3, [r3, #8]
240032fe:	2b80      	cmp	r3, #128	; 0x80
24003300:	d102      	bne.n	24003308 <HAL_DMA_Init+0x41c>
24003302:	f44f 4380 	mov.w	r3, #16384	; 0x4000
24003306:	e01a      	b.n	2400333e <HAL_DMA_Init+0x452>
24003308:	2300      	movs	r3, #0
2400330a:	e018      	b.n	2400333e <HAL_DMA_Init+0x452>
2400330c:	fe10803f 	.word	0xfe10803f
24003310:	5c001000 	.word	0x5c001000
24003314:	ffff0000 	.word	0xffff0000
24003318:	58025408 	.word	0x58025408
2400331c:	5802541c 	.word	0x5802541c
24003320:	58025430 	.word	0x58025430
24003324:	58025444 	.word	0x58025444
24003328:	58025458 	.word	0x58025458
2400332c:	5802546c 	.word	0x5802546c
24003330:	58025480 	.word	0x58025480
24003334:	58025494 	.word	0x58025494
24003338:	fffe000f 	.word	0xfffe000f
2400333c:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
2400333e:	687a      	ldr	r2, [r7, #4]
24003340:	68d2      	ldr	r2, [r2, #12]
24003342:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24003344:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
24003346:	687b      	ldr	r3, [r7, #4]
24003348:	691b      	ldr	r3, [r3, #16]
2400334a:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
2400334c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
2400334e:	687b      	ldr	r3, [r7, #4]
24003350:	695b      	ldr	r3, [r3, #20]
24003352:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
24003354:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
24003356:	687b      	ldr	r3, [r7, #4]
24003358:	699b      	ldr	r3, [r3, #24]
2400335a:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
2400335c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
2400335e:	687b      	ldr	r3, [r7, #4]
24003360:	69db      	ldr	r3, [r3, #28]
24003362:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
24003364:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
24003366:	687b      	ldr	r3, [r7, #4]
24003368:	6a1b      	ldr	r3, [r3, #32]
2400336a:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
2400336c:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
2400336e:	697a      	ldr	r2, [r7, #20]
24003370:	4313      	orrs	r3, r2
24003372:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
24003374:	687b      	ldr	r3, [r7, #4]
24003376:	681b      	ldr	r3, [r3, #0]
24003378:	697a      	ldr	r2, [r7, #20]
2400337a:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
2400337c:	687b      	ldr	r3, [r7, #4]
2400337e:	681b      	ldr	r3, [r3, #0]
24003380:	461a      	mov	r2, r3
24003382:	4b6e      	ldr	r3, [pc, #440]	; (2400353c <HAL_DMA_Init+0x650>)
24003384:	4413      	add	r3, r2
24003386:	4a6e      	ldr	r2, [pc, #440]	; (24003540 <HAL_DMA_Init+0x654>)
24003388:	fba2 2303 	umull	r2, r3, r2, r3
2400338c:	091b      	lsrs	r3, r3, #4
2400338e:	009a      	lsls	r2, r3, #2
24003390:	687b      	ldr	r3, [r7, #4]
24003392:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24003394:	6878      	ldr	r0, [r7, #4]
24003396:	f003 f90b 	bl	240065b0 <DMA_CalcBaseAndBitshift>
2400339a:	4603      	mov	r3, r0
2400339c:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
2400339e:	687b      	ldr	r3, [r7, #4]
240033a0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240033a2:	f003 031f 	and.w	r3, r3, #31
240033a6:	2201      	movs	r2, #1
240033a8:	409a      	lsls	r2, r3
240033aa:	68fb      	ldr	r3, [r7, #12]
240033ac:	605a      	str	r2, [r3, #4]
240033ae:	e008      	b.n	240033c2 <HAL_DMA_Init+0x4d6>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
240033b0:	687b      	ldr	r3, [r7, #4]
240033b2:	2240      	movs	r2, #64	; 0x40
240033b4:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
240033b6:	687b      	ldr	r3, [r7, #4]
240033b8:	2203      	movs	r2, #3
240033ba:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    return HAL_ERROR;
240033be:	2301      	movs	r3, #1
240033c0:	e0b7      	b.n	24003532 <HAL_DMA_Init+0x646>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240033c2:	687b      	ldr	r3, [r7, #4]
240033c4:	681b      	ldr	r3, [r3, #0]
240033c6:	4a5f      	ldr	r2, [pc, #380]	; (24003544 <HAL_DMA_Init+0x658>)
240033c8:	4293      	cmp	r3, r2
240033ca:	d072      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
240033cc:	687b      	ldr	r3, [r7, #4]
240033ce:	681b      	ldr	r3, [r3, #0]
240033d0:	4a5d      	ldr	r2, [pc, #372]	; (24003548 <HAL_DMA_Init+0x65c>)
240033d2:	4293      	cmp	r3, r2
240033d4:	d06d      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
240033d6:	687b      	ldr	r3, [r7, #4]
240033d8:	681b      	ldr	r3, [r3, #0]
240033da:	4a5c      	ldr	r2, [pc, #368]	; (2400354c <HAL_DMA_Init+0x660>)
240033dc:	4293      	cmp	r3, r2
240033de:	d068      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
240033e0:	687b      	ldr	r3, [r7, #4]
240033e2:	681b      	ldr	r3, [r3, #0]
240033e4:	4a5a      	ldr	r2, [pc, #360]	; (24003550 <HAL_DMA_Init+0x664>)
240033e6:	4293      	cmp	r3, r2
240033e8:	d063      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
240033ea:	687b      	ldr	r3, [r7, #4]
240033ec:	681b      	ldr	r3, [r3, #0]
240033ee:	4a59      	ldr	r2, [pc, #356]	; (24003554 <HAL_DMA_Init+0x668>)
240033f0:	4293      	cmp	r3, r2
240033f2:	d05e      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
240033f4:	687b      	ldr	r3, [r7, #4]
240033f6:	681b      	ldr	r3, [r3, #0]
240033f8:	4a57      	ldr	r2, [pc, #348]	; (24003558 <HAL_DMA_Init+0x66c>)
240033fa:	4293      	cmp	r3, r2
240033fc:	d059      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
240033fe:	687b      	ldr	r3, [r7, #4]
24003400:	681b      	ldr	r3, [r3, #0]
24003402:	4a56      	ldr	r2, [pc, #344]	; (2400355c <HAL_DMA_Init+0x670>)
24003404:	4293      	cmp	r3, r2
24003406:	d054      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003408:	687b      	ldr	r3, [r7, #4]
2400340a:	681b      	ldr	r3, [r3, #0]
2400340c:	4a54      	ldr	r2, [pc, #336]	; (24003560 <HAL_DMA_Init+0x674>)
2400340e:	4293      	cmp	r3, r2
24003410:	d04f      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003412:	687b      	ldr	r3, [r7, #4]
24003414:	681b      	ldr	r3, [r3, #0]
24003416:	4a53      	ldr	r2, [pc, #332]	; (24003564 <HAL_DMA_Init+0x678>)
24003418:	4293      	cmp	r3, r2
2400341a:	d04a      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
2400341c:	687b      	ldr	r3, [r7, #4]
2400341e:	681b      	ldr	r3, [r3, #0]
24003420:	4a51      	ldr	r2, [pc, #324]	; (24003568 <HAL_DMA_Init+0x67c>)
24003422:	4293      	cmp	r3, r2
24003424:	d045      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003426:	687b      	ldr	r3, [r7, #4]
24003428:	681b      	ldr	r3, [r3, #0]
2400342a:	4a50      	ldr	r2, [pc, #320]	; (2400356c <HAL_DMA_Init+0x680>)
2400342c:	4293      	cmp	r3, r2
2400342e:	d040      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003430:	687b      	ldr	r3, [r7, #4]
24003432:	681b      	ldr	r3, [r3, #0]
24003434:	4a4e      	ldr	r2, [pc, #312]	; (24003570 <HAL_DMA_Init+0x684>)
24003436:	4293      	cmp	r3, r2
24003438:	d03b      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
2400343a:	687b      	ldr	r3, [r7, #4]
2400343c:	681b      	ldr	r3, [r3, #0]
2400343e:	4a4d      	ldr	r2, [pc, #308]	; (24003574 <HAL_DMA_Init+0x688>)
24003440:	4293      	cmp	r3, r2
24003442:	d036      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003444:	687b      	ldr	r3, [r7, #4]
24003446:	681b      	ldr	r3, [r3, #0]
24003448:	4a4b      	ldr	r2, [pc, #300]	; (24003578 <HAL_DMA_Init+0x68c>)
2400344a:	4293      	cmp	r3, r2
2400344c:	d031      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
2400344e:	687b      	ldr	r3, [r7, #4]
24003450:	681b      	ldr	r3, [r3, #0]
24003452:	4a4a      	ldr	r2, [pc, #296]	; (2400357c <HAL_DMA_Init+0x690>)
24003454:	4293      	cmp	r3, r2
24003456:	d02c      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003458:	687b      	ldr	r3, [r7, #4]
2400345a:	681b      	ldr	r3, [r3, #0]
2400345c:	4a48      	ldr	r2, [pc, #288]	; (24003580 <HAL_DMA_Init+0x694>)
2400345e:	4293      	cmp	r3, r2
24003460:	d027      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003462:	687b      	ldr	r3, [r7, #4]
24003464:	681b      	ldr	r3, [r3, #0]
24003466:	4a47      	ldr	r2, [pc, #284]	; (24003584 <HAL_DMA_Init+0x698>)
24003468:	4293      	cmp	r3, r2
2400346a:	d022      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
2400346c:	687b      	ldr	r3, [r7, #4]
2400346e:	681b      	ldr	r3, [r3, #0]
24003470:	4a45      	ldr	r2, [pc, #276]	; (24003588 <HAL_DMA_Init+0x69c>)
24003472:	4293      	cmp	r3, r2
24003474:	d01d      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003476:	687b      	ldr	r3, [r7, #4]
24003478:	681b      	ldr	r3, [r3, #0]
2400347a:	4a44      	ldr	r2, [pc, #272]	; (2400358c <HAL_DMA_Init+0x6a0>)
2400347c:	4293      	cmp	r3, r2
2400347e:	d018      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003480:	687b      	ldr	r3, [r7, #4]
24003482:	681b      	ldr	r3, [r3, #0]
24003484:	4a42      	ldr	r2, [pc, #264]	; (24003590 <HAL_DMA_Init+0x6a4>)
24003486:	4293      	cmp	r3, r2
24003488:	d013      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
2400348a:	687b      	ldr	r3, [r7, #4]
2400348c:	681b      	ldr	r3, [r3, #0]
2400348e:	4a41      	ldr	r2, [pc, #260]	; (24003594 <HAL_DMA_Init+0x6a8>)
24003490:	4293      	cmp	r3, r2
24003492:	d00e      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
24003494:	687b      	ldr	r3, [r7, #4]
24003496:	681b      	ldr	r3, [r3, #0]
24003498:	4a3f      	ldr	r2, [pc, #252]	; (24003598 <HAL_DMA_Init+0x6ac>)
2400349a:	4293      	cmp	r3, r2
2400349c:	d009      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
2400349e:	687b      	ldr	r3, [r7, #4]
240034a0:	681b      	ldr	r3, [r3, #0]
240034a2:	4a3e      	ldr	r2, [pc, #248]	; (2400359c <HAL_DMA_Init+0x6b0>)
240034a4:	4293      	cmp	r3, r2
240034a6:	d004      	beq.n	240034b2 <HAL_DMA_Init+0x5c6>
240034a8:	687b      	ldr	r3, [r7, #4]
240034aa:	681b      	ldr	r3, [r3, #0]
240034ac:	4a3c      	ldr	r2, [pc, #240]	; (240035a0 <HAL_DMA_Init+0x6b4>)
240034ae:	4293      	cmp	r3, r2
240034b0:	d101      	bne.n	240034b6 <HAL_DMA_Init+0x5ca>
240034b2:	2301      	movs	r3, #1
240034b4:	e000      	b.n	240034b8 <HAL_DMA_Init+0x5cc>
240034b6:	2300      	movs	r3, #0
240034b8:	2b00      	cmp	r3, #0
240034ba:	d032      	beq.n	24003522 <HAL_DMA_Init+0x636>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
240034bc:	6878      	ldr	r0, [r7, #4]
240034be:	f003 f9a5 	bl	2400680c <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
240034c2:	687b      	ldr	r3, [r7, #4]
240034c4:	689b      	ldr	r3, [r3, #8]
240034c6:	2b80      	cmp	r3, #128	; 0x80
240034c8:	d102      	bne.n	240034d0 <HAL_DMA_Init+0x5e4>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
240034ca:	687b      	ldr	r3, [r7, #4]
240034cc:	2200      	movs	r2, #0
240034ce:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
240034d0:	687b      	ldr	r3, [r7, #4]
240034d2:	685a      	ldr	r2, [r3, #4]
240034d4:	687b      	ldr	r3, [r7, #4]
240034d6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240034d8:	b2d2      	uxtb	r2, r2
240034da:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240034dc:	687b      	ldr	r3, [r7, #4]
240034de:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240034e0:	687a      	ldr	r2, [r7, #4]
240034e2:	6e92      	ldr	r2, [r2, #104]	; 0x68
240034e4:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
240034e6:	687b      	ldr	r3, [r7, #4]
240034e8:	685b      	ldr	r3, [r3, #4]
240034ea:	2b00      	cmp	r3, #0
240034ec:	d010      	beq.n	24003510 <HAL_DMA_Init+0x624>
240034ee:	687b      	ldr	r3, [r7, #4]
240034f0:	685b      	ldr	r3, [r3, #4]
240034f2:	2b08      	cmp	r3, #8
240034f4:	d80c      	bhi.n	24003510 <HAL_DMA_Init+0x624>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
240034f6:	6878      	ldr	r0, [r7, #4]
240034f8:	f003 fa22 	bl	24006940 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
240034fc:	687b      	ldr	r3, [r7, #4]
240034fe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003500:	2200      	movs	r2, #0
24003502:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24003504:	687b      	ldr	r3, [r7, #4]
24003506:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003508:	687a      	ldr	r2, [r7, #4]
2400350a:	6f52      	ldr	r2, [r2, #116]	; 0x74
2400350c:	605a      	str	r2, [r3, #4]
2400350e:	e008      	b.n	24003522 <HAL_DMA_Init+0x636>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
24003510:	687b      	ldr	r3, [r7, #4]
24003512:	2200      	movs	r2, #0
24003514:	66da      	str	r2, [r3, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
24003516:	687b      	ldr	r3, [r7, #4]
24003518:	2200      	movs	r2, #0
2400351a:	671a      	str	r2, [r3, #112]	; 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
2400351c:	687b      	ldr	r3, [r7, #4]
2400351e:	2200      	movs	r2, #0
24003520:	675a      	str	r2, [r3, #116]	; 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24003522:	687b      	ldr	r3, [r7, #4]
24003524:	2200      	movs	r2, #0
24003526:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
24003528:	687b      	ldr	r3, [r7, #4]
2400352a:	2201      	movs	r2, #1
2400352c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
24003530:	2300      	movs	r3, #0
}
24003532:	4618      	mov	r0, r3
24003534:	3718      	adds	r7, #24
24003536:	46bd      	mov	sp, r7
24003538:	bd80      	pop	{r7, pc}
2400353a:	bf00      	nop
2400353c:	a7fdabf8 	.word	0xa7fdabf8
24003540:	cccccccd 	.word	0xcccccccd
24003544:	40020010 	.word	0x40020010
24003548:	40020028 	.word	0x40020028
2400354c:	40020040 	.word	0x40020040
24003550:	40020058 	.word	0x40020058
24003554:	40020070 	.word	0x40020070
24003558:	40020088 	.word	0x40020088
2400355c:	400200a0 	.word	0x400200a0
24003560:	400200b8 	.word	0x400200b8
24003564:	40020410 	.word	0x40020410
24003568:	40020428 	.word	0x40020428
2400356c:	40020440 	.word	0x40020440
24003570:	40020458 	.word	0x40020458
24003574:	40020470 	.word	0x40020470
24003578:	40020488 	.word	0x40020488
2400357c:	400204a0 	.word	0x400204a0
24003580:	400204b8 	.word	0x400204b8
24003584:	58025408 	.word	0x58025408
24003588:	5802541c 	.word	0x5802541c
2400358c:	58025430 	.word	0x58025430
24003590:	58025444 	.word	0x58025444
24003594:	58025458 	.word	0x58025458
24003598:	5802546c 	.word	0x5802546c
2400359c:	58025480 	.word	0x58025480
240035a0:	58025494 	.word	0x58025494

240035a4 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
240035a4:	b580      	push	{r7, lr}
240035a6:	b084      	sub	sp, #16
240035a8:	af00      	add	r7, sp, #0
240035aa:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
240035ac:	687b      	ldr	r3, [r7, #4]
240035ae:	2b00      	cmp	r3, #0
240035b0:	d101      	bne.n	240035b6 <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
240035b2:	2301      	movs	r3, #1
240035b4:	e1a8      	b.n	24003908 <HAL_DMA_DeInit+0x364>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
240035b6:	687b      	ldr	r3, [r7, #4]
240035b8:	681b      	ldr	r3, [r3, #0]
240035ba:	4a82      	ldr	r2, [pc, #520]	; (240037c4 <HAL_DMA_DeInit+0x220>)
240035bc:	4293      	cmp	r3, r2
240035be:	d04a      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
240035c0:	687b      	ldr	r3, [r7, #4]
240035c2:	681b      	ldr	r3, [r3, #0]
240035c4:	4a80      	ldr	r2, [pc, #512]	; (240037c8 <HAL_DMA_DeInit+0x224>)
240035c6:	4293      	cmp	r3, r2
240035c8:	d045      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
240035ca:	687b      	ldr	r3, [r7, #4]
240035cc:	681b      	ldr	r3, [r3, #0]
240035ce:	4a7f      	ldr	r2, [pc, #508]	; (240037cc <HAL_DMA_DeInit+0x228>)
240035d0:	4293      	cmp	r3, r2
240035d2:	d040      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
240035d4:	687b      	ldr	r3, [r7, #4]
240035d6:	681b      	ldr	r3, [r3, #0]
240035d8:	4a7d      	ldr	r2, [pc, #500]	; (240037d0 <HAL_DMA_DeInit+0x22c>)
240035da:	4293      	cmp	r3, r2
240035dc:	d03b      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
240035de:	687b      	ldr	r3, [r7, #4]
240035e0:	681b      	ldr	r3, [r3, #0]
240035e2:	4a7c      	ldr	r2, [pc, #496]	; (240037d4 <HAL_DMA_DeInit+0x230>)
240035e4:	4293      	cmp	r3, r2
240035e6:	d036      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
240035e8:	687b      	ldr	r3, [r7, #4]
240035ea:	681b      	ldr	r3, [r3, #0]
240035ec:	4a7a      	ldr	r2, [pc, #488]	; (240037d8 <HAL_DMA_DeInit+0x234>)
240035ee:	4293      	cmp	r3, r2
240035f0:	d031      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
240035f2:	687b      	ldr	r3, [r7, #4]
240035f4:	681b      	ldr	r3, [r3, #0]
240035f6:	4a79      	ldr	r2, [pc, #484]	; (240037dc <HAL_DMA_DeInit+0x238>)
240035f8:	4293      	cmp	r3, r2
240035fa:	d02c      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
240035fc:	687b      	ldr	r3, [r7, #4]
240035fe:	681b      	ldr	r3, [r3, #0]
24003600:	4a77      	ldr	r2, [pc, #476]	; (240037e0 <HAL_DMA_DeInit+0x23c>)
24003602:	4293      	cmp	r3, r2
24003604:	d027      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
24003606:	687b      	ldr	r3, [r7, #4]
24003608:	681b      	ldr	r3, [r3, #0]
2400360a:	4a76      	ldr	r2, [pc, #472]	; (240037e4 <HAL_DMA_DeInit+0x240>)
2400360c:	4293      	cmp	r3, r2
2400360e:	d022      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
24003610:	687b      	ldr	r3, [r7, #4]
24003612:	681b      	ldr	r3, [r3, #0]
24003614:	4a74      	ldr	r2, [pc, #464]	; (240037e8 <HAL_DMA_DeInit+0x244>)
24003616:	4293      	cmp	r3, r2
24003618:	d01d      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
2400361a:	687b      	ldr	r3, [r7, #4]
2400361c:	681b      	ldr	r3, [r3, #0]
2400361e:	4a73      	ldr	r2, [pc, #460]	; (240037ec <HAL_DMA_DeInit+0x248>)
24003620:	4293      	cmp	r3, r2
24003622:	d018      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
24003624:	687b      	ldr	r3, [r7, #4]
24003626:	681b      	ldr	r3, [r3, #0]
24003628:	4a71      	ldr	r2, [pc, #452]	; (240037f0 <HAL_DMA_DeInit+0x24c>)
2400362a:	4293      	cmp	r3, r2
2400362c:	d013      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
2400362e:	687b      	ldr	r3, [r7, #4]
24003630:	681b      	ldr	r3, [r3, #0]
24003632:	4a70      	ldr	r2, [pc, #448]	; (240037f4 <HAL_DMA_DeInit+0x250>)
24003634:	4293      	cmp	r3, r2
24003636:	d00e      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
24003638:	687b      	ldr	r3, [r7, #4]
2400363a:	681b      	ldr	r3, [r3, #0]
2400363c:	4a6e      	ldr	r2, [pc, #440]	; (240037f8 <HAL_DMA_DeInit+0x254>)
2400363e:	4293      	cmp	r3, r2
24003640:	d009      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
24003642:	687b      	ldr	r3, [r7, #4]
24003644:	681b      	ldr	r3, [r3, #0]
24003646:	4a6d      	ldr	r2, [pc, #436]	; (240037fc <HAL_DMA_DeInit+0x258>)
24003648:	4293      	cmp	r3, r2
2400364a:	d004      	beq.n	24003656 <HAL_DMA_DeInit+0xb2>
2400364c:	687b      	ldr	r3, [r7, #4]
2400364e:	681b      	ldr	r3, [r3, #0]
24003650:	4a6b      	ldr	r2, [pc, #428]	; (24003800 <HAL_DMA_DeInit+0x25c>)
24003652:	4293      	cmp	r3, r2
24003654:	d108      	bne.n	24003668 <HAL_DMA_DeInit+0xc4>
24003656:	687b      	ldr	r3, [r7, #4]
24003658:	681b      	ldr	r3, [r3, #0]
2400365a:	681a      	ldr	r2, [r3, #0]
2400365c:	687b      	ldr	r3, [r7, #4]
2400365e:	681b      	ldr	r3, [r3, #0]
24003660:	f022 0201 	bic.w	r2, r2, #1
24003664:	601a      	str	r2, [r3, #0]
24003666:	e007      	b.n	24003678 <HAL_DMA_DeInit+0xd4>
24003668:	687b      	ldr	r3, [r7, #4]
2400366a:	681b      	ldr	r3, [r3, #0]
2400366c:	681a      	ldr	r2, [r3, #0]
2400366e:	687b      	ldr	r3, [r7, #4]
24003670:	681b      	ldr	r3, [r3, #0]
24003672:	f022 0201 	bic.w	r2, r2, #1
24003676:	601a      	str	r2, [r3, #0]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003678:	687b      	ldr	r3, [r7, #4]
2400367a:	681b      	ldr	r3, [r3, #0]
2400367c:	4a51      	ldr	r2, [pc, #324]	; (240037c4 <HAL_DMA_DeInit+0x220>)
2400367e:	4293      	cmp	r3, r2
24003680:	d04a      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
24003682:	687b      	ldr	r3, [r7, #4]
24003684:	681b      	ldr	r3, [r3, #0]
24003686:	4a50      	ldr	r2, [pc, #320]	; (240037c8 <HAL_DMA_DeInit+0x224>)
24003688:	4293      	cmp	r3, r2
2400368a:	d045      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
2400368c:	687b      	ldr	r3, [r7, #4]
2400368e:	681b      	ldr	r3, [r3, #0]
24003690:	4a4e      	ldr	r2, [pc, #312]	; (240037cc <HAL_DMA_DeInit+0x228>)
24003692:	4293      	cmp	r3, r2
24003694:	d040      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
24003696:	687b      	ldr	r3, [r7, #4]
24003698:	681b      	ldr	r3, [r3, #0]
2400369a:	4a4d      	ldr	r2, [pc, #308]	; (240037d0 <HAL_DMA_DeInit+0x22c>)
2400369c:	4293      	cmp	r3, r2
2400369e:	d03b      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036a0:	687b      	ldr	r3, [r7, #4]
240036a2:	681b      	ldr	r3, [r3, #0]
240036a4:	4a4b      	ldr	r2, [pc, #300]	; (240037d4 <HAL_DMA_DeInit+0x230>)
240036a6:	4293      	cmp	r3, r2
240036a8:	d036      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036aa:	687b      	ldr	r3, [r7, #4]
240036ac:	681b      	ldr	r3, [r3, #0]
240036ae:	4a4a      	ldr	r2, [pc, #296]	; (240037d8 <HAL_DMA_DeInit+0x234>)
240036b0:	4293      	cmp	r3, r2
240036b2:	d031      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036b4:	687b      	ldr	r3, [r7, #4]
240036b6:	681b      	ldr	r3, [r3, #0]
240036b8:	4a48      	ldr	r2, [pc, #288]	; (240037dc <HAL_DMA_DeInit+0x238>)
240036ba:	4293      	cmp	r3, r2
240036bc:	d02c      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036be:	687b      	ldr	r3, [r7, #4]
240036c0:	681b      	ldr	r3, [r3, #0]
240036c2:	4a47      	ldr	r2, [pc, #284]	; (240037e0 <HAL_DMA_DeInit+0x23c>)
240036c4:	4293      	cmp	r3, r2
240036c6:	d027      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036c8:	687b      	ldr	r3, [r7, #4]
240036ca:	681b      	ldr	r3, [r3, #0]
240036cc:	4a45      	ldr	r2, [pc, #276]	; (240037e4 <HAL_DMA_DeInit+0x240>)
240036ce:	4293      	cmp	r3, r2
240036d0:	d022      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036d2:	687b      	ldr	r3, [r7, #4]
240036d4:	681b      	ldr	r3, [r3, #0]
240036d6:	4a44      	ldr	r2, [pc, #272]	; (240037e8 <HAL_DMA_DeInit+0x244>)
240036d8:	4293      	cmp	r3, r2
240036da:	d01d      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036dc:	687b      	ldr	r3, [r7, #4]
240036de:	681b      	ldr	r3, [r3, #0]
240036e0:	4a42      	ldr	r2, [pc, #264]	; (240037ec <HAL_DMA_DeInit+0x248>)
240036e2:	4293      	cmp	r3, r2
240036e4:	d018      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036e6:	687b      	ldr	r3, [r7, #4]
240036e8:	681b      	ldr	r3, [r3, #0]
240036ea:	4a41      	ldr	r2, [pc, #260]	; (240037f0 <HAL_DMA_DeInit+0x24c>)
240036ec:	4293      	cmp	r3, r2
240036ee:	d013      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036f0:	687b      	ldr	r3, [r7, #4]
240036f2:	681b      	ldr	r3, [r3, #0]
240036f4:	4a3f      	ldr	r2, [pc, #252]	; (240037f4 <HAL_DMA_DeInit+0x250>)
240036f6:	4293      	cmp	r3, r2
240036f8:	d00e      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
240036fa:	687b      	ldr	r3, [r7, #4]
240036fc:	681b      	ldr	r3, [r3, #0]
240036fe:	4a3e      	ldr	r2, [pc, #248]	; (240037f8 <HAL_DMA_DeInit+0x254>)
24003700:	4293      	cmp	r3, r2
24003702:	d009      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
24003704:	687b      	ldr	r3, [r7, #4]
24003706:	681b      	ldr	r3, [r3, #0]
24003708:	4a3c      	ldr	r2, [pc, #240]	; (240037fc <HAL_DMA_DeInit+0x258>)
2400370a:	4293      	cmp	r3, r2
2400370c:	d004      	beq.n	24003718 <HAL_DMA_DeInit+0x174>
2400370e:	687b      	ldr	r3, [r7, #4]
24003710:	681b      	ldr	r3, [r3, #0]
24003712:	4a3b      	ldr	r2, [pc, #236]	; (24003800 <HAL_DMA_DeInit+0x25c>)
24003714:	4293      	cmp	r3, r2
24003716:	d101      	bne.n	2400371c <HAL_DMA_DeInit+0x178>
24003718:	2301      	movs	r3, #1
2400371a:	e000      	b.n	2400371e <HAL_DMA_DeInit+0x17a>
2400371c:	2300      	movs	r3, #0
2400371e:	2b00      	cmp	r3, #0
24003720:	d025      	beq.n	2400376e <HAL_DMA_DeInit+0x1ca>
  {
    /* Reset DMA Streamx control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
24003722:	687b      	ldr	r3, [r7, #4]
24003724:	681b      	ldr	r3, [r3, #0]
24003726:	2200      	movs	r2, #0
24003728:	601a      	str	r2, [r3, #0]

    /* Reset DMA Streamx number of data to transfer register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
2400372a:	687b      	ldr	r3, [r7, #4]
2400372c:	681b      	ldr	r3, [r3, #0]
2400372e:	2200      	movs	r2, #0
24003730:	605a      	str	r2, [r3, #4]

    /* Reset DMA Streamx peripheral address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
24003732:	687b      	ldr	r3, [r7, #4]
24003734:	681b      	ldr	r3, [r3, #0]
24003736:	2200      	movs	r2, #0
24003738:	609a      	str	r2, [r3, #8]

    /* Reset DMA Streamx memory 0 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
2400373a:	687b      	ldr	r3, [r7, #4]
2400373c:	681b      	ldr	r3, [r3, #0]
2400373e:	2200      	movs	r2, #0
24003740:	60da      	str	r2, [r3, #12]

    /* Reset DMA Streamx memory 1 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
24003742:	687b      	ldr	r3, [r7, #4]
24003744:	681b      	ldr	r3, [r3, #0]
24003746:	2200      	movs	r2, #0
24003748:	611a      	str	r2, [r3, #16]

    /* Reset DMA Streamx FIFO control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
2400374a:	687b      	ldr	r3, [r7, #4]
2400374c:	681b      	ldr	r3, [r3, #0]
2400374e:	2221      	movs	r2, #33	; 0x21
24003750:	615a      	str	r2, [r3, #20]

    /* Get DMA steam Base Address */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24003752:	6878      	ldr	r0, [r7, #4]
24003754:	f002 ff2c 	bl	240065b0 <DMA_CalcBaseAndBitshift>
24003758:	4603      	mov	r3, r0
2400375a:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
2400375c:	687b      	ldr	r3, [r7, #4]
2400375e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003760:	f003 031f 	and.w	r3, r3, #31
24003764:	223f      	movs	r2, #63	; 0x3f
24003766:	409a      	lsls	r2, r3
24003768:	68bb      	ldr	r3, [r7, #8]
2400376a:	609a      	str	r2, [r3, #8]
2400376c:	e081      	b.n	24003872 <HAL_DMA_DeInit+0x2ce>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
2400376e:	687b      	ldr	r3, [r7, #4]
24003770:	681b      	ldr	r3, [r3, #0]
24003772:	4a24      	ldr	r2, [pc, #144]	; (24003804 <HAL_DMA_DeInit+0x260>)
24003774:	4293      	cmp	r3, r2
24003776:	d022      	beq.n	240037be <HAL_DMA_DeInit+0x21a>
24003778:	687b      	ldr	r3, [r7, #4]
2400377a:	681b      	ldr	r3, [r3, #0]
2400377c:	4a22      	ldr	r2, [pc, #136]	; (24003808 <HAL_DMA_DeInit+0x264>)
2400377e:	4293      	cmp	r3, r2
24003780:	d01d      	beq.n	240037be <HAL_DMA_DeInit+0x21a>
24003782:	687b      	ldr	r3, [r7, #4]
24003784:	681b      	ldr	r3, [r3, #0]
24003786:	4a21      	ldr	r2, [pc, #132]	; (2400380c <HAL_DMA_DeInit+0x268>)
24003788:	4293      	cmp	r3, r2
2400378a:	d018      	beq.n	240037be <HAL_DMA_DeInit+0x21a>
2400378c:	687b      	ldr	r3, [r7, #4]
2400378e:	681b      	ldr	r3, [r3, #0]
24003790:	4a1f      	ldr	r2, [pc, #124]	; (24003810 <HAL_DMA_DeInit+0x26c>)
24003792:	4293      	cmp	r3, r2
24003794:	d013      	beq.n	240037be <HAL_DMA_DeInit+0x21a>
24003796:	687b      	ldr	r3, [r7, #4]
24003798:	681b      	ldr	r3, [r3, #0]
2400379a:	4a1e      	ldr	r2, [pc, #120]	; (24003814 <HAL_DMA_DeInit+0x270>)
2400379c:	4293      	cmp	r3, r2
2400379e:	d00e      	beq.n	240037be <HAL_DMA_DeInit+0x21a>
240037a0:	687b      	ldr	r3, [r7, #4]
240037a2:	681b      	ldr	r3, [r3, #0]
240037a4:	4a1c      	ldr	r2, [pc, #112]	; (24003818 <HAL_DMA_DeInit+0x274>)
240037a6:	4293      	cmp	r3, r2
240037a8:	d009      	beq.n	240037be <HAL_DMA_DeInit+0x21a>
240037aa:	687b      	ldr	r3, [r7, #4]
240037ac:	681b      	ldr	r3, [r3, #0]
240037ae:	4a1b      	ldr	r2, [pc, #108]	; (2400381c <HAL_DMA_DeInit+0x278>)
240037b0:	4293      	cmp	r3, r2
240037b2:	d004      	beq.n	240037be <HAL_DMA_DeInit+0x21a>
240037b4:	687b      	ldr	r3, [r7, #4]
240037b6:	681b      	ldr	r3, [r3, #0]
240037b8:	4a19      	ldr	r2, [pc, #100]	; (24003820 <HAL_DMA_DeInit+0x27c>)
240037ba:	4293      	cmp	r3, r2
240037bc:	d132      	bne.n	24003824 <HAL_DMA_DeInit+0x280>
240037be:	2301      	movs	r3, #1
240037c0:	e031      	b.n	24003826 <HAL_DMA_DeInit+0x282>
240037c2:	bf00      	nop
240037c4:	40020010 	.word	0x40020010
240037c8:	40020028 	.word	0x40020028
240037cc:	40020040 	.word	0x40020040
240037d0:	40020058 	.word	0x40020058
240037d4:	40020070 	.word	0x40020070
240037d8:	40020088 	.word	0x40020088
240037dc:	400200a0 	.word	0x400200a0
240037e0:	400200b8 	.word	0x400200b8
240037e4:	40020410 	.word	0x40020410
240037e8:	40020428 	.word	0x40020428
240037ec:	40020440 	.word	0x40020440
240037f0:	40020458 	.word	0x40020458
240037f4:	40020470 	.word	0x40020470
240037f8:	40020488 	.word	0x40020488
240037fc:	400204a0 	.word	0x400204a0
24003800:	400204b8 	.word	0x400204b8
24003804:	58025408 	.word	0x58025408
24003808:	5802541c 	.word	0x5802541c
2400380c:	58025430 	.word	0x58025430
24003810:	58025444 	.word	0x58025444
24003814:	58025458 	.word	0x58025458
24003818:	5802546c 	.word	0x5802546c
2400381c:	58025480 	.word	0x58025480
24003820:	58025494 	.word	0x58025494
24003824:	2300      	movs	r3, #0
24003826:	2b00      	cmp	r3, #0
24003828:	d021      	beq.n	2400386e <HAL_DMA_DeInit+0x2ca>
  {
    /* Reset DMA Channel control register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
2400382a:	687b      	ldr	r3, [r7, #4]
2400382c:	681b      	ldr	r3, [r3, #0]
2400382e:	2200      	movs	r2, #0
24003830:	601a      	str	r2, [r3, #0]

    /* Reset DMA Channel Number of Data to Transfer register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
24003832:	687b      	ldr	r3, [r7, #4]
24003834:	681b      	ldr	r3, [r3, #0]
24003836:	2200      	movs	r2, #0
24003838:	605a      	str	r2, [r3, #4]

    /* Reset DMA Channel peripheral address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
2400383a:	687b      	ldr	r3, [r7, #4]
2400383c:	681b      	ldr	r3, [r3, #0]
2400383e:	2200      	movs	r2, #0
24003840:	609a      	str	r2, [r3, #8]

    /* Reset DMA Channel memory 0 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
24003842:	687b      	ldr	r3, [r7, #4]
24003844:	681b      	ldr	r3, [r3, #0]
24003846:	2200      	movs	r2, #0
24003848:	60da      	str	r2, [r3, #12]

    /* Reset DMA Channel memory 1 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
2400384a:	687b      	ldr	r3, [r7, #4]
2400384c:	681b      	ldr	r3, [r3, #0]
2400384e:	2200      	movs	r2, #0
24003850:	611a      	str	r2, [r3, #16]

    /* Get DMA steam Base Address */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24003852:	6878      	ldr	r0, [r7, #4]
24003854:	f002 feac 	bl	240065b0 <DMA_CalcBaseAndBitshift>
24003858:	4603      	mov	r3, r0
2400385a:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags at correct offset within the register */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
2400385c:	687b      	ldr	r3, [r7, #4]
2400385e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003860:	f003 031f 	and.w	r3, r3, #31
24003864:	2201      	movs	r2, #1
24003866:	409a      	lsls	r2, r3
24003868:	68fb      	ldr	r3, [r7, #12]
2400386a:	605a      	str	r2, [r3, #4]
2400386c:	e001      	b.n	24003872 <HAL_DMA_DeInit+0x2ce>
  }
  else
  {
    /* Return error status */
    return HAL_ERROR;
2400386e:	2301      	movs	r3, #1
24003870:	e04a      	b.n	24003908 <HAL_DMA_DeInit+0x364>
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
#endif /* BDMA1 */
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
24003872:	6878      	ldr	r0, [r7, #4]
24003874:	f002 ffca 	bl	2400680c <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->DMAmuxChannel != 0U)
24003878:	687b      	ldr	r3, [r7, #4]
2400387a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400387c:	2b00      	cmp	r3, #0
2400387e:	d008      	beq.n	24003892 <HAL_DMA_DeInit+0x2ee>
    {
      /* Resett he DMAMUX channel that corresponds to the DMA stream */
      hdma->DMAmuxChannel->CCR = 0U;
24003880:	687b      	ldr	r3, [r7, #4]
24003882:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003884:	2200      	movs	r2, #0
24003886:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24003888:	687b      	ldr	r3, [r7, #4]
2400388a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400388c:	687a      	ldr	r2, [r7, #4]
2400388e:	6e92      	ldr	r2, [r2, #104]	; 0x68
24003890:	605a      	str	r2, [r3, #4]
    }

    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
24003892:	687b      	ldr	r3, [r7, #4]
24003894:	685b      	ldr	r3, [r3, #4]
24003896:	2b00      	cmp	r3, #0
24003898:	d00f      	beq.n	240038ba <HAL_DMA_DeInit+0x316>
2400389a:	687b      	ldr	r3, [r7, #4]
2400389c:	685b      	ldr	r3, [r3, #4]
2400389e:	2b08      	cmp	r3, #8
240038a0:	d80b      	bhi.n	240038ba <HAL_DMA_DeInit+0x316>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
240038a2:	6878      	ldr	r0, [r7, #4]
240038a4:	f003 f84c 	bl	24006940 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
240038a8:	687b      	ldr	r3, [r7, #4]
240038aa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240038ac:	2200      	movs	r2, #0
240038ae:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
240038b0:	687b      	ldr	r3, [r7, #4]
240038b2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240038b4:	687a      	ldr	r2, [r7, #4]
240038b6:	6f52      	ldr	r2, [r2, #116]	; 0x74
240038b8:	605a      	str	r2, [r3, #4]
    }

    hdma->DMAmuxRequestGen = 0U;
240038ba:	687b      	ldr	r3, [r7, #4]
240038bc:	2200      	movs	r2, #0
240038be:	66da      	str	r2, [r3, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatus = 0U;
240038c0:	687b      	ldr	r3, [r7, #4]
240038c2:	2200      	movs	r2, #0
240038c4:	671a      	str	r2, [r3, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 0U;
240038c6:	687b      	ldr	r3, [r7, #4]
240038c8:	2200      	movs	r2, #0
240038ca:	675a      	str	r2, [r3, #116]	; 0x74
  }


  /* Clean callbacks */
  hdma->XferCpltCallback       = NULL;
240038cc:	687b      	ldr	r3, [r7, #4]
240038ce:	2200      	movs	r2, #0
240038d0:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback   = NULL;
240038d2:	687b      	ldr	r3, [r7, #4]
240038d4:	2200      	movs	r2, #0
240038d6:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback     = NULL;
240038d8:	687b      	ldr	r3, [r7, #4]
240038da:	2200      	movs	r2, #0
240038dc:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
240038de:	687b      	ldr	r3, [r7, #4]
240038e0:	2200      	movs	r2, #0
240038e2:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback      = NULL;
240038e4:	687b      	ldr	r3, [r7, #4]
240038e6:	2200      	movs	r2, #0
240038e8:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback      = NULL;
240038ea:	687b      	ldr	r3, [r7, #4]
240038ec:	2200      	movs	r2, #0
240038ee:	651a      	str	r2, [r3, #80]	; 0x50

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
240038f0:	687b      	ldr	r3, [r7, #4]
240038f2:	2200      	movs	r2, #0
240038f4:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
240038f6:	687b      	ldr	r3, [r7, #4]
240038f8:	2200      	movs	r2, #0
240038fa:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
240038fe:	687b      	ldr	r3, [r7, #4]
24003900:	2200      	movs	r2, #0
24003902:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
24003906:	2300      	movs	r3, #0
}
24003908:	4618      	mov	r0, r3
2400390a:	3710      	adds	r7, #16
2400390c:	46bd      	mov	sp, r7
2400390e:	bd80      	pop	{r7, pc}

24003910 <HAL_DMA_Start>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24003910:	b580      	push	{r7, lr}
24003912:	b086      	sub	sp, #24
24003914:	af00      	add	r7, sp, #0
24003916:	60f8      	str	r0, [r7, #12]
24003918:	60b9      	str	r1, [r7, #8]
2400391a:	607a      	str	r2, [r7, #4]
2400391c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400391e:	2300      	movs	r3, #0
24003920:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24003922:	68fb      	ldr	r3, [r7, #12]
24003924:	2b00      	cmp	r3, #0
24003926:	d101      	bne.n	2400392c <HAL_DMA_Start+0x1c>
  {
    return HAL_ERROR;
24003928:	2301      	movs	r3, #1
2400392a:	e0ec      	b.n	24003b06 <HAL_DMA_Start+0x1f6>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
2400392c:	68fb      	ldr	r3, [r7, #12]
2400392e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24003932:	2b01      	cmp	r3, #1
24003934:	d101      	bne.n	2400393a <HAL_DMA_Start+0x2a>
24003936:	2302      	movs	r3, #2
24003938:	e0e5      	b.n	24003b06 <HAL_DMA_Start+0x1f6>
2400393a:	68fb      	ldr	r3, [r7, #12]
2400393c:	2201      	movs	r2, #1
2400393e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24003942:	68fb      	ldr	r3, [r7, #12]
24003944:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24003948:	b2db      	uxtb	r3, r3
2400394a:	2b01      	cmp	r3, #1
2400394c:	f040 80d0 	bne.w	24003af0 <HAL_DMA_Start+0x1e0>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24003950:	68fb      	ldr	r3, [r7, #12]
24003952:	2202      	movs	r2, #2
24003954:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24003958:	68fb      	ldr	r3, [r7, #12]
2400395a:	2200      	movs	r2, #0
2400395c:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
2400395e:	68fb      	ldr	r3, [r7, #12]
24003960:	681b      	ldr	r3, [r3, #0]
24003962:	4a6b      	ldr	r2, [pc, #428]	; (24003b10 <HAL_DMA_Start+0x200>)
24003964:	4293      	cmp	r3, r2
24003966:	d04a      	beq.n	240039fe <HAL_DMA_Start+0xee>
24003968:	68fb      	ldr	r3, [r7, #12]
2400396a:	681b      	ldr	r3, [r3, #0]
2400396c:	4a69      	ldr	r2, [pc, #420]	; (24003b14 <HAL_DMA_Start+0x204>)
2400396e:	4293      	cmp	r3, r2
24003970:	d045      	beq.n	240039fe <HAL_DMA_Start+0xee>
24003972:	68fb      	ldr	r3, [r7, #12]
24003974:	681b      	ldr	r3, [r3, #0]
24003976:	4a68      	ldr	r2, [pc, #416]	; (24003b18 <HAL_DMA_Start+0x208>)
24003978:	4293      	cmp	r3, r2
2400397a:	d040      	beq.n	240039fe <HAL_DMA_Start+0xee>
2400397c:	68fb      	ldr	r3, [r7, #12]
2400397e:	681b      	ldr	r3, [r3, #0]
24003980:	4a66      	ldr	r2, [pc, #408]	; (24003b1c <HAL_DMA_Start+0x20c>)
24003982:	4293      	cmp	r3, r2
24003984:	d03b      	beq.n	240039fe <HAL_DMA_Start+0xee>
24003986:	68fb      	ldr	r3, [r7, #12]
24003988:	681b      	ldr	r3, [r3, #0]
2400398a:	4a65      	ldr	r2, [pc, #404]	; (24003b20 <HAL_DMA_Start+0x210>)
2400398c:	4293      	cmp	r3, r2
2400398e:	d036      	beq.n	240039fe <HAL_DMA_Start+0xee>
24003990:	68fb      	ldr	r3, [r7, #12]
24003992:	681b      	ldr	r3, [r3, #0]
24003994:	4a63      	ldr	r2, [pc, #396]	; (24003b24 <HAL_DMA_Start+0x214>)
24003996:	4293      	cmp	r3, r2
24003998:	d031      	beq.n	240039fe <HAL_DMA_Start+0xee>
2400399a:	68fb      	ldr	r3, [r7, #12]
2400399c:	681b      	ldr	r3, [r3, #0]
2400399e:	4a62      	ldr	r2, [pc, #392]	; (24003b28 <HAL_DMA_Start+0x218>)
240039a0:	4293      	cmp	r3, r2
240039a2:	d02c      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039a4:	68fb      	ldr	r3, [r7, #12]
240039a6:	681b      	ldr	r3, [r3, #0]
240039a8:	4a60      	ldr	r2, [pc, #384]	; (24003b2c <HAL_DMA_Start+0x21c>)
240039aa:	4293      	cmp	r3, r2
240039ac:	d027      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039ae:	68fb      	ldr	r3, [r7, #12]
240039b0:	681b      	ldr	r3, [r3, #0]
240039b2:	4a5f      	ldr	r2, [pc, #380]	; (24003b30 <HAL_DMA_Start+0x220>)
240039b4:	4293      	cmp	r3, r2
240039b6:	d022      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039b8:	68fb      	ldr	r3, [r7, #12]
240039ba:	681b      	ldr	r3, [r3, #0]
240039bc:	4a5d      	ldr	r2, [pc, #372]	; (24003b34 <HAL_DMA_Start+0x224>)
240039be:	4293      	cmp	r3, r2
240039c0:	d01d      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039c2:	68fb      	ldr	r3, [r7, #12]
240039c4:	681b      	ldr	r3, [r3, #0]
240039c6:	4a5c      	ldr	r2, [pc, #368]	; (24003b38 <HAL_DMA_Start+0x228>)
240039c8:	4293      	cmp	r3, r2
240039ca:	d018      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039cc:	68fb      	ldr	r3, [r7, #12]
240039ce:	681b      	ldr	r3, [r3, #0]
240039d0:	4a5a      	ldr	r2, [pc, #360]	; (24003b3c <HAL_DMA_Start+0x22c>)
240039d2:	4293      	cmp	r3, r2
240039d4:	d013      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039d6:	68fb      	ldr	r3, [r7, #12]
240039d8:	681b      	ldr	r3, [r3, #0]
240039da:	4a59      	ldr	r2, [pc, #356]	; (24003b40 <HAL_DMA_Start+0x230>)
240039dc:	4293      	cmp	r3, r2
240039de:	d00e      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039e0:	68fb      	ldr	r3, [r7, #12]
240039e2:	681b      	ldr	r3, [r3, #0]
240039e4:	4a57      	ldr	r2, [pc, #348]	; (24003b44 <HAL_DMA_Start+0x234>)
240039e6:	4293      	cmp	r3, r2
240039e8:	d009      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039ea:	68fb      	ldr	r3, [r7, #12]
240039ec:	681b      	ldr	r3, [r3, #0]
240039ee:	4a56      	ldr	r2, [pc, #344]	; (24003b48 <HAL_DMA_Start+0x238>)
240039f0:	4293      	cmp	r3, r2
240039f2:	d004      	beq.n	240039fe <HAL_DMA_Start+0xee>
240039f4:	68fb      	ldr	r3, [r7, #12]
240039f6:	681b      	ldr	r3, [r3, #0]
240039f8:	4a54      	ldr	r2, [pc, #336]	; (24003b4c <HAL_DMA_Start+0x23c>)
240039fa:	4293      	cmp	r3, r2
240039fc:	d108      	bne.n	24003a10 <HAL_DMA_Start+0x100>
240039fe:	68fb      	ldr	r3, [r7, #12]
24003a00:	681b      	ldr	r3, [r3, #0]
24003a02:	681a      	ldr	r2, [r3, #0]
24003a04:	68fb      	ldr	r3, [r7, #12]
24003a06:	681b      	ldr	r3, [r3, #0]
24003a08:	f022 0201 	bic.w	r2, r2, #1
24003a0c:	601a      	str	r2, [r3, #0]
24003a0e:	e007      	b.n	24003a20 <HAL_DMA_Start+0x110>
24003a10:	68fb      	ldr	r3, [r7, #12]
24003a12:	681b      	ldr	r3, [r3, #0]
24003a14:	681a      	ldr	r2, [r3, #0]
24003a16:	68fb      	ldr	r3, [r7, #12]
24003a18:	681b      	ldr	r3, [r3, #0]
24003a1a:	f022 0201 	bic.w	r2, r2, #1
24003a1e:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
24003a20:	683b      	ldr	r3, [r7, #0]
24003a22:	687a      	ldr	r2, [r7, #4]
24003a24:	68b9      	ldr	r1, [r7, #8]
24003a26:	68f8      	ldr	r0, [r7, #12]
24003a28:	f002 fc16 	bl	24006258 <DMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
24003a2c:	68fb      	ldr	r3, [r7, #12]
24003a2e:	681b      	ldr	r3, [r3, #0]
24003a30:	4a37      	ldr	r2, [pc, #220]	; (24003b10 <HAL_DMA_Start+0x200>)
24003a32:	4293      	cmp	r3, r2
24003a34:	d04a      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a36:	68fb      	ldr	r3, [r7, #12]
24003a38:	681b      	ldr	r3, [r3, #0]
24003a3a:	4a36      	ldr	r2, [pc, #216]	; (24003b14 <HAL_DMA_Start+0x204>)
24003a3c:	4293      	cmp	r3, r2
24003a3e:	d045      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a40:	68fb      	ldr	r3, [r7, #12]
24003a42:	681b      	ldr	r3, [r3, #0]
24003a44:	4a34      	ldr	r2, [pc, #208]	; (24003b18 <HAL_DMA_Start+0x208>)
24003a46:	4293      	cmp	r3, r2
24003a48:	d040      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a4a:	68fb      	ldr	r3, [r7, #12]
24003a4c:	681b      	ldr	r3, [r3, #0]
24003a4e:	4a33      	ldr	r2, [pc, #204]	; (24003b1c <HAL_DMA_Start+0x20c>)
24003a50:	4293      	cmp	r3, r2
24003a52:	d03b      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a54:	68fb      	ldr	r3, [r7, #12]
24003a56:	681b      	ldr	r3, [r3, #0]
24003a58:	4a31      	ldr	r2, [pc, #196]	; (24003b20 <HAL_DMA_Start+0x210>)
24003a5a:	4293      	cmp	r3, r2
24003a5c:	d036      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a5e:	68fb      	ldr	r3, [r7, #12]
24003a60:	681b      	ldr	r3, [r3, #0]
24003a62:	4a30      	ldr	r2, [pc, #192]	; (24003b24 <HAL_DMA_Start+0x214>)
24003a64:	4293      	cmp	r3, r2
24003a66:	d031      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a68:	68fb      	ldr	r3, [r7, #12]
24003a6a:	681b      	ldr	r3, [r3, #0]
24003a6c:	4a2e      	ldr	r2, [pc, #184]	; (24003b28 <HAL_DMA_Start+0x218>)
24003a6e:	4293      	cmp	r3, r2
24003a70:	d02c      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a72:	68fb      	ldr	r3, [r7, #12]
24003a74:	681b      	ldr	r3, [r3, #0]
24003a76:	4a2d      	ldr	r2, [pc, #180]	; (24003b2c <HAL_DMA_Start+0x21c>)
24003a78:	4293      	cmp	r3, r2
24003a7a:	d027      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a7c:	68fb      	ldr	r3, [r7, #12]
24003a7e:	681b      	ldr	r3, [r3, #0]
24003a80:	4a2b      	ldr	r2, [pc, #172]	; (24003b30 <HAL_DMA_Start+0x220>)
24003a82:	4293      	cmp	r3, r2
24003a84:	d022      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a86:	68fb      	ldr	r3, [r7, #12]
24003a88:	681b      	ldr	r3, [r3, #0]
24003a8a:	4a2a      	ldr	r2, [pc, #168]	; (24003b34 <HAL_DMA_Start+0x224>)
24003a8c:	4293      	cmp	r3, r2
24003a8e:	d01d      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a90:	68fb      	ldr	r3, [r7, #12]
24003a92:	681b      	ldr	r3, [r3, #0]
24003a94:	4a28      	ldr	r2, [pc, #160]	; (24003b38 <HAL_DMA_Start+0x228>)
24003a96:	4293      	cmp	r3, r2
24003a98:	d018      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003a9a:	68fb      	ldr	r3, [r7, #12]
24003a9c:	681b      	ldr	r3, [r3, #0]
24003a9e:	4a27      	ldr	r2, [pc, #156]	; (24003b3c <HAL_DMA_Start+0x22c>)
24003aa0:	4293      	cmp	r3, r2
24003aa2:	d013      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003aa4:	68fb      	ldr	r3, [r7, #12]
24003aa6:	681b      	ldr	r3, [r3, #0]
24003aa8:	4a25      	ldr	r2, [pc, #148]	; (24003b40 <HAL_DMA_Start+0x230>)
24003aaa:	4293      	cmp	r3, r2
24003aac:	d00e      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003aae:	68fb      	ldr	r3, [r7, #12]
24003ab0:	681b      	ldr	r3, [r3, #0]
24003ab2:	4a24      	ldr	r2, [pc, #144]	; (24003b44 <HAL_DMA_Start+0x234>)
24003ab4:	4293      	cmp	r3, r2
24003ab6:	d009      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003ab8:	68fb      	ldr	r3, [r7, #12]
24003aba:	681b      	ldr	r3, [r3, #0]
24003abc:	4a22      	ldr	r2, [pc, #136]	; (24003b48 <HAL_DMA_Start+0x238>)
24003abe:	4293      	cmp	r3, r2
24003ac0:	d004      	beq.n	24003acc <HAL_DMA_Start+0x1bc>
24003ac2:	68fb      	ldr	r3, [r7, #12]
24003ac4:	681b      	ldr	r3, [r3, #0]
24003ac6:	4a21      	ldr	r2, [pc, #132]	; (24003b4c <HAL_DMA_Start+0x23c>)
24003ac8:	4293      	cmp	r3, r2
24003aca:	d108      	bne.n	24003ade <HAL_DMA_Start+0x1ce>
24003acc:	68fb      	ldr	r3, [r7, #12]
24003ace:	681b      	ldr	r3, [r3, #0]
24003ad0:	681a      	ldr	r2, [r3, #0]
24003ad2:	68fb      	ldr	r3, [r7, #12]
24003ad4:	681b      	ldr	r3, [r3, #0]
24003ad6:	f042 0201 	orr.w	r2, r2, #1
24003ada:	601a      	str	r2, [r3, #0]
24003adc:	e012      	b.n	24003b04 <HAL_DMA_Start+0x1f4>
24003ade:	68fb      	ldr	r3, [r7, #12]
24003ae0:	681b      	ldr	r3, [r3, #0]
24003ae2:	681a      	ldr	r2, [r3, #0]
24003ae4:	68fb      	ldr	r3, [r7, #12]
24003ae6:	681b      	ldr	r3, [r3, #0]
24003ae8:	f042 0201 	orr.w	r2, r2, #1
24003aec:	601a      	str	r2, [r3, #0]
24003aee:	e009      	b.n	24003b04 <HAL_DMA_Start+0x1f4>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24003af0:	68fb      	ldr	r3, [r7, #12]
24003af2:	f44f 6200 	mov.w	r2, #2048	; 0x800
24003af6:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hdma);
24003af8:	68fb      	ldr	r3, [r7, #12]
24003afa:	2200      	movs	r2, #0
24003afc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Return error status */
    status = HAL_ERROR;
24003b00:	2301      	movs	r3, #1
24003b02:	75fb      	strb	r3, [r7, #23]
  }
  return status;
24003b04:	7dfb      	ldrb	r3, [r7, #23]
}
24003b06:	4618      	mov	r0, r3
24003b08:	3718      	adds	r7, #24
24003b0a:	46bd      	mov	sp, r7
24003b0c:	bd80      	pop	{r7, pc}
24003b0e:	bf00      	nop
24003b10:	40020010 	.word	0x40020010
24003b14:	40020028 	.word	0x40020028
24003b18:	40020040 	.word	0x40020040
24003b1c:	40020058 	.word	0x40020058
24003b20:	40020070 	.word	0x40020070
24003b24:	40020088 	.word	0x40020088
24003b28:	400200a0 	.word	0x400200a0
24003b2c:	400200b8 	.word	0x400200b8
24003b30:	40020410 	.word	0x40020410
24003b34:	40020428 	.word	0x40020428
24003b38:	40020440 	.word	0x40020440
24003b3c:	40020458 	.word	0x40020458
24003b40:	40020470 	.word	0x40020470
24003b44:	40020488 	.word	0x40020488
24003b48:	400204a0 	.word	0x400204a0
24003b4c:	400204b8 	.word	0x400204b8

24003b50 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24003b50:	b580      	push	{r7, lr}
24003b52:	b086      	sub	sp, #24
24003b54:	af00      	add	r7, sp, #0
24003b56:	60f8      	str	r0, [r7, #12]
24003b58:	60b9      	str	r1, [r7, #8]
24003b5a:	607a      	str	r2, [r7, #4]
24003b5c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24003b5e:	2300      	movs	r3, #0
24003b60:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24003b62:	68fb      	ldr	r3, [r7, #12]
24003b64:	2b00      	cmp	r3, #0
24003b66:	d101      	bne.n	24003b6c <HAL_DMA_Start_IT+0x1c>
  {
    return HAL_ERROR;
24003b68:	2301      	movs	r3, #1
24003b6a:	e226      	b.n	24003fba <HAL_DMA_Start_IT+0x46a>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24003b6c:	68fb      	ldr	r3, [r7, #12]
24003b6e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24003b72:	2b01      	cmp	r3, #1
24003b74:	d101      	bne.n	24003b7a <HAL_DMA_Start_IT+0x2a>
24003b76:	2302      	movs	r3, #2
24003b78:	e21f      	b.n	24003fba <HAL_DMA_Start_IT+0x46a>
24003b7a:	68fb      	ldr	r3, [r7, #12]
24003b7c:	2201      	movs	r2, #1
24003b7e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24003b82:	68fb      	ldr	r3, [r7, #12]
24003b84:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24003b88:	b2db      	uxtb	r3, r3
24003b8a:	2b01      	cmp	r3, #1
24003b8c:	f040 820a 	bne.w	24003fa4 <HAL_DMA_Start_IT+0x454>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24003b90:	68fb      	ldr	r3, [r7, #12]
24003b92:	2202      	movs	r2, #2
24003b94:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24003b98:	68fb      	ldr	r3, [r7, #12]
24003b9a:	2200      	movs	r2, #0
24003b9c:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
24003b9e:	68fb      	ldr	r3, [r7, #12]
24003ba0:	681b      	ldr	r3, [r3, #0]
24003ba2:	4a68      	ldr	r2, [pc, #416]	; (24003d44 <HAL_DMA_Start_IT+0x1f4>)
24003ba4:	4293      	cmp	r3, r2
24003ba6:	d04a      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003ba8:	68fb      	ldr	r3, [r7, #12]
24003baa:	681b      	ldr	r3, [r3, #0]
24003bac:	4a66      	ldr	r2, [pc, #408]	; (24003d48 <HAL_DMA_Start_IT+0x1f8>)
24003bae:	4293      	cmp	r3, r2
24003bb0:	d045      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003bb2:	68fb      	ldr	r3, [r7, #12]
24003bb4:	681b      	ldr	r3, [r3, #0]
24003bb6:	4a65      	ldr	r2, [pc, #404]	; (24003d4c <HAL_DMA_Start_IT+0x1fc>)
24003bb8:	4293      	cmp	r3, r2
24003bba:	d040      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003bbc:	68fb      	ldr	r3, [r7, #12]
24003bbe:	681b      	ldr	r3, [r3, #0]
24003bc0:	4a63      	ldr	r2, [pc, #396]	; (24003d50 <HAL_DMA_Start_IT+0x200>)
24003bc2:	4293      	cmp	r3, r2
24003bc4:	d03b      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003bc6:	68fb      	ldr	r3, [r7, #12]
24003bc8:	681b      	ldr	r3, [r3, #0]
24003bca:	4a62      	ldr	r2, [pc, #392]	; (24003d54 <HAL_DMA_Start_IT+0x204>)
24003bcc:	4293      	cmp	r3, r2
24003bce:	d036      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003bd0:	68fb      	ldr	r3, [r7, #12]
24003bd2:	681b      	ldr	r3, [r3, #0]
24003bd4:	4a60      	ldr	r2, [pc, #384]	; (24003d58 <HAL_DMA_Start_IT+0x208>)
24003bd6:	4293      	cmp	r3, r2
24003bd8:	d031      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003bda:	68fb      	ldr	r3, [r7, #12]
24003bdc:	681b      	ldr	r3, [r3, #0]
24003bde:	4a5f      	ldr	r2, [pc, #380]	; (24003d5c <HAL_DMA_Start_IT+0x20c>)
24003be0:	4293      	cmp	r3, r2
24003be2:	d02c      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003be4:	68fb      	ldr	r3, [r7, #12]
24003be6:	681b      	ldr	r3, [r3, #0]
24003be8:	4a5d      	ldr	r2, [pc, #372]	; (24003d60 <HAL_DMA_Start_IT+0x210>)
24003bea:	4293      	cmp	r3, r2
24003bec:	d027      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003bee:	68fb      	ldr	r3, [r7, #12]
24003bf0:	681b      	ldr	r3, [r3, #0]
24003bf2:	4a5c      	ldr	r2, [pc, #368]	; (24003d64 <HAL_DMA_Start_IT+0x214>)
24003bf4:	4293      	cmp	r3, r2
24003bf6:	d022      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003bf8:	68fb      	ldr	r3, [r7, #12]
24003bfa:	681b      	ldr	r3, [r3, #0]
24003bfc:	4a5a      	ldr	r2, [pc, #360]	; (24003d68 <HAL_DMA_Start_IT+0x218>)
24003bfe:	4293      	cmp	r3, r2
24003c00:	d01d      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003c02:	68fb      	ldr	r3, [r7, #12]
24003c04:	681b      	ldr	r3, [r3, #0]
24003c06:	4a59      	ldr	r2, [pc, #356]	; (24003d6c <HAL_DMA_Start_IT+0x21c>)
24003c08:	4293      	cmp	r3, r2
24003c0a:	d018      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003c0c:	68fb      	ldr	r3, [r7, #12]
24003c0e:	681b      	ldr	r3, [r3, #0]
24003c10:	4a57      	ldr	r2, [pc, #348]	; (24003d70 <HAL_DMA_Start_IT+0x220>)
24003c12:	4293      	cmp	r3, r2
24003c14:	d013      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003c16:	68fb      	ldr	r3, [r7, #12]
24003c18:	681b      	ldr	r3, [r3, #0]
24003c1a:	4a56      	ldr	r2, [pc, #344]	; (24003d74 <HAL_DMA_Start_IT+0x224>)
24003c1c:	4293      	cmp	r3, r2
24003c1e:	d00e      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003c20:	68fb      	ldr	r3, [r7, #12]
24003c22:	681b      	ldr	r3, [r3, #0]
24003c24:	4a54      	ldr	r2, [pc, #336]	; (24003d78 <HAL_DMA_Start_IT+0x228>)
24003c26:	4293      	cmp	r3, r2
24003c28:	d009      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003c2a:	68fb      	ldr	r3, [r7, #12]
24003c2c:	681b      	ldr	r3, [r3, #0]
24003c2e:	4a53      	ldr	r2, [pc, #332]	; (24003d7c <HAL_DMA_Start_IT+0x22c>)
24003c30:	4293      	cmp	r3, r2
24003c32:	d004      	beq.n	24003c3e <HAL_DMA_Start_IT+0xee>
24003c34:	68fb      	ldr	r3, [r7, #12]
24003c36:	681b      	ldr	r3, [r3, #0]
24003c38:	4a51      	ldr	r2, [pc, #324]	; (24003d80 <HAL_DMA_Start_IT+0x230>)
24003c3a:	4293      	cmp	r3, r2
24003c3c:	d108      	bne.n	24003c50 <HAL_DMA_Start_IT+0x100>
24003c3e:	68fb      	ldr	r3, [r7, #12]
24003c40:	681b      	ldr	r3, [r3, #0]
24003c42:	681a      	ldr	r2, [r3, #0]
24003c44:	68fb      	ldr	r3, [r7, #12]
24003c46:	681b      	ldr	r3, [r3, #0]
24003c48:	f022 0201 	bic.w	r2, r2, #1
24003c4c:	601a      	str	r2, [r3, #0]
24003c4e:	e007      	b.n	24003c60 <HAL_DMA_Start_IT+0x110>
24003c50:	68fb      	ldr	r3, [r7, #12]
24003c52:	681b      	ldr	r3, [r3, #0]
24003c54:	681a      	ldr	r2, [r3, #0]
24003c56:	68fb      	ldr	r3, [r7, #12]
24003c58:	681b      	ldr	r3, [r3, #0]
24003c5a:	f022 0201 	bic.w	r2, r2, #1
24003c5e:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
24003c60:	683b      	ldr	r3, [r7, #0]
24003c62:	687a      	ldr	r2, [r7, #4]
24003c64:	68b9      	ldr	r1, [r7, #8]
24003c66:	68f8      	ldr	r0, [r7, #12]
24003c68:	f002 faf6 	bl	24006258 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003c6c:	68fb      	ldr	r3, [r7, #12]
24003c6e:	681b      	ldr	r3, [r3, #0]
24003c70:	4a34      	ldr	r2, [pc, #208]	; (24003d44 <HAL_DMA_Start_IT+0x1f4>)
24003c72:	4293      	cmp	r3, r2
24003c74:	d04a      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003c76:	68fb      	ldr	r3, [r7, #12]
24003c78:	681b      	ldr	r3, [r3, #0]
24003c7a:	4a33      	ldr	r2, [pc, #204]	; (24003d48 <HAL_DMA_Start_IT+0x1f8>)
24003c7c:	4293      	cmp	r3, r2
24003c7e:	d045      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003c80:	68fb      	ldr	r3, [r7, #12]
24003c82:	681b      	ldr	r3, [r3, #0]
24003c84:	4a31      	ldr	r2, [pc, #196]	; (24003d4c <HAL_DMA_Start_IT+0x1fc>)
24003c86:	4293      	cmp	r3, r2
24003c88:	d040      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003c8a:	68fb      	ldr	r3, [r7, #12]
24003c8c:	681b      	ldr	r3, [r3, #0]
24003c8e:	4a30      	ldr	r2, [pc, #192]	; (24003d50 <HAL_DMA_Start_IT+0x200>)
24003c90:	4293      	cmp	r3, r2
24003c92:	d03b      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003c94:	68fb      	ldr	r3, [r7, #12]
24003c96:	681b      	ldr	r3, [r3, #0]
24003c98:	4a2e      	ldr	r2, [pc, #184]	; (24003d54 <HAL_DMA_Start_IT+0x204>)
24003c9a:	4293      	cmp	r3, r2
24003c9c:	d036      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003c9e:	68fb      	ldr	r3, [r7, #12]
24003ca0:	681b      	ldr	r3, [r3, #0]
24003ca2:	4a2d      	ldr	r2, [pc, #180]	; (24003d58 <HAL_DMA_Start_IT+0x208>)
24003ca4:	4293      	cmp	r3, r2
24003ca6:	d031      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003ca8:	68fb      	ldr	r3, [r7, #12]
24003caa:	681b      	ldr	r3, [r3, #0]
24003cac:	4a2b      	ldr	r2, [pc, #172]	; (24003d5c <HAL_DMA_Start_IT+0x20c>)
24003cae:	4293      	cmp	r3, r2
24003cb0:	d02c      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003cb2:	68fb      	ldr	r3, [r7, #12]
24003cb4:	681b      	ldr	r3, [r3, #0]
24003cb6:	4a2a      	ldr	r2, [pc, #168]	; (24003d60 <HAL_DMA_Start_IT+0x210>)
24003cb8:	4293      	cmp	r3, r2
24003cba:	d027      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003cbc:	68fb      	ldr	r3, [r7, #12]
24003cbe:	681b      	ldr	r3, [r3, #0]
24003cc0:	4a28      	ldr	r2, [pc, #160]	; (24003d64 <HAL_DMA_Start_IT+0x214>)
24003cc2:	4293      	cmp	r3, r2
24003cc4:	d022      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003cc6:	68fb      	ldr	r3, [r7, #12]
24003cc8:	681b      	ldr	r3, [r3, #0]
24003cca:	4a27      	ldr	r2, [pc, #156]	; (24003d68 <HAL_DMA_Start_IT+0x218>)
24003ccc:	4293      	cmp	r3, r2
24003cce:	d01d      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003cd0:	68fb      	ldr	r3, [r7, #12]
24003cd2:	681b      	ldr	r3, [r3, #0]
24003cd4:	4a25      	ldr	r2, [pc, #148]	; (24003d6c <HAL_DMA_Start_IT+0x21c>)
24003cd6:	4293      	cmp	r3, r2
24003cd8:	d018      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003cda:	68fb      	ldr	r3, [r7, #12]
24003cdc:	681b      	ldr	r3, [r3, #0]
24003cde:	4a24      	ldr	r2, [pc, #144]	; (24003d70 <HAL_DMA_Start_IT+0x220>)
24003ce0:	4293      	cmp	r3, r2
24003ce2:	d013      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003ce4:	68fb      	ldr	r3, [r7, #12]
24003ce6:	681b      	ldr	r3, [r3, #0]
24003ce8:	4a22      	ldr	r2, [pc, #136]	; (24003d74 <HAL_DMA_Start_IT+0x224>)
24003cea:	4293      	cmp	r3, r2
24003cec:	d00e      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003cee:	68fb      	ldr	r3, [r7, #12]
24003cf0:	681b      	ldr	r3, [r3, #0]
24003cf2:	4a21      	ldr	r2, [pc, #132]	; (24003d78 <HAL_DMA_Start_IT+0x228>)
24003cf4:	4293      	cmp	r3, r2
24003cf6:	d009      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003cf8:	68fb      	ldr	r3, [r7, #12]
24003cfa:	681b      	ldr	r3, [r3, #0]
24003cfc:	4a1f      	ldr	r2, [pc, #124]	; (24003d7c <HAL_DMA_Start_IT+0x22c>)
24003cfe:	4293      	cmp	r3, r2
24003d00:	d004      	beq.n	24003d0c <HAL_DMA_Start_IT+0x1bc>
24003d02:	68fb      	ldr	r3, [r7, #12]
24003d04:	681b      	ldr	r3, [r3, #0]
24003d06:	4a1e      	ldr	r2, [pc, #120]	; (24003d80 <HAL_DMA_Start_IT+0x230>)
24003d08:	4293      	cmp	r3, r2
24003d0a:	d101      	bne.n	24003d10 <HAL_DMA_Start_IT+0x1c0>
24003d0c:	2301      	movs	r3, #1
24003d0e:	e000      	b.n	24003d12 <HAL_DMA_Start_IT+0x1c2>
24003d10:	2300      	movs	r3, #0
24003d12:	2b00      	cmp	r3, #0
24003d14:	d036      	beq.n	24003d84 <HAL_DMA_Start_IT+0x234>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
24003d16:	68fb      	ldr	r3, [r7, #12]
24003d18:	681b      	ldr	r3, [r3, #0]
24003d1a:	681b      	ldr	r3, [r3, #0]
24003d1c:	f023 021e 	bic.w	r2, r3, #30
24003d20:	68fb      	ldr	r3, [r7, #12]
24003d22:	681b      	ldr	r3, [r3, #0]
24003d24:	f042 0216 	orr.w	r2, r2, #22
24003d28:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
24003d2a:	68fb      	ldr	r3, [r7, #12]
24003d2c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24003d2e:	2b00      	cmp	r3, #0
24003d30:	d03e      	beq.n	24003db0 <HAL_DMA_Start_IT+0x260>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
24003d32:	68fb      	ldr	r3, [r7, #12]
24003d34:	681b      	ldr	r3, [r3, #0]
24003d36:	681a      	ldr	r2, [r3, #0]
24003d38:	68fb      	ldr	r3, [r7, #12]
24003d3a:	681b      	ldr	r3, [r3, #0]
24003d3c:	f042 0208 	orr.w	r2, r2, #8
24003d40:	601a      	str	r2, [r3, #0]
24003d42:	e035      	b.n	24003db0 <HAL_DMA_Start_IT+0x260>
24003d44:	40020010 	.word	0x40020010
24003d48:	40020028 	.word	0x40020028
24003d4c:	40020040 	.word	0x40020040
24003d50:	40020058 	.word	0x40020058
24003d54:	40020070 	.word	0x40020070
24003d58:	40020088 	.word	0x40020088
24003d5c:	400200a0 	.word	0x400200a0
24003d60:	400200b8 	.word	0x400200b8
24003d64:	40020410 	.word	0x40020410
24003d68:	40020428 	.word	0x40020428
24003d6c:	40020440 	.word	0x40020440
24003d70:	40020458 	.word	0x40020458
24003d74:	40020470 	.word	0x40020470
24003d78:	40020488 	.word	0x40020488
24003d7c:	400204a0 	.word	0x400204a0
24003d80:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24003d84:	68fb      	ldr	r3, [r7, #12]
24003d86:	681b      	ldr	r3, [r3, #0]
24003d88:	681b      	ldr	r3, [r3, #0]
24003d8a:	f023 020e 	bic.w	r2, r3, #14
24003d8e:	68fb      	ldr	r3, [r7, #12]
24003d90:	681b      	ldr	r3, [r3, #0]
24003d92:	f042 020a 	orr.w	r2, r2, #10
24003d96:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
24003d98:	68fb      	ldr	r3, [r7, #12]
24003d9a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24003d9c:	2b00      	cmp	r3, #0
24003d9e:	d007      	beq.n	24003db0 <HAL_DMA_Start_IT+0x260>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
24003da0:	68fb      	ldr	r3, [r7, #12]
24003da2:	681b      	ldr	r3, [r3, #0]
24003da4:	681a      	ldr	r2, [r3, #0]
24003da6:	68fb      	ldr	r3, [r7, #12]
24003da8:	681b      	ldr	r3, [r3, #0]
24003daa:	f042 0204 	orr.w	r2, r2, #4
24003dae:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24003db0:	68fb      	ldr	r3, [r7, #12]
24003db2:	681b      	ldr	r3, [r3, #0]
24003db4:	4a83      	ldr	r2, [pc, #524]	; (24003fc4 <HAL_DMA_Start_IT+0x474>)
24003db6:	4293      	cmp	r3, r2
24003db8:	d072      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003dba:	68fb      	ldr	r3, [r7, #12]
24003dbc:	681b      	ldr	r3, [r3, #0]
24003dbe:	4a82      	ldr	r2, [pc, #520]	; (24003fc8 <HAL_DMA_Start_IT+0x478>)
24003dc0:	4293      	cmp	r3, r2
24003dc2:	d06d      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003dc4:	68fb      	ldr	r3, [r7, #12]
24003dc6:	681b      	ldr	r3, [r3, #0]
24003dc8:	4a80      	ldr	r2, [pc, #512]	; (24003fcc <HAL_DMA_Start_IT+0x47c>)
24003dca:	4293      	cmp	r3, r2
24003dcc:	d068      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003dce:	68fb      	ldr	r3, [r7, #12]
24003dd0:	681b      	ldr	r3, [r3, #0]
24003dd2:	4a7f      	ldr	r2, [pc, #508]	; (24003fd0 <HAL_DMA_Start_IT+0x480>)
24003dd4:	4293      	cmp	r3, r2
24003dd6:	d063      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003dd8:	68fb      	ldr	r3, [r7, #12]
24003dda:	681b      	ldr	r3, [r3, #0]
24003ddc:	4a7d      	ldr	r2, [pc, #500]	; (24003fd4 <HAL_DMA_Start_IT+0x484>)
24003dde:	4293      	cmp	r3, r2
24003de0:	d05e      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003de2:	68fb      	ldr	r3, [r7, #12]
24003de4:	681b      	ldr	r3, [r3, #0]
24003de6:	4a7c      	ldr	r2, [pc, #496]	; (24003fd8 <HAL_DMA_Start_IT+0x488>)
24003de8:	4293      	cmp	r3, r2
24003dea:	d059      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003dec:	68fb      	ldr	r3, [r7, #12]
24003dee:	681b      	ldr	r3, [r3, #0]
24003df0:	4a7a      	ldr	r2, [pc, #488]	; (24003fdc <HAL_DMA_Start_IT+0x48c>)
24003df2:	4293      	cmp	r3, r2
24003df4:	d054      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003df6:	68fb      	ldr	r3, [r7, #12]
24003df8:	681b      	ldr	r3, [r3, #0]
24003dfa:	4a79      	ldr	r2, [pc, #484]	; (24003fe0 <HAL_DMA_Start_IT+0x490>)
24003dfc:	4293      	cmp	r3, r2
24003dfe:	d04f      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e00:	68fb      	ldr	r3, [r7, #12]
24003e02:	681b      	ldr	r3, [r3, #0]
24003e04:	4a77      	ldr	r2, [pc, #476]	; (24003fe4 <HAL_DMA_Start_IT+0x494>)
24003e06:	4293      	cmp	r3, r2
24003e08:	d04a      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e0a:	68fb      	ldr	r3, [r7, #12]
24003e0c:	681b      	ldr	r3, [r3, #0]
24003e0e:	4a76      	ldr	r2, [pc, #472]	; (24003fe8 <HAL_DMA_Start_IT+0x498>)
24003e10:	4293      	cmp	r3, r2
24003e12:	d045      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e14:	68fb      	ldr	r3, [r7, #12]
24003e16:	681b      	ldr	r3, [r3, #0]
24003e18:	4a74      	ldr	r2, [pc, #464]	; (24003fec <HAL_DMA_Start_IT+0x49c>)
24003e1a:	4293      	cmp	r3, r2
24003e1c:	d040      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e1e:	68fb      	ldr	r3, [r7, #12]
24003e20:	681b      	ldr	r3, [r3, #0]
24003e22:	4a73      	ldr	r2, [pc, #460]	; (24003ff0 <HAL_DMA_Start_IT+0x4a0>)
24003e24:	4293      	cmp	r3, r2
24003e26:	d03b      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e28:	68fb      	ldr	r3, [r7, #12]
24003e2a:	681b      	ldr	r3, [r3, #0]
24003e2c:	4a71      	ldr	r2, [pc, #452]	; (24003ff4 <HAL_DMA_Start_IT+0x4a4>)
24003e2e:	4293      	cmp	r3, r2
24003e30:	d036      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e32:	68fb      	ldr	r3, [r7, #12]
24003e34:	681b      	ldr	r3, [r3, #0]
24003e36:	4a70      	ldr	r2, [pc, #448]	; (24003ff8 <HAL_DMA_Start_IT+0x4a8>)
24003e38:	4293      	cmp	r3, r2
24003e3a:	d031      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e3c:	68fb      	ldr	r3, [r7, #12]
24003e3e:	681b      	ldr	r3, [r3, #0]
24003e40:	4a6e      	ldr	r2, [pc, #440]	; (24003ffc <HAL_DMA_Start_IT+0x4ac>)
24003e42:	4293      	cmp	r3, r2
24003e44:	d02c      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e46:	68fb      	ldr	r3, [r7, #12]
24003e48:	681b      	ldr	r3, [r3, #0]
24003e4a:	4a6d      	ldr	r2, [pc, #436]	; (24004000 <HAL_DMA_Start_IT+0x4b0>)
24003e4c:	4293      	cmp	r3, r2
24003e4e:	d027      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e50:	68fb      	ldr	r3, [r7, #12]
24003e52:	681b      	ldr	r3, [r3, #0]
24003e54:	4a6b      	ldr	r2, [pc, #428]	; (24004004 <HAL_DMA_Start_IT+0x4b4>)
24003e56:	4293      	cmp	r3, r2
24003e58:	d022      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e5a:	68fb      	ldr	r3, [r7, #12]
24003e5c:	681b      	ldr	r3, [r3, #0]
24003e5e:	4a6a      	ldr	r2, [pc, #424]	; (24004008 <HAL_DMA_Start_IT+0x4b8>)
24003e60:	4293      	cmp	r3, r2
24003e62:	d01d      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e64:	68fb      	ldr	r3, [r7, #12]
24003e66:	681b      	ldr	r3, [r3, #0]
24003e68:	4a68      	ldr	r2, [pc, #416]	; (2400400c <HAL_DMA_Start_IT+0x4bc>)
24003e6a:	4293      	cmp	r3, r2
24003e6c:	d018      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e6e:	68fb      	ldr	r3, [r7, #12]
24003e70:	681b      	ldr	r3, [r3, #0]
24003e72:	4a67      	ldr	r2, [pc, #412]	; (24004010 <HAL_DMA_Start_IT+0x4c0>)
24003e74:	4293      	cmp	r3, r2
24003e76:	d013      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e78:	68fb      	ldr	r3, [r7, #12]
24003e7a:	681b      	ldr	r3, [r3, #0]
24003e7c:	4a65      	ldr	r2, [pc, #404]	; (24004014 <HAL_DMA_Start_IT+0x4c4>)
24003e7e:	4293      	cmp	r3, r2
24003e80:	d00e      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e82:	68fb      	ldr	r3, [r7, #12]
24003e84:	681b      	ldr	r3, [r3, #0]
24003e86:	4a64      	ldr	r2, [pc, #400]	; (24004018 <HAL_DMA_Start_IT+0x4c8>)
24003e88:	4293      	cmp	r3, r2
24003e8a:	d009      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e8c:	68fb      	ldr	r3, [r7, #12]
24003e8e:	681b      	ldr	r3, [r3, #0]
24003e90:	4a62      	ldr	r2, [pc, #392]	; (2400401c <HAL_DMA_Start_IT+0x4cc>)
24003e92:	4293      	cmp	r3, r2
24003e94:	d004      	beq.n	24003ea0 <HAL_DMA_Start_IT+0x350>
24003e96:	68fb      	ldr	r3, [r7, #12]
24003e98:	681b      	ldr	r3, [r3, #0]
24003e9a:	4a61      	ldr	r2, [pc, #388]	; (24004020 <HAL_DMA_Start_IT+0x4d0>)
24003e9c:	4293      	cmp	r3, r2
24003e9e:	d101      	bne.n	24003ea4 <HAL_DMA_Start_IT+0x354>
24003ea0:	2301      	movs	r3, #1
24003ea2:	e000      	b.n	24003ea6 <HAL_DMA_Start_IT+0x356>
24003ea4:	2300      	movs	r3, #0
24003ea6:	2b00      	cmp	r3, #0
24003ea8:	d01a      	beq.n	24003ee0 <HAL_DMA_Start_IT+0x390>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
24003eaa:	68fb      	ldr	r3, [r7, #12]
24003eac:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003eae:	681b      	ldr	r3, [r3, #0]
24003eb0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24003eb4:	2b00      	cmp	r3, #0
24003eb6:	d007      	beq.n	24003ec8 <HAL_DMA_Start_IT+0x378>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
24003eb8:	68fb      	ldr	r3, [r7, #12]
24003eba:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003ebc:	681a      	ldr	r2, [r3, #0]
24003ebe:	68fb      	ldr	r3, [r7, #12]
24003ec0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003ec2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24003ec6:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
24003ec8:	68fb      	ldr	r3, [r7, #12]
24003eca:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003ecc:	2b00      	cmp	r3, #0
24003ece:	d007      	beq.n	24003ee0 <HAL_DMA_Start_IT+0x390>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
24003ed0:	68fb      	ldr	r3, [r7, #12]
24003ed2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003ed4:	681a      	ldr	r2, [r3, #0]
24003ed6:	68fb      	ldr	r3, [r7, #12]
24003ed8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003eda:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24003ede:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
24003ee0:	68fb      	ldr	r3, [r7, #12]
24003ee2:	681b      	ldr	r3, [r3, #0]
24003ee4:	4a37      	ldr	r2, [pc, #220]	; (24003fc4 <HAL_DMA_Start_IT+0x474>)
24003ee6:	4293      	cmp	r3, r2
24003ee8:	d04a      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003eea:	68fb      	ldr	r3, [r7, #12]
24003eec:	681b      	ldr	r3, [r3, #0]
24003eee:	4a36      	ldr	r2, [pc, #216]	; (24003fc8 <HAL_DMA_Start_IT+0x478>)
24003ef0:	4293      	cmp	r3, r2
24003ef2:	d045      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003ef4:	68fb      	ldr	r3, [r7, #12]
24003ef6:	681b      	ldr	r3, [r3, #0]
24003ef8:	4a34      	ldr	r2, [pc, #208]	; (24003fcc <HAL_DMA_Start_IT+0x47c>)
24003efa:	4293      	cmp	r3, r2
24003efc:	d040      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003efe:	68fb      	ldr	r3, [r7, #12]
24003f00:	681b      	ldr	r3, [r3, #0]
24003f02:	4a33      	ldr	r2, [pc, #204]	; (24003fd0 <HAL_DMA_Start_IT+0x480>)
24003f04:	4293      	cmp	r3, r2
24003f06:	d03b      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f08:	68fb      	ldr	r3, [r7, #12]
24003f0a:	681b      	ldr	r3, [r3, #0]
24003f0c:	4a31      	ldr	r2, [pc, #196]	; (24003fd4 <HAL_DMA_Start_IT+0x484>)
24003f0e:	4293      	cmp	r3, r2
24003f10:	d036      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f12:	68fb      	ldr	r3, [r7, #12]
24003f14:	681b      	ldr	r3, [r3, #0]
24003f16:	4a30      	ldr	r2, [pc, #192]	; (24003fd8 <HAL_DMA_Start_IT+0x488>)
24003f18:	4293      	cmp	r3, r2
24003f1a:	d031      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f1c:	68fb      	ldr	r3, [r7, #12]
24003f1e:	681b      	ldr	r3, [r3, #0]
24003f20:	4a2e      	ldr	r2, [pc, #184]	; (24003fdc <HAL_DMA_Start_IT+0x48c>)
24003f22:	4293      	cmp	r3, r2
24003f24:	d02c      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f26:	68fb      	ldr	r3, [r7, #12]
24003f28:	681b      	ldr	r3, [r3, #0]
24003f2a:	4a2d      	ldr	r2, [pc, #180]	; (24003fe0 <HAL_DMA_Start_IT+0x490>)
24003f2c:	4293      	cmp	r3, r2
24003f2e:	d027      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f30:	68fb      	ldr	r3, [r7, #12]
24003f32:	681b      	ldr	r3, [r3, #0]
24003f34:	4a2b      	ldr	r2, [pc, #172]	; (24003fe4 <HAL_DMA_Start_IT+0x494>)
24003f36:	4293      	cmp	r3, r2
24003f38:	d022      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f3a:	68fb      	ldr	r3, [r7, #12]
24003f3c:	681b      	ldr	r3, [r3, #0]
24003f3e:	4a2a      	ldr	r2, [pc, #168]	; (24003fe8 <HAL_DMA_Start_IT+0x498>)
24003f40:	4293      	cmp	r3, r2
24003f42:	d01d      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f44:	68fb      	ldr	r3, [r7, #12]
24003f46:	681b      	ldr	r3, [r3, #0]
24003f48:	4a28      	ldr	r2, [pc, #160]	; (24003fec <HAL_DMA_Start_IT+0x49c>)
24003f4a:	4293      	cmp	r3, r2
24003f4c:	d018      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f4e:	68fb      	ldr	r3, [r7, #12]
24003f50:	681b      	ldr	r3, [r3, #0]
24003f52:	4a27      	ldr	r2, [pc, #156]	; (24003ff0 <HAL_DMA_Start_IT+0x4a0>)
24003f54:	4293      	cmp	r3, r2
24003f56:	d013      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f58:	68fb      	ldr	r3, [r7, #12]
24003f5a:	681b      	ldr	r3, [r3, #0]
24003f5c:	4a25      	ldr	r2, [pc, #148]	; (24003ff4 <HAL_DMA_Start_IT+0x4a4>)
24003f5e:	4293      	cmp	r3, r2
24003f60:	d00e      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f62:	68fb      	ldr	r3, [r7, #12]
24003f64:	681b      	ldr	r3, [r3, #0]
24003f66:	4a24      	ldr	r2, [pc, #144]	; (24003ff8 <HAL_DMA_Start_IT+0x4a8>)
24003f68:	4293      	cmp	r3, r2
24003f6a:	d009      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f6c:	68fb      	ldr	r3, [r7, #12]
24003f6e:	681b      	ldr	r3, [r3, #0]
24003f70:	4a22      	ldr	r2, [pc, #136]	; (24003ffc <HAL_DMA_Start_IT+0x4ac>)
24003f72:	4293      	cmp	r3, r2
24003f74:	d004      	beq.n	24003f80 <HAL_DMA_Start_IT+0x430>
24003f76:	68fb      	ldr	r3, [r7, #12]
24003f78:	681b      	ldr	r3, [r3, #0]
24003f7a:	4a21      	ldr	r2, [pc, #132]	; (24004000 <HAL_DMA_Start_IT+0x4b0>)
24003f7c:	4293      	cmp	r3, r2
24003f7e:	d108      	bne.n	24003f92 <HAL_DMA_Start_IT+0x442>
24003f80:	68fb      	ldr	r3, [r7, #12]
24003f82:	681b      	ldr	r3, [r3, #0]
24003f84:	681a      	ldr	r2, [r3, #0]
24003f86:	68fb      	ldr	r3, [r7, #12]
24003f88:	681b      	ldr	r3, [r3, #0]
24003f8a:	f042 0201 	orr.w	r2, r2, #1
24003f8e:	601a      	str	r2, [r3, #0]
24003f90:	e012      	b.n	24003fb8 <HAL_DMA_Start_IT+0x468>
24003f92:	68fb      	ldr	r3, [r7, #12]
24003f94:	681b      	ldr	r3, [r3, #0]
24003f96:	681a      	ldr	r2, [r3, #0]
24003f98:	68fb      	ldr	r3, [r7, #12]
24003f9a:	681b      	ldr	r3, [r3, #0]
24003f9c:	f042 0201 	orr.w	r2, r2, #1
24003fa0:	601a      	str	r2, [r3, #0]
24003fa2:	e009      	b.n	24003fb8 <HAL_DMA_Start_IT+0x468>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24003fa4:	68fb      	ldr	r3, [r7, #12]
24003fa6:	f44f 6200 	mov.w	r2, #2048	; 0x800
24003faa:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hdma);
24003fac:	68fb      	ldr	r3, [r7, #12]
24003fae:	2200      	movs	r2, #0
24003fb0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Return error status */
    status = HAL_ERROR;
24003fb4:	2301      	movs	r3, #1
24003fb6:	75fb      	strb	r3, [r7, #23]
  }

  return status;
24003fb8:	7dfb      	ldrb	r3, [r7, #23]
}
24003fba:	4618      	mov	r0, r3
24003fbc:	3718      	adds	r7, #24
24003fbe:	46bd      	mov	sp, r7
24003fc0:	bd80      	pop	{r7, pc}
24003fc2:	bf00      	nop
24003fc4:	40020010 	.word	0x40020010
24003fc8:	40020028 	.word	0x40020028
24003fcc:	40020040 	.word	0x40020040
24003fd0:	40020058 	.word	0x40020058
24003fd4:	40020070 	.word	0x40020070
24003fd8:	40020088 	.word	0x40020088
24003fdc:	400200a0 	.word	0x400200a0
24003fe0:	400200b8 	.word	0x400200b8
24003fe4:	40020410 	.word	0x40020410
24003fe8:	40020428 	.word	0x40020428
24003fec:	40020440 	.word	0x40020440
24003ff0:	40020458 	.word	0x40020458
24003ff4:	40020470 	.word	0x40020470
24003ff8:	40020488 	.word	0x40020488
24003ffc:	400204a0 	.word	0x400204a0
24004000:	400204b8 	.word	0x400204b8
24004004:	58025408 	.word	0x58025408
24004008:	5802541c 	.word	0x5802541c
2400400c:	58025430 	.word	0x58025430
24004010:	58025444 	.word	0x58025444
24004014:	58025458 	.word	0x58025458
24004018:	5802546c 	.word	0x5802546c
2400401c:	58025480 	.word	0x58025480
24004020:	58025494 	.word	0x58025494

24004024 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
24004024:	b580      	push	{r7, lr}
24004026:	b086      	sub	sp, #24
24004028:	af00      	add	r7, sp, #0
2400402a:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;
  const __IO uint32_t *enableRegister;

  uint32_t tickstart = HAL_GetTick();
2400402c:	f7fd fff6 	bl	2400201c <HAL_GetTick>
24004030:	6138      	str	r0, [r7, #16]

 /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004032:	687b      	ldr	r3, [r7, #4]
24004034:	2b00      	cmp	r3, #0
24004036:	d101      	bne.n	2400403c <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
24004038:	2301      	movs	r3, #1
2400403a:	e2dc      	b.n	240045f6 <HAL_DMA_Abort+0x5d2>
  }

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
2400403c:	687b      	ldr	r3, [r7, #4]
2400403e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004042:	b2db      	uxtb	r3, r3
24004044:	2b02      	cmp	r3, #2
24004046:	d008      	beq.n	2400405a <HAL_DMA_Abort+0x36>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24004048:	687b      	ldr	r3, [r7, #4]
2400404a:	2280      	movs	r2, #128	; 0x80
2400404c:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
2400404e:	687b      	ldr	r3, [r7, #4]
24004050:	2200      	movs	r2, #0
24004052:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
24004056:	2301      	movs	r3, #1
24004058:	e2cd      	b.n	240045f6 <HAL_DMA_Abort+0x5d2>
  }
  else
  {
    /* Disable all the transfer interrupts */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400405a:	687b      	ldr	r3, [r7, #4]
2400405c:	681b      	ldr	r3, [r3, #0]
2400405e:	4a76      	ldr	r2, [pc, #472]	; (24004238 <HAL_DMA_Abort+0x214>)
24004060:	4293      	cmp	r3, r2
24004062:	d04a      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
24004064:	687b      	ldr	r3, [r7, #4]
24004066:	681b      	ldr	r3, [r3, #0]
24004068:	4a74      	ldr	r2, [pc, #464]	; (2400423c <HAL_DMA_Abort+0x218>)
2400406a:	4293      	cmp	r3, r2
2400406c:	d045      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
2400406e:	687b      	ldr	r3, [r7, #4]
24004070:	681b      	ldr	r3, [r3, #0]
24004072:	4a73      	ldr	r2, [pc, #460]	; (24004240 <HAL_DMA_Abort+0x21c>)
24004074:	4293      	cmp	r3, r2
24004076:	d040      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
24004078:	687b      	ldr	r3, [r7, #4]
2400407a:	681b      	ldr	r3, [r3, #0]
2400407c:	4a71      	ldr	r2, [pc, #452]	; (24004244 <HAL_DMA_Abort+0x220>)
2400407e:	4293      	cmp	r3, r2
24004080:	d03b      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
24004082:	687b      	ldr	r3, [r7, #4]
24004084:	681b      	ldr	r3, [r3, #0]
24004086:	4a70      	ldr	r2, [pc, #448]	; (24004248 <HAL_DMA_Abort+0x224>)
24004088:	4293      	cmp	r3, r2
2400408a:	d036      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
2400408c:	687b      	ldr	r3, [r7, #4]
2400408e:	681b      	ldr	r3, [r3, #0]
24004090:	4a6e      	ldr	r2, [pc, #440]	; (2400424c <HAL_DMA_Abort+0x228>)
24004092:	4293      	cmp	r3, r2
24004094:	d031      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
24004096:	687b      	ldr	r3, [r7, #4]
24004098:	681b      	ldr	r3, [r3, #0]
2400409a:	4a6d      	ldr	r2, [pc, #436]	; (24004250 <HAL_DMA_Abort+0x22c>)
2400409c:	4293      	cmp	r3, r2
2400409e:	d02c      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040a0:	687b      	ldr	r3, [r7, #4]
240040a2:	681b      	ldr	r3, [r3, #0]
240040a4:	4a6b      	ldr	r2, [pc, #428]	; (24004254 <HAL_DMA_Abort+0x230>)
240040a6:	4293      	cmp	r3, r2
240040a8:	d027      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040aa:	687b      	ldr	r3, [r7, #4]
240040ac:	681b      	ldr	r3, [r3, #0]
240040ae:	4a6a      	ldr	r2, [pc, #424]	; (24004258 <HAL_DMA_Abort+0x234>)
240040b0:	4293      	cmp	r3, r2
240040b2:	d022      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040b4:	687b      	ldr	r3, [r7, #4]
240040b6:	681b      	ldr	r3, [r3, #0]
240040b8:	4a68      	ldr	r2, [pc, #416]	; (2400425c <HAL_DMA_Abort+0x238>)
240040ba:	4293      	cmp	r3, r2
240040bc:	d01d      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040be:	687b      	ldr	r3, [r7, #4]
240040c0:	681b      	ldr	r3, [r3, #0]
240040c2:	4a67      	ldr	r2, [pc, #412]	; (24004260 <HAL_DMA_Abort+0x23c>)
240040c4:	4293      	cmp	r3, r2
240040c6:	d018      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040c8:	687b      	ldr	r3, [r7, #4]
240040ca:	681b      	ldr	r3, [r3, #0]
240040cc:	4a65      	ldr	r2, [pc, #404]	; (24004264 <HAL_DMA_Abort+0x240>)
240040ce:	4293      	cmp	r3, r2
240040d0:	d013      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040d2:	687b      	ldr	r3, [r7, #4]
240040d4:	681b      	ldr	r3, [r3, #0]
240040d6:	4a64      	ldr	r2, [pc, #400]	; (24004268 <HAL_DMA_Abort+0x244>)
240040d8:	4293      	cmp	r3, r2
240040da:	d00e      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040dc:	687b      	ldr	r3, [r7, #4]
240040de:	681b      	ldr	r3, [r3, #0]
240040e0:	4a62      	ldr	r2, [pc, #392]	; (2400426c <HAL_DMA_Abort+0x248>)
240040e2:	4293      	cmp	r3, r2
240040e4:	d009      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040e6:	687b      	ldr	r3, [r7, #4]
240040e8:	681b      	ldr	r3, [r3, #0]
240040ea:	4a61      	ldr	r2, [pc, #388]	; (24004270 <HAL_DMA_Abort+0x24c>)
240040ec:	4293      	cmp	r3, r2
240040ee:	d004      	beq.n	240040fa <HAL_DMA_Abort+0xd6>
240040f0:	687b      	ldr	r3, [r7, #4]
240040f2:	681b      	ldr	r3, [r3, #0]
240040f4:	4a5f      	ldr	r2, [pc, #380]	; (24004274 <HAL_DMA_Abort+0x250>)
240040f6:	4293      	cmp	r3, r2
240040f8:	d101      	bne.n	240040fe <HAL_DMA_Abort+0xda>
240040fa:	2301      	movs	r3, #1
240040fc:	e000      	b.n	24004100 <HAL_DMA_Abort+0xdc>
240040fe:	2300      	movs	r3, #0
24004100:	2b00      	cmp	r3, #0
24004102:	d013      	beq.n	2400412c <HAL_DMA_Abort+0x108>
    {
       /* Disable DMA All Interrupts  */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
24004104:	687b      	ldr	r3, [r7, #4]
24004106:	681b      	ldr	r3, [r3, #0]
24004108:	681a      	ldr	r2, [r3, #0]
2400410a:	687b      	ldr	r3, [r7, #4]
2400410c:	681b      	ldr	r3, [r3, #0]
2400410e:	f022 021e 	bic.w	r2, r2, #30
24004112:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
24004114:	687b      	ldr	r3, [r7, #4]
24004116:	681b      	ldr	r3, [r3, #0]
24004118:	695a      	ldr	r2, [r3, #20]
2400411a:	687b      	ldr	r3, [r7, #4]
2400411c:	681b      	ldr	r3, [r3, #0]
2400411e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
24004122:	615a      	str	r2, [r3, #20]

      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
24004124:	687b      	ldr	r3, [r7, #4]
24004126:	681b      	ldr	r3, [r3, #0]
24004128:	617b      	str	r3, [r7, #20]
2400412a:	e00a      	b.n	24004142 <HAL_DMA_Abort+0x11e>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
2400412c:	687b      	ldr	r3, [r7, #4]
2400412e:	681b      	ldr	r3, [r3, #0]
24004130:	681a      	ldr	r2, [r3, #0]
24004132:	687b      	ldr	r3, [r7, #4]
24004134:	681b      	ldr	r3, [r3, #0]
24004136:	f022 020e 	bic.w	r2, r2, #14
2400413a:	601a      	str	r2, [r3, #0]

      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
2400413c:	687b      	ldr	r3, [r7, #4]
2400413e:	681b      	ldr	r3, [r3, #0]
24004140:	617b      	str	r3, [r7, #20]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24004142:	687b      	ldr	r3, [r7, #4]
24004144:	681b      	ldr	r3, [r3, #0]
24004146:	4a3c      	ldr	r2, [pc, #240]	; (24004238 <HAL_DMA_Abort+0x214>)
24004148:	4293      	cmp	r3, r2
2400414a:	d072      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
2400414c:	687b      	ldr	r3, [r7, #4]
2400414e:	681b      	ldr	r3, [r3, #0]
24004150:	4a3a      	ldr	r2, [pc, #232]	; (2400423c <HAL_DMA_Abort+0x218>)
24004152:	4293      	cmp	r3, r2
24004154:	d06d      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
24004156:	687b      	ldr	r3, [r7, #4]
24004158:	681b      	ldr	r3, [r3, #0]
2400415a:	4a39      	ldr	r2, [pc, #228]	; (24004240 <HAL_DMA_Abort+0x21c>)
2400415c:	4293      	cmp	r3, r2
2400415e:	d068      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
24004160:	687b      	ldr	r3, [r7, #4]
24004162:	681b      	ldr	r3, [r3, #0]
24004164:	4a37      	ldr	r2, [pc, #220]	; (24004244 <HAL_DMA_Abort+0x220>)
24004166:	4293      	cmp	r3, r2
24004168:	d063      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
2400416a:	687b      	ldr	r3, [r7, #4]
2400416c:	681b      	ldr	r3, [r3, #0]
2400416e:	4a36      	ldr	r2, [pc, #216]	; (24004248 <HAL_DMA_Abort+0x224>)
24004170:	4293      	cmp	r3, r2
24004172:	d05e      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
24004174:	687b      	ldr	r3, [r7, #4]
24004176:	681b      	ldr	r3, [r3, #0]
24004178:	4a34      	ldr	r2, [pc, #208]	; (2400424c <HAL_DMA_Abort+0x228>)
2400417a:	4293      	cmp	r3, r2
2400417c:	d059      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
2400417e:	687b      	ldr	r3, [r7, #4]
24004180:	681b      	ldr	r3, [r3, #0]
24004182:	4a33      	ldr	r2, [pc, #204]	; (24004250 <HAL_DMA_Abort+0x22c>)
24004184:	4293      	cmp	r3, r2
24004186:	d054      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
24004188:	687b      	ldr	r3, [r7, #4]
2400418a:	681b      	ldr	r3, [r3, #0]
2400418c:	4a31      	ldr	r2, [pc, #196]	; (24004254 <HAL_DMA_Abort+0x230>)
2400418e:	4293      	cmp	r3, r2
24004190:	d04f      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
24004192:	687b      	ldr	r3, [r7, #4]
24004194:	681b      	ldr	r3, [r3, #0]
24004196:	4a30      	ldr	r2, [pc, #192]	; (24004258 <HAL_DMA_Abort+0x234>)
24004198:	4293      	cmp	r3, r2
2400419a:	d04a      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
2400419c:	687b      	ldr	r3, [r7, #4]
2400419e:	681b      	ldr	r3, [r3, #0]
240041a0:	4a2e      	ldr	r2, [pc, #184]	; (2400425c <HAL_DMA_Abort+0x238>)
240041a2:	4293      	cmp	r3, r2
240041a4:	d045      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041a6:	687b      	ldr	r3, [r7, #4]
240041a8:	681b      	ldr	r3, [r3, #0]
240041aa:	4a2d      	ldr	r2, [pc, #180]	; (24004260 <HAL_DMA_Abort+0x23c>)
240041ac:	4293      	cmp	r3, r2
240041ae:	d040      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041b0:	687b      	ldr	r3, [r7, #4]
240041b2:	681b      	ldr	r3, [r3, #0]
240041b4:	4a2b      	ldr	r2, [pc, #172]	; (24004264 <HAL_DMA_Abort+0x240>)
240041b6:	4293      	cmp	r3, r2
240041b8:	d03b      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041ba:	687b      	ldr	r3, [r7, #4]
240041bc:	681b      	ldr	r3, [r3, #0]
240041be:	4a2a      	ldr	r2, [pc, #168]	; (24004268 <HAL_DMA_Abort+0x244>)
240041c0:	4293      	cmp	r3, r2
240041c2:	d036      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041c4:	687b      	ldr	r3, [r7, #4]
240041c6:	681b      	ldr	r3, [r3, #0]
240041c8:	4a28      	ldr	r2, [pc, #160]	; (2400426c <HAL_DMA_Abort+0x248>)
240041ca:	4293      	cmp	r3, r2
240041cc:	d031      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041ce:	687b      	ldr	r3, [r7, #4]
240041d0:	681b      	ldr	r3, [r3, #0]
240041d2:	4a27      	ldr	r2, [pc, #156]	; (24004270 <HAL_DMA_Abort+0x24c>)
240041d4:	4293      	cmp	r3, r2
240041d6:	d02c      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041d8:	687b      	ldr	r3, [r7, #4]
240041da:	681b      	ldr	r3, [r3, #0]
240041dc:	4a25      	ldr	r2, [pc, #148]	; (24004274 <HAL_DMA_Abort+0x250>)
240041de:	4293      	cmp	r3, r2
240041e0:	d027      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041e2:	687b      	ldr	r3, [r7, #4]
240041e4:	681b      	ldr	r3, [r3, #0]
240041e6:	4a24      	ldr	r2, [pc, #144]	; (24004278 <HAL_DMA_Abort+0x254>)
240041e8:	4293      	cmp	r3, r2
240041ea:	d022      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041ec:	687b      	ldr	r3, [r7, #4]
240041ee:	681b      	ldr	r3, [r3, #0]
240041f0:	4a22      	ldr	r2, [pc, #136]	; (2400427c <HAL_DMA_Abort+0x258>)
240041f2:	4293      	cmp	r3, r2
240041f4:	d01d      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
240041f6:	687b      	ldr	r3, [r7, #4]
240041f8:	681b      	ldr	r3, [r3, #0]
240041fa:	4a21      	ldr	r2, [pc, #132]	; (24004280 <HAL_DMA_Abort+0x25c>)
240041fc:	4293      	cmp	r3, r2
240041fe:	d018      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
24004200:	687b      	ldr	r3, [r7, #4]
24004202:	681b      	ldr	r3, [r3, #0]
24004204:	4a1f      	ldr	r2, [pc, #124]	; (24004284 <HAL_DMA_Abort+0x260>)
24004206:	4293      	cmp	r3, r2
24004208:	d013      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
2400420a:	687b      	ldr	r3, [r7, #4]
2400420c:	681b      	ldr	r3, [r3, #0]
2400420e:	4a1e      	ldr	r2, [pc, #120]	; (24004288 <HAL_DMA_Abort+0x264>)
24004210:	4293      	cmp	r3, r2
24004212:	d00e      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
24004214:	687b      	ldr	r3, [r7, #4]
24004216:	681b      	ldr	r3, [r3, #0]
24004218:	4a1c      	ldr	r2, [pc, #112]	; (2400428c <HAL_DMA_Abort+0x268>)
2400421a:	4293      	cmp	r3, r2
2400421c:	d009      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
2400421e:	687b      	ldr	r3, [r7, #4]
24004220:	681b      	ldr	r3, [r3, #0]
24004222:	4a1b      	ldr	r2, [pc, #108]	; (24004290 <HAL_DMA_Abort+0x26c>)
24004224:	4293      	cmp	r3, r2
24004226:	d004      	beq.n	24004232 <HAL_DMA_Abort+0x20e>
24004228:	687b      	ldr	r3, [r7, #4]
2400422a:	681b      	ldr	r3, [r3, #0]
2400422c:	4a19      	ldr	r2, [pc, #100]	; (24004294 <HAL_DMA_Abort+0x270>)
2400422e:	4293      	cmp	r3, r2
24004230:	d132      	bne.n	24004298 <HAL_DMA_Abort+0x274>
24004232:	2301      	movs	r3, #1
24004234:	e031      	b.n	2400429a <HAL_DMA_Abort+0x276>
24004236:	bf00      	nop
24004238:	40020010 	.word	0x40020010
2400423c:	40020028 	.word	0x40020028
24004240:	40020040 	.word	0x40020040
24004244:	40020058 	.word	0x40020058
24004248:	40020070 	.word	0x40020070
2400424c:	40020088 	.word	0x40020088
24004250:	400200a0 	.word	0x400200a0
24004254:	400200b8 	.word	0x400200b8
24004258:	40020410 	.word	0x40020410
2400425c:	40020428 	.word	0x40020428
24004260:	40020440 	.word	0x40020440
24004264:	40020458 	.word	0x40020458
24004268:	40020470 	.word	0x40020470
2400426c:	40020488 	.word	0x40020488
24004270:	400204a0 	.word	0x400204a0
24004274:	400204b8 	.word	0x400204b8
24004278:	58025408 	.word	0x58025408
2400427c:	5802541c 	.word	0x5802541c
24004280:	58025430 	.word	0x58025430
24004284:	58025444 	.word	0x58025444
24004288:	58025458 	.word	0x58025458
2400428c:	5802546c 	.word	0x5802546c
24004290:	58025480 	.word	0x58025480
24004294:	58025494 	.word	0x58025494
24004298:	2300      	movs	r3, #0
2400429a:	2b00      	cmp	r3, #0
2400429c:	d007      	beq.n	240042ae <HAL_DMA_Abort+0x28a>
    {
      /* disable the DMAMUX sync overrun IT */
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
2400429e:	687b      	ldr	r3, [r7, #4]
240042a0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240042a2:	681a      	ldr	r2, [r3, #0]
240042a4:	687b      	ldr	r3, [r7, #4]
240042a6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240042a8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
240042ac:	601a      	str	r2, [r3, #0]
    }

    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
240042ae:	687b      	ldr	r3, [r7, #4]
240042b0:	681b      	ldr	r3, [r3, #0]
240042b2:	4a6d      	ldr	r2, [pc, #436]	; (24004468 <HAL_DMA_Abort+0x444>)
240042b4:	4293      	cmp	r3, r2
240042b6:	d04a      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
240042b8:	687b      	ldr	r3, [r7, #4]
240042ba:	681b      	ldr	r3, [r3, #0]
240042bc:	4a6b      	ldr	r2, [pc, #428]	; (2400446c <HAL_DMA_Abort+0x448>)
240042be:	4293      	cmp	r3, r2
240042c0:	d045      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
240042c2:	687b      	ldr	r3, [r7, #4]
240042c4:	681b      	ldr	r3, [r3, #0]
240042c6:	4a6a      	ldr	r2, [pc, #424]	; (24004470 <HAL_DMA_Abort+0x44c>)
240042c8:	4293      	cmp	r3, r2
240042ca:	d040      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
240042cc:	687b      	ldr	r3, [r7, #4]
240042ce:	681b      	ldr	r3, [r3, #0]
240042d0:	4a68      	ldr	r2, [pc, #416]	; (24004474 <HAL_DMA_Abort+0x450>)
240042d2:	4293      	cmp	r3, r2
240042d4:	d03b      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
240042d6:	687b      	ldr	r3, [r7, #4]
240042d8:	681b      	ldr	r3, [r3, #0]
240042da:	4a67      	ldr	r2, [pc, #412]	; (24004478 <HAL_DMA_Abort+0x454>)
240042dc:	4293      	cmp	r3, r2
240042de:	d036      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
240042e0:	687b      	ldr	r3, [r7, #4]
240042e2:	681b      	ldr	r3, [r3, #0]
240042e4:	4a65      	ldr	r2, [pc, #404]	; (2400447c <HAL_DMA_Abort+0x458>)
240042e6:	4293      	cmp	r3, r2
240042e8:	d031      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
240042ea:	687b      	ldr	r3, [r7, #4]
240042ec:	681b      	ldr	r3, [r3, #0]
240042ee:	4a64      	ldr	r2, [pc, #400]	; (24004480 <HAL_DMA_Abort+0x45c>)
240042f0:	4293      	cmp	r3, r2
240042f2:	d02c      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
240042f4:	687b      	ldr	r3, [r7, #4]
240042f6:	681b      	ldr	r3, [r3, #0]
240042f8:	4a62      	ldr	r2, [pc, #392]	; (24004484 <HAL_DMA_Abort+0x460>)
240042fa:	4293      	cmp	r3, r2
240042fc:	d027      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
240042fe:	687b      	ldr	r3, [r7, #4]
24004300:	681b      	ldr	r3, [r3, #0]
24004302:	4a61      	ldr	r2, [pc, #388]	; (24004488 <HAL_DMA_Abort+0x464>)
24004304:	4293      	cmp	r3, r2
24004306:	d022      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
24004308:	687b      	ldr	r3, [r7, #4]
2400430a:	681b      	ldr	r3, [r3, #0]
2400430c:	4a5f      	ldr	r2, [pc, #380]	; (2400448c <HAL_DMA_Abort+0x468>)
2400430e:	4293      	cmp	r3, r2
24004310:	d01d      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
24004312:	687b      	ldr	r3, [r7, #4]
24004314:	681b      	ldr	r3, [r3, #0]
24004316:	4a5e      	ldr	r2, [pc, #376]	; (24004490 <HAL_DMA_Abort+0x46c>)
24004318:	4293      	cmp	r3, r2
2400431a:	d018      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
2400431c:	687b      	ldr	r3, [r7, #4]
2400431e:	681b      	ldr	r3, [r3, #0]
24004320:	4a5c      	ldr	r2, [pc, #368]	; (24004494 <HAL_DMA_Abort+0x470>)
24004322:	4293      	cmp	r3, r2
24004324:	d013      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
24004326:	687b      	ldr	r3, [r7, #4]
24004328:	681b      	ldr	r3, [r3, #0]
2400432a:	4a5b      	ldr	r2, [pc, #364]	; (24004498 <HAL_DMA_Abort+0x474>)
2400432c:	4293      	cmp	r3, r2
2400432e:	d00e      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
24004330:	687b      	ldr	r3, [r7, #4]
24004332:	681b      	ldr	r3, [r3, #0]
24004334:	4a59      	ldr	r2, [pc, #356]	; (2400449c <HAL_DMA_Abort+0x478>)
24004336:	4293      	cmp	r3, r2
24004338:	d009      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
2400433a:	687b      	ldr	r3, [r7, #4]
2400433c:	681b      	ldr	r3, [r3, #0]
2400433e:	4a58      	ldr	r2, [pc, #352]	; (240044a0 <HAL_DMA_Abort+0x47c>)
24004340:	4293      	cmp	r3, r2
24004342:	d004      	beq.n	2400434e <HAL_DMA_Abort+0x32a>
24004344:	687b      	ldr	r3, [r7, #4]
24004346:	681b      	ldr	r3, [r3, #0]
24004348:	4a56      	ldr	r2, [pc, #344]	; (240044a4 <HAL_DMA_Abort+0x480>)
2400434a:	4293      	cmp	r3, r2
2400434c:	d108      	bne.n	24004360 <HAL_DMA_Abort+0x33c>
2400434e:	687b      	ldr	r3, [r7, #4]
24004350:	681b      	ldr	r3, [r3, #0]
24004352:	681a      	ldr	r2, [r3, #0]
24004354:	687b      	ldr	r3, [r7, #4]
24004356:	681b      	ldr	r3, [r3, #0]
24004358:	f022 0201 	bic.w	r2, r2, #1
2400435c:	601a      	str	r2, [r3, #0]
2400435e:	e007      	b.n	24004370 <HAL_DMA_Abort+0x34c>
24004360:	687b      	ldr	r3, [r7, #4]
24004362:	681b      	ldr	r3, [r3, #0]
24004364:	681a      	ldr	r2, [r3, #0]
24004366:	687b      	ldr	r3, [r7, #4]
24004368:	681b      	ldr	r3, [r3, #0]
2400436a:	f022 0201 	bic.w	r2, r2, #1
2400436e:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
24004370:	e013      	b.n	2400439a <HAL_DMA_Abort+0x376>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
24004372:	f7fd fe53 	bl	2400201c <HAL_GetTick>
24004376:	4602      	mov	r2, r0
24004378:	693b      	ldr	r3, [r7, #16]
2400437a:	1ad3      	subs	r3, r2, r3
2400437c:	2b05      	cmp	r3, #5
2400437e:	d90c      	bls.n	2400439a <HAL_DMA_Abort+0x376>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24004380:	687b      	ldr	r3, [r7, #4]
24004382:	2220      	movs	r2, #32
24004384:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
24004386:	687b      	ldr	r3, [r7, #4]
24004388:	2203      	movs	r2, #3
2400438a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
2400438e:	687b      	ldr	r3, [r7, #4]
24004390:	2200      	movs	r2, #0
24004392:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
24004396:	2301      	movs	r3, #1
24004398:	e12d      	b.n	240045f6 <HAL_DMA_Abort+0x5d2>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
2400439a:	697b      	ldr	r3, [r7, #20]
2400439c:	681b      	ldr	r3, [r3, #0]
2400439e:	f003 0301 	and.w	r3, r3, #1
240043a2:	2b00      	cmp	r3, #0
240043a4:	d1e5      	bne.n	24004372 <HAL_DMA_Abort+0x34e>
      }
    }

    /* Clear all interrupt flags at correct offset within the register */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240043a6:	687b      	ldr	r3, [r7, #4]
240043a8:	681b      	ldr	r3, [r3, #0]
240043aa:	4a2f      	ldr	r2, [pc, #188]	; (24004468 <HAL_DMA_Abort+0x444>)
240043ac:	4293      	cmp	r3, r2
240043ae:	d04a      	beq.n	24004446 <HAL_DMA_Abort+0x422>
240043b0:	687b      	ldr	r3, [r7, #4]
240043b2:	681b      	ldr	r3, [r3, #0]
240043b4:	4a2d      	ldr	r2, [pc, #180]	; (2400446c <HAL_DMA_Abort+0x448>)
240043b6:	4293      	cmp	r3, r2
240043b8:	d045      	beq.n	24004446 <HAL_DMA_Abort+0x422>
240043ba:	687b      	ldr	r3, [r7, #4]
240043bc:	681b      	ldr	r3, [r3, #0]
240043be:	4a2c      	ldr	r2, [pc, #176]	; (24004470 <HAL_DMA_Abort+0x44c>)
240043c0:	4293      	cmp	r3, r2
240043c2:	d040      	beq.n	24004446 <HAL_DMA_Abort+0x422>
240043c4:	687b      	ldr	r3, [r7, #4]
240043c6:	681b      	ldr	r3, [r3, #0]
240043c8:	4a2a      	ldr	r2, [pc, #168]	; (24004474 <HAL_DMA_Abort+0x450>)
240043ca:	4293      	cmp	r3, r2
240043cc:	d03b      	beq.n	24004446 <HAL_DMA_Abort+0x422>
240043ce:	687b      	ldr	r3, [r7, #4]
240043d0:	681b      	ldr	r3, [r3, #0]
240043d2:	4a29      	ldr	r2, [pc, #164]	; (24004478 <HAL_DMA_Abort+0x454>)
240043d4:	4293      	cmp	r3, r2
240043d6:	d036      	beq.n	24004446 <HAL_DMA_Abort+0x422>
240043d8:	687b      	ldr	r3, [r7, #4]
240043da:	681b      	ldr	r3, [r3, #0]
240043dc:	4a27      	ldr	r2, [pc, #156]	; (2400447c <HAL_DMA_Abort+0x458>)
240043de:	4293      	cmp	r3, r2
240043e0:	d031      	beq.n	24004446 <HAL_DMA_Abort+0x422>
240043e2:	687b      	ldr	r3, [r7, #4]
240043e4:	681b      	ldr	r3, [r3, #0]
240043e6:	4a26      	ldr	r2, [pc, #152]	; (24004480 <HAL_DMA_Abort+0x45c>)
240043e8:	4293      	cmp	r3, r2
240043ea:	d02c      	beq.n	24004446 <HAL_DMA_Abort+0x422>
240043ec:	687b      	ldr	r3, [r7, #4]
240043ee:	681b      	ldr	r3, [r3, #0]
240043f0:	4a24      	ldr	r2, [pc, #144]	; (24004484 <HAL_DMA_Abort+0x460>)
240043f2:	4293      	cmp	r3, r2
240043f4:	d027      	beq.n	24004446 <HAL_DMA_Abort+0x422>
240043f6:	687b      	ldr	r3, [r7, #4]
240043f8:	681b      	ldr	r3, [r3, #0]
240043fa:	4a23      	ldr	r2, [pc, #140]	; (24004488 <HAL_DMA_Abort+0x464>)
240043fc:	4293      	cmp	r3, r2
240043fe:	d022      	beq.n	24004446 <HAL_DMA_Abort+0x422>
24004400:	687b      	ldr	r3, [r7, #4]
24004402:	681b      	ldr	r3, [r3, #0]
24004404:	4a21      	ldr	r2, [pc, #132]	; (2400448c <HAL_DMA_Abort+0x468>)
24004406:	4293      	cmp	r3, r2
24004408:	d01d      	beq.n	24004446 <HAL_DMA_Abort+0x422>
2400440a:	687b      	ldr	r3, [r7, #4]
2400440c:	681b      	ldr	r3, [r3, #0]
2400440e:	4a20      	ldr	r2, [pc, #128]	; (24004490 <HAL_DMA_Abort+0x46c>)
24004410:	4293      	cmp	r3, r2
24004412:	d018      	beq.n	24004446 <HAL_DMA_Abort+0x422>
24004414:	687b      	ldr	r3, [r7, #4]
24004416:	681b      	ldr	r3, [r3, #0]
24004418:	4a1e      	ldr	r2, [pc, #120]	; (24004494 <HAL_DMA_Abort+0x470>)
2400441a:	4293      	cmp	r3, r2
2400441c:	d013      	beq.n	24004446 <HAL_DMA_Abort+0x422>
2400441e:	687b      	ldr	r3, [r7, #4]
24004420:	681b      	ldr	r3, [r3, #0]
24004422:	4a1d      	ldr	r2, [pc, #116]	; (24004498 <HAL_DMA_Abort+0x474>)
24004424:	4293      	cmp	r3, r2
24004426:	d00e      	beq.n	24004446 <HAL_DMA_Abort+0x422>
24004428:	687b      	ldr	r3, [r7, #4]
2400442a:	681b      	ldr	r3, [r3, #0]
2400442c:	4a1b      	ldr	r2, [pc, #108]	; (2400449c <HAL_DMA_Abort+0x478>)
2400442e:	4293      	cmp	r3, r2
24004430:	d009      	beq.n	24004446 <HAL_DMA_Abort+0x422>
24004432:	687b      	ldr	r3, [r7, #4]
24004434:	681b      	ldr	r3, [r3, #0]
24004436:	4a1a      	ldr	r2, [pc, #104]	; (240044a0 <HAL_DMA_Abort+0x47c>)
24004438:	4293      	cmp	r3, r2
2400443a:	d004      	beq.n	24004446 <HAL_DMA_Abort+0x422>
2400443c:	687b      	ldr	r3, [r7, #4]
2400443e:	681b      	ldr	r3, [r3, #0]
24004440:	4a18      	ldr	r2, [pc, #96]	; (240044a4 <HAL_DMA_Abort+0x480>)
24004442:	4293      	cmp	r3, r2
24004444:	d101      	bne.n	2400444a <HAL_DMA_Abort+0x426>
24004446:	2301      	movs	r3, #1
24004448:	e000      	b.n	2400444c <HAL_DMA_Abort+0x428>
2400444a:	2300      	movs	r3, #0
2400444c:	2b00      	cmp	r3, #0
2400444e:	d02b      	beq.n	240044a8 <HAL_DMA_Abort+0x484>
    {
      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24004450:	687b      	ldr	r3, [r7, #4]
24004452:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004454:	60bb      	str	r3, [r7, #8]
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24004456:	687b      	ldr	r3, [r7, #4]
24004458:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400445a:	f003 031f 	and.w	r3, r3, #31
2400445e:	223f      	movs	r2, #63	; 0x3f
24004460:	409a      	lsls	r2, r3
24004462:	68bb      	ldr	r3, [r7, #8]
24004464:	609a      	str	r2, [r3, #8]
24004466:	e02a      	b.n	240044be <HAL_DMA_Abort+0x49a>
24004468:	40020010 	.word	0x40020010
2400446c:	40020028 	.word	0x40020028
24004470:	40020040 	.word	0x40020040
24004474:	40020058 	.word	0x40020058
24004478:	40020070 	.word	0x40020070
2400447c:	40020088 	.word	0x40020088
24004480:	400200a0 	.word	0x400200a0
24004484:	400200b8 	.word	0x400200b8
24004488:	40020410 	.word	0x40020410
2400448c:	40020428 	.word	0x40020428
24004490:	40020440 	.word	0x40020440
24004494:	40020458 	.word	0x40020458
24004498:	40020470 	.word	0x40020470
2400449c:	40020488 	.word	0x40020488
240044a0:	400204a0 	.word	0x400204a0
240044a4:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
240044a8:	687b      	ldr	r3, [r7, #4]
240044aa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240044ac:	60fb      	str	r3, [r7, #12]
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
240044ae:	687b      	ldr	r3, [r7, #4]
240044b0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240044b2:	f003 031f 	and.w	r3, r3, #31
240044b6:	2201      	movs	r2, #1
240044b8:	409a      	lsls	r2, r3
240044ba:	68fb      	ldr	r3, [r7, #12]
240044bc:	605a      	str	r2, [r3, #4]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240044be:	687b      	ldr	r3, [r7, #4]
240044c0:	681b      	ldr	r3, [r3, #0]
240044c2:	4a4f      	ldr	r2, [pc, #316]	; (24004600 <HAL_DMA_Abort+0x5dc>)
240044c4:	4293      	cmp	r3, r2
240044c6:	d072      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
240044c8:	687b      	ldr	r3, [r7, #4]
240044ca:	681b      	ldr	r3, [r3, #0]
240044cc:	4a4d      	ldr	r2, [pc, #308]	; (24004604 <HAL_DMA_Abort+0x5e0>)
240044ce:	4293      	cmp	r3, r2
240044d0:	d06d      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
240044d2:	687b      	ldr	r3, [r7, #4]
240044d4:	681b      	ldr	r3, [r3, #0]
240044d6:	4a4c      	ldr	r2, [pc, #304]	; (24004608 <HAL_DMA_Abort+0x5e4>)
240044d8:	4293      	cmp	r3, r2
240044da:	d068      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
240044dc:	687b      	ldr	r3, [r7, #4]
240044de:	681b      	ldr	r3, [r3, #0]
240044e0:	4a4a      	ldr	r2, [pc, #296]	; (2400460c <HAL_DMA_Abort+0x5e8>)
240044e2:	4293      	cmp	r3, r2
240044e4:	d063      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
240044e6:	687b      	ldr	r3, [r7, #4]
240044e8:	681b      	ldr	r3, [r3, #0]
240044ea:	4a49      	ldr	r2, [pc, #292]	; (24004610 <HAL_DMA_Abort+0x5ec>)
240044ec:	4293      	cmp	r3, r2
240044ee:	d05e      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
240044f0:	687b      	ldr	r3, [r7, #4]
240044f2:	681b      	ldr	r3, [r3, #0]
240044f4:	4a47      	ldr	r2, [pc, #284]	; (24004614 <HAL_DMA_Abort+0x5f0>)
240044f6:	4293      	cmp	r3, r2
240044f8:	d059      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
240044fa:	687b      	ldr	r3, [r7, #4]
240044fc:	681b      	ldr	r3, [r3, #0]
240044fe:	4a46      	ldr	r2, [pc, #280]	; (24004618 <HAL_DMA_Abort+0x5f4>)
24004500:	4293      	cmp	r3, r2
24004502:	d054      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004504:	687b      	ldr	r3, [r7, #4]
24004506:	681b      	ldr	r3, [r3, #0]
24004508:	4a44      	ldr	r2, [pc, #272]	; (2400461c <HAL_DMA_Abort+0x5f8>)
2400450a:	4293      	cmp	r3, r2
2400450c:	d04f      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
2400450e:	687b      	ldr	r3, [r7, #4]
24004510:	681b      	ldr	r3, [r3, #0]
24004512:	4a43      	ldr	r2, [pc, #268]	; (24004620 <HAL_DMA_Abort+0x5fc>)
24004514:	4293      	cmp	r3, r2
24004516:	d04a      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004518:	687b      	ldr	r3, [r7, #4]
2400451a:	681b      	ldr	r3, [r3, #0]
2400451c:	4a41      	ldr	r2, [pc, #260]	; (24004624 <HAL_DMA_Abort+0x600>)
2400451e:	4293      	cmp	r3, r2
24004520:	d045      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004522:	687b      	ldr	r3, [r7, #4]
24004524:	681b      	ldr	r3, [r3, #0]
24004526:	4a40      	ldr	r2, [pc, #256]	; (24004628 <HAL_DMA_Abort+0x604>)
24004528:	4293      	cmp	r3, r2
2400452a:	d040      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
2400452c:	687b      	ldr	r3, [r7, #4]
2400452e:	681b      	ldr	r3, [r3, #0]
24004530:	4a3e      	ldr	r2, [pc, #248]	; (2400462c <HAL_DMA_Abort+0x608>)
24004532:	4293      	cmp	r3, r2
24004534:	d03b      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004536:	687b      	ldr	r3, [r7, #4]
24004538:	681b      	ldr	r3, [r3, #0]
2400453a:	4a3d      	ldr	r2, [pc, #244]	; (24004630 <HAL_DMA_Abort+0x60c>)
2400453c:	4293      	cmp	r3, r2
2400453e:	d036      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004540:	687b      	ldr	r3, [r7, #4]
24004542:	681b      	ldr	r3, [r3, #0]
24004544:	4a3b      	ldr	r2, [pc, #236]	; (24004634 <HAL_DMA_Abort+0x610>)
24004546:	4293      	cmp	r3, r2
24004548:	d031      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
2400454a:	687b      	ldr	r3, [r7, #4]
2400454c:	681b      	ldr	r3, [r3, #0]
2400454e:	4a3a      	ldr	r2, [pc, #232]	; (24004638 <HAL_DMA_Abort+0x614>)
24004550:	4293      	cmp	r3, r2
24004552:	d02c      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004554:	687b      	ldr	r3, [r7, #4]
24004556:	681b      	ldr	r3, [r3, #0]
24004558:	4a38      	ldr	r2, [pc, #224]	; (2400463c <HAL_DMA_Abort+0x618>)
2400455a:	4293      	cmp	r3, r2
2400455c:	d027      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
2400455e:	687b      	ldr	r3, [r7, #4]
24004560:	681b      	ldr	r3, [r3, #0]
24004562:	4a37      	ldr	r2, [pc, #220]	; (24004640 <HAL_DMA_Abort+0x61c>)
24004564:	4293      	cmp	r3, r2
24004566:	d022      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004568:	687b      	ldr	r3, [r7, #4]
2400456a:	681b      	ldr	r3, [r3, #0]
2400456c:	4a35      	ldr	r2, [pc, #212]	; (24004644 <HAL_DMA_Abort+0x620>)
2400456e:	4293      	cmp	r3, r2
24004570:	d01d      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004572:	687b      	ldr	r3, [r7, #4]
24004574:	681b      	ldr	r3, [r3, #0]
24004576:	4a34      	ldr	r2, [pc, #208]	; (24004648 <HAL_DMA_Abort+0x624>)
24004578:	4293      	cmp	r3, r2
2400457a:	d018      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
2400457c:	687b      	ldr	r3, [r7, #4]
2400457e:	681b      	ldr	r3, [r3, #0]
24004580:	4a32      	ldr	r2, [pc, #200]	; (2400464c <HAL_DMA_Abort+0x628>)
24004582:	4293      	cmp	r3, r2
24004584:	d013      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004586:	687b      	ldr	r3, [r7, #4]
24004588:	681b      	ldr	r3, [r3, #0]
2400458a:	4a31      	ldr	r2, [pc, #196]	; (24004650 <HAL_DMA_Abort+0x62c>)
2400458c:	4293      	cmp	r3, r2
2400458e:	d00e      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
24004590:	687b      	ldr	r3, [r7, #4]
24004592:	681b      	ldr	r3, [r3, #0]
24004594:	4a2f      	ldr	r2, [pc, #188]	; (24004654 <HAL_DMA_Abort+0x630>)
24004596:	4293      	cmp	r3, r2
24004598:	d009      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
2400459a:	687b      	ldr	r3, [r7, #4]
2400459c:	681b      	ldr	r3, [r3, #0]
2400459e:	4a2e      	ldr	r2, [pc, #184]	; (24004658 <HAL_DMA_Abort+0x634>)
240045a0:	4293      	cmp	r3, r2
240045a2:	d004      	beq.n	240045ae <HAL_DMA_Abort+0x58a>
240045a4:	687b      	ldr	r3, [r7, #4]
240045a6:	681b      	ldr	r3, [r3, #0]
240045a8:	4a2c      	ldr	r2, [pc, #176]	; (2400465c <HAL_DMA_Abort+0x638>)
240045aa:	4293      	cmp	r3, r2
240045ac:	d101      	bne.n	240045b2 <HAL_DMA_Abort+0x58e>
240045ae:	2301      	movs	r3, #1
240045b0:	e000      	b.n	240045b4 <HAL_DMA_Abort+0x590>
240045b2:	2300      	movs	r3, #0
240045b4:	2b00      	cmp	r3, #0
240045b6:	d015      	beq.n	240045e4 <HAL_DMA_Abort+0x5c0>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240045b8:	687b      	ldr	r3, [r7, #4]
240045ba:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240045bc:	687a      	ldr	r2, [r7, #4]
240045be:	6e92      	ldr	r2, [r2, #104]	; 0x68
240045c0:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
240045c2:	687b      	ldr	r3, [r7, #4]
240045c4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240045c6:	2b00      	cmp	r3, #0
240045c8:	d00c      	beq.n	240045e4 <HAL_DMA_Abort+0x5c0>
      {
        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT */
        /* disable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
240045ca:	687b      	ldr	r3, [r7, #4]
240045cc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240045ce:	681a      	ldr	r2, [r3, #0]
240045d0:	687b      	ldr	r3, [r7, #4]
240045d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240045d4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
240045d8:	601a      	str	r2, [r3, #0]

        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
240045da:	687b      	ldr	r3, [r7, #4]
240045dc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240045de:	687a      	ldr	r2, [r7, #4]
240045e0:	6f52      	ldr	r2, [r2, #116]	; 0x74
240045e2:	605a      	str	r2, [r3, #4]
      }
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
240045e4:	687b      	ldr	r3, [r7, #4]
240045e6:	2201      	movs	r2, #1
240045e8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
240045ec:	687b      	ldr	r3, [r7, #4]
240045ee:	2200      	movs	r2, #0
240045f0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  }

  return HAL_OK;
240045f4:	2300      	movs	r3, #0
}
240045f6:	4618      	mov	r0, r3
240045f8:	3718      	adds	r7, #24
240045fa:	46bd      	mov	sp, r7
240045fc:	bd80      	pop	{r7, pc}
240045fe:	bf00      	nop
24004600:	40020010 	.word	0x40020010
24004604:	40020028 	.word	0x40020028
24004608:	40020040 	.word	0x40020040
2400460c:	40020058 	.word	0x40020058
24004610:	40020070 	.word	0x40020070
24004614:	40020088 	.word	0x40020088
24004618:	400200a0 	.word	0x400200a0
2400461c:	400200b8 	.word	0x400200b8
24004620:	40020410 	.word	0x40020410
24004624:	40020428 	.word	0x40020428
24004628:	40020440 	.word	0x40020440
2400462c:	40020458 	.word	0x40020458
24004630:	40020470 	.word	0x40020470
24004634:	40020488 	.word	0x40020488
24004638:	400204a0 	.word	0x400204a0
2400463c:	400204b8 	.word	0x400204b8
24004640:	58025408 	.word	0x58025408
24004644:	5802541c 	.word	0x5802541c
24004648:	58025430 	.word	0x58025430
2400464c:	58025444 	.word	0x58025444
24004650:	58025458 	.word	0x58025458
24004654:	5802546c 	.word	0x5802546c
24004658:	58025480 	.word	0x58025480
2400465c:	58025494 	.word	0x58025494

24004660 <HAL_DMA_Abort_IT>:
  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
24004660:	b580      	push	{r7, lr}
24004662:	b084      	sub	sp, #16
24004664:	af00      	add	r7, sp, #0
24004666:	6078      	str	r0, [r7, #4]
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004668:	687b      	ldr	r3, [r7, #4]
2400466a:	2b00      	cmp	r3, #0
2400466c:	d101      	bne.n	24004672 <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
2400466e:	2301      	movs	r3, #1
24004670:	e237      	b.n	24004ae2 <HAL_DMA_Abort_IT+0x482>
  }

  if(hdma->State != HAL_DMA_STATE_BUSY)
24004672:	687b      	ldr	r3, [r7, #4]
24004674:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004678:	b2db      	uxtb	r3, r3
2400467a:	2b02      	cmp	r3, #2
2400467c:	d004      	beq.n	24004688 <HAL_DMA_Abort_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
2400467e:	687b      	ldr	r3, [r7, #4]
24004680:	2280      	movs	r2, #128	; 0x80
24004682:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
24004684:	2301      	movs	r3, #1
24004686:	e22c      	b.n	24004ae2 <HAL_DMA_Abort_IT+0x482>
  }
  else
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004688:	687b      	ldr	r3, [r7, #4]
2400468a:	681b      	ldr	r3, [r3, #0]
2400468c:	4a5c      	ldr	r2, [pc, #368]	; (24004800 <HAL_DMA_Abort_IT+0x1a0>)
2400468e:	4293      	cmp	r3, r2
24004690:	d04a      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
24004692:	687b      	ldr	r3, [r7, #4]
24004694:	681b      	ldr	r3, [r3, #0]
24004696:	4a5b      	ldr	r2, [pc, #364]	; (24004804 <HAL_DMA_Abort_IT+0x1a4>)
24004698:	4293      	cmp	r3, r2
2400469a:	d045      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
2400469c:	687b      	ldr	r3, [r7, #4]
2400469e:	681b      	ldr	r3, [r3, #0]
240046a0:	4a59      	ldr	r2, [pc, #356]	; (24004808 <HAL_DMA_Abort_IT+0x1a8>)
240046a2:	4293      	cmp	r3, r2
240046a4:	d040      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046a6:	687b      	ldr	r3, [r7, #4]
240046a8:	681b      	ldr	r3, [r3, #0]
240046aa:	4a58      	ldr	r2, [pc, #352]	; (2400480c <HAL_DMA_Abort_IT+0x1ac>)
240046ac:	4293      	cmp	r3, r2
240046ae:	d03b      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046b0:	687b      	ldr	r3, [r7, #4]
240046b2:	681b      	ldr	r3, [r3, #0]
240046b4:	4a56      	ldr	r2, [pc, #344]	; (24004810 <HAL_DMA_Abort_IT+0x1b0>)
240046b6:	4293      	cmp	r3, r2
240046b8:	d036      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046ba:	687b      	ldr	r3, [r7, #4]
240046bc:	681b      	ldr	r3, [r3, #0]
240046be:	4a55      	ldr	r2, [pc, #340]	; (24004814 <HAL_DMA_Abort_IT+0x1b4>)
240046c0:	4293      	cmp	r3, r2
240046c2:	d031      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046c4:	687b      	ldr	r3, [r7, #4]
240046c6:	681b      	ldr	r3, [r3, #0]
240046c8:	4a53      	ldr	r2, [pc, #332]	; (24004818 <HAL_DMA_Abort_IT+0x1b8>)
240046ca:	4293      	cmp	r3, r2
240046cc:	d02c      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046ce:	687b      	ldr	r3, [r7, #4]
240046d0:	681b      	ldr	r3, [r3, #0]
240046d2:	4a52      	ldr	r2, [pc, #328]	; (2400481c <HAL_DMA_Abort_IT+0x1bc>)
240046d4:	4293      	cmp	r3, r2
240046d6:	d027      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046d8:	687b      	ldr	r3, [r7, #4]
240046da:	681b      	ldr	r3, [r3, #0]
240046dc:	4a50      	ldr	r2, [pc, #320]	; (24004820 <HAL_DMA_Abort_IT+0x1c0>)
240046de:	4293      	cmp	r3, r2
240046e0:	d022      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046e2:	687b      	ldr	r3, [r7, #4]
240046e4:	681b      	ldr	r3, [r3, #0]
240046e6:	4a4f      	ldr	r2, [pc, #316]	; (24004824 <HAL_DMA_Abort_IT+0x1c4>)
240046e8:	4293      	cmp	r3, r2
240046ea:	d01d      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046ec:	687b      	ldr	r3, [r7, #4]
240046ee:	681b      	ldr	r3, [r3, #0]
240046f0:	4a4d      	ldr	r2, [pc, #308]	; (24004828 <HAL_DMA_Abort_IT+0x1c8>)
240046f2:	4293      	cmp	r3, r2
240046f4:	d018      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
240046f6:	687b      	ldr	r3, [r7, #4]
240046f8:	681b      	ldr	r3, [r3, #0]
240046fa:	4a4c      	ldr	r2, [pc, #304]	; (2400482c <HAL_DMA_Abort_IT+0x1cc>)
240046fc:	4293      	cmp	r3, r2
240046fe:	d013      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
24004700:	687b      	ldr	r3, [r7, #4]
24004702:	681b      	ldr	r3, [r3, #0]
24004704:	4a4a      	ldr	r2, [pc, #296]	; (24004830 <HAL_DMA_Abort_IT+0x1d0>)
24004706:	4293      	cmp	r3, r2
24004708:	d00e      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
2400470a:	687b      	ldr	r3, [r7, #4]
2400470c:	681b      	ldr	r3, [r3, #0]
2400470e:	4a49      	ldr	r2, [pc, #292]	; (24004834 <HAL_DMA_Abort_IT+0x1d4>)
24004710:	4293      	cmp	r3, r2
24004712:	d009      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
24004714:	687b      	ldr	r3, [r7, #4]
24004716:	681b      	ldr	r3, [r3, #0]
24004718:	4a47      	ldr	r2, [pc, #284]	; (24004838 <HAL_DMA_Abort_IT+0x1d8>)
2400471a:	4293      	cmp	r3, r2
2400471c:	d004      	beq.n	24004728 <HAL_DMA_Abort_IT+0xc8>
2400471e:	687b      	ldr	r3, [r7, #4]
24004720:	681b      	ldr	r3, [r3, #0]
24004722:	4a46      	ldr	r2, [pc, #280]	; (2400483c <HAL_DMA_Abort_IT+0x1dc>)
24004724:	4293      	cmp	r3, r2
24004726:	d101      	bne.n	2400472c <HAL_DMA_Abort_IT+0xcc>
24004728:	2301      	movs	r3, #1
2400472a:	e000      	b.n	2400472e <HAL_DMA_Abort_IT+0xce>
2400472c:	2300      	movs	r3, #0
2400472e:	2b00      	cmp	r3, #0
24004730:	f000 8086 	beq.w	24004840 <HAL_DMA_Abort_IT+0x1e0>
    {
      /* Set Abort State  */
      hdma->State = HAL_DMA_STATE_ABORT;
24004734:	687b      	ldr	r3, [r7, #4]
24004736:	2204      	movs	r2, #4
24004738:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
2400473c:	687b      	ldr	r3, [r7, #4]
2400473e:	681b      	ldr	r3, [r3, #0]
24004740:	4a2f      	ldr	r2, [pc, #188]	; (24004800 <HAL_DMA_Abort_IT+0x1a0>)
24004742:	4293      	cmp	r3, r2
24004744:	d04a      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
24004746:	687b      	ldr	r3, [r7, #4]
24004748:	681b      	ldr	r3, [r3, #0]
2400474a:	4a2e      	ldr	r2, [pc, #184]	; (24004804 <HAL_DMA_Abort_IT+0x1a4>)
2400474c:	4293      	cmp	r3, r2
2400474e:	d045      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
24004750:	687b      	ldr	r3, [r7, #4]
24004752:	681b      	ldr	r3, [r3, #0]
24004754:	4a2c      	ldr	r2, [pc, #176]	; (24004808 <HAL_DMA_Abort_IT+0x1a8>)
24004756:	4293      	cmp	r3, r2
24004758:	d040      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
2400475a:	687b      	ldr	r3, [r7, #4]
2400475c:	681b      	ldr	r3, [r3, #0]
2400475e:	4a2b      	ldr	r2, [pc, #172]	; (2400480c <HAL_DMA_Abort_IT+0x1ac>)
24004760:	4293      	cmp	r3, r2
24004762:	d03b      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
24004764:	687b      	ldr	r3, [r7, #4]
24004766:	681b      	ldr	r3, [r3, #0]
24004768:	4a29      	ldr	r2, [pc, #164]	; (24004810 <HAL_DMA_Abort_IT+0x1b0>)
2400476a:	4293      	cmp	r3, r2
2400476c:	d036      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
2400476e:	687b      	ldr	r3, [r7, #4]
24004770:	681b      	ldr	r3, [r3, #0]
24004772:	4a28      	ldr	r2, [pc, #160]	; (24004814 <HAL_DMA_Abort_IT+0x1b4>)
24004774:	4293      	cmp	r3, r2
24004776:	d031      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
24004778:	687b      	ldr	r3, [r7, #4]
2400477a:	681b      	ldr	r3, [r3, #0]
2400477c:	4a26      	ldr	r2, [pc, #152]	; (24004818 <HAL_DMA_Abort_IT+0x1b8>)
2400477e:	4293      	cmp	r3, r2
24004780:	d02c      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
24004782:	687b      	ldr	r3, [r7, #4]
24004784:	681b      	ldr	r3, [r3, #0]
24004786:	4a25      	ldr	r2, [pc, #148]	; (2400481c <HAL_DMA_Abort_IT+0x1bc>)
24004788:	4293      	cmp	r3, r2
2400478a:	d027      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
2400478c:	687b      	ldr	r3, [r7, #4]
2400478e:	681b      	ldr	r3, [r3, #0]
24004790:	4a23      	ldr	r2, [pc, #140]	; (24004820 <HAL_DMA_Abort_IT+0x1c0>)
24004792:	4293      	cmp	r3, r2
24004794:	d022      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
24004796:	687b      	ldr	r3, [r7, #4]
24004798:	681b      	ldr	r3, [r3, #0]
2400479a:	4a22      	ldr	r2, [pc, #136]	; (24004824 <HAL_DMA_Abort_IT+0x1c4>)
2400479c:	4293      	cmp	r3, r2
2400479e:	d01d      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
240047a0:	687b      	ldr	r3, [r7, #4]
240047a2:	681b      	ldr	r3, [r3, #0]
240047a4:	4a20      	ldr	r2, [pc, #128]	; (24004828 <HAL_DMA_Abort_IT+0x1c8>)
240047a6:	4293      	cmp	r3, r2
240047a8:	d018      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
240047aa:	687b      	ldr	r3, [r7, #4]
240047ac:	681b      	ldr	r3, [r3, #0]
240047ae:	4a1f      	ldr	r2, [pc, #124]	; (2400482c <HAL_DMA_Abort_IT+0x1cc>)
240047b0:	4293      	cmp	r3, r2
240047b2:	d013      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
240047b4:	687b      	ldr	r3, [r7, #4]
240047b6:	681b      	ldr	r3, [r3, #0]
240047b8:	4a1d      	ldr	r2, [pc, #116]	; (24004830 <HAL_DMA_Abort_IT+0x1d0>)
240047ba:	4293      	cmp	r3, r2
240047bc:	d00e      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
240047be:	687b      	ldr	r3, [r7, #4]
240047c0:	681b      	ldr	r3, [r3, #0]
240047c2:	4a1c      	ldr	r2, [pc, #112]	; (24004834 <HAL_DMA_Abort_IT+0x1d4>)
240047c4:	4293      	cmp	r3, r2
240047c6:	d009      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
240047c8:	687b      	ldr	r3, [r7, #4]
240047ca:	681b      	ldr	r3, [r3, #0]
240047cc:	4a1a      	ldr	r2, [pc, #104]	; (24004838 <HAL_DMA_Abort_IT+0x1d8>)
240047ce:	4293      	cmp	r3, r2
240047d0:	d004      	beq.n	240047dc <HAL_DMA_Abort_IT+0x17c>
240047d2:	687b      	ldr	r3, [r7, #4]
240047d4:	681b      	ldr	r3, [r3, #0]
240047d6:	4a19      	ldr	r2, [pc, #100]	; (2400483c <HAL_DMA_Abort_IT+0x1dc>)
240047d8:	4293      	cmp	r3, r2
240047da:	d108      	bne.n	240047ee <HAL_DMA_Abort_IT+0x18e>
240047dc:	687b      	ldr	r3, [r7, #4]
240047de:	681b      	ldr	r3, [r3, #0]
240047e0:	681a      	ldr	r2, [r3, #0]
240047e2:	687b      	ldr	r3, [r7, #4]
240047e4:	681b      	ldr	r3, [r3, #0]
240047e6:	f022 0201 	bic.w	r2, r2, #1
240047ea:	601a      	str	r2, [r3, #0]
240047ec:	e178      	b.n	24004ae0 <HAL_DMA_Abort_IT+0x480>
240047ee:	687b      	ldr	r3, [r7, #4]
240047f0:	681b      	ldr	r3, [r3, #0]
240047f2:	681a      	ldr	r2, [r3, #0]
240047f4:	687b      	ldr	r3, [r7, #4]
240047f6:	681b      	ldr	r3, [r3, #0]
240047f8:	f022 0201 	bic.w	r2, r2, #1
240047fc:	601a      	str	r2, [r3, #0]
240047fe:	e16f      	b.n	24004ae0 <HAL_DMA_Abort_IT+0x480>
24004800:	40020010 	.word	0x40020010
24004804:	40020028 	.word	0x40020028
24004808:	40020040 	.word	0x40020040
2400480c:	40020058 	.word	0x40020058
24004810:	40020070 	.word	0x40020070
24004814:	40020088 	.word	0x40020088
24004818:	400200a0 	.word	0x400200a0
2400481c:	400200b8 	.word	0x400200b8
24004820:	40020410 	.word	0x40020410
24004824:	40020428 	.word	0x40020428
24004828:	40020440 	.word	0x40020440
2400482c:	40020458 	.word	0x40020458
24004830:	40020470 	.word	0x40020470
24004834:	40020488 	.word	0x40020488
24004838:	400204a0 	.word	0x400204a0
2400483c:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts  */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
24004840:	687b      	ldr	r3, [r7, #4]
24004842:	681b      	ldr	r3, [r3, #0]
24004844:	681a      	ldr	r2, [r3, #0]
24004846:	687b      	ldr	r3, [r7, #4]
24004848:	681b      	ldr	r3, [r3, #0]
2400484a:	f022 020e 	bic.w	r2, r2, #14
2400484e:	601a      	str	r2, [r3, #0]

      /* Disable the channel */
      __HAL_DMA_DISABLE(hdma);
24004850:	687b      	ldr	r3, [r7, #4]
24004852:	681b      	ldr	r3, [r3, #0]
24004854:	4a6c      	ldr	r2, [pc, #432]	; (24004a08 <HAL_DMA_Abort_IT+0x3a8>)
24004856:	4293      	cmp	r3, r2
24004858:	d04a      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
2400485a:	687b      	ldr	r3, [r7, #4]
2400485c:	681b      	ldr	r3, [r3, #0]
2400485e:	4a6b      	ldr	r2, [pc, #428]	; (24004a0c <HAL_DMA_Abort_IT+0x3ac>)
24004860:	4293      	cmp	r3, r2
24004862:	d045      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
24004864:	687b      	ldr	r3, [r7, #4]
24004866:	681b      	ldr	r3, [r3, #0]
24004868:	4a69      	ldr	r2, [pc, #420]	; (24004a10 <HAL_DMA_Abort_IT+0x3b0>)
2400486a:	4293      	cmp	r3, r2
2400486c:	d040      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
2400486e:	687b      	ldr	r3, [r7, #4]
24004870:	681b      	ldr	r3, [r3, #0]
24004872:	4a68      	ldr	r2, [pc, #416]	; (24004a14 <HAL_DMA_Abort_IT+0x3b4>)
24004874:	4293      	cmp	r3, r2
24004876:	d03b      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
24004878:	687b      	ldr	r3, [r7, #4]
2400487a:	681b      	ldr	r3, [r3, #0]
2400487c:	4a66      	ldr	r2, [pc, #408]	; (24004a18 <HAL_DMA_Abort_IT+0x3b8>)
2400487e:	4293      	cmp	r3, r2
24004880:	d036      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
24004882:	687b      	ldr	r3, [r7, #4]
24004884:	681b      	ldr	r3, [r3, #0]
24004886:	4a65      	ldr	r2, [pc, #404]	; (24004a1c <HAL_DMA_Abort_IT+0x3bc>)
24004888:	4293      	cmp	r3, r2
2400488a:	d031      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
2400488c:	687b      	ldr	r3, [r7, #4]
2400488e:	681b      	ldr	r3, [r3, #0]
24004890:	4a63      	ldr	r2, [pc, #396]	; (24004a20 <HAL_DMA_Abort_IT+0x3c0>)
24004892:	4293      	cmp	r3, r2
24004894:	d02c      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
24004896:	687b      	ldr	r3, [r7, #4]
24004898:	681b      	ldr	r3, [r3, #0]
2400489a:	4a62      	ldr	r2, [pc, #392]	; (24004a24 <HAL_DMA_Abort_IT+0x3c4>)
2400489c:	4293      	cmp	r3, r2
2400489e:	d027      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
240048a0:	687b      	ldr	r3, [r7, #4]
240048a2:	681b      	ldr	r3, [r3, #0]
240048a4:	4a60      	ldr	r2, [pc, #384]	; (24004a28 <HAL_DMA_Abort_IT+0x3c8>)
240048a6:	4293      	cmp	r3, r2
240048a8:	d022      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
240048aa:	687b      	ldr	r3, [r7, #4]
240048ac:	681b      	ldr	r3, [r3, #0]
240048ae:	4a5f      	ldr	r2, [pc, #380]	; (24004a2c <HAL_DMA_Abort_IT+0x3cc>)
240048b0:	4293      	cmp	r3, r2
240048b2:	d01d      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
240048b4:	687b      	ldr	r3, [r7, #4]
240048b6:	681b      	ldr	r3, [r3, #0]
240048b8:	4a5d      	ldr	r2, [pc, #372]	; (24004a30 <HAL_DMA_Abort_IT+0x3d0>)
240048ba:	4293      	cmp	r3, r2
240048bc:	d018      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
240048be:	687b      	ldr	r3, [r7, #4]
240048c0:	681b      	ldr	r3, [r3, #0]
240048c2:	4a5c      	ldr	r2, [pc, #368]	; (24004a34 <HAL_DMA_Abort_IT+0x3d4>)
240048c4:	4293      	cmp	r3, r2
240048c6:	d013      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
240048c8:	687b      	ldr	r3, [r7, #4]
240048ca:	681b      	ldr	r3, [r3, #0]
240048cc:	4a5a      	ldr	r2, [pc, #360]	; (24004a38 <HAL_DMA_Abort_IT+0x3d8>)
240048ce:	4293      	cmp	r3, r2
240048d0:	d00e      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
240048d2:	687b      	ldr	r3, [r7, #4]
240048d4:	681b      	ldr	r3, [r3, #0]
240048d6:	4a59      	ldr	r2, [pc, #356]	; (24004a3c <HAL_DMA_Abort_IT+0x3dc>)
240048d8:	4293      	cmp	r3, r2
240048da:	d009      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
240048dc:	687b      	ldr	r3, [r7, #4]
240048de:	681b      	ldr	r3, [r3, #0]
240048e0:	4a57      	ldr	r2, [pc, #348]	; (24004a40 <HAL_DMA_Abort_IT+0x3e0>)
240048e2:	4293      	cmp	r3, r2
240048e4:	d004      	beq.n	240048f0 <HAL_DMA_Abort_IT+0x290>
240048e6:	687b      	ldr	r3, [r7, #4]
240048e8:	681b      	ldr	r3, [r3, #0]
240048ea:	4a56      	ldr	r2, [pc, #344]	; (24004a44 <HAL_DMA_Abort_IT+0x3e4>)
240048ec:	4293      	cmp	r3, r2
240048ee:	d108      	bne.n	24004902 <HAL_DMA_Abort_IT+0x2a2>
240048f0:	687b      	ldr	r3, [r7, #4]
240048f2:	681b      	ldr	r3, [r3, #0]
240048f4:	681a      	ldr	r2, [r3, #0]
240048f6:	687b      	ldr	r3, [r7, #4]
240048f8:	681b      	ldr	r3, [r3, #0]
240048fa:	f022 0201 	bic.w	r2, r2, #1
240048fe:	601a      	str	r2, [r3, #0]
24004900:	e007      	b.n	24004912 <HAL_DMA_Abort_IT+0x2b2>
24004902:	687b      	ldr	r3, [r7, #4]
24004904:	681b      	ldr	r3, [r3, #0]
24004906:	681a      	ldr	r2, [r3, #0]
24004908:	687b      	ldr	r3, [r7, #4]
2400490a:	681b      	ldr	r3, [r3, #0]
2400490c:	f022 0201 	bic.w	r2, r2, #1
24004910:	601a      	str	r2, [r3, #0]

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24004912:	687b      	ldr	r3, [r7, #4]
24004914:	681b      	ldr	r3, [r3, #0]
24004916:	4a3c      	ldr	r2, [pc, #240]	; (24004a08 <HAL_DMA_Abort_IT+0x3a8>)
24004918:	4293      	cmp	r3, r2
2400491a:	d072      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
2400491c:	687b      	ldr	r3, [r7, #4]
2400491e:	681b      	ldr	r3, [r3, #0]
24004920:	4a3a      	ldr	r2, [pc, #232]	; (24004a0c <HAL_DMA_Abort_IT+0x3ac>)
24004922:	4293      	cmp	r3, r2
24004924:	d06d      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
24004926:	687b      	ldr	r3, [r7, #4]
24004928:	681b      	ldr	r3, [r3, #0]
2400492a:	4a39      	ldr	r2, [pc, #228]	; (24004a10 <HAL_DMA_Abort_IT+0x3b0>)
2400492c:	4293      	cmp	r3, r2
2400492e:	d068      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
24004930:	687b      	ldr	r3, [r7, #4]
24004932:	681b      	ldr	r3, [r3, #0]
24004934:	4a37      	ldr	r2, [pc, #220]	; (24004a14 <HAL_DMA_Abort_IT+0x3b4>)
24004936:	4293      	cmp	r3, r2
24004938:	d063      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
2400493a:	687b      	ldr	r3, [r7, #4]
2400493c:	681b      	ldr	r3, [r3, #0]
2400493e:	4a36      	ldr	r2, [pc, #216]	; (24004a18 <HAL_DMA_Abort_IT+0x3b8>)
24004940:	4293      	cmp	r3, r2
24004942:	d05e      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
24004944:	687b      	ldr	r3, [r7, #4]
24004946:	681b      	ldr	r3, [r3, #0]
24004948:	4a34      	ldr	r2, [pc, #208]	; (24004a1c <HAL_DMA_Abort_IT+0x3bc>)
2400494a:	4293      	cmp	r3, r2
2400494c:	d059      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
2400494e:	687b      	ldr	r3, [r7, #4]
24004950:	681b      	ldr	r3, [r3, #0]
24004952:	4a33      	ldr	r2, [pc, #204]	; (24004a20 <HAL_DMA_Abort_IT+0x3c0>)
24004954:	4293      	cmp	r3, r2
24004956:	d054      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
24004958:	687b      	ldr	r3, [r7, #4]
2400495a:	681b      	ldr	r3, [r3, #0]
2400495c:	4a31      	ldr	r2, [pc, #196]	; (24004a24 <HAL_DMA_Abort_IT+0x3c4>)
2400495e:	4293      	cmp	r3, r2
24004960:	d04f      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
24004962:	687b      	ldr	r3, [r7, #4]
24004964:	681b      	ldr	r3, [r3, #0]
24004966:	4a30      	ldr	r2, [pc, #192]	; (24004a28 <HAL_DMA_Abort_IT+0x3c8>)
24004968:	4293      	cmp	r3, r2
2400496a:	d04a      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
2400496c:	687b      	ldr	r3, [r7, #4]
2400496e:	681b      	ldr	r3, [r3, #0]
24004970:	4a2e      	ldr	r2, [pc, #184]	; (24004a2c <HAL_DMA_Abort_IT+0x3cc>)
24004972:	4293      	cmp	r3, r2
24004974:	d045      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
24004976:	687b      	ldr	r3, [r7, #4]
24004978:	681b      	ldr	r3, [r3, #0]
2400497a:	4a2d      	ldr	r2, [pc, #180]	; (24004a30 <HAL_DMA_Abort_IT+0x3d0>)
2400497c:	4293      	cmp	r3, r2
2400497e:	d040      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
24004980:	687b      	ldr	r3, [r7, #4]
24004982:	681b      	ldr	r3, [r3, #0]
24004984:	4a2b      	ldr	r2, [pc, #172]	; (24004a34 <HAL_DMA_Abort_IT+0x3d4>)
24004986:	4293      	cmp	r3, r2
24004988:	d03b      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
2400498a:	687b      	ldr	r3, [r7, #4]
2400498c:	681b      	ldr	r3, [r3, #0]
2400498e:	4a2a      	ldr	r2, [pc, #168]	; (24004a38 <HAL_DMA_Abort_IT+0x3d8>)
24004990:	4293      	cmp	r3, r2
24004992:	d036      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
24004994:	687b      	ldr	r3, [r7, #4]
24004996:	681b      	ldr	r3, [r3, #0]
24004998:	4a28      	ldr	r2, [pc, #160]	; (24004a3c <HAL_DMA_Abort_IT+0x3dc>)
2400499a:	4293      	cmp	r3, r2
2400499c:	d031      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
2400499e:	687b      	ldr	r3, [r7, #4]
240049a0:	681b      	ldr	r3, [r3, #0]
240049a2:	4a27      	ldr	r2, [pc, #156]	; (24004a40 <HAL_DMA_Abort_IT+0x3e0>)
240049a4:	4293      	cmp	r3, r2
240049a6:	d02c      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049a8:	687b      	ldr	r3, [r7, #4]
240049aa:	681b      	ldr	r3, [r3, #0]
240049ac:	4a25      	ldr	r2, [pc, #148]	; (24004a44 <HAL_DMA_Abort_IT+0x3e4>)
240049ae:	4293      	cmp	r3, r2
240049b0:	d027      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049b2:	687b      	ldr	r3, [r7, #4]
240049b4:	681b      	ldr	r3, [r3, #0]
240049b6:	4a24      	ldr	r2, [pc, #144]	; (24004a48 <HAL_DMA_Abort_IT+0x3e8>)
240049b8:	4293      	cmp	r3, r2
240049ba:	d022      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049bc:	687b      	ldr	r3, [r7, #4]
240049be:	681b      	ldr	r3, [r3, #0]
240049c0:	4a22      	ldr	r2, [pc, #136]	; (24004a4c <HAL_DMA_Abort_IT+0x3ec>)
240049c2:	4293      	cmp	r3, r2
240049c4:	d01d      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049c6:	687b      	ldr	r3, [r7, #4]
240049c8:	681b      	ldr	r3, [r3, #0]
240049ca:	4a21      	ldr	r2, [pc, #132]	; (24004a50 <HAL_DMA_Abort_IT+0x3f0>)
240049cc:	4293      	cmp	r3, r2
240049ce:	d018      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049d0:	687b      	ldr	r3, [r7, #4]
240049d2:	681b      	ldr	r3, [r3, #0]
240049d4:	4a1f      	ldr	r2, [pc, #124]	; (24004a54 <HAL_DMA_Abort_IT+0x3f4>)
240049d6:	4293      	cmp	r3, r2
240049d8:	d013      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049da:	687b      	ldr	r3, [r7, #4]
240049dc:	681b      	ldr	r3, [r3, #0]
240049de:	4a1e      	ldr	r2, [pc, #120]	; (24004a58 <HAL_DMA_Abort_IT+0x3f8>)
240049e0:	4293      	cmp	r3, r2
240049e2:	d00e      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049e4:	687b      	ldr	r3, [r7, #4]
240049e6:	681b      	ldr	r3, [r3, #0]
240049e8:	4a1c      	ldr	r2, [pc, #112]	; (24004a5c <HAL_DMA_Abort_IT+0x3fc>)
240049ea:	4293      	cmp	r3, r2
240049ec:	d009      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049ee:	687b      	ldr	r3, [r7, #4]
240049f0:	681b      	ldr	r3, [r3, #0]
240049f2:	4a1b      	ldr	r2, [pc, #108]	; (24004a60 <HAL_DMA_Abort_IT+0x400>)
240049f4:	4293      	cmp	r3, r2
240049f6:	d004      	beq.n	24004a02 <HAL_DMA_Abort_IT+0x3a2>
240049f8:	687b      	ldr	r3, [r7, #4]
240049fa:	681b      	ldr	r3, [r3, #0]
240049fc:	4a19      	ldr	r2, [pc, #100]	; (24004a64 <HAL_DMA_Abort_IT+0x404>)
240049fe:	4293      	cmp	r3, r2
24004a00:	d132      	bne.n	24004a68 <HAL_DMA_Abort_IT+0x408>
24004a02:	2301      	movs	r3, #1
24004a04:	e031      	b.n	24004a6a <HAL_DMA_Abort_IT+0x40a>
24004a06:	bf00      	nop
24004a08:	40020010 	.word	0x40020010
24004a0c:	40020028 	.word	0x40020028
24004a10:	40020040 	.word	0x40020040
24004a14:	40020058 	.word	0x40020058
24004a18:	40020070 	.word	0x40020070
24004a1c:	40020088 	.word	0x40020088
24004a20:	400200a0 	.word	0x400200a0
24004a24:	400200b8 	.word	0x400200b8
24004a28:	40020410 	.word	0x40020410
24004a2c:	40020428 	.word	0x40020428
24004a30:	40020440 	.word	0x40020440
24004a34:	40020458 	.word	0x40020458
24004a38:	40020470 	.word	0x40020470
24004a3c:	40020488 	.word	0x40020488
24004a40:	400204a0 	.word	0x400204a0
24004a44:	400204b8 	.word	0x400204b8
24004a48:	58025408 	.word	0x58025408
24004a4c:	5802541c 	.word	0x5802541c
24004a50:	58025430 	.word	0x58025430
24004a54:	58025444 	.word	0x58025444
24004a58:	58025458 	.word	0x58025458
24004a5c:	5802546c 	.word	0x5802546c
24004a60:	58025480 	.word	0x58025480
24004a64:	58025494 	.word	0x58025494
24004a68:	2300      	movs	r3, #0
24004a6a:	2b00      	cmp	r3, #0
24004a6c:	d028      	beq.n	24004ac0 <HAL_DMA_Abort_IT+0x460>
      {
        /* disable the DMAMUX sync overrun IT */
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24004a6e:	687b      	ldr	r3, [r7, #4]
24004a70:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24004a72:	681a      	ldr	r2, [r3, #0]
24004a74:	687b      	ldr	r3, [r7, #4]
24004a76:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24004a78:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24004a7c:	601a      	str	r2, [r3, #0]

        /* Clear all flags */
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24004a7e:	687b      	ldr	r3, [r7, #4]
24004a80:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004a82:	60fb      	str	r3, [r7, #12]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24004a84:	687b      	ldr	r3, [r7, #4]
24004a86:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004a88:	f003 031f 	and.w	r3, r3, #31
24004a8c:	2201      	movs	r2, #1
24004a8e:	409a      	lsls	r2, r3
24004a90:	68fb      	ldr	r3, [r7, #12]
24004a92:	605a      	str	r2, [r3, #4]

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24004a94:	687b      	ldr	r3, [r7, #4]
24004a96:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24004a98:	687a      	ldr	r2, [r7, #4]
24004a9a:	6e92      	ldr	r2, [r2, #104]	; 0x68
24004a9c:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
24004a9e:	687b      	ldr	r3, [r7, #4]
24004aa0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004aa2:	2b00      	cmp	r3, #0
24004aa4:	d00c      	beq.n	24004ac0 <HAL_DMA_Abort_IT+0x460>
        {
          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
          /* disable the request gen overrun IT */
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
24004aa6:	687b      	ldr	r3, [r7, #4]
24004aa8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004aaa:	681a      	ldr	r2, [r3, #0]
24004aac:	687b      	ldr	r3, [r7, #4]
24004aae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004ab0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24004ab4:	601a      	str	r2, [r3, #0]

          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24004ab6:	687b      	ldr	r3, [r7, #4]
24004ab8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24004aba:	687a      	ldr	r2, [r7, #4]
24004abc:	6f52      	ldr	r2, [r2, #116]	; 0x74
24004abe:	605a      	str	r2, [r3, #4]
        }
      }

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
24004ac0:	687b      	ldr	r3, [r7, #4]
24004ac2:	2201      	movs	r2, #1
24004ac4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
24004ac8:	687b      	ldr	r3, [r7, #4]
24004aca:	2200      	movs	r2, #0
24004acc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Call User Abort callback */
      if(hdma->XferAbortCallback != NULL)
24004ad0:	687b      	ldr	r3, [r7, #4]
24004ad2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24004ad4:	2b00      	cmp	r3, #0
24004ad6:	d003      	beq.n	24004ae0 <HAL_DMA_Abort_IT+0x480>
      {
        hdma->XferAbortCallback(hdma);
24004ad8:	687b      	ldr	r3, [r7, #4]
24004ada:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24004adc:	6878      	ldr	r0, [r7, #4]
24004ade:	4798      	blx	r3
      }
    }
  }

  return HAL_OK;
24004ae0:	2300      	movs	r3, #0
}
24004ae2:	4618      	mov	r0, r3
24004ae4:	3710      	adds	r7, #16
24004ae6:	46bd      	mov	sp, r7
24004ae8:	bd80      	pop	{r7, pc}
24004aea:	bf00      	nop

24004aec <HAL_DMA_PollForTransfer>:
  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode).
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
24004aec:	b580      	push	{r7, lr}
24004aee:	b08a      	sub	sp, #40	; 0x28
24004af0:	af00      	add	r7, sp, #0
24004af2:	60f8      	str	r0, [r7, #12]
24004af4:	460b      	mov	r3, r1
24004af6:	607a      	str	r2, [r7, #4]
24004af8:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
24004afa:	2300      	movs	r3, #0
24004afc:	76fb      	strb	r3, [r7, #27]
  uint32_t cpltlevel_mask;
  uint32_t tickstart = HAL_GetTick();
24004afe:	f7fd fa8d 	bl	2400201c <HAL_GetTick>
24004b02:	6178      	str	r0, [r7, #20]
  __IO uint32_t *isr_reg;
  /* IT clear flag register */
  __IO uint32_t *ifcr_reg;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004b04:	68fb      	ldr	r3, [r7, #12]
24004b06:	2b00      	cmp	r3, #0
24004b08:	d101      	bne.n	24004b0e <HAL_DMA_PollForTransfer+0x22>
  {
    return HAL_ERROR;
24004b0a:	2301      	movs	r3, #1
24004b0c:	e374      	b.n	240051f8 <HAL_DMA_PollForTransfer+0x70c>
  }

  if(HAL_DMA_STATE_BUSY != hdma->State)
24004b0e:	68fb      	ldr	r3, [r7, #12]
24004b10:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004b14:	b2db      	uxtb	r3, r3
24004b16:	2b02      	cmp	r3, #2
24004b18:	d008      	beq.n	24004b2c <HAL_DMA_PollForTransfer+0x40>
  {
    /* No transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24004b1a:	68fb      	ldr	r3, [r7, #12]
24004b1c:	2280      	movs	r2, #128	; 0x80
24004b1e:	655a      	str	r2, [r3, #84]	; 0x54
    __HAL_UNLOCK(hdma);
24004b20:	68fb      	ldr	r3, [r7, #12]
24004b22:	2200      	movs	r2, #0
24004b24:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
24004b28:	2301      	movs	r3, #1
24004b2a:	e365      	b.n	240051f8 <HAL_DMA_PollForTransfer+0x70c>
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004b2c:	68fb      	ldr	r3, [r7, #12]
24004b2e:	681b      	ldr	r3, [r3, #0]
24004b30:	4a7b      	ldr	r2, [pc, #492]	; (24004d20 <HAL_DMA_PollForTransfer+0x234>)
24004b32:	4293      	cmp	r3, r2
24004b34:	d04a      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b36:	68fb      	ldr	r3, [r7, #12]
24004b38:	681b      	ldr	r3, [r3, #0]
24004b3a:	4a7a      	ldr	r2, [pc, #488]	; (24004d24 <HAL_DMA_PollForTransfer+0x238>)
24004b3c:	4293      	cmp	r3, r2
24004b3e:	d045      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b40:	68fb      	ldr	r3, [r7, #12]
24004b42:	681b      	ldr	r3, [r3, #0]
24004b44:	4a78      	ldr	r2, [pc, #480]	; (24004d28 <HAL_DMA_PollForTransfer+0x23c>)
24004b46:	4293      	cmp	r3, r2
24004b48:	d040      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b4a:	68fb      	ldr	r3, [r7, #12]
24004b4c:	681b      	ldr	r3, [r3, #0]
24004b4e:	4a77      	ldr	r2, [pc, #476]	; (24004d2c <HAL_DMA_PollForTransfer+0x240>)
24004b50:	4293      	cmp	r3, r2
24004b52:	d03b      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b54:	68fb      	ldr	r3, [r7, #12]
24004b56:	681b      	ldr	r3, [r3, #0]
24004b58:	4a75      	ldr	r2, [pc, #468]	; (24004d30 <HAL_DMA_PollForTransfer+0x244>)
24004b5a:	4293      	cmp	r3, r2
24004b5c:	d036      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b5e:	68fb      	ldr	r3, [r7, #12]
24004b60:	681b      	ldr	r3, [r3, #0]
24004b62:	4a74      	ldr	r2, [pc, #464]	; (24004d34 <HAL_DMA_PollForTransfer+0x248>)
24004b64:	4293      	cmp	r3, r2
24004b66:	d031      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b68:	68fb      	ldr	r3, [r7, #12]
24004b6a:	681b      	ldr	r3, [r3, #0]
24004b6c:	4a72      	ldr	r2, [pc, #456]	; (24004d38 <HAL_DMA_PollForTransfer+0x24c>)
24004b6e:	4293      	cmp	r3, r2
24004b70:	d02c      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b72:	68fb      	ldr	r3, [r7, #12]
24004b74:	681b      	ldr	r3, [r3, #0]
24004b76:	4a71      	ldr	r2, [pc, #452]	; (24004d3c <HAL_DMA_PollForTransfer+0x250>)
24004b78:	4293      	cmp	r3, r2
24004b7a:	d027      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b7c:	68fb      	ldr	r3, [r7, #12]
24004b7e:	681b      	ldr	r3, [r3, #0]
24004b80:	4a6f      	ldr	r2, [pc, #444]	; (24004d40 <HAL_DMA_PollForTransfer+0x254>)
24004b82:	4293      	cmp	r3, r2
24004b84:	d022      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b86:	68fb      	ldr	r3, [r7, #12]
24004b88:	681b      	ldr	r3, [r3, #0]
24004b8a:	4a6e      	ldr	r2, [pc, #440]	; (24004d44 <HAL_DMA_PollForTransfer+0x258>)
24004b8c:	4293      	cmp	r3, r2
24004b8e:	d01d      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b90:	68fb      	ldr	r3, [r7, #12]
24004b92:	681b      	ldr	r3, [r3, #0]
24004b94:	4a6c      	ldr	r2, [pc, #432]	; (24004d48 <HAL_DMA_PollForTransfer+0x25c>)
24004b96:	4293      	cmp	r3, r2
24004b98:	d018      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004b9a:	68fb      	ldr	r3, [r7, #12]
24004b9c:	681b      	ldr	r3, [r3, #0]
24004b9e:	4a6b      	ldr	r2, [pc, #428]	; (24004d4c <HAL_DMA_PollForTransfer+0x260>)
24004ba0:	4293      	cmp	r3, r2
24004ba2:	d013      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004ba4:	68fb      	ldr	r3, [r7, #12]
24004ba6:	681b      	ldr	r3, [r3, #0]
24004ba8:	4a69      	ldr	r2, [pc, #420]	; (24004d50 <HAL_DMA_PollForTransfer+0x264>)
24004baa:	4293      	cmp	r3, r2
24004bac:	d00e      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004bae:	68fb      	ldr	r3, [r7, #12]
24004bb0:	681b      	ldr	r3, [r3, #0]
24004bb2:	4a68      	ldr	r2, [pc, #416]	; (24004d54 <HAL_DMA_PollForTransfer+0x268>)
24004bb4:	4293      	cmp	r3, r2
24004bb6:	d009      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004bb8:	68fb      	ldr	r3, [r7, #12]
24004bba:	681b      	ldr	r3, [r3, #0]
24004bbc:	4a66      	ldr	r2, [pc, #408]	; (24004d58 <HAL_DMA_PollForTransfer+0x26c>)
24004bbe:	4293      	cmp	r3, r2
24004bc0:	d004      	beq.n	24004bcc <HAL_DMA_PollForTransfer+0xe0>
24004bc2:	68fb      	ldr	r3, [r7, #12]
24004bc4:	681b      	ldr	r3, [r3, #0]
24004bc6:	4a65      	ldr	r2, [pc, #404]	; (24004d5c <HAL_DMA_PollForTransfer+0x270>)
24004bc8:	4293      	cmp	r3, r2
24004bca:	d101      	bne.n	24004bd0 <HAL_DMA_PollForTransfer+0xe4>
24004bcc:	2301      	movs	r3, #1
24004bce:	e000      	b.n	24004bd2 <HAL_DMA_PollForTransfer+0xe6>
24004bd0:	2300      	movs	r3, #0
24004bd2:	2b00      	cmp	r3, #0
24004bd4:	d028      	beq.n	24004c28 <HAL_DMA_PollForTransfer+0x13c>
  {
    /* Polling mode not supported in circular mode and double buffering mode */
    if ((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) != 0U)
24004bd6:	68fb      	ldr	r3, [r7, #12]
24004bd8:	681b      	ldr	r3, [r3, #0]
24004bda:	681b      	ldr	r3, [r3, #0]
24004bdc:	f403 7380 	and.w	r3, r3, #256	; 0x100
24004be0:	2b00      	cmp	r3, #0
24004be2:	d005      	beq.n	24004bf0 <HAL_DMA_PollForTransfer+0x104>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24004be4:	68fb      	ldr	r3, [r7, #12]
24004be6:	f44f 7280 	mov.w	r2, #256	; 0x100
24004bea:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
24004bec:	2301      	movs	r3, #1
24004bee:	e303      	b.n	240051f8 <HAL_DMA_PollForTransfer+0x70c>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
24004bf0:	7afb      	ldrb	r3, [r7, #11]
24004bf2:	2b00      	cmp	r3, #0
24004bf4:	d108      	bne.n	24004c08 <HAL_DMA_PollForTransfer+0x11c>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
24004bf6:	68fb      	ldr	r3, [r7, #12]
24004bf8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004bfa:	f003 031f 	and.w	r3, r3, #31
24004bfe:	2220      	movs	r2, #32
24004c00:	fa02 f303 	lsl.w	r3, r2, r3
24004c04:	627b      	str	r3, [r7, #36]	; 0x24
24004c06:	e007      	b.n	24004c18 <HAL_DMA_PollForTransfer+0x12c>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24004c08:	68fb      	ldr	r3, [r7, #12]
24004c0a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004c0c:	f003 031f 	and.w	r3, r3, #31
24004c10:	2210      	movs	r2, #16
24004c12:	fa02 f303 	lsl.w	r3, r2, r3
24004c16:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24004c18:	68fb      	ldr	r3, [r7, #12]
24004c1a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004c1c:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
24004c1e:	68fb      	ldr	r3, [r7, #12]
24004c20:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004c22:	3308      	adds	r3, #8
24004c24:	61fb      	str	r3, [r7, #28]
24004c26:	e1d5      	b.n	24004fd4 <HAL_DMA_PollForTransfer+0x4e8>
  }
  else /* BDMA channel */
  {
    /* Polling mode not supported in circular mode */
    if ((((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR & BDMA_CCR_CIRC) != 0U)
24004c28:	68fb      	ldr	r3, [r7, #12]
24004c2a:	681b      	ldr	r3, [r3, #0]
24004c2c:	681b      	ldr	r3, [r3, #0]
24004c2e:	f003 0320 	and.w	r3, r3, #32
24004c32:	2b00      	cmp	r3, #0
24004c34:	d005      	beq.n	24004c42 <HAL_DMA_PollForTransfer+0x156>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24004c36:	68fb      	ldr	r3, [r7, #12]
24004c38:	f44f 7280 	mov.w	r2, #256	; 0x100
24004c3c:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
24004c3e:	2301      	movs	r3, #1
24004c40:	e2da      	b.n	240051f8 <HAL_DMA_PollForTransfer+0x70c>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
24004c42:	7afb      	ldrb	r3, [r7, #11]
24004c44:	2b00      	cmp	r3, #0
24004c46:	d108      	bne.n	24004c5a <HAL_DMA_PollForTransfer+0x16e>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);
24004c48:	68fb      	ldr	r3, [r7, #12]
24004c4a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004c4c:	f003 031f 	and.w	r3, r3, #31
24004c50:	2202      	movs	r2, #2
24004c52:	fa02 f303 	lsl.w	r3, r2, r3
24004c56:	627b      	str	r3, [r7, #36]	; 0x24
24004c58:	e007      	b.n	24004c6a <HAL_DMA_PollForTransfer+0x17e>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);
24004c5a:	68fb      	ldr	r3, [r7, #12]
24004c5c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004c5e:	f003 031f 	and.w	r3, r3, #31
24004c62:	2204      	movs	r2, #4
24004c64:	fa02 f303 	lsl.w	r3, r2, r3
24004c68:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24004c6a:	68fb      	ldr	r3, [r7, #12]
24004c6c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004c6e:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
24004c70:	68fb      	ldr	r3, [r7, #12]
24004c72:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004c74:	3304      	adds	r3, #4
24004c76:	61fb      	str	r3, [r7, #28]
  }

  while(((*isr_reg) & cpltlevel_mask) == 0U)
24004c78:	e1ac      	b.n	24004fd4 <HAL_DMA_PollForTransfer+0x4e8>
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004c7a:	68fb      	ldr	r3, [r7, #12]
24004c7c:	681b      	ldr	r3, [r3, #0]
24004c7e:	4a28      	ldr	r2, [pc, #160]	; (24004d20 <HAL_DMA_PollForTransfer+0x234>)
24004c80:	4293      	cmp	r3, r2
24004c82:	d04a      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004c84:	68fb      	ldr	r3, [r7, #12]
24004c86:	681b      	ldr	r3, [r3, #0]
24004c88:	4a26      	ldr	r2, [pc, #152]	; (24004d24 <HAL_DMA_PollForTransfer+0x238>)
24004c8a:	4293      	cmp	r3, r2
24004c8c:	d045      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004c8e:	68fb      	ldr	r3, [r7, #12]
24004c90:	681b      	ldr	r3, [r3, #0]
24004c92:	4a25      	ldr	r2, [pc, #148]	; (24004d28 <HAL_DMA_PollForTransfer+0x23c>)
24004c94:	4293      	cmp	r3, r2
24004c96:	d040      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004c98:	68fb      	ldr	r3, [r7, #12]
24004c9a:	681b      	ldr	r3, [r3, #0]
24004c9c:	4a23      	ldr	r2, [pc, #140]	; (24004d2c <HAL_DMA_PollForTransfer+0x240>)
24004c9e:	4293      	cmp	r3, r2
24004ca0:	d03b      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004ca2:	68fb      	ldr	r3, [r7, #12]
24004ca4:	681b      	ldr	r3, [r3, #0]
24004ca6:	4a22      	ldr	r2, [pc, #136]	; (24004d30 <HAL_DMA_PollForTransfer+0x244>)
24004ca8:	4293      	cmp	r3, r2
24004caa:	d036      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004cac:	68fb      	ldr	r3, [r7, #12]
24004cae:	681b      	ldr	r3, [r3, #0]
24004cb0:	4a20      	ldr	r2, [pc, #128]	; (24004d34 <HAL_DMA_PollForTransfer+0x248>)
24004cb2:	4293      	cmp	r3, r2
24004cb4:	d031      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004cb6:	68fb      	ldr	r3, [r7, #12]
24004cb8:	681b      	ldr	r3, [r3, #0]
24004cba:	4a1f      	ldr	r2, [pc, #124]	; (24004d38 <HAL_DMA_PollForTransfer+0x24c>)
24004cbc:	4293      	cmp	r3, r2
24004cbe:	d02c      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004cc0:	68fb      	ldr	r3, [r7, #12]
24004cc2:	681b      	ldr	r3, [r3, #0]
24004cc4:	4a1d      	ldr	r2, [pc, #116]	; (24004d3c <HAL_DMA_PollForTransfer+0x250>)
24004cc6:	4293      	cmp	r3, r2
24004cc8:	d027      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004cca:	68fb      	ldr	r3, [r7, #12]
24004ccc:	681b      	ldr	r3, [r3, #0]
24004cce:	4a1c      	ldr	r2, [pc, #112]	; (24004d40 <HAL_DMA_PollForTransfer+0x254>)
24004cd0:	4293      	cmp	r3, r2
24004cd2:	d022      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004cd4:	68fb      	ldr	r3, [r7, #12]
24004cd6:	681b      	ldr	r3, [r3, #0]
24004cd8:	4a1a      	ldr	r2, [pc, #104]	; (24004d44 <HAL_DMA_PollForTransfer+0x258>)
24004cda:	4293      	cmp	r3, r2
24004cdc:	d01d      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004cde:	68fb      	ldr	r3, [r7, #12]
24004ce0:	681b      	ldr	r3, [r3, #0]
24004ce2:	4a19      	ldr	r2, [pc, #100]	; (24004d48 <HAL_DMA_PollForTransfer+0x25c>)
24004ce4:	4293      	cmp	r3, r2
24004ce6:	d018      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004ce8:	68fb      	ldr	r3, [r7, #12]
24004cea:	681b      	ldr	r3, [r3, #0]
24004cec:	4a17      	ldr	r2, [pc, #92]	; (24004d4c <HAL_DMA_PollForTransfer+0x260>)
24004cee:	4293      	cmp	r3, r2
24004cf0:	d013      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004cf2:	68fb      	ldr	r3, [r7, #12]
24004cf4:	681b      	ldr	r3, [r3, #0]
24004cf6:	4a16      	ldr	r2, [pc, #88]	; (24004d50 <HAL_DMA_PollForTransfer+0x264>)
24004cf8:	4293      	cmp	r3, r2
24004cfa:	d00e      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004cfc:	68fb      	ldr	r3, [r7, #12]
24004cfe:	681b      	ldr	r3, [r3, #0]
24004d00:	4a14      	ldr	r2, [pc, #80]	; (24004d54 <HAL_DMA_PollForTransfer+0x268>)
24004d02:	4293      	cmp	r3, r2
24004d04:	d009      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004d06:	68fb      	ldr	r3, [r7, #12]
24004d08:	681b      	ldr	r3, [r3, #0]
24004d0a:	4a13      	ldr	r2, [pc, #76]	; (24004d58 <HAL_DMA_PollForTransfer+0x26c>)
24004d0c:	4293      	cmp	r3, r2
24004d0e:	d004      	beq.n	24004d1a <HAL_DMA_PollForTransfer+0x22e>
24004d10:	68fb      	ldr	r3, [r7, #12]
24004d12:	681b      	ldr	r3, [r3, #0]
24004d14:	4a11      	ldr	r2, [pc, #68]	; (24004d5c <HAL_DMA_PollForTransfer+0x270>)
24004d16:	4293      	cmp	r3, r2
24004d18:	d122      	bne.n	24004d60 <HAL_DMA_PollForTransfer+0x274>
24004d1a:	2301      	movs	r3, #1
24004d1c:	e021      	b.n	24004d62 <HAL_DMA_PollForTransfer+0x276>
24004d1e:	bf00      	nop
24004d20:	40020010 	.word	0x40020010
24004d24:	40020028 	.word	0x40020028
24004d28:	40020040 	.word	0x40020040
24004d2c:	40020058 	.word	0x40020058
24004d30:	40020070 	.word	0x40020070
24004d34:	40020088 	.word	0x40020088
24004d38:	400200a0 	.word	0x400200a0
24004d3c:	400200b8 	.word	0x400200b8
24004d40:	40020410 	.word	0x40020410
24004d44:	40020428 	.word	0x40020428
24004d48:	40020440 	.word	0x40020440
24004d4c:	40020458 	.word	0x40020458
24004d50:	40020470 	.word	0x40020470
24004d54:	40020488 	.word	0x40020488
24004d58:	400204a0 	.word	0x400204a0
24004d5c:	400204b8 	.word	0x400204b8
24004d60:	2300      	movs	r3, #0
24004d62:	2b00      	cmp	r3, #0
24004d64:	d057      	beq.n	24004e16 <HAL_DMA_PollForTransfer+0x32a>
    {
      if(((*isr_reg) & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24004d66:	6a3b      	ldr	r3, [r7, #32]
24004d68:	681a      	ldr	r2, [r3, #0]
24004d6a:	68fb      	ldr	r3, [r7, #12]
24004d6c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004d6e:	f003 031f 	and.w	r3, r3, #31
24004d72:	fa22 f303 	lsr.w	r3, r2, r3
24004d76:	f003 0301 	and.w	r3, r3, #1
24004d7a:	2b00      	cmp	r3, #0
24004d7c:	d00d      	beq.n	24004d9a <HAL_DMA_PollForTransfer+0x2ae>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
24004d7e:	68fb      	ldr	r3, [r7, #12]
24004d80:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004d82:	f043 0202 	orr.w	r2, r3, #2
24004d86:	68fb      	ldr	r3, [r7, #12]
24004d88:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the FIFO error flag */
        (*ifcr_reg) = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24004d8a:	68fb      	ldr	r3, [r7, #12]
24004d8c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004d8e:	f003 031f 	and.w	r3, r3, #31
24004d92:	2201      	movs	r2, #1
24004d94:	409a      	lsls	r2, r3
24004d96:	69fb      	ldr	r3, [r7, #28]
24004d98:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24004d9a:	6a3b      	ldr	r3, [r7, #32]
24004d9c:	681a      	ldr	r2, [r3, #0]
24004d9e:	68fb      	ldr	r3, [r7, #12]
24004da0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004da2:	f003 031f 	and.w	r3, r3, #31
24004da6:	2104      	movs	r1, #4
24004da8:	fa01 f303 	lsl.w	r3, r1, r3
24004dac:	4013      	ands	r3, r2
24004dae:	2b00      	cmp	r3, #0
24004db0:	d00d      	beq.n	24004dce <HAL_DMA_PollForTransfer+0x2e2>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
24004db2:	68fb      	ldr	r3, [r7, #12]
24004db4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004db6:	f043 0204 	orr.w	r2, r3, #4
24004dba:	68fb      	ldr	r3, [r7, #12]
24004dbc:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the Direct Mode error flag */
        (*ifcr_reg) = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
24004dbe:	68fb      	ldr	r3, [r7, #12]
24004dc0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004dc2:	f003 031f 	and.w	r3, r3, #31
24004dc6:	2204      	movs	r2, #4
24004dc8:	409a      	lsls	r2, r3
24004dca:	69fb      	ldr	r3, [r7, #28]
24004dcc:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24004dce:	6a3b      	ldr	r3, [r7, #32]
24004dd0:	681a      	ldr	r2, [r3, #0]
24004dd2:	68fb      	ldr	r3, [r7, #12]
24004dd4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004dd6:	f003 031f 	and.w	r3, r3, #31
24004dda:	2108      	movs	r1, #8
24004ddc:	fa01 f303 	lsl.w	r3, r1, r3
24004de0:	4013      	ands	r3, r2
24004de2:	2b00      	cmp	r3, #0
24004de4:	d038      	beq.n	24004e58 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
24004de6:	68fb      	ldr	r3, [r7, #12]
24004de8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004dea:	f043 0201 	orr.w	r2, r3, #1
24004dee:	68fb      	ldr	r3, [r7, #12]
24004df0:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the transfer error flag */
        (*ifcr_reg) = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
24004df2:	68fb      	ldr	r3, [r7, #12]
24004df4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004df6:	f003 031f 	and.w	r3, r3, #31
24004dfa:	2208      	movs	r2, #8
24004dfc:	409a      	lsls	r2, r3
24004dfe:	69fb      	ldr	r3, [r7, #28]
24004e00:	601a      	str	r2, [r3, #0]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
24004e02:	68fb      	ldr	r3, [r7, #12]
24004e04:	2201      	movs	r2, #1
24004e06:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24004e0a:	68fb      	ldr	r3, [r7, #12]
24004e0c:	2200      	movs	r2, #0
24004e0e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
24004e12:	2301      	movs	r3, #1
24004e14:	e1f0      	b.n	240051f8 <HAL_DMA_PollForTransfer+0x70c>
      }
    }
    else /* BDMA channel */
    {
      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)
24004e16:	6a3b      	ldr	r3, [r7, #32]
24004e18:	681a      	ldr	r2, [r3, #0]
24004e1a:	68fb      	ldr	r3, [r7, #12]
24004e1c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004e1e:	f003 031f 	and.w	r3, r3, #31
24004e22:	2108      	movs	r1, #8
24004e24:	fa01 f303 	lsl.w	r3, r1, r3
24004e28:	4013      	ands	r3, r2
24004e2a:	2b00      	cmp	r3, #0
24004e2c:	d014      	beq.n	24004e58 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* When a DMA transfer error occurs */
        /* A hardware clear of its EN bits is performed */
        /* Clear all flags */
        (*isr_reg) = ((BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU));
24004e2e:	68fb      	ldr	r3, [r7, #12]
24004e30:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004e32:	f003 031f 	and.w	r3, r3, #31
24004e36:	2201      	movs	r2, #1
24004e38:	409a      	lsls	r2, r3
24004e3a:	6a3b      	ldr	r3, [r7, #32]
24004e3c:	601a      	str	r2, [r3, #0]

        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TE;
24004e3e:	68fb      	ldr	r3, [r7, #12]
24004e40:	2201      	movs	r2, #1
24004e42:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
24004e44:	68fb      	ldr	r3, [r7, #12]
24004e46:	2201      	movs	r2, #1
24004e48:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24004e4c:	68fb      	ldr	r3, [r7, #12]
24004e4e:	2200      	movs	r2, #0
24004e50:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
24004e54:	2301      	movs	r3, #1
24004e56:	e1cf      	b.n	240051f8 <HAL_DMA_PollForTransfer+0x70c>
      }
    }

    /* Check for the Timeout (Not applicable in circular mode)*/
    if(Timeout != HAL_MAX_DELAY)
24004e58:	687b      	ldr	r3, [r7, #4]
24004e5a:	f1b3 3fff 	cmp.w	r3, #4294967295
24004e5e:	d012      	beq.n	24004e86 <HAL_DMA_PollForTransfer+0x39a>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
24004e60:	f7fd f8dc 	bl	2400201c <HAL_GetTick>
24004e64:	4602      	mov	r2, r0
24004e66:	697b      	ldr	r3, [r7, #20]
24004e68:	1ad3      	subs	r3, r2, r3
24004e6a:	687a      	ldr	r2, [r7, #4]
24004e6c:	429a      	cmp	r2, r3
24004e6e:	d302      	bcc.n	24004e76 <HAL_DMA_PollForTransfer+0x38a>
24004e70:	687b      	ldr	r3, [r7, #4]
24004e72:	2b00      	cmp	r3, #0
24004e74:	d107      	bne.n	24004e86 <HAL_DMA_PollForTransfer+0x39a>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24004e76:	68fb      	ldr	r3, [r7, #12]
24004e78:	2220      	movs	r2, #32
24004e7a:	655a      	str	r2, [r3, #84]	; 0x54

        /* if timeout then abort the current transfer */
        /* No need to check return value: as in this case we will return HAL_ERROR with HAL_DMA_ERROR_TIMEOUT error code  */
        (void) HAL_DMA_Abort(hdma);
24004e7c:	68f8      	ldr	r0, [r7, #12]
24004e7e:	f7ff f8d1 	bl	24004024 <HAL_DMA_Abort>
              - Clear the transfer error flags
              - Unlock
              - Set the State
          */

        return HAL_ERROR;
24004e82:	2301      	movs	r3, #1
24004e84:	e1b8      	b.n	240051f8 <HAL_DMA_PollForTransfer+0x70c>
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24004e86:	68fb      	ldr	r3, [r7, #12]
24004e88:	681b      	ldr	r3, [r3, #0]
24004e8a:	4a81      	ldr	r2, [pc, #516]	; (24005090 <HAL_DMA_PollForTransfer+0x5a4>)
24004e8c:	4293      	cmp	r3, r2
24004e8e:	d072      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004e90:	68fb      	ldr	r3, [r7, #12]
24004e92:	681b      	ldr	r3, [r3, #0]
24004e94:	4a7f      	ldr	r2, [pc, #508]	; (24005094 <HAL_DMA_PollForTransfer+0x5a8>)
24004e96:	4293      	cmp	r3, r2
24004e98:	d06d      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004e9a:	68fb      	ldr	r3, [r7, #12]
24004e9c:	681b      	ldr	r3, [r3, #0]
24004e9e:	4a7e      	ldr	r2, [pc, #504]	; (24005098 <HAL_DMA_PollForTransfer+0x5ac>)
24004ea0:	4293      	cmp	r3, r2
24004ea2:	d068      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004ea4:	68fb      	ldr	r3, [r7, #12]
24004ea6:	681b      	ldr	r3, [r3, #0]
24004ea8:	4a7c      	ldr	r2, [pc, #496]	; (2400509c <HAL_DMA_PollForTransfer+0x5b0>)
24004eaa:	4293      	cmp	r3, r2
24004eac:	d063      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004eae:	68fb      	ldr	r3, [r7, #12]
24004eb0:	681b      	ldr	r3, [r3, #0]
24004eb2:	4a7b      	ldr	r2, [pc, #492]	; (240050a0 <HAL_DMA_PollForTransfer+0x5b4>)
24004eb4:	4293      	cmp	r3, r2
24004eb6:	d05e      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004eb8:	68fb      	ldr	r3, [r7, #12]
24004eba:	681b      	ldr	r3, [r3, #0]
24004ebc:	4a79      	ldr	r2, [pc, #484]	; (240050a4 <HAL_DMA_PollForTransfer+0x5b8>)
24004ebe:	4293      	cmp	r3, r2
24004ec0:	d059      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004ec2:	68fb      	ldr	r3, [r7, #12]
24004ec4:	681b      	ldr	r3, [r3, #0]
24004ec6:	4a78      	ldr	r2, [pc, #480]	; (240050a8 <HAL_DMA_PollForTransfer+0x5bc>)
24004ec8:	4293      	cmp	r3, r2
24004eca:	d054      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004ecc:	68fb      	ldr	r3, [r7, #12]
24004ece:	681b      	ldr	r3, [r3, #0]
24004ed0:	4a76      	ldr	r2, [pc, #472]	; (240050ac <HAL_DMA_PollForTransfer+0x5c0>)
24004ed2:	4293      	cmp	r3, r2
24004ed4:	d04f      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004ed6:	68fb      	ldr	r3, [r7, #12]
24004ed8:	681b      	ldr	r3, [r3, #0]
24004eda:	4a75      	ldr	r2, [pc, #468]	; (240050b0 <HAL_DMA_PollForTransfer+0x5c4>)
24004edc:	4293      	cmp	r3, r2
24004ede:	d04a      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004ee0:	68fb      	ldr	r3, [r7, #12]
24004ee2:	681b      	ldr	r3, [r3, #0]
24004ee4:	4a73      	ldr	r2, [pc, #460]	; (240050b4 <HAL_DMA_PollForTransfer+0x5c8>)
24004ee6:	4293      	cmp	r3, r2
24004ee8:	d045      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004eea:	68fb      	ldr	r3, [r7, #12]
24004eec:	681b      	ldr	r3, [r3, #0]
24004eee:	4a72      	ldr	r2, [pc, #456]	; (240050b8 <HAL_DMA_PollForTransfer+0x5cc>)
24004ef0:	4293      	cmp	r3, r2
24004ef2:	d040      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004ef4:	68fb      	ldr	r3, [r7, #12]
24004ef6:	681b      	ldr	r3, [r3, #0]
24004ef8:	4a70      	ldr	r2, [pc, #448]	; (240050bc <HAL_DMA_PollForTransfer+0x5d0>)
24004efa:	4293      	cmp	r3, r2
24004efc:	d03b      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004efe:	68fb      	ldr	r3, [r7, #12]
24004f00:	681b      	ldr	r3, [r3, #0]
24004f02:	4a6f      	ldr	r2, [pc, #444]	; (240050c0 <HAL_DMA_PollForTransfer+0x5d4>)
24004f04:	4293      	cmp	r3, r2
24004f06:	d036      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f08:	68fb      	ldr	r3, [r7, #12]
24004f0a:	681b      	ldr	r3, [r3, #0]
24004f0c:	4a6d      	ldr	r2, [pc, #436]	; (240050c4 <HAL_DMA_PollForTransfer+0x5d8>)
24004f0e:	4293      	cmp	r3, r2
24004f10:	d031      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f12:	68fb      	ldr	r3, [r7, #12]
24004f14:	681b      	ldr	r3, [r3, #0]
24004f16:	4a6c      	ldr	r2, [pc, #432]	; (240050c8 <HAL_DMA_PollForTransfer+0x5dc>)
24004f18:	4293      	cmp	r3, r2
24004f1a:	d02c      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f1c:	68fb      	ldr	r3, [r7, #12]
24004f1e:	681b      	ldr	r3, [r3, #0]
24004f20:	4a6a      	ldr	r2, [pc, #424]	; (240050cc <HAL_DMA_PollForTransfer+0x5e0>)
24004f22:	4293      	cmp	r3, r2
24004f24:	d027      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f26:	68fb      	ldr	r3, [r7, #12]
24004f28:	681b      	ldr	r3, [r3, #0]
24004f2a:	4a69      	ldr	r2, [pc, #420]	; (240050d0 <HAL_DMA_PollForTransfer+0x5e4>)
24004f2c:	4293      	cmp	r3, r2
24004f2e:	d022      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f30:	68fb      	ldr	r3, [r7, #12]
24004f32:	681b      	ldr	r3, [r3, #0]
24004f34:	4a67      	ldr	r2, [pc, #412]	; (240050d4 <HAL_DMA_PollForTransfer+0x5e8>)
24004f36:	4293      	cmp	r3, r2
24004f38:	d01d      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f3a:	68fb      	ldr	r3, [r7, #12]
24004f3c:	681b      	ldr	r3, [r3, #0]
24004f3e:	4a66      	ldr	r2, [pc, #408]	; (240050d8 <HAL_DMA_PollForTransfer+0x5ec>)
24004f40:	4293      	cmp	r3, r2
24004f42:	d018      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f44:	68fb      	ldr	r3, [r7, #12]
24004f46:	681b      	ldr	r3, [r3, #0]
24004f48:	4a64      	ldr	r2, [pc, #400]	; (240050dc <HAL_DMA_PollForTransfer+0x5f0>)
24004f4a:	4293      	cmp	r3, r2
24004f4c:	d013      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f4e:	68fb      	ldr	r3, [r7, #12]
24004f50:	681b      	ldr	r3, [r3, #0]
24004f52:	4a63      	ldr	r2, [pc, #396]	; (240050e0 <HAL_DMA_PollForTransfer+0x5f4>)
24004f54:	4293      	cmp	r3, r2
24004f56:	d00e      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f58:	68fb      	ldr	r3, [r7, #12]
24004f5a:	681b      	ldr	r3, [r3, #0]
24004f5c:	4a61      	ldr	r2, [pc, #388]	; (240050e4 <HAL_DMA_PollForTransfer+0x5f8>)
24004f5e:	4293      	cmp	r3, r2
24004f60:	d009      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f62:	68fb      	ldr	r3, [r7, #12]
24004f64:	681b      	ldr	r3, [r3, #0]
24004f66:	4a60      	ldr	r2, [pc, #384]	; (240050e8 <HAL_DMA_PollForTransfer+0x5fc>)
24004f68:	4293      	cmp	r3, r2
24004f6a:	d004      	beq.n	24004f76 <HAL_DMA_PollForTransfer+0x48a>
24004f6c:	68fb      	ldr	r3, [r7, #12]
24004f6e:	681b      	ldr	r3, [r3, #0]
24004f70:	4a5e      	ldr	r2, [pc, #376]	; (240050ec <HAL_DMA_PollForTransfer+0x600>)
24004f72:	4293      	cmp	r3, r2
24004f74:	d101      	bne.n	24004f7a <HAL_DMA_PollForTransfer+0x48e>
24004f76:	2301      	movs	r3, #1
24004f78:	e000      	b.n	24004f7c <HAL_DMA_PollForTransfer+0x490>
24004f7a:	2300      	movs	r3, #0
24004f7c:	2b00      	cmp	r3, #0
24004f7e:	d029      	beq.n	24004fd4 <HAL_DMA_PollForTransfer+0x4e8>
    {
      /* Check for DMAMUX Request generator (if used) overrun status */
      if(hdma->DMAmuxRequestGen != 0U)
24004f80:	68fb      	ldr	r3, [r7, #12]
24004f82:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004f84:	2b00      	cmp	r3, #0
24004f86:	d012      	beq.n	24004fae <HAL_DMA_PollForTransfer+0x4c2>
      {
        /* if using DMAMUX request generator Check for DMAMUX request generator overrun */
        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
24004f88:	68fb      	ldr	r3, [r7, #12]
24004f8a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24004f8c:	681a      	ldr	r2, [r3, #0]
24004f8e:	68fb      	ldr	r3, [r7, #12]
24004f90:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24004f92:	4013      	ands	r3, r2
24004f94:	2b00      	cmp	r3, #0
24004f96:	d00a      	beq.n	24004fae <HAL_DMA_PollForTransfer+0x4c2>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24004f98:	68fb      	ldr	r3, [r7, #12]
24004f9a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24004f9c:	68fa      	ldr	r2, [r7, #12]
24004f9e:	6f52      	ldr	r2, [r2, #116]	; 0x74
24004fa0:	605a      	str	r2, [r3, #4]

          /* Update error code */
          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
24004fa2:	68fb      	ldr	r3, [r7, #12]
24004fa4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004fa6:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
24004faa:	68fb      	ldr	r3, [r7, #12]
24004fac:	655a      	str	r2, [r3, #84]	; 0x54
        }
      }

      /* Check for DMAMUX Synchronization overrun */
      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
24004fae:	68fb      	ldr	r3, [r7, #12]
24004fb0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24004fb2:	681a      	ldr	r2, [r3, #0]
24004fb4:	68fb      	ldr	r3, [r7, #12]
24004fb6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24004fb8:	4013      	ands	r3, r2
24004fba:	2b00      	cmp	r3, #0
24004fbc:	d00a      	beq.n	24004fd4 <HAL_DMA_PollForTransfer+0x4e8>
      {
        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24004fbe:	68fb      	ldr	r3, [r7, #12]
24004fc0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24004fc2:	68fa      	ldr	r2, [r7, #12]
24004fc4:	6e92      	ldr	r2, [r2, #104]	; 0x68
24004fc6:	605a      	str	r2, [r3, #4]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
24004fc8:	68fb      	ldr	r3, [r7, #12]
24004fca:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004fcc:	f443 7200 	orr.w	r2, r3, #512	; 0x200
24004fd0:	68fb      	ldr	r3, [r7, #12]
24004fd2:	655a      	str	r2, [r3, #84]	; 0x54
  while(((*isr_reg) & cpltlevel_mask) == 0U)
24004fd4:	6a3b      	ldr	r3, [r7, #32]
24004fd6:	681a      	ldr	r2, [r3, #0]
24004fd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24004fda:	4013      	ands	r3, r2
24004fdc:	2b00      	cmp	r3, #0
24004fde:	f43f ae4c 	beq.w	24004c7a <HAL_DMA_PollForTransfer+0x18e>
    }
  }


  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
24004fe2:	7afb      	ldrb	r3, [r7, #11]
24004fe4:	2b00      	cmp	r3, #0
24004fe6:	f040 80a0 	bne.w	2400512a <HAL_DMA_PollForTransfer+0x63e>
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004fea:	68fb      	ldr	r3, [r7, #12]
24004fec:	681b      	ldr	r3, [r3, #0]
24004fee:	4a28      	ldr	r2, [pc, #160]	; (24005090 <HAL_DMA_PollForTransfer+0x5a4>)
24004ff0:	4293      	cmp	r3, r2
24004ff2:	d04a      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24004ff4:	68fb      	ldr	r3, [r7, #12]
24004ff6:	681b      	ldr	r3, [r3, #0]
24004ff8:	4a26      	ldr	r2, [pc, #152]	; (24005094 <HAL_DMA_PollForTransfer+0x5a8>)
24004ffa:	4293      	cmp	r3, r2
24004ffc:	d045      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24004ffe:	68fb      	ldr	r3, [r7, #12]
24005000:	681b      	ldr	r3, [r3, #0]
24005002:	4a25      	ldr	r2, [pc, #148]	; (24005098 <HAL_DMA_PollForTransfer+0x5ac>)
24005004:	4293      	cmp	r3, r2
24005006:	d040      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005008:	68fb      	ldr	r3, [r7, #12]
2400500a:	681b      	ldr	r3, [r3, #0]
2400500c:	4a23      	ldr	r2, [pc, #140]	; (2400509c <HAL_DMA_PollForTransfer+0x5b0>)
2400500e:	4293      	cmp	r3, r2
24005010:	d03b      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005012:	68fb      	ldr	r3, [r7, #12]
24005014:	681b      	ldr	r3, [r3, #0]
24005016:	4a22      	ldr	r2, [pc, #136]	; (240050a0 <HAL_DMA_PollForTransfer+0x5b4>)
24005018:	4293      	cmp	r3, r2
2400501a:	d036      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
2400501c:	68fb      	ldr	r3, [r7, #12]
2400501e:	681b      	ldr	r3, [r3, #0]
24005020:	4a20      	ldr	r2, [pc, #128]	; (240050a4 <HAL_DMA_PollForTransfer+0x5b8>)
24005022:	4293      	cmp	r3, r2
24005024:	d031      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005026:	68fb      	ldr	r3, [r7, #12]
24005028:	681b      	ldr	r3, [r3, #0]
2400502a:	4a1f      	ldr	r2, [pc, #124]	; (240050a8 <HAL_DMA_PollForTransfer+0x5bc>)
2400502c:	4293      	cmp	r3, r2
2400502e:	d02c      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005030:	68fb      	ldr	r3, [r7, #12]
24005032:	681b      	ldr	r3, [r3, #0]
24005034:	4a1d      	ldr	r2, [pc, #116]	; (240050ac <HAL_DMA_PollForTransfer+0x5c0>)
24005036:	4293      	cmp	r3, r2
24005038:	d027      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
2400503a:	68fb      	ldr	r3, [r7, #12]
2400503c:	681b      	ldr	r3, [r3, #0]
2400503e:	4a1c      	ldr	r2, [pc, #112]	; (240050b0 <HAL_DMA_PollForTransfer+0x5c4>)
24005040:	4293      	cmp	r3, r2
24005042:	d022      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005044:	68fb      	ldr	r3, [r7, #12]
24005046:	681b      	ldr	r3, [r3, #0]
24005048:	4a1a      	ldr	r2, [pc, #104]	; (240050b4 <HAL_DMA_PollForTransfer+0x5c8>)
2400504a:	4293      	cmp	r3, r2
2400504c:	d01d      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
2400504e:	68fb      	ldr	r3, [r7, #12]
24005050:	681b      	ldr	r3, [r3, #0]
24005052:	4a19      	ldr	r2, [pc, #100]	; (240050b8 <HAL_DMA_PollForTransfer+0x5cc>)
24005054:	4293      	cmp	r3, r2
24005056:	d018      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005058:	68fb      	ldr	r3, [r7, #12]
2400505a:	681b      	ldr	r3, [r3, #0]
2400505c:	4a17      	ldr	r2, [pc, #92]	; (240050bc <HAL_DMA_PollForTransfer+0x5d0>)
2400505e:	4293      	cmp	r3, r2
24005060:	d013      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005062:	68fb      	ldr	r3, [r7, #12]
24005064:	681b      	ldr	r3, [r3, #0]
24005066:	4a16      	ldr	r2, [pc, #88]	; (240050c0 <HAL_DMA_PollForTransfer+0x5d4>)
24005068:	4293      	cmp	r3, r2
2400506a:	d00e      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
2400506c:	68fb      	ldr	r3, [r7, #12]
2400506e:	681b      	ldr	r3, [r3, #0]
24005070:	4a14      	ldr	r2, [pc, #80]	; (240050c4 <HAL_DMA_PollForTransfer+0x5d8>)
24005072:	4293      	cmp	r3, r2
24005074:	d009      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005076:	68fb      	ldr	r3, [r7, #12]
24005078:	681b      	ldr	r3, [r3, #0]
2400507a:	4a13      	ldr	r2, [pc, #76]	; (240050c8 <HAL_DMA_PollForTransfer+0x5dc>)
2400507c:	4293      	cmp	r3, r2
2400507e:	d004      	beq.n	2400508a <HAL_DMA_PollForTransfer+0x59e>
24005080:	68fb      	ldr	r3, [r7, #12]
24005082:	681b      	ldr	r3, [r3, #0]
24005084:	4a11      	ldr	r2, [pc, #68]	; (240050cc <HAL_DMA_PollForTransfer+0x5e0>)
24005086:	4293      	cmp	r3, r2
24005088:	d132      	bne.n	240050f0 <HAL_DMA_PollForTransfer+0x604>
2400508a:	2301      	movs	r3, #1
2400508c:	e031      	b.n	240050f2 <HAL_DMA_PollForTransfer+0x606>
2400508e:	bf00      	nop
24005090:	40020010 	.word	0x40020010
24005094:	40020028 	.word	0x40020028
24005098:	40020040 	.word	0x40020040
2400509c:	40020058 	.word	0x40020058
240050a0:	40020070 	.word	0x40020070
240050a4:	40020088 	.word	0x40020088
240050a8:	400200a0 	.word	0x400200a0
240050ac:	400200b8 	.word	0x400200b8
240050b0:	40020410 	.word	0x40020410
240050b4:	40020428 	.word	0x40020428
240050b8:	40020440 	.word	0x40020440
240050bc:	40020458 	.word	0x40020458
240050c0:	40020470 	.word	0x40020470
240050c4:	40020488 	.word	0x40020488
240050c8:	400204a0 	.word	0x400204a0
240050cc:	400204b8 	.word	0x400204b8
240050d0:	58025408 	.word	0x58025408
240050d4:	5802541c 	.word	0x5802541c
240050d8:	58025430 	.word	0x58025430
240050dc:	58025444 	.word	0x58025444
240050e0:	58025458 	.word	0x58025458
240050e4:	5802546c 	.word	0x5802546c
240050e8:	58025480 	.word	0x58025480
240050ec:	58025494 	.word	0x58025494
240050f0:	2300      	movs	r3, #0
240050f2:	2b00      	cmp	r3, #0
240050f4:	d008      	beq.n	24005108 <HAL_DMA_PollForTransfer+0x61c>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);
240050f6:	68fb      	ldr	r3, [r7, #12]
240050f8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240050fa:	f003 031f 	and.w	r3, r3, #31
240050fe:	2230      	movs	r2, #48	; 0x30
24005100:	409a      	lsls	r2, r3
24005102:	69fb      	ldr	r3, [r7, #28]
24005104:	601a      	str	r2, [r3, #0]
24005106:	e007      	b.n	24005118 <HAL_DMA_PollForTransfer+0x62c>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU));
24005108:	68fb      	ldr	r3, [r7, #12]
2400510a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400510c:	f003 031f 	and.w	r3, r3, #31
24005110:	2202      	movs	r2, #2
24005112:	409a      	lsls	r2, r3
24005114:	69fb      	ldr	r3, [r7, #28]
24005116:	601a      	str	r2, [r3, #0]
    }

    hdma->State = HAL_DMA_STATE_READY;
24005118:	68fb      	ldr	r3, [r7, #12]
2400511a:	2201      	movs	r2, #1
2400511c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24005120:	68fb      	ldr	r3, [r7, #12]
24005122:	2200      	movs	r2, #0
24005124:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
24005128:	e065      	b.n	240051f6 <HAL_DMA_PollForTransfer+0x70a>
  }
  else /*CompleteLevel = HAL_DMA_HALF_TRANSFER*/
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400512a:	68fb      	ldr	r3, [r7, #12]
2400512c:	681b      	ldr	r3, [r3, #0]
2400512e:	4a34      	ldr	r2, [pc, #208]	; (24005200 <HAL_DMA_PollForTransfer+0x714>)
24005130:	4293      	cmp	r3, r2
24005132:	d04a      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
24005134:	68fb      	ldr	r3, [r7, #12]
24005136:	681b      	ldr	r3, [r3, #0]
24005138:	4a32      	ldr	r2, [pc, #200]	; (24005204 <HAL_DMA_PollForTransfer+0x718>)
2400513a:	4293      	cmp	r3, r2
2400513c:	d045      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
2400513e:	68fb      	ldr	r3, [r7, #12]
24005140:	681b      	ldr	r3, [r3, #0]
24005142:	4a31      	ldr	r2, [pc, #196]	; (24005208 <HAL_DMA_PollForTransfer+0x71c>)
24005144:	4293      	cmp	r3, r2
24005146:	d040      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
24005148:	68fb      	ldr	r3, [r7, #12]
2400514a:	681b      	ldr	r3, [r3, #0]
2400514c:	4a2f      	ldr	r2, [pc, #188]	; (2400520c <HAL_DMA_PollForTransfer+0x720>)
2400514e:	4293      	cmp	r3, r2
24005150:	d03b      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
24005152:	68fb      	ldr	r3, [r7, #12]
24005154:	681b      	ldr	r3, [r3, #0]
24005156:	4a2e      	ldr	r2, [pc, #184]	; (24005210 <HAL_DMA_PollForTransfer+0x724>)
24005158:	4293      	cmp	r3, r2
2400515a:	d036      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
2400515c:	68fb      	ldr	r3, [r7, #12]
2400515e:	681b      	ldr	r3, [r3, #0]
24005160:	4a2c      	ldr	r2, [pc, #176]	; (24005214 <HAL_DMA_PollForTransfer+0x728>)
24005162:	4293      	cmp	r3, r2
24005164:	d031      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
24005166:	68fb      	ldr	r3, [r7, #12]
24005168:	681b      	ldr	r3, [r3, #0]
2400516a:	4a2b      	ldr	r2, [pc, #172]	; (24005218 <HAL_DMA_PollForTransfer+0x72c>)
2400516c:	4293      	cmp	r3, r2
2400516e:	d02c      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
24005170:	68fb      	ldr	r3, [r7, #12]
24005172:	681b      	ldr	r3, [r3, #0]
24005174:	4a29      	ldr	r2, [pc, #164]	; (2400521c <HAL_DMA_PollForTransfer+0x730>)
24005176:	4293      	cmp	r3, r2
24005178:	d027      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
2400517a:	68fb      	ldr	r3, [r7, #12]
2400517c:	681b      	ldr	r3, [r3, #0]
2400517e:	4a28      	ldr	r2, [pc, #160]	; (24005220 <HAL_DMA_PollForTransfer+0x734>)
24005180:	4293      	cmp	r3, r2
24005182:	d022      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
24005184:	68fb      	ldr	r3, [r7, #12]
24005186:	681b      	ldr	r3, [r3, #0]
24005188:	4a26      	ldr	r2, [pc, #152]	; (24005224 <HAL_DMA_PollForTransfer+0x738>)
2400518a:	4293      	cmp	r3, r2
2400518c:	d01d      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
2400518e:	68fb      	ldr	r3, [r7, #12]
24005190:	681b      	ldr	r3, [r3, #0]
24005192:	4a25      	ldr	r2, [pc, #148]	; (24005228 <HAL_DMA_PollForTransfer+0x73c>)
24005194:	4293      	cmp	r3, r2
24005196:	d018      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
24005198:	68fb      	ldr	r3, [r7, #12]
2400519a:	681b      	ldr	r3, [r3, #0]
2400519c:	4a23      	ldr	r2, [pc, #140]	; (2400522c <HAL_DMA_PollForTransfer+0x740>)
2400519e:	4293      	cmp	r3, r2
240051a0:	d013      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
240051a2:	68fb      	ldr	r3, [r7, #12]
240051a4:	681b      	ldr	r3, [r3, #0]
240051a6:	4a22      	ldr	r2, [pc, #136]	; (24005230 <HAL_DMA_PollForTransfer+0x744>)
240051a8:	4293      	cmp	r3, r2
240051aa:	d00e      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
240051ac:	68fb      	ldr	r3, [r7, #12]
240051ae:	681b      	ldr	r3, [r3, #0]
240051b0:	4a20      	ldr	r2, [pc, #128]	; (24005234 <HAL_DMA_PollForTransfer+0x748>)
240051b2:	4293      	cmp	r3, r2
240051b4:	d009      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
240051b6:	68fb      	ldr	r3, [r7, #12]
240051b8:	681b      	ldr	r3, [r3, #0]
240051ba:	4a1f      	ldr	r2, [pc, #124]	; (24005238 <HAL_DMA_PollForTransfer+0x74c>)
240051bc:	4293      	cmp	r3, r2
240051be:	d004      	beq.n	240051ca <HAL_DMA_PollForTransfer+0x6de>
240051c0:	68fb      	ldr	r3, [r7, #12]
240051c2:	681b      	ldr	r3, [r3, #0]
240051c4:	4a1d      	ldr	r2, [pc, #116]	; (2400523c <HAL_DMA_PollForTransfer+0x750>)
240051c6:	4293      	cmp	r3, r2
240051c8:	d101      	bne.n	240051ce <HAL_DMA_PollForTransfer+0x6e2>
240051ca:	2301      	movs	r3, #1
240051cc:	e000      	b.n	240051d0 <HAL_DMA_PollForTransfer+0x6e4>
240051ce:	2300      	movs	r3, #0
240051d0:	2b00      	cmp	r3, #0
240051d2:	d008      	beq.n	240051e6 <HAL_DMA_PollForTransfer+0x6fa>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4) << (hdma->StreamIndex & 0x1FU);
240051d4:	68fb      	ldr	r3, [r7, #12]
240051d6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240051d8:	f003 031f 	and.w	r3, r3, #31
240051dc:	2210      	movs	r2, #16
240051de:	409a      	lsls	r2, r3
240051e0:	69fb      	ldr	r3, [r7, #28]
240051e2:	601a      	str	r2, [r3, #0]
240051e4:	e007      	b.n	240051f6 <HAL_DMA_PollForTransfer+0x70a>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU));
240051e6:	68fb      	ldr	r3, [r7, #12]
240051e8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240051ea:	f003 031f 	and.w	r3, r3, #31
240051ee:	2204      	movs	r2, #4
240051f0:	409a      	lsls	r2, r3
240051f2:	69fb      	ldr	r3, [r7, #28]
240051f4:	601a      	str	r2, [r3, #0]
    }
  }

  return status;
240051f6:	7efb      	ldrb	r3, [r7, #27]
}
240051f8:	4618      	mov	r0, r3
240051fa:	3728      	adds	r7, #40	; 0x28
240051fc:	46bd      	mov	sp, r7
240051fe:	bd80      	pop	{r7, pc}
24005200:	40020010 	.word	0x40020010
24005204:	40020028 	.word	0x40020028
24005208:	40020040 	.word	0x40020040
2400520c:	40020058 	.word	0x40020058
24005210:	40020070 	.word	0x40020070
24005214:	40020088 	.word	0x40020088
24005218:	400200a0 	.word	0x400200a0
2400521c:	400200b8 	.word	0x400200b8
24005220:	40020410 	.word	0x40020410
24005224:	40020428 	.word	0x40020428
24005228:	40020440 	.word	0x40020440
2400522c:	40020458 	.word	0x40020458
24005230:	40020470 	.word	0x40020470
24005234:	40020488 	.word	0x40020488
24005238:	400204a0 	.word	0x400204a0
2400523c:	400204b8 	.word	0x400204b8

24005240 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
24005240:	b580      	push	{r7, lr}
24005242:	b08a      	sub	sp, #40	; 0x28
24005244:	af00      	add	r7, sp, #0
24005246:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
24005248:	2300      	movs	r3, #0
2400524a:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
2400524c:	4b67      	ldr	r3, [pc, #412]	; (240053ec <HAL_DMA_IRQHandler+0x1ac>)
2400524e:	681b      	ldr	r3, [r3, #0]
24005250:	4a67      	ldr	r2, [pc, #412]	; (240053f0 <HAL_DMA_IRQHandler+0x1b0>)
24005252:	fba2 2303 	umull	r2, r3, r2, r3
24005256:	0a9b      	lsrs	r3, r3, #10
24005258:	627b      	str	r3, [r7, #36]	; 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
2400525a:	687b      	ldr	r3, [r7, #4]
2400525c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400525e:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24005260:	687b      	ldr	r3, [r7, #4]
24005262:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005264:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
24005266:	6a3b      	ldr	r3, [r7, #32]
24005268:	681b      	ldr	r3, [r3, #0]
2400526a:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
2400526c:	69fb      	ldr	r3, [r7, #28]
2400526e:	681b      	ldr	r3, [r3, #0]
24005270:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
24005272:	687b      	ldr	r3, [r7, #4]
24005274:	681b      	ldr	r3, [r3, #0]
24005276:	4a5f      	ldr	r2, [pc, #380]	; (240053f4 <HAL_DMA_IRQHandler+0x1b4>)
24005278:	4293      	cmp	r3, r2
2400527a:	d04a      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
2400527c:	687b      	ldr	r3, [r7, #4]
2400527e:	681b      	ldr	r3, [r3, #0]
24005280:	4a5d      	ldr	r2, [pc, #372]	; (240053f8 <HAL_DMA_IRQHandler+0x1b8>)
24005282:	4293      	cmp	r3, r2
24005284:	d045      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
24005286:	687b      	ldr	r3, [r7, #4]
24005288:	681b      	ldr	r3, [r3, #0]
2400528a:	4a5c      	ldr	r2, [pc, #368]	; (240053fc <HAL_DMA_IRQHandler+0x1bc>)
2400528c:	4293      	cmp	r3, r2
2400528e:	d040      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
24005290:	687b      	ldr	r3, [r7, #4]
24005292:	681b      	ldr	r3, [r3, #0]
24005294:	4a5a      	ldr	r2, [pc, #360]	; (24005400 <HAL_DMA_IRQHandler+0x1c0>)
24005296:	4293      	cmp	r3, r2
24005298:	d03b      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
2400529a:	687b      	ldr	r3, [r7, #4]
2400529c:	681b      	ldr	r3, [r3, #0]
2400529e:	4a59      	ldr	r2, [pc, #356]	; (24005404 <HAL_DMA_IRQHandler+0x1c4>)
240052a0:	4293      	cmp	r3, r2
240052a2:	d036      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052a4:	687b      	ldr	r3, [r7, #4]
240052a6:	681b      	ldr	r3, [r3, #0]
240052a8:	4a57      	ldr	r2, [pc, #348]	; (24005408 <HAL_DMA_IRQHandler+0x1c8>)
240052aa:	4293      	cmp	r3, r2
240052ac:	d031      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052ae:	687b      	ldr	r3, [r7, #4]
240052b0:	681b      	ldr	r3, [r3, #0]
240052b2:	4a56      	ldr	r2, [pc, #344]	; (2400540c <HAL_DMA_IRQHandler+0x1cc>)
240052b4:	4293      	cmp	r3, r2
240052b6:	d02c      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052b8:	687b      	ldr	r3, [r7, #4]
240052ba:	681b      	ldr	r3, [r3, #0]
240052bc:	4a54      	ldr	r2, [pc, #336]	; (24005410 <HAL_DMA_IRQHandler+0x1d0>)
240052be:	4293      	cmp	r3, r2
240052c0:	d027      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052c2:	687b      	ldr	r3, [r7, #4]
240052c4:	681b      	ldr	r3, [r3, #0]
240052c6:	4a53      	ldr	r2, [pc, #332]	; (24005414 <HAL_DMA_IRQHandler+0x1d4>)
240052c8:	4293      	cmp	r3, r2
240052ca:	d022      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052cc:	687b      	ldr	r3, [r7, #4]
240052ce:	681b      	ldr	r3, [r3, #0]
240052d0:	4a51      	ldr	r2, [pc, #324]	; (24005418 <HAL_DMA_IRQHandler+0x1d8>)
240052d2:	4293      	cmp	r3, r2
240052d4:	d01d      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052d6:	687b      	ldr	r3, [r7, #4]
240052d8:	681b      	ldr	r3, [r3, #0]
240052da:	4a50      	ldr	r2, [pc, #320]	; (2400541c <HAL_DMA_IRQHandler+0x1dc>)
240052dc:	4293      	cmp	r3, r2
240052de:	d018      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052e0:	687b      	ldr	r3, [r7, #4]
240052e2:	681b      	ldr	r3, [r3, #0]
240052e4:	4a4e      	ldr	r2, [pc, #312]	; (24005420 <HAL_DMA_IRQHandler+0x1e0>)
240052e6:	4293      	cmp	r3, r2
240052e8:	d013      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052ea:	687b      	ldr	r3, [r7, #4]
240052ec:	681b      	ldr	r3, [r3, #0]
240052ee:	4a4d      	ldr	r2, [pc, #308]	; (24005424 <HAL_DMA_IRQHandler+0x1e4>)
240052f0:	4293      	cmp	r3, r2
240052f2:	d00e      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052f4:	687b      	ldr	r3, [r7, #4]
240052f6:	681b      	ldr	r3, [r3, #0]
240052f8:	4a4b      	ldr	r2, [pc, #300]	; (24005428 <HAL_DMA_IRQHandler+0x1e8>)
240052fa:	4293      	cmp	r3, r2
240052fc:	d009      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
240052fe:	687b      	ldr	r3, [r7, #4]
24005300:	681b      	ldr	r3, [r3, #0]
24005302:	4a4a      	ldr	r2, [pc, #296]	; (2400542c <HAL_DMA_IRQHandler+0x1ec>)
24005304:	4293      	cmp	r3, r2
24005306:	d004      	beq.n	24005312 <HAL_DMA_IRQHandler+0xd2>
24005308:	687b      	ldr	r3, [r7, #4]
2400530a:	681b      	ldr	r3, [r3, #0]
2400530c:	4a48      	ldr	r2, [pc, #288]	; (24005430 <HAL_DMA_IRQHandler+0x1f0>)
2400530e:	4293      	cmp	r3, r2
24005310:	d101      	bne.n	24005316 <HAL_DMA_IRQHandler+0xd6>
24005312:	2301      	movs	r3, #1
24005314:	e000      	b.n	24005318 <HAL_DMA_IRQHandler+0xd8>
24005316:	2300      	movs	r3, #0
24005318:	2b00      	cmp	r3, #0
2400531a:	f000 842b 	beq.w	24005b74 <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
2400531e:	687b      	ldr	r3, [r7, #4]
24005320:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005322:	f003 031f 	and.w	r3, r3, #31
24005326:	2208      	movs	r2, #8
24005328:	409a      	lsls	r2, r3
2400532a:	69bb      	ldr	r3, [r7, #24]
2400532c:	4013      	ands	r3, r2
2400532e:	2b00      	cmp	r3, #0
24005330:	f000 80a2 	beq.w	24005478 <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
24005334:	687b      	ldr	r3, [r7, #4]
24005336:	681b      	ldr	r3, [r3, #0]
24005338:	4a2e      	ldr	r2, [pc, #184]	; (240053f4 <HAL_DMA_IRQHandler+0x1b4>)
2400533a:	4293      	cmp	r3, r2
2400533c:	d04a      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
2400533e:	687b      	ldr	r3, [r7, #4]
24005340:	681b      	ldr	r3, [r3, #0]
24005342:	4a2d      	ldr	r2, [pc, #180]	; (240053f8 <HAL_DMA_IRQHandler+0x1b8>)
24005344:	4293      	cmp	r3, r2
24005346:	d045      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
24005348:	687b      	ldr	r3, [r7, #4]
2400534a:	681b      	ldr	r3, [r3, #0]
2400534c:	4a2b      	ldr	r2, [pc, #172]	; (240053fc <HAL_DMA_IRQHandler+0x1bc>)
2400534e:	4293      	cmp	r3, r2
24005350:	d040      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
24005352:	687b      	ldr	r3, [r7, #4]
24005354:	681b      	ldr	r3, [r3, #0]
24005356:	4a2a      	ldr	r2, [pc, #168]	; (24005400 <HAL_DMA_IRQHandler+0x1c0>)
24005358:	4293      	cmp	r3, r2
2400535a:	d03b      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
2400535c:	687b      	ldr	r3, [r7, #4]
2400535e:	681b      	ldr	r3, [r3, #0]
24005360:	4a28      	ldr	r2, [pc, #160]	; (24005404 <HAL_DMA_IRQHandler+0x1c4>)
24005362:	4293      	cmp	r3, r2
24005364:	d036      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
24005366:	687b      	ldr	r3, [r7, #4]
24005368:	681b      	ldr	r3, [r3, #0]
2400536a:	4a27      	ldr	r2, [pc, #156]	; (24005408 <HAL_DMA_IRQHandler+0x1c8>)
2400536c:	4293      	cmp	r3, r2
2400536e:	d031      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
24005370:	687b      	ldr	r3, [r7, #4]
24005372:	681b      	ldr	r3, [r3, #0]
24005374:	4a25      	ldr	r2, [pc, #148]	; (2400540c <HAL_DMA_IRQHandler+0x1cc>)
24005376:	4293      	cmp	r3, r2
24005378:	d02c      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
2400537a:	687b      	ldr	r3, [r7, #4]
2400537c:	681b      	ldr	r3, [r3, #0]
2400537e:	4a24      	ldr	r2, [pc, #144]	; (24005410 <HAL_DMA_IRQHandler+0x1d0>)
24005380:	4293      	cmp	r3, r2
24005382:	d027      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
24005384:	687b      	ldr	r3, [r7, #4]
24005386:	681b      	ldr	r3, [r3, #0]
24005388:	4a22      	ldr	r2, [pc, #136]	; (24005414 <HAL_DMA_IRQHandler+0x1d4>)
2400538a:	4293      	cmp	r3, r2
2400538c:	d022      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
2400538e:	687b      	ldr	r3, [r7, #4]
24005390:	681b      	ldr	r3, [r3, #0]
24005392:	4a21      	ldr	r2, [pc, #132]	; (24005418 <HAL_DMA_IRQHandler+0x1d8>)
24005394:	4293      	cmp	r3, r2
24005396:	d01d      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
24005398:	687b      	ldr	r3, [r7, #4]
2400539a:	681b      	ldr	r3, [r3, #0]
2400539c:	4a1f      	ldr	r2, [pc, #124]	; (2400541c <HAL_DMA_IRQHandler+0x1dc>)
2400539e:	4293      	cmp	r3, r2
240053a0:	d018      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
240053a2:	687b      	ldr	r3, [r7, #4]
240053a4:	681b      	ldr	r3, [r3, #0]
240053a6:	4a1e      	ldr	r2, [pc, #120]	; (24005420 <HAL_DMA_IRQHandler+0x1e0>)
240053a8:	4293      	cmp	r3, r2
240053aa:	d013      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
240053ac:	687b      	ldr	r3, [r7, #4]
240053ae:	681b      	ldr	r3, [r3, #0]
240053b0:	4a1c      	ldr	r2, [pc, #112]	; (24005424 <HAL_DMA_IRQHandler+0x1e4>)
240053b2:	4293      	cmp	r3, r2
240053b4:	d00e      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
240053b6:	687b      	ldr	r3, [r7, #4]
240053b8:	681b      	ldr	r3, [r3, #0]
240053ba:	4a1b      	ldr	r2, [pc, #108]	; (24005428 <HAL_DMA_IRQHandler+0x1e8>)
240053bc:	4293      	cmp	r3, r2
240053be:	d009      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
240053c0:	687b      	ldr	r3, [r7, #4]
240053c2:	681b      	ldr	r3, [r3, #0]
240053c4:	4a19      	ldr	r2, [pc, #100]	; (2400542c <HAL_DMA_IRQHandler+0x1ec>)
240053c6:	4293      	cmp	r3, r2
240053c8:	d004      	beq.n	240053d4 <HAL_DMA_IRQHandler+0x194>
240053ca:	687b      	ldr	r3, [r7, #4]
240053cc:	681b      	ldr	r3, [r3, #0]
240053ce:	4a18      	ldr	r2, [pc, #96]	; (24005430 <HAL_DMA_IRQHandler+0x1f0>)
240053d0:	4293      	cmp	r3, r2
240053d2:	d12f      	bne.n	24005434 <HAL_DMA_IRQHandler+0x1f4>
240053d4:	687b      	ldr	r3, [r7, #4]
240053d6:	681b      	ldr	r3, [r3, #0]
240053d8:	681b      	ldr	r3, [r3, #0]
240053da:	f003 0304 	and.w	r3, r3, #4
240053de:	2b00      	cmp	r3, #0
240053e0:	bf14      	ite	ne
240053e2:	2301      	movne	r3, #1
240053e4:	2300      	moveq	r3, #0
240053e6:	b2db      	uxtb	r3, r3
240053e8:	e02e      	b.n	24005448 <HAL_DMA_IRQHandler+0x208>
240053ea:	bf00      	nop
240053ec:	240004b0 	.word	0x240004b0
240053f0:	1b4e81b5 	.word	0x1b4e81b5
240053f4:	40020010 	.word	0x40020010
240053f8:	40020028 	.word	0x40020028
240053fc:	40020040 	.word	0x40020040
24005400:	40020058 	.word	0x40020058
24005404:	40020070 	.word	0x40020070
24005408:	40020088 	.word	0x40020088
2400540c:	400200a0 	.word	0x400200a0
24005410:	400200b8 	.word	0x400200b8
24005414:	40020410 	.word	0x40020410
24005418:	40020428 	.word	0x40020428
2400541c:	40020440 	.word	0x40020440
24005420:	40020458 	.word	0x40020458
24005424:	40020470 	.word	0x40020470
24005428:	40020488 	.word	0x40020488
2400542c:	400204a0 	.word	0x400204a0
24005430:	400204b8 	.word	0x400204b8
24005434:	687b      	ldr	r3, [r7, #4]
24005436:	681b      	ldr	r3, [r3, #0]
24005438:	681b      	ldr	r3, [r3, #0]
2400543a:	f003 0308 	and.w	r3, r3, #8
2400543e:	2b00      	cmp	r3, #0
24005440:	bf14      	ite	ne
24005442:	2301      	movne	r3, #1
24005444:	2300      	moveq	r3, #0
24005446:	b2db      	uxtb	r3, r3
24005448:	2b00      	cmp	r3, #0
2400544a:	d015      	beq.n	24005478 <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
2400544c:	687b      	ldr	r3, [r7, #4]
2400544e:	681b      	ldr	r3, [r3, #0]
24005450:	681a      	ldr	r2, [r3, #0]
24005452:	687b      	ldr	r3, [r7, #4]
24005454:	681b      	ldr	r3, [r3, #0]
24005456:	f022 0204 	bic.w	r2, r2, #4
2400545a:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
2400545c:	687b      	ldr	r3, [r7, #4]
2400545e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005460:	f003 031f 	and.w	r3, r3, #31
24005464:	2208      	movs	r2, #8
24005466:	409a      	lsls	r2, r3
24005468:	6a3b      	ldr	r3, [r7, #32]
2400546a:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
2400546c:	687b      	ldr	r3, [r7, #4]
2400546e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005470:	f043 0201 	orr.w	r2, r3, #1
24005474:	687b      	ldr	r3, [r7, #4]
24005476:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24005478:	687b      	ldr	r3, [r7, #4]
2400547a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400547c:	f003 031f 	and.w	r3, r3, #31
24005480:	69ba      	ldr	r2, [r7, #24]
24005482:	fa22 f303 	lsr.w	r3, r2, r3
24005486:	f003 0301 	and.w	r3, r3, #1
2400548a:	2b00      	cmp	r3, #0
2400548c:	d06e      	beq.n	2400556c <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
2400548e:	687b      	ldr	r3, [r7, #4]
24005490:	681b      	ldr	r3, [r3, #0]
24005492:	4a69      	ldr	r2, [pc, #420]	; (24005638 <HAL_DMA_IRQHandler+0x3f8>)
24005494:	4293      	cmp	r3, r2
24005496:	d04a      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
24005498:	687b      	ldr	r3, [r7, #4]
2400549a:	681b      	ldr	r3, [r3, #0]
2400549c:	4a67      	ldr	r2, [pc, #412]	; (2400563c <HAL_DMA_IRQHandler+0x3fc>)
2400549e:	4293      	cmp	r3, r2
240054a0:	d045      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054a2:	687b      	ldr	r3, [r7, #4]
240054a4:	681b      	ldr	r3, [r3, #0]
240054a6:	4a66      	ldr	r2, [pc, #408]	; (24005640 <HAL_DMA_IRQHandler+0x400>)
240054a8:	4293      	cmp	r3, r2
240054aa:	d040      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054ac:	687b      	ldr	r3, [r7, #4]
240054ae:	681b      	ldr	r3, [r3, #0]
240054b0:	4a64      	ldr	r2, [pc, #400]	; (24005644 <HAL_DMA_IRQHandler+0x404>)
240054b2:	4293      	cmp	r3, r2
240054b4:	d03b      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054b6:	687b      	ldr	r3, [r7, #4]
240054b8:	681b      	ldr	r3, [r3, #0]
240054ba:	4a63      	ldr	r2, [pc, #396]	; (24005648 <HAL_DMA_IRQHandler+0x408>)
240054bc:	4293      	cmp	r3, r2
240054be:	d036      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054c0:	687b      	ldr	r3, [r7, #4]
240054c2:	681b      	ldr	r3, [r3, #0]
240054c4:	4a61      	ldr	r2, [pc, #388]	; (2400564c <HAL_DMA_IRQHandler+0x40c>)
240054c6:	4293      	cmp	r3, r2
240054c8:	d031      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054ca:	687b      	ldr	r3, [r7, #4]
240054cc:	681b      	ldr	r3, [r3, #0]
240054ce:	4a60      	ldr	r2, [pc, #384]	; (24005650 <HAL_DMA_IRQHandler+0x410>)
240054d0:	4293      	cmp	r3, r2
240054d2:	d02c      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054d4:	687b      	ldr	r3, [r7, #4]
240054d6:	681b      	ldr	r3, [r3, #0]
240054d8:	4a5e      	ldr	r2, [pc, #376]	; (24005654 <HAL_DMA_IRQHandler+0x414>)
240054da:	4293      	cmp	r3, r2
240054dc:	d027      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054de:	687b      	ldr	r3, [r7, #4]
240054e0:	681b      	ldr	r3, [r3, #0]
240054e2:	4a5d      	ldr	r2, [pc, #372]	; (24005658 <HAL_DMA_IRQHandler+0x418>)
240054e4:	4293      	cmp	r3, r2
240054e6:	d022      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054e8:	687b      	ldr	r3, [r7, #4]
240054ea:	681b      	ldr	r3, [r3, #0]
240054ec:	4a5b      	ldr	r2, [pc, #364]	; (2400565c <HAL_DMA_IRQHandler+0x41c>)
240054ee:	4293      	cmp	r3, r2
240054f0:	d01d      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054f2:	687b      	ldr	r3, [r7, #4]
240054f4:	681b      	ldr	r3, [r3, #0]
240054f6:	4a5a      	ldr	r2, [pc, #360]	; (24005660 <HAL_DMA_IRQHandler+0x420>)
240054f8:	4293      	cmp	r3, r2
240054fa:	d018      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
240054fc:	687b      	ldr	r3, [r7, #4]
240054fe:	681b      	ldr	r3, [r3, #0]
24005500:	4a58      	ldr	r2, [pc, #352]	; (24005664 <HAL_DMA_IRQHandler+0x424>)
24005502:	4293      	cmp	r3, r2
24005504:	d013      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
24005506:	687b      	ldr	r3, [r7, #4]
24005508:	681b      	ldr	r3, [r3, #0]
2400550a:	4a57      	ldr	r2, [pc, #348]	; (24005668 <HAL_DMA_IRQHandler+0x428>)
2400550c:	4293      	cmp	r3, r2
2400550e:	d00e      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
24005510:	687b      	ldr	r3, [r7, #4]
24005512:	681b      	ldr	r3, [r3, #0]
24005514:	4a55      	ldr	r2, [pc, #340]	; (2400566c <HAL_DMA_IRQHandler+0x42c>)
24005516:	4293      	cmp	r3, r2
24005518:	d009      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
2400551a:	687b      	ldr	r3, [r7, #4]
2400551c:	681b      	ldr	r3, [r3, #0]
2400551e:	4a54      	ldr	r2, [pc, #336]	; (24005670 <HAL_DMA_IRQHandler+0x430>)
24005520:	4293      	cmp	r3, r2
24005522:	d004      	beq.n	2400552e <HAL_DMA_IRQHandler+0x2ee>
24005524:	687b      	ldr	r3, [r7, #4]
24005526:	681b      	ldr	r3, [r3, #0]
24005528:	4a52      	ldr	r2, [pc, #328]	; (24005674 <HAL_DMA_IRQHandler+0x434>)
2400552a:	4293      	cmp	r3, r2
2400552c:	d10a      	bne.n	24005544 <HAL_DMA_IRQHandler+0x304>
2400552e:	687b      	ldr	r3, [r7, #4]
24005530:	681b      	ldr	r3, [r3, #0]
24005532:	695b      	ldr	r3, [r3, #20]
24005534:	f003 0380 	and.w	r3, r3, #128	; 0x80
24005538:	2b00      	cmp	r3, #0
2400553a:	bf14      	ite	ne
2400553c:	2301      	movne	r3, #1
2400553e:	2300      	moveq	r3, #0
24005540:	b2db      	uxtb	r3, r3
24005542:	e003      	b.n	2400554c <HAL_DMA_IRQHandler+0x30c>
24005544:	687b      	ldr	r3, [r7, #4]
24005546:	681b      	ldr	r3, [r3, #0]
24005548:	681b      	ldr	r3, [r3, #0]
2400554a:	2300      	movs	r3, #0
2400554c:	2b00      	cmp	r3, #0
2400554e:	d00d      	beq.n	2400556c <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24005550:	687b      	ldr	r3, [r7, #4]
24005552:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005554:	f003 031f 	and.w	r3, r3, #31
24005558:	2201      	movs	r2, #1
2400555a:	409a      	lsls	r2, r3
2400555c:	6a3b      	ldr	r3, [r7, #32]
2400555e:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
24005560:	687b      	ldr	r3, [r7, #4]
24005562:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005564:	f043 0202 	orr.w	r2, r3, #2
24005568:	687b      	ldr	r3, [r7, #4]
2400556a:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
2400556c:	687b      	ldr	r3, [r7, #4]
2400556e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005570:	f003 031f 	and.w	r3, r3, #31
24005574:	2204      	movs	r2, #4
24005576:	409a      	lsls	r2, r3
24005578:	69bb      	ldr	r3, [r7, #24]
2400557a:	4013      	ands	r3, r2
2400557c:	2b00      	cmp	r3, #0
2400557e:	f000 808f 	beq.w	240056a0 <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
24005582:	687b      	ldr	r3, [r7, #4]
24005584:	681b      	ldr	r3, [r3, #0]
24005586:	4a2c      	ldr	r2, [pc, #176]	; (24005638 <HAL_DMA_IRQHandler+0x3f8>)
24005588:	4293      	cmp	r3, r2
2400558a:	d04a      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
2400558c:	687b      	ldr	r3, [r7, #4]
2400558e:	681b      	ldr	r3, [r3, #0]
24005590:	4a2a      	ldr	r2, [pc, #168]	; (2400563c <HAL_DMA_IRQHandler+0x3fc>)
24005592:	4293      	cmp	r3, r2
24005594:	d045      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
24005596:	687b      	ldr	r3, [r7, #4]
24005598:	681b      	ldr	r3, [r3, #0]
2400559a:	4a29      	ldr	r2, [pc, #164]	; (24005640 <HAL_DMA_IRQHandler+0x400>)
2400559c:	4293      	cmp	r3, r2
2400559e:	d040      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055a0:	687b      	ldr	r3, [r7, #4]
240055a2:	681b      	ldr	r3, [r3, #0]
240055a4:	4a27      	ldr	r2, [pc, #156]	; (24005644 <HAL_DMA_IRQHandler+0x404>)
240055a6:	4293      	cmp	r3, r2
240055a8:	d03b      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055aa:	687b      	ldr	r3, [r7, #4]
240055ac:	681b      	ldr	r3, [r3, #0]
240055ae:	4a26      	ldr	r2, [pc, #152]	; (24005648 <HAL_DMA_IRQHandler+0x408>)
240055b0:	4293      	cmp	r3, r2
240055b2:	d036      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055b4:	687b      	ldr	r3, [r7, #4]
240055b6:	681b      	ldr	r3, [r3, #0]
240055b8:	4a24      	ldr	r2, [pc, #144]	; (2400564c <HAL_DMA_IRQHandler+0x40c>)
240055ba:	4293      	cmp	r3, r2
240055bc:	d031      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055be:	687b      	ldr	r3, [r7, #4]
240055c0:	681b      	ldr	r3, [r3, #0]
240055c2:	4a23      	ldr	r2, [pc, #140]	; (24005650 <HAL_DMA_IRQHandler+0x410>)
240055c4:	4293      	cmp	r3, r2
240055c6:	d02c      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055c8:	687b      	ldr	r3, [r7, #4]
240055ca:	681b      	ldr	r3, [r3, #0]
240055cc:	4a21      	ldr	r2, [pc, #132]	; (24005654 <HAL_DMA_IRQHandler+0x414>)
240055ce:	4293      	cmp	r3, r2
240055d0:	d027      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055d2:	687b      	ldr	r3, [r7, #4]
240055d4:	681b      	ldr	r3, [r3, #0]
240055d6:	4a20      	ldr	r2, [pc, #128]	; (24005658 <HAL_DMA_IRQHandler+0x418>)
240055d8:	4293      	cmp	r3, r2
240055da:	d022      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055dc:	687b      	ldr	r3, [r7, #4]
240055de:	681b      	ldr	r3, [r3, #0]
240055e0:	4a1e      	ldr	r2, [pc, #120]	; (2400565c <HAL_DMA_IRQHandler+0x41c>)
240055e2:	4293      	cmp	r3, r2
240055e4:	d01d      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055e6:	687b      	ldr	r3, [r7, #4]
240055e8:	681b      	ldr	r3, [r3, #0]
240055ea:	4a1d      	ldr	r2, [pc, #116]	; (24005660 <HAL_DMA_IRQHandler+0x420>)
240055ec:	4293      	cmp	r3, r2
240055ee:	d018      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055f0:	687b      	ldr	r3, [r7, #4]
240055f2:	681b      	ldr	r3, [r3, #0]
240055f4:	4a1b      	ldr	r2, [pc, #108]	; (24005664 <HAL_DMA_IRQHandler+0x424>)
240055f6:	4293      	cmp	r3, r2
240055f8:	d013      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
240055fa:	687b      	ldr	r3, [r7, #4]
240055fc:	681b      	ldr	r3, [r3, #0]
240055fe:	4a1a      	ldr	r2, [pc, #104]	; (24005668 <HAL_DMA_IRQHandler+0x428>)
24005600:	4293      	cmp	r3, r2
24005602:	d00e      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
24005604:	687b      	ldr	r3, [r7, #4]
24005606:	681b      	ldr	r3, [r3, #0]
24005608:	4a18      	ldr	r2, [pc, #96]	; (2400566c <HAL_DMA_IRQHandler+0x42c>)
2400560a:	4293      	cmp	r3, r2
2400560c:	d009      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
2400560e:	687b      	ldr	r3, [r7, #4]
24005610:	681b      	ldr	r3, [r3, #0]
24005612:	4a17      	ldr	r2, [pc, #92]	; (24005670 <HAL_DMA_IRQHandler+0x430>)
24005614:	4293      	cmp	r3, r2
24005616:	d004      	beq.n	24005622 <HAL_DMA_IRQHandler+0x3e2>
24005618:	687b      	ldr	r3, [r7, #4]
2400561a:	681b      	ldr	r3, [r3, #0]
2400561c:	4a15      	ldr	r2, [pc, #84]	; (24005674 <HAL_DMA_IRQHandler+0x434>)
2400561e:	4293      	cmp	r3, r2
24005620:	d12a      	bne.n	24005678 <HAL_DMA_IRQHandler+0x438>
24005622:	687b      	ldr	r3, [r7, #4]
24005624:	681b      	ldr	r3, [r3, #0]
24005626:	681b      	ldr	r3, [r3, #0]
24005628:	f003 0302 	and.w	r3, r3, #2
2400562c:	2b00      	cmp	r3, #0
2400562e:	bf14      	ite	ne
24005630:	2301      	movne	r3, #1
24005632:	2300      	moveq	r3, #0
24005634:	b2db      	uxtb	r3, r3
24005636:	e023      	b.n	24005680 <HAL_DMA_IRQHandler+0x440>
24005638:	40020010 	.word	0x40020010
2400563c:	40020028 	.word	0x40020028
24005640:	40020040 	.word	0x40020040
24005644:	40020058 	.word	0x40020058
24005648:	40020070 	.word	0x40020070
2400564c:	40020088 	.word	0x40020088
24005650:	400200a0 	.word	0x400200a0
24005654:	400200b8 	.word	0x400200b8
24005658:	40020410 	.word	0x40020410
2400565c:	40020428 	.word	0x40020428
24005660:	40020440 	.word	0x40020440
24005664:	40020458 	.word	0x40020458
24005668:	40020470 	.word	0x40020470
2400566c:	40020488 	.word	0x40020488
24005670:	400204a0 	.word	0x400204a0
24005674:	400204b8 	.word	0x400204b8
24005678:	687b      	ldr	r3, [r7, #4]
2400567a:	681b      	ldr	r3, [r3, #0]
2400567c:	681b      	ldr	r3, [r3, #0]
2400567e:	2300      	movs	r3, #0
24005680:	2b00      	cmp	r3, #0
24005682:	d00d      	beq.n	240056a0 <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
24005684:	687b      	ldr	r3, [r7, #4]
24005686:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005688:	f003 031f 	and.w	r3, r3, #31
2400568c:	2204      	movs	r2, #4
2400568e:	409a      	lsls	r2, r3
24005690:	6a3b      	ldr	r3, [r7, #32]
24005692:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
24005694:	687b      	ldr	r3, [r7, #4]
24005696:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005698:	f043 0204 	orr.w	r2, r3, #4
2400569c:	687b      	ldr	r3, [r7, #4]
2400569e:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240056a0:	687b      	ldr	r3, [r7, #4]
240056a2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240056a4:	f003 031f 	and.w	r3, r3, #31
240056a8:	2210      	movs	r2, #16
240056aa:	409a      	lsls	r2, r3
240056ac:	69bb      	ldr	r3, [r7, #24]
240056ae:	4013      	ands	r3, r2
240056b0:	2b00      	cmp	r3, #0
240056b2:	f000 80a6 	beq.w	24005802 <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
240056b6:	687b      	ldr	r3, [r7, #4]
240056b8:	681b      	ldr	r3, [r3, #0]
240056ba:	4a85      	ldr	r2, [pc, #532]	; (240058d0 <HAL_DMA_IRQHandler+0x690>)
240056bc:	4293      	cmp	r3, r2
240056be:	d04a      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
240056c0:	687b      	ldr	r3, [r7, #4]
240056c2:	681b      	ldr	r3, [r3, #0]
240056c4:	4a83      	ldr	r2, [pc, #524]	; (240058d4 <HAL_DMA_IRQHandler+0x694>)
240056c6:	4293      	cmp	r3, r2
240056c8:	d045      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
240056ca:	687b      	ldr	r3, [r7, #4]
240056cc:	681b      	ldr	r3, [r3, #0]
240056ce:	4a82      	ldr	r2, [pc, #520]	; (240058d8 <HAL_DMA_IRQHandler+0x698>)
240056d0:	4293      	cmp	r3, r2
240056d2:	d040      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
240056d4:	687b      	ldr	r3, [r7, #4]
240056d6:	681b      	ldr	r3, [r3, #0]
240056d8:	4a80      	ldr	r2, [pc, #512]	; (240058dc <HAL_DMA_IRQHandler+0x69c>)
240056da:	4293      	cmp	r3, r2
240056dc:	d03b      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
240056de:	687b      	ldr	r3, [r7, #4]
240056e0:	681b      	ldr	r3, [r3, #0]
240056e2:	4a7f      	ldr	r2, [pc, #508]	; (240058e0 <HAL_DMA_IRQHandler+0x6a0>)
240056e4:	4293      	cmp	r3, r2
240056e6:	d036      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
240056e8:	687b      	ldr	r3, [r7, #4]
240056ea:	681b      	ldr	r3, [r3, #0]
240056ec:	4a7d      	ldr	r2, [pc, #500]	; (240058e4 <HAL_DMA_IRQHandler+0x6a4>)
240056ee:	4293      	cmp	r3, r2
240056f0:	d031      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
240056f2:	687b      	ldr	r3, [r7, #4]
240056f4:	681b      	ldr	r3, [r3, #0]
240056f6:	4a7c      	ldr	r2, [pc, #496]	; (240058e8 <HAL_DMA_IRQHandler+0x6a8>)
240056f8:	4293      	cmp	r3, r2
240056fa:	d02c      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
240056fc:	687b      	ldr	r3, [r7, #4]
240056fe:	681b      	ldr	r3, [r3, #0]
24005700:	4a7a      	ldr	r2, [pc, #488]	; (240058ec <HAL_DMA_IRQHandler+0x6ac>)
24005702:	4293      	cmp	r3, r2
24005704:	d027      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
24005706:	687b      	ldr	r3, [r7, #4]
24005708:	681b      	ldr	r3, [r3, #0]
2400570a:	4a79      	ldr	r2, [pc, #484]	; (240058f0 <HAL_DMA_IRQHandler+0x6b0>)
2400570c:	4293      	cmp	r3, r2
2400570e:	d022      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
24005710:	687b      	ldr	r3, [r7, #4]
24005712:	681b      	ldr	r3, [r3, #0]
24005714:	4a77      	ldr	r2, [pc, #476]	; (240058f4 <HAL_DMA_IRQHandler+0x6b4>)
24005716:	4293      	cmp	r3, r2
24005718:	d01d      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
2400571a:	687b      	ldr	r3, [r7, #4]
2400571c:	681b      	ldr	r3, [r3, #0]
2400571e:	4a76      	ldr	r2, [pc, #472]	; (240058f8 <HAL_DMA_IRQHandler+0x6b8>)
24005720:	4293      	cmp	r3, r2
24005722:	d018      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
24005724:	687b      	ldr	r3, [r7, #4]
24005726:	681b      	ldr	r3, [r3, #0]
24005728:	4a74      	ldr	r2, [pc, #464]	; (240058fc <HAL_DMA_IRQHandler+0x6bc>)
2400572a:	4293      	cmp	r3, r2
2400572c:	d013      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
2400572e:	687b      	ldr	r3, [r7, #4]
24005730:	681b      	ldr	r3, [r3, #0]
24005732:	4a73      	ldr	r2, [pc, #460]	; (24005900 <HAL_DMA_IRQHandler+0x6c0>)
24005734:	4293      	cmp	r3, r2
24005736:	d00e      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
24005738:	687b      	ldr	r3, [r7, #4]
2400573a:	681b      	ldr	r3, [r3, #0]
2400573c:	4a71      	ldr	r2, [pc, #452]	; (24005904 <HAL_DMA_IRQHandler+0x6c4>)
2400573e:	4293      	cmp	r3, r2
24005740:	d009      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
24005742:	687b      	ldr	r3, [r7, #4]
24005744:	681b      	ldr	r3, [r3, #0]
24005746:	4a70      	ldr	r2, [pc, #448]	; (24005908 <HAL_DMA_IRQHandler+0x6c8>)
24005748:	4293      	cmp	r3, r2
2400574a:	d004      	beq.n	24005756 <HAL_DMA_IRQHandler+0x516>
2400574c:	687b      	ldr	r3, [r7, #4]
2400574e:	681b      	ldr	r3, [r3, #0]
24005750:	4a6e      	ldr	r2, [pc, #440]	; (2400590c <HAL_DMA_IRQHandler+0x6cc>)
24005752:	4293      	cmp	r3, r2
24005754:	d10a      	bne.n	2400576c <HAL_DMA_IRQHandler+0x52c>
24005756:	687b      	ldr	r3, [r7, #4]
24005758:	681b      	ldr	r3, [r3, #0]
2400575a:	681b      	ldr	r3, [r3, #0]
2400575c:	f003 0308 	and.w	r3, r3, #8
24005760:	2b00      	cmp	r3, #0
24005762:	bf14      	ite	ne
24005764:	2301      	movne	r3, #1
24005766:	2300      	moveq	r3, #0
24005768:	b2db      	uxtb	r3, r3
2400576a:	e009      	b.n	24005780 <HAL_DMA_IRQHandler+0x540>
2400576c:	687b      	ldr	r3, [r7, #4]
2400576e:	681b      	ldr	r3, [r3, #0]
24005770:	681b      	ldr	r3, [r3, #0]
24005772:	f003 0304 	and.w	r3, r3, #4
24005776:	2b00      	cmp	r3, #0
24005778:	bf14      	ite	ne
2400577a:	2301      	movne	r3, #1
2400577c:	2300      	moveq	r3, #0
2400577e:	b2db      	uxtb	r3, r3
24005780:	2b00      	cmp	r3, #0
24005782:	d03e      	beq.n	24005802 <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24005784:	687b      	ldr	r3, [r7, #4]
24005786:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005788:	f003 031f 	and.w	r3, r3, #31
2400578c:	2210      	movs	r2, #16
2400578e:	409a      	lsls	r2, r3
24005790:	6a3b      	ldr	r3, [r7, #32]
24005792:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
24005794:	687b      	ldr	r3, [r7, #4]
24005796:	681b      	ldr	r3, [r3, #0]
24005798:	681b      	ldr	r3, [r3, #0]
2400579a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2400579e:	2b00      	cmp	r3, #0
240057a0:	d018      	beq.n	240057d4 <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
240057a2:	687b      	ldr	r3, [r7, #4]
240057a4:	681b      	ldr	r3, [r3, #0]
240057a6:	681b      	ldr	r3, [r3, #0]
240057a8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
240057ac:	2b00      	cmp	r3, #0
240057ae:	d108      	bne.n	240057c2 <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
240057b0:	687b      	ldr	r3, [r7, #4]
240057b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240057b4:	2b00      	cmp	r3, #0
240057b6:	d024      	beq.n	24005802 <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
240057b8:	687b      	ldr	r3, [r7, #4]
240057ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240057bc:	6878      	ldr	r0, [r7, #4]
240057be:	4798      	blx	r3
240057c0:	e01f      	b.n	24005802 <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
240057c2:	687b      	ldr	r3, [r7, #4]
240057c4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240057c6:	2b00      	cmp	r3, #0
240057c8:	d01b      	beq.n	24005802 <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
240057ca:	687b      	ldr	r3, [r7, #4]
240057cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240057ce:	6878      	ldr	r0, [r7, #4]
240057d0:	4798      	blx	r3
240057d2:	e016      	b.n	24005802 <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
240057d4:	687b      	ldr	r3, [r7, #4]
240057d6:	681b      	ldr	r3, [r3, #0]
240057d8:	681b      	ldr	r3, [r3, #0]
240057da:	f403 7380 	and.w	r3, r3, #256	; 0x100
240057de:	2b00      	cmp	r3, #0
240057e0:	d107      	bne.n	240057f2 <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
240057e2:	687b      	ldr	r3, [r7, #4]
240057e4:	681b      	ldr	r3, [r3, #0]
240057e6:	681a      	ldr	r2, [r3, #0]
240057e8:	687b      	ldr	r3, [r7, #4]
240057ea:	681b      	ldr	r3, [r3, #0]
240057ec:	f022 0208 	bic.w	r2, r2, #8
240057f0:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
240057f2:	687b      	ldr	r3, [r7, #4]
240057f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240057f6:	2b00      	cmp	r3, #0
240057f8:	d003      	beq.n	24005802 <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
240057fa:	687b      	ldr	r3, [r7, #4]
240057fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240057fe:	6878      	ldr	r0, [r7, #4]
24005800:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24005802:	687b      	ldr	r3, [r7, #4]
24005804:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005806:	f003 031f 	and.w	r3, r3, #31
2400580a:	2220      	movs	r2, #32
2400580c:	409a      	lsls	r2, r3
2400580e:	69bb      	ldr	r3, [r7, #24]
24005810:	4013      	ands	r3, r2
24005812:	2b00      	cmp	r3, #0
24005814:	f000 8110 	beq.w	24005a38 <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
24005818:	687b      	ldr	r3, [r7, #4]
2400581a:	681b      	ldr	r3, [r3, #0]
2400581c:	4a2c      	ldr	r2, [pc, #176]	; (240058d0 <HAL_DMA_IRQHandler+0x690>)
2400581e:	4293      	cmp	r3, r2
24005820:	d04a      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
24005822:	687b      	ldr	r3, [r7, #4]
24005824:	681b      	ldr	r3, [r3, #0]
24005826:	4a2b      	ldr	r2, [pc, #172]	; (240058d4 <HAL_DMA_IRQHandler+0x694>)
24005828:	4293      	cmp	r3, r2
2400582a:	d045      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
2400582c:	687b      	ldr	r3, [r7, #4]
2400582e:	681b      	ldr	r3, [r3, #0]
24005830:	4a29      	ldr	r2, [pc, #164]	; (240058d8 <HAL_DMA_IRQHandler+0x698>)
24005832:	4293      	cmp	r3, r2
24005834:	d040      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
24005836:	687b      	ldr	r3, [r7, #4]
24005838:	681b      	ldr	r3, [r3, #0]
2400583a:	4a28      	ldr	r2, [pc, #160]	; (240058dc <HAL_DMA_IRQHandler+0x69c>)
2400583c:	4293      	cmp	r3, r2
2400583e:	d03b      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
24005840:	687b      	ldr	r3, [r7, #4]
24005842:	681b      	ldr	r3, [r3, #0]
24005844:	4a26      	ldr	r2, [pc, #152]	; (240058e0 <HAL_DMA_IRQHandler+0x6a0>)
24005846:	4293      	cmp	r3, r2
24005848:	d036      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
2400584a:	687b      	ldr	r3, [r7, #4]
2400584c:	681b      	ldr	r3, [r3, #0]
2400584e:	4a25      	ldr	r2, [pc, #148]	; (240058e4 <HAL_DMA_IRQHandler+0x6a4>)
24005850:	4293      	cmp	r3, r2
24005852:	d031      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
24005854:	687b      	ldr	r3, [r7, #4]
24005856:	681b      	ldr	r3, [r3, #0]
24005858:	4a23      	ldr	r2, [pc, #140]	; (240058e8 <HAL_DMA_IRQHandler+0x6a8>)
2400585a:	4293      	cmp	r3, r2
2400585c:	d02c      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
2400585e:	687b      	ldr	r3, [r7, #4]
24005860:	681b      	ldr	r3, [r3, #0]
24005862:	4a22      	ldr	r2, [pc, #136]	; (240058ec <HAL_DMA_IRQHandler+0x6ac>)
24005864:	4293      	cmp	r3, r2
24005866:	d027      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
24005868:	687b      	ldr	r3, [r7, #4]
2400586a:	681b      	ldr	r3, [r3, #0]
2400586c:	4a20      	ldr	r2, [pc, #128]	; (240058f0 <HAL_DMA_IRQHandler+0x6b0>)
2400586e:	4293      	cmp	r3, r2
24005870:	d022      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
24005872:	687b      	ldr	r3, [r7, #4]
24005874:	681b      	ldr	r3, [r3, #0]
24005876:	4a1f      	ldr	r2, [pc, #124]	; (240058f4 <HAL_DMA_IRQHandler+0x6b4>)
24005878:	4293      	cmp	r3, r2
2400587a:	d01d      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
2400587c:	687b      	ldr	r3, [r7, #4]
2400587e:	681b      	ldr	r3, [r3, #0]
24005880:	4a1d      	ldr	r2, [pc, #116]	; (240058f8 <HAL_DMA_IRQHandler+0x6b8>)
24005882:	4293      	cmp	r3, r2
24005884:	d018      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
24005886:	687b      	ldr	r3, [r7, #4]
24005888:	681b      	ldr	r3, [r3, #0]
2400588a:	4a1c      	ldr	r2, [pc, #112]	; (240058fc <HAL_DMA_IRQHandler+0x6bc>)
2400588c:	4293      	cmp	r3, r2
2400588e:	d013      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
24005890:	687b      	ldr	r3, [r7, #4]
24005892:	681b      	ldr	r3, [r3, #0]
24005894:	4a1a      	ldr	r2, [pc, #104]	; (24005900 <HAL_DMA_IRQHandler+0x6c0>)
24005896:	4293      	cmp	r3, r2
24005898:	d00e      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
2400589a:	687b      	ldr	r3, [r7, #4]
2400589c:	681b      	ldr	r3, [r3, #0]
2400589e:	4a19      	ldr	r2, [pc, #100]	; (24005904 <HAL_DMA_IRQHandler+0x6c4>)
240058a0:	4293      	cmp	r3, r2
240058a2:	d009      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
240058a4:	687b      	ldr	r3, [r7, #4]
240058a6:	681b      	ldr	r3, [r3, #0]
240058a8:	4a17      	ldr	r2, [pc, #92]	; (24005908 <HAL_DMA_IRQHandler+0x6c8>)
240058aa:	4293      	cmp	r3, r2
240058ac:	d004      	beq.n	240058b8 <HAL_DMA_IRQHandler+0x678>
240058ae:	687b      	ldr	r3, [r7, #4]
240058b0:	681b      	ldr	r3, [r3, #0]
240058b2:	4a16      	ldr	r2, [pc, #88]	; (2400590c <HAL_DMA_IRQHandler+0x6cc>)
240058b4:	4293      	cmp	r3, r2
240058b6:	d12b      	bne.n	24005910 <HAL_DMA_IRQHandler+0x6d0>
240058b8:	687b      	ldr	r3, [r7, #4]
240058ba:	681b      	ldr	r3, [r3, #0]
240058bc:	681b      	ldr	r3, [r3, #0]
240058be:	f003 0310 	and.w	r3, r3, #16
240058c2:	2b00      	cmp	r3, #0
240058c4:	bf14      	ite	ne
240058c6:	2301      	movne	r3, #1
240058c8:	2300      	moveq	r3, #0
240058ca:	b2db      	uxtb	r3, r3
240058cc:	e02a      	b.n	24005924 <HAL_DMA_IRQHandler+0x6e4>
240058ce:	bf00      	nop
240058d0:	40020010 	.word	0x40020010
240058d4:	40020028 	.word	0x40020028
240058d8:	40020040 	.word	0x40020040
240058dc:	40020058 	.word	0x40020058
240058e0:	40020070 	.word	0x40020070
240058e4:	40020088 	.word	0x40020088
240058e8:	400200a0 	.word	0x400200a0
240058ec:	400200b8 	.word	0x400200b8
240058f0:	40020410 	.word	0x40020410
240058f4:	40020428 	.word	0x40020428
240058f8:	40020440 	.word	0x40020440
240058fc:	40020458 	.word	0x40020458
24005900:	40020470 	.word	0x40020470
24005904:	40020488 	.word	0x40020488
24005908:	400204a0 	.word	0x400204a0
2400590c:	400204b8 	.word	0x400204b8
24005910:	687b      	ldr	r3, [r7, #4]
24005912:	681b      	ldr	r3, [r3, #0]
24005914:	681b      	ldr	r3, [r3, #0]
24005916:	f003 0302 	and.w	r3, r3, #2
2400591a:	2b00      	cmp	r3, #0
2400591c:	bf14      	ite	ne
2400591e:	2301      	movne	r3, #1
24005920:	2300      	moveq	r3, #0
24005922:	b2db      	uxtb	r3, r3
24005924:	2b00      	cmp	r3, #0
24005926:	f000 8087 	beq.w	24005a38 <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
2400592a:	687b      	ldr	r3, [r7, #4]
2400592c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400592e:	f003 031f 	and.w	r3, r3, #31
24005932:	2220      	movs	r2, #32
24005934:	409a      	lsls	r2, r3
24005936:	6a3b      	ldr	r3, [r7, #32]
24005938:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
2400593a:	687b      	ldr	r3, [r7, #4]
2400593c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24005940:	b2db      	uxtb	r3, r3
24005942:	2b04      	cmp	r3, #4
24005944:	d139      	bne.n	240059ba <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
24005946:	687b      	ldr	r3, [r7, #4]
24005948:	681b      	ldr	r3, [r3, #0]
2400594a:	681a      	ldr	r2, [r3, #0]
2400594c:	687b      	ldr	r3, [r7, #4]
2400594e:	681b      	ldr	r3, [r3, #0]
24005950:	f022 0216 	bic.w	r2, r2, #22
24005954:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
24005956:	687b      	ldr	r3, [r7, #4]
24005958:	681b      	ldr	r3, [r3, #0]
2400595a:	695a      	ldr	r2, [r3, #20]
2400595c:	687b      	ldr	r3, [r7, #4]
2400595e:	681b      	ldr	r3, [r3, #0]
24005960:	f022 0280 	bic.w	r2, r2, #128	; 0x80
24005964:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24005966:	687b      	ldr	r3, [r7, #4]
24005968:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400596a:	2b00      	cmp	r3, #0
2400596c:	d103      	bne.n	24005976 <HAL_DMA_IRQHandler+0x736>
2400596e:	687b      	ldr	r3, [r7, #4]
24005970:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005972:	2b00      	cmp	r3, #0
24005974:	d007      	beq.n	24005986 <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
24005976:	687b      	ldr	r3, [r7, #4]
24005978:	681b      	ldr	r3, [r3, #0]
2400597a:	681a      	ldr	r2, [r3, #0]
2400597c:	687b      	ldr	r3, [r7, #4]
2400597e:	681b      	ldr	r3, [r3, #0]
24005980:	f022 0208 	bic.w	r2, r2, #8
24005984:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24005986:	687b      	ldr	r3, [r7, #4]
24005988:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400598a:	f003 031f 	and.w	r3, r3, #31
2400598e:	223f      	movs	r2, #63	; 0x3f
24005990:	409a      	lsls	r2, r3
24005992:	6a3b      	ldr	r3, [r7, #32]
24005994:	609a      	str	r2, [r3, #8]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
24005996:	687b      	ldr	r3, [r7, #4]
24005998:	2201      	movs	r2, #1
2400599a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
2400599e:	687b      	ldr	r3, [r7, #4]
240059a0:	2200      	movs	r2, #0
240059a2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          if(hdma->XferAbortCallback != NULL)
240059a6:	687b      	ldr	r3, [r7, #4]
240059a8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240059aa:	2b00      	cmp	r3, #0
240059ac:	f000 834a 	beq.w	24006044 <HAL_DMA_IRQHandler+0xe04>
          {
            hdma->XferAbortCallback(hdma);
240059b0:	687b      	ldr	r3, [r7, #4]
240059b2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240059b4:	6878      	ldr	r0, [r7, #4]
240059b6:	4798      	blx	r3
          }
          return;
240059b8:	e344      	b.n	24006044 <HAL_DMA_IRQHandler+0xe04>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
240059ba:	687b      	ldr	r3, [r7, #4]
240059bc:	681b      	ldr	r3, [r3, #0]
240059be:	681b      	ldr	r3, [r3, #0]
240059c0:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
240059c4:	2b00      	cmp	r3, #0
240059c6:	d018      	beq.n	240059fa <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
240059c8:	687b      	ldr	r3, [r7, #4]
240059ca:	681b      	ldr	r3, [r3, #0]
240059cc:	681b      	ldr	r3, [r3, #0]
240059ce:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
240059d2:	2b00      	cmp	r3, #0
240059d4:	d108      	bne.n	240059e8 <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
240059d6:	687b      	ldr	r3, [r7, #4]
240059d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240059da:	2b00      	cmp	r3, #0
240059dc:	d02c      	beq.n	24005a38 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
240059de:	687b      	ldr	r3, [r7, #4]
240059e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240059e2:	6878      	ldr	r0, [r7, #4]
240059e4:	4798      	blx	r3
240059e6:	e027      	b.n	24005a38 <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
240059e8:	687b      	ldr	r3, [r7, #4]
240059ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240059ec:	2b00      	cmp	r3, #0
240059ee:	d023      	beq.n	24005a38 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
240059f0:	687b      	ldr	r3, [r7, #4]
240059f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240059f4:	6878      	ldr	r0, [r7, #4]
240059f6:	4798      	blx	r3
240059f8:	e01e      	b.n	24005a38 <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
240059fa:	687b      	ldr	r3, [r7, #4]
240059fc:	681b      	ldr	r3, [r3, #0]
240059fe:	681b      	ldr	r3, [r3, #0]
24005a00:	f403 7380 	and.w	r3, r3, #256	; 0x100
24005a04:	2b00      	cmp	r3, #0
24005a06:	d10f      	bne.n	24005a28 <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
24005a08:	687b      	ldr	r3, [r7, #4]
24005a0a:	681b      	ldr	r3, [r3, #0]
24005a0c:	681a      	ldr	r2, [r3, #0]
24005a0e:	687b      	ldr	r3, [r7, #4]
24005a10:	681b      	ldr	r3, [r3, #0]
24005a12:	f022 0210 	bic.w	r2, r2, #16
24005a16:	601a      	str	r2, [r3, #0]

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
24005a18:	687b      	ldr	r3, [r7, #4]
24005a1a:	2201      	movs	r2, #1
24005a1c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
24005a20:	687b      	ldr	r3, [r7, #4]
24005a22:	2200      	movs	r2, #0
24005a24:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
          }

          if(hdma->XferCpltCallback != NULL)
24005a28:	687b      	ldr	r3, [r7, #4]
24005a2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005a2c:	2b00      	cmp	r3, #0
24005a2e:	d003      	beq.n	24005a38 <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
24005a30:	687b      	ldr	r3, [r7, #4]
24005a32:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005a34:	6878      	ldr	r0, [r7, #4]
24005a36:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
24005a38:	687b      	ldr	r3, [r7, #4]
24005a3a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005a3c:	2b00      	cmp	r3, #0
24005a3e:	f000 8306 	beq.w	2400604e <HAL_DMA_IRQHandler+0xe0e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
24005a42:	687b      	ldr	r3, [r7, #4]
24005a44:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005a46:	f003 0301 	and.w	r3, r3, #1
24005a4a:	2b00      	cmp	r3, #0
24005a4c:	f000 8088 	beq.w	24005b60 <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
24005a50:	687b      	ldr	r3, [r7, #4]
24005a52:	2204      	movs	r2, #4
24005a54:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
24005a58:	687b      	ldr	r3, [r7, #4]
24005a5a:	681b      	ldr	r3, [r3, #0]
24005a5c:	4a7a      	ldr	r2, [pc, #488]	; (24005c48 <HAL_DMA_IRQHandler+0xa08>)
24005a5e:	4293      	cmp	r3, r2
24005a60:	d04a      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005a62:	687b      	ldr	r3, [r7, #4]
24005a64:	681b      	ldr	r3, [r3, #0]
24005a66:	4a79      	ldr	r2, [pc, #484]	; (24005c4c <HAL_DMA_IRQHandler+0xa0c>)
24005a68:	4293      	cmp	r3, r2
24005a6a:	d045      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005a6c:	687b      	ldr	r3, [r7, #4]
24005a6e:	681b      	ldr	r3, [r3, #0]
24005a70:	4a77      	ldr	r2, [pc, #476]	; (24005c50 <HAL_DMA_IRQHandler+0xa10>)
24005a72:	4293      	cmp	r3, r2
24005a74:	d040      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005a76:	687b      	ldr	r3, [r7, #4]
24005a78:	681b      	ldr	r3, [r3, #0]
24005a7a:	4a76      	ldr	r2, [pc, #472]	; (24005c54 <HAL_DMA_IRQHandler+0xa14>)
24005a7c:	4293      	cmp	r3, r2
24005a7e:	d03b      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005a80:	687b      	ldr	r3, [r7, #4]
24005a82:	681b      	ldr	r3, [r3, #0]
24005a84:	4a74      	ldr	r2, [pc, #464]	; (24005c58 <HAL_DMA_IRQHandler+0xa18>)
24005a86:	4293      	cmp	r3, r2
24005a88:	d036      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005a8a:	687b      	ldr	r3, [r7, #4]
24005a8c:	681b      	ldr	r3, [r3, #0]
24005a8e:	4a73      	ldr	r2, [pc, #460]	; (24005c5c <HAL_DMA_IRQHandler+0xa1c>)
24005a90:	4293      	cmp	r3, r2
24005a92:	d031      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005a94:	687b      	ldr	r3, [r7, #4]
24005a96:	681b      	ldr	r3, [r3, #0]
24005a98:	4a71      	ldr	r2, [pc, #452]	; (24005c60 <HAL_DMA_IRQHandler+0xa20>)
24005a9a:	4293      	cmp	r3, r2
24005a9c:	d02c      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005a9e:	687b      	ldr	r3, [r7, #4]
24005aa0:	681b      	ldr	r3, [r3, #0]
24005aa2:	4a70      	ldr	r2, [pc, #448]	; (24005c64 <HAL_DMA_IRQHandler+0xa24>)
24005aa4:	4293      	cmp	r3, r2
24005aa6:	d027      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005aa8:	687b      	ldr	r3, [r7, #4]
24005aaa:	681b      	ldr	r3, [r3, #0]
24005aac:	4a6e      	ldr	r2, [pc, #440]	; (24005c68 <HAL_DMA_IRQHandler+0xa28>)
24005aae:	4293      	cmp	r3, r2
24005ab0:	d022      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005ab2:	687b      	ldr	r3, [r7, #4]
24005ab4:	681b      	ldr	r3, [r3, #0]
24005ab6:	4a6d      	ldr	r2, [pc, #436]	; (24005c6c <HAL_DMA_IRQHandler+0xa2c>)
24005ab8:	4293      	cmp	r3, r2
24005aba:	d01d      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005abc:	687b      	ldr	r3, [r7, #4]
24005abe:	681b      	ldr	r3, [r3, #0]
24005ac0:	4a6b      	ldr	r2, [pc, #428]	; (24005c70 <HAL_DMA_IRQHandler+0xa30>)
24005ac2:	4293      	cmp	r3, r2
24005ac4:	d018      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005ac6:	687b      	ldr	r3, [r7, #4]
24005ac8:	681b      	ldr	r3, [r3, #0]
24005aca:	4a6a      	ldr	r2, [pc, #424]	; (24005c74 <HAL_DMA_IRQHandler+0xa34>)
24005acc:	4293      	cmp	r3, r2
24005ace:	d013      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005ad0:	687b      	ldr	r3, [r7, #4]
24005ad2:	681b      	ldr	r3, [r3, #0]
24005ad4:	4a68      	ldr	r2, [pc, #416]	; (24005c78 <HAL_DMA_IRQHandler+0xa38>)
24005ad6:	4293      	cmp	r3, r2
24005ad8:	d00e      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005ada:	687b      	ldr	r3, [r7, #4]
24005adc:	681b      	ldr	r3, [r3, #0]
24005ade:	4a67      	ldr	r2, [pc, #412]	; (24005c7c <HAL_DMA_IRQHandler+0xa3c>)
24005ae0:	4293      	cmp	r3, r2
24005ae2:	d009      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005ae4:	687b      	ldr	r3, [r7, #4]
24005ae6:	681b      	ldr	r3, [r3, #0]
24005ae8:	4a65      	ldr	r2, [pc, #404]	; (24005c80 <HAL_DMA_IRQHandler+0xa40>)
24005aea:	4293      	cmp	r3, r2
24005aec:	d004      	beq.n	24005af8 <HAL_DMA_IRQHandler+0x8b8>
24005aee:	687b      	ldr	r3, [r7, #4]
24005af0:	681b      	ldr	r3, [r3, #0]
24005af2:	4a64      	ldr	r2, [pc, #400]	; (24005c84 <HAL_DMA_IRQHandler+0xa44>)
24005af4:	4293      	cmp	r3, r2
24005af6:	d108      	bne.n	24005b0a <HAL_DMA_IRQHandler+0x8ca>
24005af8:	687b      	ldr	r3, [r7, #4]
24005afa:	681b      	ldr	r3, [r3, #0]
24005afc:	681a      	ldr	r2, [r3, #0]
24005afe:	687b      	ldr	r3, [r7, #4]
24005b00:	681b      	ldr	r3, [r3, #0]
24005b02:	f022 0201 	bic.w	r2, r2, #1
24005b06:	601a      	str	r2, [r3, #0]
24005b08:	e007      	b.n	24005b1a <HAL_DMA_IRQHandler+0x8da>
24005b0a:	687b      	ldr	r3, [r7, #4]
24005b0c:	681b      	ldr	r3, [r3, #0]
24005b0e:	681a      	ldr	r2, [r3, #0]
24005b10:	687b      	ldr	r3, [r7, #4]
24005b12:	681b      	ldr	r3, [r3, #0]
24005b14:	f022 0201 	bic.w	r2, r2, #1
24005b18:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
24005b1a:	68fb      	ldr	r3, [r7, #12]
24005b1c:	3301      	adds	r3, #1
24005b1e:	60fb      	str	r3, [r7, #12]
24005b20:	6a7a      	ldr	r2, [r7, #36]	; 0x24
24005b22:	429a      	cmp	r2, r3
24005b24:	d307      	bcc.n	24005b36 <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
24005b26:	687b      	ldr	r3, [r7, #4]
24005b28:	681b      	ldr	r3, [r3, #0]
24005b2a:	681b      	ldr	r3, [r3, #0]
24005b2c:	f003 0301 	and.w	r3, r3, #1
24005b30:	2b00      	cmp	r3, #0
24005b32:	d1f2      	bne.n	24005b1a <HAL_DMA_IRQHandler+0x8da>
24005b34:	e000      	b.n	24005b38 <HAL_DMA_IRQHandler+0x8f8>
            break;
24005b36:	bf00      	nop

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24005b38:	687b      	ldr	r3, [r7, #4]
24005b3a:	681b      	ldr	r3, [r3, #0]
24005b3c:	681b      	ldr	r3, [r3, #0]
24005b3e:	f003 0301 	and.w	r3, r3, #1
24005b42:	2b00      	cmp	r3, #0
24005b44:	d004      	beq.n	24005b50 <HAL_DMA_IRQHandler+0x910>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
24005b46:	687b      	ldr	r3, [r7, #4]
24005b48:	2203      	movs	r2, #3
24005b4a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
24005b4e:	e003      	b.n	24005b58 <HAL_DMA_IRQHandler+0x918>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
24005b50:	687b      	ldr	r3, [r7, #4]
24005b52:	2201      	movs	r2, #1
24005b54:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24005b58:	687b      	ldr	r3, [r7, #4]
24005b5a:	2200      	movs	r2, #0
24005b5c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      }

      if(hdma->XferErrorCallback != NULL)
24005b60:	687b      	ldr	r3, [r7, #4]
24005b62:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24005b64:	2b00      	cmp	r3, #0
24005b66:	f000 8272 	beq.w	2400604e <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24005b6a:	687b      	ldr	r3, [r7, #4]
24005b6c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24005b6e:	6878      	ldr	r0, [r7, #4]
24005b70:	4798      	blx	r3
24005b72:	e26c      	b.n	2400604e <HAL_DMA_IRQHandler+0xe0e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
24005b74:	687b      	ldr	r3, [r7, #4]
24005b76:	681b      	ldr	r3, [r3, #0]
24005b78:	4a43      	ldr	r2, [pc, #268]	; (24005c88 <HAL_DMA_IRQHandler+0xa48>)
24005b7a:	4293      	cmp	r3, r2
24005b7c:	d022      	beq.n	24005bc4 <HAL_DMA_IRQHandler+0x984>
24005b7e:	687b      	ldr	r3, [r7, #4]
24005b80:	681b      	ldr	r3, [r3, #0]
24005b82:	4a42      	ldr	r2, [pc, #264]	; (24005c8c <HAL_DMA_IRQHandler+0xa4c>)
24005b84:	4293      	cmp	r3, r2
24005b86:	d01d      	beq.n	24005bc4 <HAL_DMA_IRQHandler+0x984>
24005b88:	687b      	ldr	r3, [r7, #4]
24005b8a:	681b      	ldr	r3, [r3, #0]
24005b8c:	4a40      	ldr	r2, [pc, #256]	; (24005c90 <HAL_DMA_IRQHandler+0xa50>)
24005b8e:	4293      	cmp	r3, r2
24005b90:	d018      	beq.n	24005bc4 <HAL_DMA_IRQHandler+0x984>
24005b92:	687b      	ldr	r3, [r7, #4]
24005b94:	681b      	ldr	r3, [r3, #0]
24005b96:	4a3f      	ldr	r2, [pc, #252]	; (24005c94 <HAL_DMA_IRQHandler+0xa54>)
24005b98:	4293      	cmp	r3, r2
24005b9a:	d013      	beq.n	24005bc4 <HAL_DMA_IRQHandler+0x984>
24005b9c:	687b      	ldr	r3, [r7, #4]
24005b9e:	681b      	ldr	r3, [r3, #0]
24005ba0:	4a3d      	ldr	r2, [pc, #244]	; (24005c98 <HAL_DMA_IRQHandler+0xa58>)
24005ba2:	4293      	cmp	r3, r2
24005ba4:	d00e      	beq.n	24005bc4 <HAL_DMA_IRQHandler+0x984>
24005ba6:	687b      	ldr	r3, [r7, #4]
24005ba8:	681b      	ldr	r3, [r3, #0]
24005baa:	4a3c      	ldr	r2, [pc, #240]	; (24005c9c <HAL_DMA_IRQHandler+0xa5c>)
24005bac:	4293      	cmp	r3, r2
24005bae:	d009      	beq.n	24005bc4 <HAL_DMA_IRQHandler+0x984>
24005bb0:	687b      	ldr	r3, [r7, #4]
24005bb2:	681b      	ldr	r3, [r3, #0]
24005bb4:	4a3a      	ldr	r2, [pc, #232]	; (24005ca0 <HAL_DMA_IRQHandler+0xa60>)
24005bb6:	4293      	cmp	r3, r2
24005bb8:	d004      	beq.n	24005bc4 <HAL_DMA_IRQHandler+0x984>
24005bba:	687b      	ldr	r3, [r7, #4]
24005bbc:	681b      	ldr	r3, [r3, #0]
24005bbe:	4a39      	ldr	r2, [pc, #228]	; (24005ca4 <HAL_DMA_IRQHandler+0xa64>)
24005bc0:	4293      	cmp	r3, r2
24005bc2:	d101      	bne.n	24005bc8 <HAL_DMA_IRQHandler+0x988>
24005bc4:	2301      	movs	r3, #1
24005bc6:	e000      	b.n	24005bca <HAL_DMA_IRQHandler+0x98a>
24005bc8:	2300      	movs	r3, #0
24005bca:	2b00      	cmp	r3, #0
24005bcc:	f000 823f 	beq.w	2400604e <HAL_DMA_IRQHandler+0xe0e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
24005bd0:	687b      	ldr	r3, [r7, #4]
24005bd2:	681b      	ldr	r3, [r3, #0]
24005bd4:	681b      	ldr	r3, [r3, #0]
24005bd6:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
24005bd8:	687b      	ldr	r3, [r7, #4]
24005bda:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005bdc:	f003 031f 	and.w	r3, r3, #31
24005be0:	2204      	movs	r2, #4
24005be2:	409a      	lsls	r2, r3
24005be4:	697b      	ldr	r3, [r7, #20]
24005be6:	4013      	ands	r3, r2
24005be8:	2b00      	cmp	r3, #0
24005bea:	f000 80cd 	beq.w	24005d88 <HAL_DMA_IRQHandler+0xb48>
24005bee:	693b      	ldr	r3, [r7, #16]
24005bf0:	f003 0304 	and.w	r3, r3, #4
24005bf4:	2b00      	cmp	r3, #0
24005bf6:	f000 80c7 	beq.w	24005d88 <HAL_DMA_IRQHandler+0xb48>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
24005bfa:	687b      	ldr	r3, [r7, #4]
24005bfc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005bfe:	f003 031f 	and.w	r3, r3, #31
24005c02:	2204      	movs	r2, #4
24005c04:	409a      	lsls	r2, r3
24005c06:	69fb      	ldr	r3, [r7, #28]
24005c08:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005c0a:	693b      	ldr	r3, [r7, #16]
24005c0c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24005c10:	2b00      	cmp	r3, #0
24005c12:	d049      	beq.n	24005ca8 <HAL_DMA_IRQHandler+0xa68>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
24005c14:	693b      	ldr	r3, [r7, #16]
24005c16:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24005c1a:	2b00      	cmp	r3, #0
24005c1c:	d109      	bne.n	24005c32 <HAL_DMA_IRQHandler+0x9f2>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
24005c1e:	687b      	ldr	r3, [r7, #4]
24005c20:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005c22:	2b00      	cmp	r3, #0
24005c24:	f000 8210 	beq.w	24006048 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
24005c28:	687b      	ldr	r3, [r7, #4]
24005c2a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005c2c:	6878      	ldr	r0, [r7, #4]
24005c2e:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005c30:	e20a      	b.n	24006048 <HAL_DMA_IRQHandler+0xe08>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
24005c32:	687b      	ldr	r3, [r7, #4]
24005c34:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005c36:	2b00      	cmp	r3, #0
24005c38:	f000 8206 	beq.w	24006048 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
24005c3c:	687b      	ldr	r3, [r7, #4]
24005c3e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005c40:	6878      	ldr	r0, [r7, #4]
24005c42:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005c44:	e200      	b.n	24006048 <HAL_DMA_IRQHandler+0xe08>
24005c46:	bf00      	nop
24005c48:	40020010 	.word	0x40020010
24005c4c:	40020028 	.word	0x40020028
24005c50:	40020040 	.word	0x40020040
24005c54:	40020058 	.word	0x40020058
24005c58:	40020070 	.word	0x40020070
24005c5c:	40020088 	.word	0x40020088
24005c60:	400200a0 	.word	0x400200a0
24005c64:	400200b8 	.word	0x400200b8
24005c68:	40020410 	.word	0x40020410
24005c6c:	40020428 	.word	0x40020428
24005c70:	40020440 	.word	0x40020440
24005c74:	40020458 	.word	0x40020458
24005c78:	40020470 	.word	0x40020470
24005c7c:	40020488 	.word	0x40020488
24005c80:	400204a0 	.word	0x400204a0
24005c84:	400204b8 	.word	0x400204b8
24005c88:	58025408 	.word	0x58025408
24005c8c:	5802541c 	.word	0x5802541c
24005c90:	58025430 	.word	0x58025430
24005c94:	58025444 	.word	0x58025444
24005c98:	58025458 	.word	0x58025458
24005c9c:	5802546c 	.word	0x5802546c
24005ca0:	58025480 	.word	0x58025480
24005ca4:	58025494 	.word	0x58025494
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
24005ca8:	693b      	ldr	r3, [r7, #16]
24005caa:	f003 0320 	and.w	r3, r3, #32
24005cae:	2b00      	cmp	r3, #0
24005cb0:	d160      	bne.n	24005d74 <HAL_DMA_IRQHandler+0xb34>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
24005cb2:	687b      	ldr	r3, [r7, #4]
24005cb4:	681b      	ldr	r3, [r3, #0]
24005cb6:	4a7f      	ldr	r2, [pc, #508]	; (24005eb4 <HAL_DMA_IRQHandler+0xc74>)
24005cb8:	4293      	cmp	r3, r2
24005cba:	d04a      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005cbc:	687b      	ldr	r3, [r7, #4]
24005cbe:	681b      	ldr	r3, [r3, #0]
24005cc0:	4a7d      	ldr	r2, [pc, #500]	; (24005eb8 <HAL_DMA_IRQHandler+0xc78>)
24005cc2:	4293      	cmp	r3, r2
24005cc4:	d045      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005cc6:	687b      	ldr	r3, [r7, #4]
24005cc8:	681b      	ldr	r3, [r3, #0]
24005cca:	4a7c      	ldr	r2, [pc, #496]	; (24005ebc <HAL_DMA_IRQHandler+0xc7c>)
24005ccc:	4293      	cmp	r3, r2
24005cce:	d040      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005cd0:	687b      	ldr	r3, [r7, #4]
24005cd2:	681b      	ldr	r3, [r3, #0]
24005cd4:	4a7a      	ldr	r2, [pc, #488]	; (24005ec0 <HAL_DMA_IRQHandler+0xc80>)
24005cd6:	4293      	cmp	r3, r2
24005cd8:	d03b      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005cda:	687b      	ldr	r3, [r7, #4]
24005cdc:	681b      	ldr	r3, [r3, #0]
24005cde:	4a79      	ldr	r2, [pc, #484]	; (24005ec4 <HAL_DMA_IRQHandler+0xc84>)
24005ce0:	4293      	cmp	r3, r2
24005ce2:	d036      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005ce4:	687b      	ldr	r3, [r7, #4]
24005ce6:	681b      	ldr	r3, [r3, #0]
24005ce8:	4a77      	ldr	r2, [pc, #476]	; (24005ec8 <HAL_DMA_IRQHandler+0xc88>)
24005cea:	4293      	cmp	r3, r2
24005cec:	d031      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005cee:	687b      	ldr	r3, [r7, #4]
24005cf0:	681b      	ldr	r3, [r3, #0]
24005cf2:	4a76      	ldr	r2, [pc, #472]	; (24005ecc <HAL_DMA_IRQHandler+0xc8c>)
24005cf4:	4293      	cmp	r3, r2
24005cf6:	d02c      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005cf8:	687b      	ldr	r3, [r7, #4]
24005cfa:	681b      	ldr	r3, [r3, #0]
24005cfc:	4a74      	ldr	r2, [pc, #464]	; (24005ed0 <HAL_DMA_IRQHandler+0xc90>)
24005cfe:	4293      	cmp	r3, r2
24005d00:	d027      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005d02:	687b      	ldr	r3, [r7, #4]
24005d04:	681b      	ldr	r3, [r3, #0]
24005d06:	4a73      	ldr	r2, [pc, #460]	; (24005ed4 <HAL_DMA_IRQHandler+0xc94>)
24005d08:	4293      	cmp	r3, r2
24005d0a:	d022      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005d0c:	687b      	ldr	r3, [r7, #4]
24005d0e:	681b      	ldr	r3, [r3, #0]
24005d10:	4a71      	ldr	r2, [pc, #452]	; (24005ed8 <HAL_DMA_IRQHandler+0xc98>)
24005d12:	4293      	cmp	r3, r2
24005d14:	d01d      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005d16:	687b      	ldr	r3, [r7, #4]
24005d18:	681b      	ldr	r3, [r3, #0]
24005d1a:	4a70      	ldr	r2, [pc, #448]	; (24005edc <HAL_DMA_IRQHandler+0xc9c>)
24005d1c:	4293      	cmp	r3, r2
24005d1e:	d018      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005d20:	687b      	ldr	r3, [r7, #4]
24005d22:	681b      	ldr	r3, [r3, #0]
24005d24:	4a6e      	ldr	r2, [pc, #440]	; (24005ee0 <HAL_DMA_IRQHandler+0xca0>)
24005d26:	4293      	cmp	r3, r2
24005d28:	d013      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005d2a:	687b      	ldr	r3, [r7, #4]
24005d2c:	681b      	ldr	r3, [r3, #0]
24005d2e:	4a6d      	ldr	r2, [pc, #436]	; (24005ee4 <HAL_DMA_IRQHandler+0xca4>)
24005d30:	4293      	cmp	r3, r2
24005d32:	d00e      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005d34:	687b      	ldr	r3, [r7, #4]
24005d36:	681b      	ldr	r3, [r3, #0]
24005d38:	4a6b      	ldr	r2, [pc, #428]	; (24005ee8 <HAL_DMA_IRQHandler+0xca8>)
24005d3a:	4293      	cmp	r3, r2
24005d3c:	d009      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005d3e:	687b      	ldr	r3, [r7, #4]
24005d40:	681b      	ldr	r3, [r3, #0]
24005d42:	4a6a      	ldr	r2, [pc, #424]	; (24005eec <HAL_DMA_IRQHandler+0xcac>)
24005d44:	4293      	cmp	r3, r2
24005d46:	d004      	beq.n	24005d52 <HAL_DMA_IRQHandler+0xb12>
24005d48:	687b      	ldr	r3, [r7, #4]
24005d4a:	681b      	ldr	r3, [r3, #0]
24005d4c:	4a68      	ldr	r2, [pc, #416]	; (24005ef0 <HAL_DMA_IRQHandler+0xcb0>)
24005d4e:	4293      	cmp	r3, r2
24005d50:	d108      	bne.n	24005d64 <HAL_DMA_IRQHandler+0xb24>
24005d52:	687b      	ldr	r3, [r7, #4]
24005d54:	681b      	ldr	r3, [r3, #0]
24005d56:	681a      	ldr	r2, [r3, #0]
24005d58:	687b      	ldr	r3, [r7, #4]
24005d5a:	681b      	ldr	r3, [r3, #0]
24005d5c:	f022 0208 	bic.w	r2, r2, #8
24005d60:	601a      	str	r2, [r3, #0]
24005d62:	e007      	b.n	24005d74 <HAL_DMA_IRQHandler+0xb34>
24005d64:	687b      	ldr	r3, [r7, #4]
24005d66:	681b      	ldr	r3, [r3, #0]
24005d68:	681a      	ldr	r2, [r3, #0]
24005d6a:	687b      	ldr	r3, [r7, #4]
24005d6c:	681b      	ldr	r3, [r3, #0]
24005d6e:	f022 0204 	bic.w	r2, r2, #4
24005d72:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
24005d74:	687b      	ldr	r3, [r7, #4]
24005d76:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005d78:	2b00      	cmp	r3, #0
24005d7a:	f000 8165 	beq.w	24006048 <HAL_DMA_IRQHandler+0xe08>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
24005d7e:	687b      	ldr	r3, [r7, #4]
24005d80:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005d82:	6878      	ldr	r0, [r7, #4]
24005d84:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005d86:	e15f      	b.n	24006048 <HAL_DMA_IRQHandler+0xe08>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
24005d88:	687b      	ldr	r3, [r7, #4]
24005d8a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005d8c:	f003 031f 	and.w	r3, r3, #31
24005d90:	2202      	movs	r2, #2
24005d92:	409a      	lsls	r2, r3
24005d94:	697b      	ldr	r3, [r7, #20]
24005d96:	4013      	ands	r3, r2
24005d98:	2b00      	cmp	r3, #0
24005d9a:	f000 80c5 	beq.w	24005f28 <HAL_DMA_IRQHandler+0xce8>
24005d9e:	693b      	ldr	r3, [r7, #16]
24005da0:	f003 0302 	and.w	r3, r3, #2
24005da4:	2b00      	cmp	r3, #0
24005da6:	f000 80bf 	beq.w	24005f28 <HAL_DMA_IRQHandler+0xce8>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
24005daa:	687b      	ldr	r3, [r7, #4]
24005dac:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005dae:	f003 031f 	and.w	r3, r3, #31
24005db2:	2202      	movs	r2, #2
24005db4:	409a      	lsls	r2, r3
24005db6:	69fb      	ldr	r3, [r7, #28]
24005db8:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005dba:	693b      	ldr	r3, [r7, #16]
24005dbc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24005dc0:	2b00      	cmp	r3, #0
24005dc2:	d018      	beq.n	24005df6 <HAL_DMA_IRQHandler+0xbb6>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
24005dc4:	693b      	ldr	r3, [r7, #16]
24005dc6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24005dca:	2b00      	cmp	r3, #0
24005dcc:	d109      	bne.n	24005de2 <HAL_DMA_IRQHandler+0xba2>
        {
          if(hdma->XferM1CpltCallback != NULL)
24005dce:	687b      	ldr	r3, [r7, #4]
24005dd0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24005dd2:	2b00      	cmp	r3, #0
24005dd4:	f000 813a 	beq.w	2400604c <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
24005dd8:	687b      	ldr	r3, [r7, #4]
24005dda:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24005ddc:	6878      	ldr	r0, [r7, #4]
24005dde:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005de0:	e134      	b.n	2400604c <HAL_DMA_IRQHandler+0xe0c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
24005de2:	687b      	ldr	r3, [r7, #4]
24005de4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005de6:	2b00      	cmp	r3, #0
24005de8:	f000 8130 	beq.w	2400604c <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
24005dec:	687b      	ldr	r3, [r7, #4]
24005dee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005df0:	6878      	ldr	r0, [r7, #4]
24005df2:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005df4:	e12a      	b.n	2400604c <HAL_DMA_IRQHandler+0xe0c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
24005df6:	693b      	ldr	r3, [r7, #16]
24005df8:	f003 0320 	and.w	r3, r3, #32
24005dfc:	2b00      	cmp	r3, #0
24005dfe:	f040 8089 	bne.w	24005f14 <HAL_DMA_IRQHandler+0xcd4>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
24005e02:	687b      	ldr	r3, [r7, #4]
24005e04:	681b      	ldr	r3, [r3, #0]
24005e06:	4a2b      	ldr	r2, [pc, #172]	; (24005eb4 <HAL_DMA_IRQHandler+0xc74>)
24005e08:	4293      	cmp	r3, r2
24005e0a:	d04a      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e0c:	687b      	ldr	r3, [r7, #4]
24005e0e:	681b      	ldr	r3, [r3, #0]
24005e10:	4a29      	ldr	r2, [pc, #164]	; (24005eb8 <HAL_DMA_IRQHandler+0xc78>)
24005e12:	4293      	cmp	r3, r2
24005e14:	d045      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e16:	687b      	ldr	r3, [r7, #4]
24005e18:	681b      	ldr	r3, [r3, #0]
24005e1a:	4a28      	ldr	r2, [pc, #160]	; (24005ebc <HAL_DMA_IRQHandler+0xc7c>)
24005e1c:	4293      	cmp	r3, r2
24005e1e:	d040      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e20:	687b      	ldr	r3, [r7, #4]
24005e22:	681b      	ldr	r3, [r3, #0]
24005e24:	4a26      	ldr	r2, [pc, #152]	; (24005ec0 <HAL_DMA_IRQHandler+0xc80>)
24005e26:	4293      	cmp	r3, r2
24005e28:	d03b      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e2a:	687b      	ldr	r3, [r7, #4]
24005e2c:	681b      	ldr	r3, [r3, #0]
24005e2e:	4a25      	ldr	r2, [pc, #148]	; (24005ec4 <HAL_DMA_IRQHandler+0xc84>)
24005e30:	4293      	cmp	r3, r2
24005e32:	d036      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e34:	687b      	ldr	r3, [r7, #4]
24005e36:	681b      	ldr	r3, [r3, #0]
24005e38:	4a23      	ldr	r2, [pc, #140]	; (24005ec8 <HAL_DMA_IRQHandler+0xc88>)
24005e3a:	4293      	cmp	r3, r2
24005e3c:	d031      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e3e:	687b      	ldr	r3, [r7, #4]
24005e40:	681b      	ldr	r3, [r3, #0]
24005e42:	4a22      	ldr	r2, [pc, #136]	; (24005ecc <HAL_DMA_IRQHandler+0xc8c>)
24005e44:	4293      	cmp	r3, r2
24005e46:	d02c      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e48:	687b      	ldr	r3, [r7, #4]
24005e4a:	681b      	ldr	r3, [r3, #0]
24005e4c:	4a20      	ldr	r2, [pc, #128]	; (24005ed0 <HAL_DMA_IRQHandler+0xc90>)
24005e4e:	4293      	cmp	r3, r2
24005e50:	d027      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e52:	687b      	ldr	r3, [r7, #4]
24005e54:	681b      	ldr	r3, [r3, #0]
24005e56:	4a1f      	ldr	r2, [pc, #124]	; (24005ed4 <HAL_DMA_IRQHandler+0xc94>)
24005e58:	4293      	cmp	r3, r2
24005e5a:	d022      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e5c:	687b      	ldr	r3, [r7, #4]
24005e5e:	681b      	ldr	r3, [r3, #0]
24005e60:	4a1d      	ldr	r2, [pc, #116]	; (24005ed8 <HAL_DMA_IRQHandler+0xc98>)
24005e62:	4293      	cmp	r3, r2
24005e64:	d01d      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e66:	687b      	ldr	r3, [r7, #4]
24005e68:	681b      	ldr	r3, [r3, #0]
24005e6a:	4a1c      	ldr	r2, [pc, #112]	; (24005edc <HAL_DMA_IRQHandler+0xc9c>)
24005e6c:	4293      	cmp	r3, r2
24005e6e:	d018      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e70:	687b      	ldr	r3, [r7, #4]
24005e72:	681b      	ldr	r3, [r3, #0]
24005e74:	4a1a      	ldr	r2, [pc, #104]	; (24005ee0 <HAL_DMA_IRQHandler+0xca0>)
24005e76:	4293      	cmp	r3, r2
24005e78:	d013      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e7a:	687b      	ldr	r3, [r7, #4]
24005e7c:	681b      	ldr	r3, [r3, #0]
24005e7e:	4a19      	ldr	r2, [pc, #100]	; (24005ee4 <HAL_DMA_IRQHandler+0xca4>)
24005e80:	4293      	cmp	r3, r2
24005e82:	d00e      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e84:	687b      	ldr	r3, [r7, #4]
24005e86:	681b      	ldr	r3, [r3, #0]
24005e88:	4a17      	ldr	r2, [pc, #92]	; (24005ee8 <HAL_DMA_IRQHandler+0xca8>)
24005e8a:	4293      	cmp	r3, r2
24005e8c:	d009      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e8e:	687b      	ldr	r3, [r7, #4]
24005e90:	681b      	ldr	r3, [r3, #0]
24005e92:	4a16      	ldr	r2, [pc, #88]	; (24005eec <HAL_DMA_IRQHandler+0xcac>)
24005e94:	4293      	cmp	r3, r2
24005e96:	d004      	beq.n	24005ea2 <HAL_DMA_IRQHandler+0xc62>
24005e98:	687b      	ldr	r3, [r7, #4]
24005e9a:	681b      	ldr	r3, [r3, #0]
24005e9c:	4a14      	ldr	r2, [pc, #80]	; (24005ef0 <HAL_DMA_IRQHandler+0xcb0>)
24005e9e:	4293      	cmp	r3, r2
24005ea0:	d128      	bne.n	24005ef4 <HAL_DMA_IRQHandler+0xcb4>
24005ea2:	687b      	ldr	r3, [r7, #4]
24005ea4:	681b      	ldr	r3, [r3, #0]
24005ea6:	681a      	ldr	r2, [r3, #0]
24005ea8:	687b      	ldr	r3, [r7, #4]
24005eaa:	681b      	ldr	r3, [r3, #0]
24005eac:	f022 0214 	bic.w	r2, r2, #20
24005eb0:	601a      	str	r2, [r3, #0]
24005eb2:	e027      	b.n	24005f04 <HAL_DMA_IRQHandler+0xcc4>
24005eb4:	40020010 	.word	0x40020010
24005eb8:	40020028 	.word	0x40020028
24005ebc:	40020040 	.word	0x40020040
24005ec0:	40020058 	.word	0x40020058
24005ec4:	40020070 	.word	0x40020070
24005ec8:	40020088 	.word	0x40020088
24005ecc:	400200a0 	.word	0x400200a0
24005ed0:	400200b8 	.word	0x400200b8
24005ed4:	40020410 	.word	0x40020410
24005ed8:	40020428 	.word	0x40020428
24005edc:	40020440 	.word	0x40020440
24005ee0:	40020458 	.word	0x40020458
24005ee4:	40020470 	.word	0x40020470
24005ee8:	40020488 	.word	0x40020488
24005eec:	400204a0 	.word	0x400204a0
24005ef0:	400204b8 	.word	0x400204b8
24005ef4:	687b      	ldr	r3, [r7, #4]
24005ef6:	681b      	ldr	r3, [r3, #0]
24005ef8:	681a      	ldr	r2, [r3, #0]
24005efa:	687b      	ldr	r3, [r7, #4]
24005efc:	681b      	ldr	r3, [r3, #0]
24005efe:	f022 020a 	bic.w	r2, r2, #10
24005f02:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
24005f04:	687b      	ldr	r3, [r7, #4]
24005f06:	2201      	movs	r2, #1
24005f08:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
24005f0c:	687b      	ldr	r3, [r7, #4]
24005f0e:	2200      	movs	r2, #0
24005f10:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        }

        if(hdma->XferCpltCallback != NULL)
24005f14:	687b      	ldr	r3, [r7, #4]
24005f16:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005f18:	2b00      	cmp	r3, #0
24005f1a:	f000 8097 	beq.w	2400604c <HAL_DMA_IRQHandler+0xe0c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
24005f1e:	687b      	ldr	r3, [r7, #4]
24005f20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005f22:	6878      	ldr	r0, [r7, #4]
24005f24:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005f26:	e091      	b.n	2400604c <HAL_DMA_IRQHandler+0xe0c>
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
24005f28:	687b      	ldr	r3, [r7, #4]
24005f2a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005f2c:	f003 031f 	and.w	r3, r3, #31
24005f30:	2208      	movs	r2, #8
24005f32:	409a      	lsls	r2, r3
24005f34:	697b      	ldr	r3, [r7, #20]
24005f36:	4013      	ands	r3, r2
24005f38:	2b00      	cmp	r3, #0
24005f3a:	f000 8088 	beq.w	2400604e <HAL_DMA_IRQHandler+0xe0e>
24005f3e:	693b      	ldr	r3, [r7, #16]
24005f40:	f003 0308 	and.w	r3, r3, #8
24005f44:	2b00      	cmp	r3, #0
24005f46:	f000 8082 	beq.w	2400604e <HAL_DMA_IRQHandler+0xe0e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
24005f4a:	687b      	ldr	r3, [r7, #4]
24005f4c:	681b      	ldr	r3, [r3, #0]
24005f4e:	4a41      	ldr	r2, [pc, #260]	; (24006054 <HAL_DMA_IRQHandler+0xe14>)
24005f50:	4293      	cmp	r3, r2
24005f52:	d04a      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005f54:	687b      	ldr	r3, [r7, #4]
24005f56:	681b      	ldr	r3, [r3, #0]
24005f58:	4a3f      	ldr	r2, [pc, #252]	; (24006058 <HAL_DMA_IRQHandler+0xe18>)
24005f5a:	4293      	cmp	r3, r2
24005f5c:	d045      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005f5e:	687b      	ldr	r3, [r7, #4]
24005f60:	681b      	ldr	r3, [r3, #0]
24005f62:	4a3e      	ldr	r2, [pc, #248]	; (2400605c <HAL_DMA_IRQHandler+0xe1c>)
24005f64:	4293      	cmp	r3, r2
24005f66:	d040      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005f68:	687b      	ldr	r3, [r7, #4]
24005f6a:	681b      	ldr	r3, [r3, #0]
24005f6c:	4a3c      	ldr	r2, [pc, #240]	; (24006060 <HAL_DMA_IRQHandler+0xe20>)
24005f6e:	4293      	cmp	r3, r2
24005f70:	d03b      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005f72:	687b      	ldr	r3, [r7, #4]
24005f74:	681b      	ldr	r3, [r3, #0]
24005f76:	4a3b      	ldr	r2, [pc, #236]	; (24006064 <HAL_DMA_IRQHandler+0xe24>)
24005f78:	4293      	cmp	r3, r2
24005f7a:	d036      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005f7c:	687b      	ldr	r3, [r7, #4]
24005f7e:	681b      	ldr	r3, [r3, #0]
24005f80:	4a39      	ldr	r2, [pc, #228]	; (24006068 <HAL_DMA_IRQHandler+0xe28>)
24005f82:	4293      	cmp	r3, r2
24005f84:	d031      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005f86:	687b      	ldr	r3, [r7, #4]
24005f88:	681b      	ldr	r3, [r3, #0]
24005f8a:	4a38      	ldr	r2, [pc, #224]	; (2400606c <HAL_DMA_IRQHandler+0xe2c>)
24005f8c:	4293      	cmp	r3, r2
24005f8e:	d02c      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005f90:	687b      	ldr	r3, [r7, #4]
24005f92:	681b      	ldr	r3, [r3, #0]
24005f94:	4a36      	ldr	r2, [pc, #216]	; (24006070 <HAL_DMA_IRQHandler+0xe30>)
24005f96:	4293      	cmp	r3, r2
24005f98:	d027      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005f9a:	687b      	ldr	r3, [r7, #4]
24005f9c:	681b      	ldr	r3, [r3, #0]
24005f9e:	4a35      	ldr	r2, [pc, #212]	; (24006074 <HAL_DMA_IRQHandler+0xe34>)
24005fa0:	4293      	cmp	r3, r2
24005fa2:	d022      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005fa4:	687b      	ldr	r3, [r7, #4]
24005fa6:	681b      	ldr	r3, [r3, #0]
24005fa8:	4a33      	ldr	r2, [pc, #204]	; (24006078 <HAL_DMA_IRQHandler+0xe38>)
24005faa:	4293      	cmp	r3, r2
24005fac:	d01d      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005fae:	687b      	ldr	r3, [r7, #4]
24005fb0:	681b      	ldr	r3, [r3, #0]
24005fb2:	4a32      	ldr	r2, [pc, #200]	; (2400607c <HAL_DMA_IRQHandler+0xe3c>)
24005fb4:	4293      	cmp	r3, r2
24005fb6:	d018      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005fb8:	687b      	ldr	r3, [r7, #4]
24005fba:	681b      	ldr	r3, [r3, #0]
24005fbc:	4a30      	ldr	r2, [pc, #192]	; (24006080 <HAL_DMA_IRQHandler+0xe40>)
24005fbe:	4293      	cmp	r3, r2
24005fc0:	d013      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005fc2:	687b      	ldr	r3, [r7, #4]
24005fc4:	681b      	ldr	r3, [r3, #0]
24005fc6:	4a2f      	ldr	r2, [pc, #188]	; (24006084 <HAL_DMA_IRQHandler+0xe44>)
24005fc8:	4293      	cmp	r3, r2
24005fca:	d00e      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005fcc:	687b      	ldr	r3, [r7, #4]
24005fce:	681b      	ldr	r3, [r3, #0]
24005fd0:	4a2d      	ldr	r2, [pc, #180]	; (24006088 <HAL_DMA_IRQHandler+0xe48>)
24005fd2:	4293      	cmp	r3, r2
24005fd4:	d009      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005fd6:	687b      	ldr	r3, [r7, #4]
24005fd8:	681b      	ldr	r3, [r3, #0]
24005fda:	4a2c      	ldr	r2, [pc, #176]	; (2400608c <HAL_DMA_IRQHandler+0xe4c>)
24005fdc:	4293      	cmp	r3, r2
24005fde:	d004      	beq.n	24005fea <HAL_DMA_IRQHandler+0xdaa>
24005fe0:	687b      	ldr	r3, [r7, #4]
24005fe2:	681b      	ldr	r3, [r3, #0]
24005fe4:	4a2a      	ldr	r2, [pc, #168]	; (24006090 <HAL_DMA_IRQHandler+0xe50>)
24005fe6:	4293      	cmp	r3, r2
24005fe8:	d108      	bne.n	24005ffc <HAL_DMA_IRQHandler+0xdbc>
24005fea:	687b      	ldr	r3, [r7, #4]
24005fec:	681b      	ldr	r3, [r3, #0]
24005fee:	681a      	ldr	r2, [r3, #0]
24005ff0:	687b      	ldr	r3, [r7, #4]
24005ff2:	681b      	ldr	r3, [r3, #0]
24005ff4:	f022 021c 	bic.w	r2, r2, #28
24005ff8:	601a      	str	r2, [r3, #0]
24005ffa:	e007      	b.n	2400600c <HAL_DMA_IRQHandler+0xdcc>
24005ffc:	687b      	ldr	r3, [r7, #4]
24005ffe:	681b      	ldr	r3, [r3, #0]
24006000:	681a      	ldr	r2, [r3, #0]
24006002:	687b      	ldr	r3, [r7, #4]
24006004:	681b      	ldr	r3, [r3, #0]
24006006:	f022 020e 	bic.w	r2, r2, #14
2400600a:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
2400600c:	687b      	ldr	r3, [r7, #4]
2400600e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006010:	f003 031f 	and.w	r3, r3, #31
24006014:	2201      	movs	r2, #1
24006016:	409a      	lsls	r2, r3
24006018:	69fb      	ldr	r3, [r7, #28]
2400601a:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
2400601c:	687b      	ldr	r3, [r7, #4]
2400601e:	2201      	movs	r2, #1
24006020:	655a      	str	r2, [r3, #84]	; 0x54

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
24006022:	687b      	ldr	r3, [r7, #4]
24006024:	2201      	movs	r2, #1
24006026:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
2400602a:	687b      	ldr	r3, [r7, #4]
2400602c:	2200      	movs	r2, #0
2400602e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if (hdma->XferErrorCallback != NULL)
24006032:	687b      	ldr	r3, [r7, #4]
24006034:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24006036:	2b00      	cmp	r3, #0
24006038:	d009      	beq.n	2400604e <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
2400603a:	687b      	ldr	r3, [r7, #4]
2400603c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400603e:	6878      	ldr	r0, [r7, #4]
24006040:	4798      	blx	r3
24006042:	e004      	b.n	2400604e <HAL_DMA_IRQHandler+0xe0e>
          return;
24006044:	bf00      	nop
24006046:	e002      	b.n	2400604e <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24006048:	bf00      	nop
2400604a:	e000      	b.n	2400604e <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
2400604c:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
2400604e:	3728      	adds	r7, #40	; 0x28
24006050:	46bd      	mov	sp, r7
24006052:	bd80      	pop	{r7, pc}
24006054:	40020010 	.word	0x40020010
24006058:	40020028 	.word	0x40020028
2400605c:	40020040 	.word	0x40020040
24006060:	40020058 	.word	0x40020058
24006064:	40020070 	.word	0x40020070
24006068:	40020088 	.word	0x40020088
2400606c:	400200a0 	.word	0x400200a0
24006070:	400200b8 	.word	0x400200b8
24006074:	40020410 	.word	0x40020410
24006078:	40020428 	.word	0x40020428
2400607c:	40020440 	.word	0x40020440
24006080:	40020458 	.word	0x40020458
24006084:	40020470 	.word	0x40020470
24006088:	40020488 	.word	0x40020488
2400608c:	400204a0 	.word	0x400204a0
24006090:	400204b8 	.word	0x400204b8

24006094 <HAL_DMA_RegisterCallback>:
  * @param  pCallback:            pointer to private callback function which has pointer to
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
{
24006094:	b480      	push	{r7}
24006096:	b087      	sub	sp, #28
24006098:	af00      	add	r7, sp, #0
2400609a:	60f8      	str	r0, [r7, #12]
2400609c:	460b      	mov	r3, r1
2400609e:	607a      	str	r2, [r7, #4]
240060a0:	72fb      	strb	r3, [r7, #11]

  HAL_StatusTypeDef status = HAL_OK;
240060a2:	2300      	movs	r3, #0
240060a4:	75fb      	strb	r3, [r7, #23]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
240060a6:	68fb      	ldr	r3, [r7, #12]
240060a8:	2b00      	cmp	r3, #0
240060aa:	d101      	bne.n	240060b0 <HAL_DMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
240060ac:	2301      	movs	r3, #1
240060ae:	e045      	b.n	2400613c <HAL_DMA_RegisterCallback+0xa8>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
240060b0:	68fb      	ldr	r3, [r7, #12]
240060b2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
240060b6:	2b01      	cmp	r3, #1
240060b8:	d101      	bne.n	240060be <HAL_DMA_RegisterCallback+0x2a>
240060ba:	2302      	movs	r3, #2
240060bc:	e03e      	b.n	2400613c <HAL_DMA_RegisterCallback+0xa8>
240060be:	68fb      	ldr	r3, [r7, #12]
240060c0:	2201      	movs	r2, #1
240060c2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
240060c6:	68fb      	ldr	r3, [r7, #12]
240060c8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240060cc:	b2db      	uxtb	r3, r3
240060ce:	2b01      	cmp	r3, #1
240060d0:	d12d      	bne.n	2400612e <HAL_DMA_RegisterCallback+0x9a>
  {
    switch (CallbackID)
240060d2:	7afb      	ldrb	r3, [r7, #11]
240060d4:	2b05      	cmp	r3, #5
240060d6:	d827      	bhi.n	24006128 <HAL_DMA_RegisterCallback+0x94>
240060d8:	a201      	add	r2, pc, #4	; (adr r2, 240060e0 <HAL_DMA_RegisterCallback+0x4c>)
240060da:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240060de:	bf00      	nop
240060e0:	240060f9 	.word	0x240060f9
240060e4:	24006101 	.word	0x24006101
240060e8:	24006109 	.word	0x24006109
240060ec:	24006111 	.word	0x24006111
240060f0:	24006119 	.word	0x24006119
240060f4:	24006121 	.word	0x24006121
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = pCallback;
240060f8:	68fb      	ldr	r3, [r7, #12]
240060fa:	687a      	ldr	r2, [r7, #4]
240060fc:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
240060fe:	e018      	b.n	24006132 <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = pCallback;
24006100:	68fb      	ldr	r3, [r7, #12]
24006102:	687a      	ldr	r2, [r7, #4]
24006104:	641a      	str	r2, [r3, #64]	; 0x40
      break;
24006106:	e014      	b.n	24006132 <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = pCallback;
24006108:	68fb      	ldr	r3, [r7, #12]
2400610a:	687a      	ldr	r2, [r7, #4]
2400610c:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400610e:	e010      	b.n	24006132 <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = pCallback;
24006110:	68fb      	ldr	r3, [r7, #12]
24006112:	687a      	ldr	r2, [r7, #4]
24006114:	649a      	str	r2, [r3, #72]	; 0x48
      break;
24006116:	e00c      	b.n	24006132 <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = pCallback;
24006118:	68fb      	ldr	r3, [r7, #12]
2400611a:	687a      	ldr	r2, [r7, #4]
2400611c:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400611e:	e008      	b.n	24006132 <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = pCallback;
24006120:	68fb      	ldr	r3, [r7, #12]
24006122:	687a      	ldr	r2, [r7, #4]
24006124:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24006126:	e004      	b.n	24006132 <HAL_DMA_RegisterCallback+0x9e>

    default:
      status =  HAL_ERROR;
24006128:	2301      	movs	r3, #1
2400612a:	75fb      	strb	r3, [r7, #23]
      break;
2400612c:	e001      	b.n	24006132 <HAL_DMA_RegisterCallback+0x9e>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400612e:	2301      	movs	r3, #1
24006130:	75fb      	strb	r3, [r7, #23]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
24006132:	68fb      	ldr	r3, [r7, #12]
24006134:	2200      	movs	r2, #0
24006136:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
2400613a:	7dfb      	ldrb	r3, [r7, #23]
}
2400613c:	4618      	mov	r0, r3
2400613e:	371c      	adds	r7, #28
24006140:	46bd      	mov	sp, r7
24006142:	f85d 7b04 	ldr.w	r7, [sp], #4
24006146:	4770      	bx	lr

24006148 <HAL_DMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
{
24006148:	b480      	push	{r7}
2400614a:	b085      	sub	sp, #20
2400614c:	af00      	add	r7, sp, #0
2400614e:	6078      	str	r0, [r7, #4]
24006150:	460b      	mov	r3, r1
24006152:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
24006154:	2300      	movs	r3, #0
24006156:	73fb      	strb	r3, [r7, #15]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24006158:	687b      	ldr	r3, [r7, #4]
2400615a:	2b00      	cmp	r3, #0
2400615c:	d101      	bne.n	24006162 <HAL_DMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
2400615e:	2301      	movs	r3, #1
24006160:	e059      	b.n	24006216 <HAL_DMA_UnRegisterCallback+0xce>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24006162:	687b      	ldr	r3, [r7, #4]
24006164:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24006168:	2b01      	cmp	r3, #1
2400616a:	d101      	bne.n	24006170 <HAL_DMA_UnRegisterCallback+0x28>
2400616c:	2302      	movs	r3, #2
2400616e:	e052      	b.n	24006216 <HAL_DMA_UnRegisterCallback+0xce>
24006170:	687b      	ldr	r3, [r7, #4]
24006172:	2201      	movs	r2, #1
24006174:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24006178:	687b      	ldr	r3, [r7, #4]
2400617a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400617e:	b2db      	uxtb	r3, r3
24006180:	2b01      	cmp	r3, #1
24006182:	d141      	bne.n	24006208 <HAL_DMA_UnRegisterCallback+0xc0>
  {
    switch (CallbackID)
24006184:	78fb      	ldrb	r3, [r7, #3]
24006186:	2b06      	cmp	r3, #6
24006188:	d83b      	bhi.n	24006202 <HAL_DMA_UnRegisterCallback+0xba>
2400618a:	a201      	add	r2, pc, #4	; (adr r2, 24006190 <HAL_DMA_UnRegisterCallback+0x48>)
2400618c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24006190:	240061ad 	.word	0x240061ad
24006194:	240061b5 	.word	0x240061b5
24006198:	240061bd 	.word	0x240061bd
2400619c:	240061c5 	.word	0x240061c5
240061a0:	240061cd 	.word	0x240061cd
240061a4:	240061d5 	.word	0x240061d5
240061a8:	240061dd 	.word	0x240061dd
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = NULL;
240061ac:	687b      	ldr	r3, [r7, #4]
240061ae:	2200      	movs	r2, #0
240061b0:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
240061b2:	e02b      	b.n	2400620c <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = NULL;
240061b4:	687b      	ldr	r3, [r7, #4]
240061b6:	2200      	movs	r2, #0
240061b8:	641a      	str	r2, [r3, #64]	; 0x40
      break;
240061ba:	e027      	b.n	2400620c <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = NULL;
240061bc:	687b      	ldr	r3, [r7, #4]
240061be:	2200      	movs	r2, #0
240061c0:	645a      	str	r2, [r3, #68]	; 0x44
      break;
240061c2:	e023      	b.n	2400620c <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = NULL;
240061c4:	687b      	ldr	r3, [r7, #4]
240061c6:	2200      	movs	r2, #0
240061c8:	649a      	str	r2, [r3, #72]	; 0x48
      break;
240061ca:	e01f      	b.n	2400620c <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = NULL;
240061cc:	687b      	ldr	r3, [r7, #4]
240061ce:	2200      	movs	r2, #0
240061d0:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
240061d2:	e01b      	b.n	2400620c <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = NULL;
240061d4:	687b      	ldr	r3, [r7, #4]
240061d6:	2200      	movs	r2, #0
240061d8:	651a      	str	r2, [r3, #80]	; 0x50
      break;
240061da:	e017      	b.n	2400620c <HAL_DMA_UnRegisterCallback+0xc4>

    case   HAL_DMA_XFER_ALL_CB_ID:
      hdma->XferCpltCallback = NULL;
240061dc:	687b      	ldr	r3, [r7, #4]
240061de:	2200      	movs	r2, #0
240061e0:	63da      	str	r2, [r3, #60]	; 0x3c
      hdma->XferHalfCpltCallback = NULL;
240061e2:	687b      	ldr	r3, [r7, #4]
240061e4:	2200      	movs	r2, #0
240061e6:	641a      	str	r2, [r3, #64]	; 0x40
      hdma->XferM1CpltCallback = NULL;
240061e8:	687b      	ldr	r3, [r7, #4]
240061ea:	2200      	movs	r2, #0
240061ec:	645a      	str	r2, [r3, #68]	; 0x44
      hdma->XferM1HalfCpltCallback = NULL;
240061ee:	687b      	ldr	r3, [r7, #4]
240061f0:	2200      	movs	r2, #0
240061f2:	649a      	str	r2, [r3, #72]	; 0x48
      hdma->XferErrorCallback = NULL;
240061f4:	687b      	ldr	r3, [r7, #4]
240061f6:	2200      	movs	r2, #0
240061f8:	64da      	str	r2, [r3, #76]	; 0x4c
      hdma->XferAbortCallback = NULL;
240061fa:	687b      	ldr	r3, [r7, #4]
240061fc:	2200      	movs	r2, #0
240061fe:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24006200:	e004      	b.n	2400620c <HAL_DMA_UnRegisterCallback+0xc4>

    default:
      status = HAL_ERROR;
24006202:	2301      	movs	r3, #1
24006204:	73fb      	strb	r3, [r7, #15]
      break;
24006206:	e001      	b.n	2400620c <HAL_DMA_UnRegisterCallback+0xc4>
    }
  }
  else
  {
    status = HAL_ERROR;
24006208:	2301      	movs	r3, #1
2400620a:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
2400620c:	687b      	ldr	r3, [r7, #4]
2400620e:	2200      	movs	r2, #0
24006210:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
24006214:	7bfb      	ldrb	r3, [r7, #15]
}
24006216:	4618      	mov	r0, r3
24006218:	3714      	adds	r7, #20
2400621a:	46bd      	mov	sp, r7
2400621c:	f85d 7b04 	ldr.w	r7, [sp], #4
24006220:	4770      	bx	lr
24006222:	bf00      	nop

24006224 <HAL_DMA_GetState>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
24006224:	b480      	push	{r7}
24006226:	b083      	sub	sp, #12
24006228:	af00      	add	r7, sp, #0
2400622a:	6078      	str	r0, [r7, #4]
  return hdma->State;
2400622c:	687b      	ldr	r3, [r7, #4]
2400622e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24006232:	b2db      	uxtb	r3, r3
}
24006234:	4618      	mov	r0, r3
24006236:	370c      	adds	r7, #12
24006238:	46bd      	mov	sp, r7
2400623a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400623e:	4770      	bx	lr

24006240 <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
24006240:	b480      	push	{r7}
24006242:	b083      	sub	sp, #12
24006244:	af00      	add	r7, sp, #0
24006246:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
24006248:	687b      	ldr	r3, [r7, #4]
2400624a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
2400624c:	4618      	mov	r0, r3
2400624e:	370c      	adds	r7, #12
24006250:	46bd      	mov	sp, r7
24006252:	f85d 7b04 	ldr.w	r7, [sp], #4
24006256:	4770      	bx	lr

24006258 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24006258:	b480      	push	{r7}
2400625a:	b087      	sub	sp, #28
2400625c:	af00      	add	r7, sp, #0
2400625e:	60f8      	str	r0, [r7, #12]
24006260:	60b9      	str	r1, [r7, #8]
24006262:	607a      	str	r2, [r7, #4]
24006264:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24006266:	68fb      	ldr	r3, [r7, #12]
24006268:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400626a:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
2400626c:	68fb      	ldr	r3, [r7, #12]
2400626e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006270:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24006272:	68fb      	ldr	r3, [r7, #12]
24006274:	681b      	ldr	r3, [r3, #0]
24006276:	4a7f      	ldr	r2, [pc, #508]	; (24006474 <DMA_SetConfig+0x21c>)
24006278:	4293      	cmp	r3, r2
2400627a:	d072      	beq.n	24006362 <DMA_SetConfig+0x10a>
2400627c:	68fb      	ldr	r3, [r7, #12]
2400627e:	681b      	ldr	r3, [r3, #0]
24006280:	4a7d      	ldr	r2, [pc, #500]	; (24006478 <DMA_SetConfig+0x220>)
24006282:	4293      	cmp	r3, r2
24006284:	d06d      	beq.n	24006362 <DMA_SetConfig+0x10a>
24006286:	68fb      	ldr	r3, [r7, #12]
24006288:	681b      	ldr	r3, [r3, #0]
2400628a:	4a7c      	ldr	r2, [pc, #496]	; (2400647c <DMA_SetConfig+0x224>)
2400628c:	4293      	cmp	r3, r2
2400628e:	d068      	beq.n	24006362 <DMA_SetConfig+0x10a>
24006290:	68fb      	ldr	r3, [r7, #12]
24006292:	681b      	ldr	r3, [r3, #0]
24006294:	4a7a      	ldr	r2, [pc, #488]	; (24006480 <DMA_SetConfig+0x228>)
24006296:	4293      	cmp	r3, r2
24006298:	d063      	beq.n	24006362 <DMA_SetConfig+0x10a>
2400629a:	68fb      	ldr	r3, [r7, #12]
2400629c:	681b      	ldr	r3, [r3, #0]
2400629e:	4a79      	ldr	r2, [pc, #484]	; (24006484 <DMA_SetConfig+0x22c>)
240062a0:	4293      	cmp	r3, r2
240062a2:	d05e      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062a4:	68fb      	ldr	r3, [r7, #12]
240062a6:	681b      	ldr	r3, [r3, #0]
240062a8:	4a77      	ldr	r2, [pc, #476]	; (24006488 <DMA_SetConfig+0x230>)
240062aa:	4293      	cmp	r3, r2
240062ac:	d059      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062ae:	68fb      	ldr	r3, [r7, #12]
240062b0:	681b      	ldr	r3, [r3, #0]
240062b2:	4a76      	ldr	r2, [pc, #472]	; (2400648c <DMA_SetConfig+0x234>)
240062b4:	4293      	cmp	r3, r2
240062b6:	d054      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062b8:	68fb      	ldr	r3, [r7, #12]
240062ba:	681b      	ldr	r3, [r3, #0]
240062bc:	4a74      	ldr	r2, [pc, #464]	; (24006490 <DMA_SetConfig+0x238>)
240062be:	4293      	cmp	r3, r2
240062c0:	d04f      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062c2:	68fb      	ldr	r3, [r7, #12]
240062c4:	681b      	ldr	r3, [r3, #0]
240062c6:	4a73      	ldr	r2, [pc, #460]	; (24006494 <DMA_SetConfig+0x23c>)
240062c8:	4293      	cmp	r3, r2
240062ca:	d04a      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062cc:	68fb      	ldr	r3, [r7, #12]
240062ce:	681b      	ldr	r3, [r3, #0]
240062d0:	4a71      	ldr	r2, [pc, #452]	; (24006498 <DMA_SetConfig+0x240>)
240062d2:	4293      	cmp	r3, r2
240062d4:	d045      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062d6:	68fb      	ldr	r3, [r7, #12]
240062d8:	681b      	ldr	r3, [r3, #0]
240062da:	4a70      	ldr	r2, [pc, #448]	; (2400649c <DMA_SetConfig+0x244>)
240062dc:	4293      	cmp	r3, r2
240062de:	d040      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062e0:	68fb      	ldr	r3, [r7, #12]
240062e2:	681b      	ldr	r3, [r3, #0]
240062e4:	4a6e      	ldr	r2, [pc, #440]	; (240064a0 <DMA_SetConfig+0x248>)
240062e6:	4293      	cmp	r3, r2
240062e8:	d03b      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062ea:	68fb      	ldr	r3, [r7, #12]
240062ec:	681b      	ldr	r3, [r3, #0]
240062ee:	4a6d      	ldr	r2, [pc, #436]	; (240064a4 <DMA_SetConfig+0x24c>)
240062f0:	4293      	cmp	r3, r2
240062f2:	d036      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062f4:	68fb      	ldr	r3, [r7, #12]
240062f6:	681b      	ldr	r3, [r3, #0]
240062f8:	4a6b      	ldr	r2, [pc, #428]	; (240064a8 <DMA_SetConfig+0x250>)
240062fa:	4293      	cmp	r3, r2
240062fc:	d031      	beq.n	24006362 <DMA_SetConfig+0x10a>
240062fe:	68fb      	ldr	r3, [r7, #12]
24006300:	681b      	ldr	r3, [r3, #0]
24006302:	4a6a      	ldr	r2, [pc, #424]	; (240064ac <DMA_SetConfig+0x254>)
24006304:	4293      	cmp	r3, r2
24006306:	d02c      	beq.n	24006362 <DMA_SetConfig+0x10a>
24006308:	68fb      	ldr	r3, [r7, #12]
2400630a:	681b      	ldr	r3, [r3, #0]
2400630c:	4a68      	ldr	r2, [pc, #416]	; (240064b0 <DMA_SetConfig+0x258>)
2400630e:	4293      	cmp	r3, r2
24006310:	d027      	beq.n	24006362 <DMA_SetConfig+0x10a>
24006312:	68fb      	ldr	r3, [r7, #12]
24006314:	681b      	ldr	r3, [r3, #0]
24006316:	4a67      	ldr	r2, [pc, #412]	; (240064b4 <DMA_SetConfig+0x25c>)
24006318:	4293      	cmp	r3, r2
2400631a:	d022      	beq.n	24006362 <DMA_SetConfig+0x10a>
2400631c:	68fb      	ldr	r3, [r7, #12]
2400631e:	681b      	ldr	r3, [r3, #0]
24006320:	4a65      	ldr	r2, [pc, #404]	; (240064b8 <DMA_SetConfig+0x260>)
24006322:	4293      	cmp	r3, r2
24006324:	d01d      	beq.n	24006362 <DMA_SetConfig+0x10a>
24006326:	68fb      	ldr	r3, [r7, #12]
24006328:	681b      	ldr	r3, [r3, #0]
2400632a:	4a64      	ldr	r2, [pc, #400]	; (240064bc <DMA_SetConfig+0x264>)
2400632c:	4293      	cmp	r3, r2
2400632e:	d018      	beq.n	24006362 <DMA_SetConfig+0x10a>
24006330:	68fb      	ldr	r3, [r7, #12]
24006332:	681b      	ldr	r3, [r3, #0]
24006334:	4a62      	ldr	r2, [pc, #392]	; (240064c0 <DMA_SetConfig+0x268>)
24006336:	4293      	cmp	r3, r2
24006338:	d013      	beq.n	24006362 <DMA_SetConfig+0x10a>
2400633a:	68fb      	ldr	r3, [r7, #12]
2400633c:	681b      	ldr	r3, [r3, #0]
2400633e:	4a61      	ldr	r2, [pc, #388]	; (240064c4 <DMA_SetConfig+0x26c>)
24006340:	4293      	cmp	r3, r2
24006342:	d00e      	beq.n	24006362 <DMA_SetConfig+0x10a>
24006344:	68fb      	ldr	r3, [r7, #12]
24006346:	681b      	ldr	r3, [r3, #0]
24006348:	4a5f      	ldr	r2, [pc, #380]	; (240064c8 <DMA_SetConfig+0x270>)
2400634a:	4293      	cmp	r3, r2
2400634c:	d009      	beq.n	24006362 <DMA_SetConfig+0x10a>
2400634e:	68fb      	ldr	r3, [r7, #12]
24006350:	681b      	ldr	r3, [r3, #0]
24006352:	4a5e      	ldr	r2, [pc, #376]	; (240064cc <DMA_SetConfig+0x274>)
24006354:	4293      	cmp	r3, r2
24006356:	d004      	beq.n	24006362 <DMA_SetConfig+0x10a>
24006358:	68fb      	ldr	r3, [r7, #12]
2400635a:	681b      	ldr	r3, [r3, #0]
2400635c:	4a5c      	ldr	r2, [pc, #368]	; (240064d0 <DMA_SetConfig+0x278>)
2400635e:	4293      	cmp	r3, r2
24006360:	d101      	bne.n	24006366 <DMA_SetConfig+0x10e>
24006362:	2301      	movs	r3, #1
24006364:	e000      	b.n	24006368 <DMA_SetConfig+0x110>
24006366:	2300      	movs	r3, #0
24006368:	2b00      	cmp	r3, #0
2400636a:	d00d      	beq.n	24006388 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
2400636c:	68fb      	ldr	r3, [r7, #12]
2400636e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24006370:	68fa      	ldr	r2, [r7, #12]
24006372:	6e92      	ldr	r2, [r2, #104]	; 0x68
24006374:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
24006376:	68fb      	ldr	r3, [r7, #12]
24006378:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400637a:	2b00      	cmp	r3, #0
2400637c:	d004      	beq.n	24006388 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2400637e:	68fb      	ldr	r3, [r7, #12]
24006380:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24006382:	68fa      	ldr	r2, [r7, #12]
24006384:	6f52      	ldr	r2, [r2, #116]	; 0x74
24006386:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24006388:	68fb      	ldr	r3, [r7, #12]
2400638a:	681b      	ldr	r3, [r3, #0]
2400638c:	4a39      	ldr	r2, [pc, #228]	; (24006474 <DMA_SetConfig+0x21c>)
2400638e:	4293      	cmp	r3, r2
24006390:	d04a      	beq.n	24006428 <DMA_SetConfig+0x1d0>
24006392:	68fb      	ldr	r3, [r7, #12]
24006394:	681b      	ldr	r3, [r3, #0]
24006396:	4a38      	ldr	r2, [pc, #224]	; (24006478 <DMA_SetConfig+0x220>)
24006398:	4293      	cmp	r3, r2
2400639a:	d045      	beq.n	24006428 <DMA_SetConfig+0x1d0>
2400639c:	68fb      	ldr	r3, [r7, #12]
2400639e:	681b      	ldr	r3, [r3, #0]
240063a0:	4a36      	ldr	r2, [pc, #216]	; (2400647c <DMA_SetConfig+0x224>)
240063a2:	4293      	cmp	r3, r2
240063a4:	d040      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063a6:	68fb      	ldr	r3, [r7, #12]
240063a8:	681b      	ldr	r3, [r3, #0]
240063aa:	4a35      	ldr	r2, [pc, #212]	; (24006480 <DMA_SetConfig+0x228>)
240063ac:	4293      	cmp	r3, r2
240063ae:	d03b      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063b0:	68fb      	ldr	r3, [r7, #12]
240063b2:	681b      	ldr	r3, [r3, #0]
240063b4:	4a33      	ldr	r2, [pc, #204]	; (24006484 <DMA_SetConfig+0x22c>)
240063b6:	4293      	cmp	r3, r2
240063b8:	d036      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063ba:	68fb      	ldr	r3, [r7, #12]
240063bc:	681b      	ldr	r3, [r3, #0]
240063be:	4a32      	ldr	r2, [pc, #200]	; (24006488 <DMA_SetConfig+0x230>)
240063c0:	4293      	cmp	r3, r2
240063c2:	d031      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063c4:	68fb      	ldr	r3, [r7, #12]
240063c6:	681b      	ldr	r3, [r3, #0]
240063c8:	4a30      	ldr	r2, [pc, #192]	; (2400648c <DMA_SetConfig+0x234>)
240063ca:	4293      	cmp	r3, r2
240063cc:	d02c      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063ce:	68fb      	ldr	r3, [r7, #12]
240063d0:	681b      	ldr	r3, [r3, #0]
240063d2:	4a2f      	ldr	r2, [pc, #188]	; (24006490 <DMA_SetConfig+0x238>)
240063d4:	4293      	cmp	r3, r2
240063d6:	d027      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063d8:	68fb      	ldr	r3, [r7, #12]
240063da:	681b      	ldr	r3, [r3, #0]
240063dc:	4a2d      	ldr	r2, [pc, #180]	; (24006494 <DMA_SetConfig+0x23c>)
240063de:	4293      	cmp	r3, r2
240063e0:	d022      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063e2:	68fb      	ldr	r3, [r7, #12]
240063e4:	681b      	ldr	r3, [r3, #0]
240063e6:	4a2c      	ldr	r2, [pc, #176]	; (24006498 <DMA_SetConfig+0x240>)
240063e8:	4293      	cmp	r3, r2
240063ea:	d01d      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063ec:	68fb      	ldr	r3, [r7, #12]
240063ee:	681b      	ldr	r3, [r3, #0]
240063f0:	4a2a      	ldr	r2, [pc, #168]	; (2400649c <DMA_SetConfig+0x244>)
240063f2:	4293      	cmp	r3, r2
240063f4:	d018      	beq.n	24006428 <DMA_SetConfig+0x1d0>
240063f6:	68fb      	ldr	r3, [r7, #12]
240063f8:	681b      	ldr	r3, [r3, #0]
240063fa:	4a29      	ldr	r2, [pc, #164]	; (240064a0 <DMA_SetConfig+0x248>)
240063fc:	4293      	cmp	r3, r2
240063fe:	d013      	beq.n	24006428 <DMA_SetConfig+0x1d0>
24006400:	68fb      	ldr	r3, [r7, #12]
24006402:	681b      	ldr	r3, [r3, #0]
24006404:	4a27      	ldr	r2, [pc, #156]	; (240064a4 <DMA_SetConfig+0x24c>)
24006406:	4293      	cmp	r3, r2
24006408:	d00e      	beq.n	24006428 <DMA_SetConfig+0x1d0>
2400640a:	68fb      	ldr	r3, [r7, #12]
2400640c:	681b      	ldr	r3, [r3, #0]
2400640e:	4a26      	ldr	r2, [pc, #152]	; (240064a8 <DMA_SetConfig+0x250>)
24006410:	4293      	cmp	r3, r2
24006412:	d009      	beq.n	24006428 <DMA_SetConfig+0x1d0>
24006414:	68fb      	ldr	r3, [r7, #12]
24006416:	681b      	ldr	r3, [r3, #0]
24006418:	4a24      	ldr	r2, [pc, #144]	; (240064ac <DMA_SetConfig+0x254>)
2400641a:	4293      	cmp	r3, r2
2400641c:	d004      	beq.n	24006428 <DMA_SetConfig+0x1d0>
2400641e:	68fb      	ldr	r3, [r7, #12]
24006420:	681b      	ldr	r3, [r3, #0]
24006422:	4a23      	ldr	r2, [pc, #140]	; (240064b0 <DMA_SetConfig+0x258>)
24006424:	4293      	cmp	r3, r2
24006426:	d101      	bne.n	2400642c <DMA_SetConfig+0x1d4>
24006428:	2301      	movs	r3, #1
2400642a:	e000      	b.n	2400642e <DMA_SetConfig+0x1d6>
2400642c:	2300      	movs	r3, #0
2400642e:	2b00      	cmp	r3, #0
24006430:	d059      	beq.n	240064e6 <DMA_SetConfig+0x28e>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24006432:	68fb      	ldr	r3, [r7, #12]
24006434:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006436:	f003 031f 	and.w	r3, r3, #31
2400643a:	223f      	movs	r2, #63	; 0x3f
2400643c:	409a      	lsls	r2, r3
2400643e:	697b      	ldr	r3, [r7, #20]
24006440:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
24006442:	68fb      	ldr	r3, [r7, #12]
24006444:	681b      	ldr	r3, [r3, #0]
24006446:	681a      	ldr	r2, [r3, #0]
24006448:	68fb      	ldr	r3, [r7, #12]
2400644a:	681b      	ldr	r3, [r3, #0]
2400644c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
24006450:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
24006452:	68fb      	ldr	r3, [r7, #12]
24006454:	681b      	ldr	r3, [r3, #0]
24006456:	683a      	ldr	r2, [r7, #0]
24006458:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
2400645a:	68fb      	ldr	r3, [r7, #12]
2400645c:	689b      	ldr	r3, [r3, #8]
2400645e:	2b40      	cmp	r3, #64	; 0x40
24006460:	d138      	bne.n	240064d4 <DMA_SetConfig+0x27c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
24006462:	68fb      	ldr	r3, [r7, #12]
24006464:	681b      	ldr	r3, [r3, #0]
24006466:	687a      	ldr	r2, [r7, #4]
24006468:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
2400646a:	68fb      	ldr	r3, [r7, #12]
2400646c:	681b      	ldr	r3, [r3, #0]
2400646e:	68ba      	ldr	r2, [r7, #8]
24006470:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
24006472:	e086      	b.n	24006582 <DMA_SetConfig+0x32a>
24006474:	40020010 	.word	0x40020010
24006478:	40020028 	.word	0x40020028
2400647c:	40020040 	.word	0x40020040
24006480:	40020058 	.word	0x40020058
24006484:	40020070 	.word	0x40020070
24006488:	40020088 	.word	0x40020088
2400648c:	400200a0 	.word	0x400200a0
24006490:	400200b8 	.word	0x400200b8
24006494:	40020410 	.word	0x40020410
24006498:	40020428 	.word	0x40020428
2400649c:	40020440 	.word	0x40020440
240064a0:	40020458 	.word	0x40020458
240064a4:	40020470 	.word	0x40020470
240064a8:	40020488 	.word	0x40020488
240064ac:	400204a0 	.word	0x400204a0
240064b0:	400204b8 	.word	0x400204b8
240064b4:	58025408 	.word	0x58025408
240064b8:	5802541c 	.word	0x5802541c
240064bc:	58025430 	.word	0x58025430
240064c0:	58025444 	.word	0x58025444
240064c4:	58025458 	.word	0x58025458
240064c8:	5802546c 	.word	0x5802546c
240064cc:	58025480 	.word	0x58025480
240064d0:	58025494 	.word	0x58025494
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
240064d4:	68fb      	ldr	r3, [r7, #12]
240064d6:	681b      	ldr	r3, [r3, #0]
240064d8:	68ba      	ldr	r2, [r7, #8]
240064da:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
240064dc:	68fb      	ldr	r3, [r7, #12]
240064de:	681b      	ldr	r3, [r3, #0]
240064e0:	687a      	ldr	r2, [r7, #4]
240064e2:	60da      	str	r2, [r3, #12]
}
240064e4:	e04d      	b.n	24006582 <DMA_SetConfig+0x32a>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
240064e6:	68fb      	ldr	r3, [r7, #12]
240064e8:	681b      	ldr	r3, [r3, #0]
240064ea:	4a29      	ldr	r2, [pc, #164]	; (24006590 <DMA_SetConfig+0x338>)
240064ec:	4293      	cmp	r3, r2
240064ee:	d022      	beq.n	24006536 <DMA_SetConfig+0x2de>
240064f0:	68fb      	ldr	r3, [r7, #12]
240064f2:	681b      	ldr	r3, [r3, #0]
240064f4:	4a27      	ldr	r2, [pc, #156]	; (24006594 <DMA_SetConfig+0x33c>)
240064f6:	4293      	cmp	r3, r2
240064f8:	d01d      	beq.n	24006536 <DMA_SetConfig+0x2de>
240064fa:	68fb      	ldr	r3, [r7, #12]
240064fc:	681b      	ldr	r3, [r3, #0]
240064fe:	4a26      	ldr	r2, [pc, #152]	; (24006598 <DMA_SetConfig+0x340>)
24006500:	4293      	cmp	r3, r2
24006502:	d018      	beq.n	24006536 <DMA_SetConfig+0x2de>
24006504:	68fb      	ldr	r3, [r7, #12]
24006506:	681b      	ldr	r3, [r3, #0]
24006508:	4a24      	ldr	r2, [pc, #144]	; (2400659c <DMA_SetConfig+0x344>)
2400650a:	4293      	cmp	r3, r2
2400650c:	d013      	beq.n	24006536 <DMA_SetConfig+0x2de>
2400650e:	68fb      	ldr	r3, [r7, #12]
24006510:	681b      	ldr	r3, [r3, #0]
24006512:	4a23      	ldr	r2, [pc, #140]	; (240065a0 <DMA_SetConfig+0x348>)
24006514:	4293      	cmp	r3, r2
24006516:	d00e      	beq.n	24006536 <DMA_SetConfig+0x2de>
24006518:	68fb      	ldr	r3, [r7, #12]
2400651a:	681b      	ldr	r3, [r3, #0]
2400651c:	4a21      	ldr	r2, [pc, #132]	; (240065a4 <DMA_SetConfig+0x34c>)
2400651e:	4293      	cmp	r3, r2
24006520:	d009      	beq.n	24006536 <DMA_SetConfig+0x2de>
24006522:	68fb      	ldr	r3, [r7, #12]
24006524:	681b      	ldr	r3, [r3, #0]
24006526:	4a20      	ldr	r2, [pc, #128]	; (240065a8 <DMA_SetConfig+0x350>)
24006528:	4293      	cmp	r3, r2
2400652a:	d004      	beq.n	24006536 <DMA_SetConfig+0x2de>
2400652c:	68fb      	ldr	r3, [r7, #12]
2400652e:	681b      	ldr	r3, [r3, #0]
24006530:	4a1e      	ldr	r2, [pc, #120]	; (240065ac <DMA_SetConfig+0x354>)
24006532:	4293      	cmp	r3, r2
24006534:	d101      	bne.n	2400653a <DMA_SetConfig+0x2e2>
24006536:	2301      	movs	r3, #1
24006538:	e000      	b.n	2400653c <DMA_SetConfig+0x2e4>
2400653a:	2300      	movs	r3, #0
2400653c:	2b00      	cmp	r3, #0
2400653e:	d020      	beq.n	24006582 <DMA_SetConfig+0x32a>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24006540:	68fb      	ldr	r3, [r7, #12]
24006542:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006544:	f003 031f 	and.w	r3, r3, #31
24006548:	2201      	movs	r2, #1
2400654a:	409a      	lsls	r2, r3
2400654c:	693b      	ldr	r3, [r7, #16]
2400654e:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
24006550:	68fb      	ldr	r3, [r7, #12]
24006552:	681b      	ldr	r3, [r3, #0]
24006554:	683a      	ldr	r2, [r7, #0]
24006556:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24006558:	68fb      	ldr	r3, [r7, #12]
2400655a:	689b      	ldr	r3, [r3, #8]
2400655c:	2b40      	cmp	r3, #64	; 0x40
2400655e:	d108      	bne.n	24006572 <DMA_SetConfig+0x31a>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
24006560:	68fb      	ldr	r3, [r7, #12]
24006562:	681b      	ldr	r3, [r3, #0]
24006564:	687a      	ldr	r2, [r7, #4]
24006566:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
24006568:	68fb      	ldr	r3, [r7, #12]
2400656a:	681b      	ldr	r3, [r3, #0]
2400656c:	68ba      	ldr	r2, [r7, #8]
2400656e:	60da      	str	r2, [r3, #12]
}
24006570:	e007      	b.n	24006582 <DMA_SetConfig+0x32a>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
24006572:	68fb      	ldr	r3, [r7, #12]
24006574:	681b      	ldr	r3, [r3, #0]
24006576:	68ba      	ldr	r2, [r7, #8]
24006578:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
2400657a:	68fb      	ldr	r3, [r7, #12]
2400657c:	681b      	ldr	r3, [r3, #0]
2400657e:	687a      	ldr	r2, [r7, #4]
24006580:	60da      	str	r2, [r3, #12]
}
24006582:	bf00      	nop
24006584:	371c      	adds	r7, #28
24006586:	46bd      	mov	sp, r7
24006588:	f85d 7b04 	ldr.w	r7, [sp], #4
2400658c:	4770      	bx	lr
2400658e:	bf00      	nop
24006590:	58025408 	.word	0x58025408
24006594:	5802541c 	.word	0x5802541c
24006598:	58025430 	.word	0x58025430
2400659c:	58025444 	.word	0x58025444
240065a0:	58025458 	.word	0x58025458
240065a4:	5802546c 	.word	0x5802546c
240065a8:	58025480 	.word	0x58025480
240065ac:	58025494 	.word	0x58025494

240065b0 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
240065b0:	b480      	push	{r7}
240065b2:	b085      	sub	sp, #20
240065b4:	af00      	add	r7, sp, #0
240065b6:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240065b8:	687b      	ldr	r3, [r7, #4]
240065ba:	681b      	ldr	r3, [r3, #0]
240065bc:	4a42      	ldr	r2, [pc, #264]	; (240066c8 <DMA_CalcBaseAndBitshift+0x118>)
240065be:	4293      	cmp	r3, r2
240065c0:	d04a      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
240065c2:	687b      	ldr	r3, [r7, #4]
240065c4:	681b      	ldr	r3, [r3, #0]
240065c6:	4a41      	ldr	r2, [pc, #260]	; (240066cc <DMA_CalcBaseAndBitshift+0x11c>)
240065c8:	4293      	cmp	r3, r2
240065ca:	d045      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
240065cc:	687b      	ldr	r3, [r7, #4]
240065ce:	681b      	ldr	r3, [r3, #0]
240065d0:	4a3f      	ldr	r2, [pc, #252]	; (240066d0 <DMA_CalcBaseAndBitshift+0x120>)
240065d2:	4293      	cmp	r3, r2
240065d4:	d040      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
240065d6:	687b      	ldr	r3, [r7, #4]
240065d8:	681b      	ldr	r3, [r3, #0]
240065da:	4a3e      	ldr	r2, [pc, #248]	; (240066d4 <DMA_CalcBaseAndBitshift+0x124>)
240065dc:	4293      	cmp	r3, r2
240065de:	d03b      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
240065e0:	687b      	ldr	r3, [r7, #4]
240065e2:	681b      	ldr	r3, [r3, #0]
240065e4:	4a3c      	ldr	r2, [pc, #240]	; (240066d8 <DMA_CalcBaseAndBitshift+0x128>)
240065e6:	4293      	cmp	r3, r2
240065e8:	d036      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
240065ea:	687b      	ldr	r3, [r7, #4]
240065ec:	681b      	ldr	r3, [r3, #0]
240065ee:	4a3b      	ldr	r2, [pc, #236]	; (240066dc <DMA_CalcBaseAndBitshift+0x12c>)
240065f0:	4293      	cmp	r3, r2
240065f2:	d031      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
240065f4:	687b      	ldr	r3, [r7, #4]
240065f6:	681b      	ldr	r3, [r3, #0]
240065f8:	4a39      	ldr	r2, [pc, #228]	; (240066e0 <DMA_CalcBaseAndBitshift+0x130>)
240065fa:	4293      	cmp	r3, r2
240065fc:	d02c      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
240065fe:	687b      	ldr	r3, [r7, #4]
24006600:	681b      	ldr	r3, [r3, #0]
24006602:	4a38      	ldr	r2, [pc, #224]	; (240066e4 <DMA_CalcBaseAndBitshift+0x134>)
24006604:	4293      	cmp	r3, r2
24006606:	d027      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
24006608:	687b      	ldr	r3, [r7, #4]
2400660a:	681b      	ldr	r3, [r3, #0]
2400660c:	4a36      	ldr	r2, [pc, #216]	; (240066e8 <DMA_CalcBaseAndBitshift+0x138>)
2400660e:	4293      	cmp	r3, r2
24006610:	d022      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
24006612:	687b      	ldr	r3, [r7, #4]
24006614:	681b      	ldr	r3, [r3, #0]
24006616:	4a35      	ldr	r2, [pc, #212]	; (240066ec <DMA_CalcBaseAndBitshift+0x13c>)
24006618:	4293      	cmp	r3, r2
2400661a:	d01d      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
2400661c:	687b      	ldr	r3, [r7, #4]
2400661e:	681b      	ldr	r3, [r3, #0]
24006620:	4a33      	ldr	r2, [pc, #204]	; (240066f0 <DMA_CalcBaseAndBitshift+0x140>)
24006622:	4293      	cmp	r3, r2
24006624:	d018      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
24006626:	687b      	ldr	r3, [r7, #4]
24006628:	681b      	ldr	r3, [r3, #0]
2400662a:	4a32      	ldr	r2, [pc, #200]	; (240066f4 <DMA_CalcBaseAndBitshift+0x144>)
2400662c:	4293      	cmp	r3, r2
2400662e:	d013      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
24006630:	687b      	ldr	r3, [r7, #4]
24006632:	681b      	ldr	r3, [r3, #0]
24006634:	4a30      	ldr	r2, [pc, #192]	; (240066f8 <DMA_CalcBaseAndBitshift+0x148>)
24006636:	4293      	cmp	r3, r2
24006638:	d00e      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
2400663a:	687b      	ldr	r3, [r7, #4]
2400663c:	681b      	ldr	r3, [r3, #0]
2400663e:	4a2f      	ldr	r2, [pc, #188]	; (240066fc <DMA_CalcBaseAndBitshift+0x14c>)
24006640:	4293      	cmp	r3, r2
24006642:	d009      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
24006644:	687b      	ldr	r3, [r7, #4]
24006646:	681b      	ldr	r3, [r3, #0]
24006648:	4a2d      	ldr	r2, [pc, #180]	; (24006700 <DMA_CalcBaseAndBitshift+0x150>)
2400664a:	4293      	cmp	r3, r2
2400664c:	d004      	beq.n	24006658 <DMA_CalcBaseAndBitshift+0xa8>
2400664e:	687b      	ldr	r3, [r7, #4]
24006650:	681b      	ldr	r3, [r3, #0]
24006652:	4a2c      	ldr	r2, [pc, #176]	; (24006704 <DMA_CalcBaseAndBitshift+0x154>)
24006654:	4293      	cmp	r3, r2
24006656:	d101      	bne.n	2400665c <DMA_CalcBaseAndBitshift+0xac>
24006658:	2301      	movs	r3, #1
2400665a:	e000      	b.n	2400665e <DMA_CalcBaseAndBitshift+0xae>
2400665c:	2300      	movs	r3, #0
2400665e:	2b00      	cmp	r3, #0
24006660:	d024      	beq.n	240066ac <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
24006662:	687b      	ldr	r3, [r7, #4]
24006664:	681b      	ldr	r3, [r3, #0]
24006666:	b2db      	uxtb	r3, r3
24006668:	3b10      	subs	r3, #16
2400666a:	4a27      	ldr	r2, [pc, #156]	; (24006708 <DMA_CalcBaseAndBitshift+0x158>)
2400666c:	fba2 2303 	umull	r2, r3, r2, r3
24006670:	091b      	lsrs	r3, r3, #4
24006672:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
24006674:	68fb      	ldr	r3, [r7, #12]
24006676:	f003 0307 	and.w	r3, r3, #7
2400667a:	4a24      	ldr	r2, [pc, #144]	; (2400670c <DMA_CalcBaseAndBitshift+0x15c>)
2400667c:	5cd3      	ldrb	r3, [r2, r3]
2400667e:	461a      	mov	r2, r3
24006680:	687b      	ldr	r3, [r7, #4]
24006682:	65da      	str	r2, [r3, #92]	; 0x5c

    if (stream_number > 3U)
24006684:	68fb      	ldr	r3, [r7, #12]
24006686:	2b03      	cmp	r3, #3
24006688:	d908      	bls.n	2400669c <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
2400668a:	687b      	ldr	r3, [r7, #4]
2400668c:	681b      	ldr	r3, [r3, #0]
2400668e:	461a      	mov	r2, r3
24006690:	4b1f      	ldr	r3, [pc, #124]	; (24006710 <DMA_CalcBaseAndBitshift+0x160>)
24006692:	4013      	ands	r3, r2
24006694:	1d1a      	adds	r2, r3, #4
24006696:	687b      	ldr	r3, [r7, #4]
24006698:	659a      	str	r2, [r3, #88]	; 0x58
2400669a:	e00d      	b.n	240066b8 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
2400669c:	687b      	ldr	r3, [r7, #4]
2400669e:	681b      	ldr	r3, [r3, #0]
240066a0:	461a      	mov	r2, r3
240066a2:	4b1b      	ldr	r3, [pc, #108]	; (24006710 <DMA_CalcBaseAndBitshift+0x160>)
240066a4:	4013      	ands	r3, r2
240066a6:	687a      	ldr	r2, [r7, #4]
240066a8:	6593      	str	r3, [r2, #88]	; 0x58
240066aa:	e005      	b.n	240066b8 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
240066ac:	687b      	ldr	r3, [r7, #4]
240066ae:	681b      	ldr	r3, [r3, #0]
240066b0:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
240066b4:	687b      	ldr	r3, [r7, #4]
240066b6:	659a      	str	r2, [r3, #88]	; 0x58
  }

  return hdma->StreamBaseAddress;
240066b8:	687b      	ldr	r3, [r7, #4]
240066ba:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
240066bc:	4618      	mov	r0, r3
240066be:	3714      	adds	r7, #20
240066c0:	46bd      	mov	sp, r7
240066c2:	f85d 7b04 	ldr.w	r7, [sp], #4
240066c6:	4770      	bx	lr
240066c8:	40020010 	.word	0x40020010
240066cc:	40020028 	.word	0x40020028
240066d0:	40020040 	.word	0x40020040
240066d4:	40020058 	.word	0x40020058
240066d8:	40020070 	.word	0x40020070
240066dc:	40020088 	.word	0x40020088
240066e0:	400200a0 	.word	0x400200a0
240066e4:	400200b8 	.word	0x400200b8
240066e8:	40020410 	.word	0x40020410
240066ec:	40020428 	.word	0x40020428
240066f0:	40020440 	.word	0x40020440
240066f4:	40020458 	.word	0x40020458
240066f8:	40020470 	.word	0x40020470
240066fc:	40020488 	.word	0x40020488
24006700:	400204a0 	.word	0x400204a0
24006704:	400204b8 	.word	0x400204b8
24006708:	aaaaaaab 	.word	0xaaaaaaab
2400670c:	24020fa4 	.word	0x24020fa4
24006710:	fffffc00 	.word	0xfffffc00

24006714 <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
24006714:	b480      	push	{r7}
24006716:	b085      	sub	sp, #20
24006718:	af00      	add	r7, sp, #0
2400671a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2400671c:	2300      	movs	r3, #0
2400671e:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
24006720:	687b      	ldr	r3, [r7, #4]
24006722:	699b      	ldr	r3, [r3, #24]
24006724:	2b00      	cmp	r3, #0
24006726:	d120      	bne.n	2400676a <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
24006728:	687b      	ldr	r3, [r7, #4]
2400672a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2400672c:	2b03      	cmp	r3, #3
2400672e:	d858      	bhi.n	240067e2 <DMA_CheckFifoParam+0xce>
24006730:	a201      	add	r2, pc, #4	; (adr r2, 24006738 <DMA_CheckFifoParam+0x24>)
24006732:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24006736:	bf00      	nop
24006738:	24006749 	.word	0x24006749
2400673c:	2400675b 	.word	0x2400675b
24006740:	24006749 	.word	0x24006749
24006744:	240067e3 	.word	0x240067e3
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
24006748:	687b      	ldr	r3, [r7, #4]
2400674a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400674c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24006750:	2b00      	cmp	r3, #0
24006752:	d048      	beq.n	240067e6 <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
24006754:	2301      	movs	r3, #1
24006756:	73fb      	strb	r3, [r7, #15]
        }
        break;
24006758:	e045      	b.n	240067e6 <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
2400675a:	687b      	ldr	r3, [r7, #4]
2400675c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400675e:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
24006762:	d142      	bne.n	240067ea <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
24006764:	2301      	movs	r3, #1
24006766:	73fb      	strb	r3, [r7, #15]
        }
        break;
24006768:	e03f      	b.n	240067ea <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
2400676a:	687b      	ldr	r3, [r7, #4]
2400676c:	699b      	ldr	r3, [r3, #24]
2400676e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24006772:	d123      	bne.n	240067bc <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
24006774:	687b      	ldr	r3, [r7, #4]
24006776:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24006778:	2b03      	cmp	r3, #3
2400677a:	d838      	bhi.n	240067ee <DMA_CheckFifoParam+0xda>
2400677c:	a201      	add	r2, pc, #4	; (adr r2, 24006784 <DMA_CheckFifoParam+0x70>)
2400677e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24006782:	bf00      	nop
24006784:	24006795 	.word	0x24006795
24006788:	2400679b 	.word	0x2400679b
2400678c:	24006795 	.word	0x24006795
24006790:	240067ad 	.word	0x240067ad
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
24006794:	2301      	movs	r3, #1
24006796:	73fb      	strb	r3, [r7, #15]
        break;
24006798:	e030      	b.n	240067fc <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
2400679a:	687b      	ldr	r3, [r7, #4]
2400679c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400679e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
240067a2:	2b00      	cmp	r3, #0
240067a4:	d025      	beq.n	240067f2 <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
240067a6:	2301      	movs	r3, #1
240067a8:	73fb      	strb	r3, [r7, #15]
        }
        break;
240067aa:	e022      	b.n	240067f2 <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
240067ac:	687b      	ldr	r3, [r7, #4]
240067ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240067b0:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
240067b4:	d11f      	bne.n	240067f6 <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
240067b6:	2301      	movs	r3, #1
240067b8:	73fb      	strb	r3, [r7, #15]
        }
        break;
240067ba:	e01c      	b.n	240067f6 <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
240067bc:	687b      	ldr	r3, [r7, #4]
240067be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240067c0:	2b02      	cmp	r3, #2
240067c2:	d902      	bls.n	240067ca <DMA_CheckFifoParam+0xb6>
240067c4:	2b03      	cmp	r3, #3
240067c6:	d003      	beq.n	240067d0 <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
240067c8:	e018      	b.n	240067fc <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
240067ca:	2301      	movs	r3, #1
240067cc:	73fb      	strb	r3, [r7, #15]
        break;
240067ce:	e015      	b.n	240067fc <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
240067d0:	687b      	ldr	r3, [r7, #4]
240067d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240067d4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
240067d8:	2b00      	cmp	r3, #0
240067da:	d00e      	beq.n	240067fa <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
240067dc:	2301      	movs	r3, #1
240067de:	73fb      	strb	r3, [r7, #15]
    break;
240067e0:	e00b      	b.n	240067fa <DMA_CheckFifoParam+0xe6>
        break;
240067e2:	bf00      	nop
240067e4:	e00a      	b.n	240067fc <DMA_CheckFifoParam+0xe8>
        break;
240067e6:	bf00      	nop
240067e8:	e008      	b.n	240067fc <DMA_CheckFifoParam+0xe8>
        break;
240067ea:	bf00      	nop
240067ec:	e006      	b.n	240067fc <DMA_CheckFifoParam+0xe8>
        break;
240067ee:	bf00      	nop
240067f0:	e004      	b.n	240067fc <DMA_CheckFifoParam+0xe8>
        break;
240067f2:	bf00      	nop
240067f4:	e002      	b.n	240067fc <DMA_CheckFifoParam+0xe8>
        break;
240067f6:	bf00      	nop
240067f8:	e000      	b.n	240067fc <DMA_CheckFifoParam+0xe8>
    break;
240067fa:	bf00      	nop
    }
  }

  return status;
240067fc:	7bfb      	ldrb	r3, [r7, #15]
}
240067fe:	4618      	mov	r0, r3
24006800:	3714      	adds	r7, #20
24006802:	46bd      	mov	sp, r7
24006804:	f85d 7b04 	ldr.w	r7, [sp], #4
24006808:	4770      	bx	lr
2400680a:	bf00      	nop

2400680c <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
2400680c:	b480      	push	{r7}
2400680e:	b085      	sub	sp, #20
24006810:	af00      	add	r7, sp, #0
24006812:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
24006814:	687b      	ldr	r3, [r7, #4]
24006816:	681b      	ldr	r3, [r3, #0]
24006818:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
2400681a:	687b      	ldr	r3, [r7, #4]
2400681c:	681b      	ldr	r3, [r3, #0]
2400681e:	4a38      	ldr	r2, [pc, #224]	; (24006900 <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
24006820:	4293      	cmp	r3, r2
24006822:	d022      	beq.n	2400686a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006824:	687b      	ldr	r3, [r7, #4]
24006826:	681b      	ldr	r3, [r3, #0]
24006828:	4a36      	ldr	r2, [pc, #216]	; (24006904 <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
2400682a:	4293      	cmp	r3, r2
2400682c:	d01d      	beq.n	2400686a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2400682e:	687b      	ldr	r3, [r7, #4]
24006830:	681b      	ldr	r3, [r3, #0]
24006832:	4a35      	ldr	r2, [pc, #212]	; (24006908 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
24006834:	4293      	cmp	r3, r2
24006836:	d018      	beq.n	2400686a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006838:	687b      	ldr	r3, [r7, #4]
2400683a:	681b      	ldr	r3, [r3, #0]
2400683c:	4a33      	ldr	r2, [pc, #204]	; (2400690c <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
2400683e:	4293      	cmp	r3, r2
24006840:	d013      	beq.n	2400686a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006842:	687b      	ldr	r3, [r7, #4]
24006844:	681b      	ldr	r3, [r3, #0]
24006846:	4a32      	ldr	r2, [pc, #200]	; (24006910 <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
24006848:	4293      	cmp	r3, r2
2400684a:	d00e      	beq.n	2400686a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2400684c:	687b      	ldr	r3, [r7, #4]
2400684e:	681b      	ldr	r3, [r3, #0]
24006850:	4a30      	ldr	r2, [pc, #192]	; (24006914 <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
24006852:	4293      	cmp	r3, r2
24006854:	d009      	beq.n	2400686a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006856:	687b      	ldr	r3, [r7, #4]
24006858:	681b      	ldr	r3, [r3, #0]
2400685a:	4a2f      	ldr	r2, [pc, #188]	; (24006918 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
2400685c:	4293      	cmp	r3, r2
2400685e:	d004      	beq.n	2400686a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006860:	687b      	ldr	r3, [r7, #4]
24006862:	681b      	ldr	r3, [r3, #0]
24006864:	4a2d      	ldr	r2, [pc, #180]	; (2400691c <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
24006866:	4293      	cmp	r3, r2
24006868:	d101      	bne.n	2400686e <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
2400686a:	2301      	movs	r3, #1
2400686c:	e000      	b.n	24006870 <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
2400686e:	2300      	movs	r3, #0
24006870:	2b00      	cmp	r3, #0
24006872:	d01a      	beq.n	240068aa <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
24006874:	687b      	ldr	r3, [r7, #4]
24006876:	681b      	ldr	r3, [r3, #0]
24006878:	b2db      	uxtb	r3, r3
2400687a:	3b08      	subs	r3, #8
2400687c:	4a28      	ldr	r2, [pc, #160]	; (24006920 <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
2400687e:	fba2 2303 	umull	r2, r3, r2, r3
24006882:	091b      	lsrs	r3, r3, #4
24006884:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
24006886:	68fa      	ldr	r2, [r7, #12]
24006888:	4b26      	ldr	r3, [pc, #152]	; (24006924 <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
2400688a:	4413      	add	r3, r2
2400688c:	009b      	lsls	r3, r3, #2
2400688e:	461a      	mov	r2, r3
24006890:	687b      	ldr	r3, [r7, #4]
24006892:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
24006894:	687b      	ldr	r3, [r7, #4]
24006896:	4a24      	ldr	r2, [pc, #144]	; (24006928 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
24006898:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
2400689a:	68fb      	ldr	r3, [r7, #12]
2400689c:	f003 031f 	and.w	r3, r3, #31
240068a0:	2201      	movs	r2, #1
240068a2:	409a      	lsls	r2, r3
240068a4:	687b      	ldr	r3, [r7, #4]
240068a6:	669a      	str	r2, [r3, #104]	; 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
240068a8:	e024      	b.n	240068f4 <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
240068aa:	687b      	ldr	r3, [r7, #4]
240068ac:	681b      	ldr	r3, [r3, #0]
240068ae:	b2db      	uxtb	r3, r3
240068b0:	3b10      	subs	r3, #16
240068b2:	4a1e      	ldr	r2, [pc, #120]	; (2400692c <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
240068b4:	fba2 2303 	umull	r2, r3, r2, r3
240068b8:	091b      	lsrs	r3, r3, #4
240068ba:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
240068bc:	68bb      	ldr	r3, [r7, #8]
240068be:	4a1c      	ldr	r2, [pc, #112]	; (24006930 <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
240068c0:	4293      	cmp	r3, r2
240068c2:	d806      	bhi.n	240068d2 <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
240068c4:	68bb      	ldr	r3, [r7, #8]
240068c6:	4a1b      	ldr	r2, [pc, #108]	; (24006934 <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
240068c8:	4293      	cmp	r3, r2
240068ca:	d902      	bls.n	240068d2 <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
240068cc:	68fb      	ldr	r3, [r7, #12]
240068ce:	3308      	adds	r3, #8
240068d0:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
240068d2:	68fa      	ldr	r2, [r7, #12]
240068d4:	4b18      	ldr	r3, [pc, #96]	; (24006938 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
240068d6:	4413      	add	r3, r2
240068d8:	009b      	lsls	r3, r3, #2
240068da:	461a      	mov	r2, r3
240068dc:	687b      	ldr	r3, [r7, #4]
240068de:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
240068e0:	687b      	ldr	r3, [r7, #4]
240068e2:	4a16      	ldr	r2, [pc, #88]	; (2400693c <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
240068e4:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
240068e6:	68fb      	ldr	r3, [r7, #12]
240068e8:	f003 031f 	and.w	r3, r3, #31
240068ec:	2201      	movs	r2, #1
240068ee:	409a      	lsls	r2, r3
240068f0:	687b      	ldr	r3, [r7, #4]
240068f2:	669a      	str	r2, [r3, #104]	; 0x68
}
240068f4:	bf00      	nop
240068f6:	3714      	adds	r7, #20
240068f8:	46bd      	mov	sp, r7
240068fa:	f85d 7b04 	ldr.w	r7, [sp], #4
240068fe:	4770      	bx	lr
24006900:	58025408 	.word	0x58025408
24006904:	5802541c 	.word	0x5802541c
24006908:	58025430 	.word	0x58025430
2400690c:	58025444 	.word	0x58025444
24006910:	58025458 	.word	0x58025458
24006914:	5802546c 	.word	0x5802546c
24006918:	58025480 	.word	0x58025480
2400691c:	58025494 	.word	0x58025494
24006920:	cccccccd 	.word	0xcccccccd
24006924:	16009600 	.word	0x16009600
24006928:	58025880 	.word	0x58025880
2400692c:	aaaaaaab 	.word	0xaaaaaaab
24006930:	400204b8 	.word	0x400204b8
24006934:	4002040f 	.word	0x4002040f
24006938:	10008200 	.word	0x10008200
2400693c:	40020880 	.word	0x40020880

24006940 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
24006940:	b480      	push	{r7}
24006942:	b085      	sub	sp, #20
24006944:	af00      	add	r7, sp, #0
24006946:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
24006948:	687b      	ldr	r3, [r7, #4]
2400694a:	685b      	ldr	r3, [r3, #4]
2400694c:	b2db      	uxtb	r3, r3
2400694e:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
24006950:	68fb      	ldr	r3, [r7, #12]
24006952:	2b00      	cmp	r3, #0
24006954:	d04a      	beq.n	240069ec <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
24006956:	68fb      	ldr	r3, [r7, #12]
24006958:	2b08      	cmp	r3, #8
2400695a:	d847      	bhi.n	240069ec <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
2400695c:	687b      	ldr	r3, [r7, #4]
2400695e:	681b      	ldr	r3, [r3, #0]
24006960:	4a25      	ldr	r2, [pc, #148]	; (240069f8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
24006962:	4293      	cmp	r3, r2
24006964:	d022      	beq.n	240069ac <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006966:	687b      	ldr	r3, [r7, #4]
24006968:	681b      	ldr	r3, [r3, #0]
2400696a:	4a24      	ldr	r2, [pc, #144]	; (240069fc <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
2400696c:	4293      	cmp	r3, r2
2400696e:	d01d      	beq.n	240069ac <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006970:	687b      	ldr	r3, [r7, #4]
24006972:	681b      	ldr	r3, [r3, #0]
24006974:	4a22      	ldr	r2, [pc, #136]	; (24006a00 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
24006976:	4293      	cmp	r3, r2
24006978:	d018      	beq.n	240069ac <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2400697a:	687b      	ldr	r3, [r7, #4]
2400697c:	681b      	ldr	r3, [r3, #0]
2400697e:	4a21      	ldr	r2, [pc, #132]	; (24006a04 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
24006980:	4293      	cmp	r3, r2
24006982:	d013      	beq.n	240069ac <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006984:	687b      	ldr	r3, [r7, #4]
24006986:	681b      	ldr	r3, [r3, #0]
24006988:	4a1f      	ldr	r2, [pc, #124]	; (24006a08 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
2400698a:	4293      	cmp	r3, r2
2400698c:	d00e      	beq.n	240069ac <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2400698e:	687b      	ldr	r3, [r7, #4]
24006990:	681b      	ldr	r3, [r3, #0]
24006992:	4a1e      	ldr	r2, [pc, #120]	; (24006a0c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
24006994:	4293      	cmp	r3, r2
24006996:	d009      	beq.n	240069ac <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006998:	687b      	ldr	r3, [r7, #4]
2400699a:	681b      	ldr	r3, [r3, #0]
2400699c:	4a1c      	ldr	r2, [pc, #112]	; (24006a10 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
2400699e:	4293      	cmp	r3, r2
240069a0:	d004      	beq.n	240069ac <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
240069a2:	687b      	ldr	r3, [r7, #4]
240069a4:	681b      	ldr	r3, [r3, #0]
240069a6:	4a1b      	ldr	r2, [pc, #108]	; (24006a14 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
240069a8:	4293      	cmp	r3, r2
240069aa:	d101      	bne.n	240069b0 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
240069ac:	2301      	movs	r3, #1
240069ae:	e000      	b.n	240069b2 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
240069b0:	2300      	movs	r3, #0
240069b2:	2b00      	cmp	r3, #0
240069b4:	d00a      	beq.n	240069cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
240069b6:	68fa      	ldr	r2, [r7, #12]
240069b8:	4b17      	ldr	r3, [pc, #92]	; (24006a18 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
240069ba:	4413      	add	r3, r2
240069bc:	009b      	lsls	r3, r3, #2
240069be:	461a      	mov	r2, r3
240069c0:	687b      	ldr	r3, [r7, #4]
240069c2:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
240069c4:	687b      	ldr	r3, [r7, #4]
240069c6:	4a15      	ldr	r2, [pc, #84]	; (24006a1c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
240069c8:	671a      	str	r2, [r3, #112]	; 0x70
240069ca:	e009      	b.n	240069e0 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
240069cc:	68fa      	ldr	r2, [r7, #12]
240069ce:	4b14      	ldr	r3, [pc, #80]	; (24006a20 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
240069d0:	4413      	add	r3, r2
240069d2:	009b      	lsls	r3, r3, #2
240069d4:	461a      	mov	r2, r3
240069d6:	687b      	ldr	r3, [r7, #4]
240069d8:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
240069da:	687b      	ldr	r3, [r7, #4]
240069dc:	4a11      	ldr	r2, [pc, #68]	; (24006a24 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
240069de:	671a      	str	r2, [r3, #112]	; 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
240069e0:	68fb      	ldr	r3, [r7, #12]
240069e2:	3b01      	subs	r3, #1
240069e4:	2201      	movs	r2, #1
240069e6:	409a      	lsls	r2, r3
240069e8:	687b      	ldr	r3, [r7, #4]
240069ea:	675a      	str	r2, [r3, #116]	; 0x74
  }
}
240069ec:	bf00      	nop
240069ee:	3714      	adds	r7, #20
240069f0:	46bd      	mov	sp, r7
240069f2:	f85d 7b04 	ldr.w	r7, [sp], #4
240069f6:	4770      	bx	lr
240069f8:	58025408 	.word	0x58025408
240069fc:	5802541c 	.word	0x5802541c
24006a00:	58025430 	.word	0x58025430
24006a04:	58025444 	.word	0x58025444
24006a08:	58025458 	.word	0x58025458
24006a0c:	5802546c 	.word	0x5802546c
24006a10:	58025480 	.word	0x58025480
24006a14:	58025494 	.word	0x58025494
24006a18:	1600963f 	.word	0x1600963f
24006a1c:	58025940 	.word	0x58025940
24006a20:	1000823f 	.word	0x1000823f
24006a24:	40020940 	.word	0x40020940

24006a28 <HAL_DMAEx_MultiBufferStart>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
24006a28:	b580      	push	{r7, lr}
24006a2a:	b086      	sub	sp, #24
24006a2c:	af00      	add	r7, sp, #0
24006a2e:	60f8      	str	r0, [r7, #12]
24006a30:	60b9      	str	r1, [r7, #8]
24006a32:	607a      	str	r2, [r7, #4]
24006a34:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24006a36:	2300      	movs	r3, #0
24006a38:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24006a3a:	68fb      	ldr	r3, [r7, #12]
24006a3c:	689b      	ldr	r3, [r3, #8]
24006a3e:	2b80      	cmp	r3, #128	; 0x80
24006a40:	d106      	bne.n	24006a50 <HAL_DMAEx_MultiBufferStart+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24006a42:	68fb      	ldr	r3, [r7, #12]
24006a44:	f44f 7280 	mov.w	r2, #256	; 0x100
24006a48:	655a      	str	r2, [r3, #84]	; 0x54
    status = HAL_ERROR;
24006a4a:	2301      	movs	r3, #1
24006a4c:	75fb      	strb	r3, [r7, #23]
24006a4e:	e1c8      	b.n	24006de2 <HAL_DMAEx_MultiBufferStart+0x3ba>
  }
  else
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
24006a50:	68fb      	ldr	r3, [r7, #12]
24006a52:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24006a56:	2b01      	cmp	r3, #1
24006a58:	d101      	bne.n	24006a5e <HAL_DMAEx_MultiBufferStart+0x36>
24006a5a:	2302      	movs	r3, #2
24006a5c:	e1c2      	b.n	24006de4 <HAL_DMAEx_MultiBufferStart+0x3bc>
24006a5e:	68fb      	ldr	r3, [r7, #12]
24006a60:	2201      	movs	r2, #1
24006a62:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    if(HAL_DMA_STATE_READY == hdma->State)
24006a66:	68fb      	ldr	r3, [r7, #12]
24006a68:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24006a6c:	b2db      	uxtb	r3, r3
24006a6e:	2b01      	cmp	r3, #1
24006a70:	f040 81b1 	bne.w	24006dd6 <HAL_DMAEx_MultiBufferStart+0x3ae>
    {
      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_BUSY;
24006a74:	68fb      	ldr	r3, [r7, #12]
24006a76:	2202      	movs	r2, #2
24006a78:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Initialize the error code */
      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24006a7c:	68fb      	ldr	r3, [r7, #12]
24006a7e:	2200      	movs	r2, #0
24006a80:	655a      	str	r2, [r3, #84]	; 0x54

      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24006a82:	68fb      	ldr	r3, [r7, #12]
24006a84:	681b      	ldr	r3, [r3, #0]
24006a86:	4a7f      	ldr	r2, [pc, #508]	; (24006c84 <HAL_DMAEx_MultiBufferStart+0x25c>)
24006a88:	4293      	cmp	r3, r2
24006a8a:	d04a      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006a8c:	68fb      	ldr	r3, [r7, #12]
24006a8e:	681b      	ldr	r3, [r3, #0]
24006a90:	4a7d      	ldr	r2, [pc, #500]	; (24006c88 <HAL_DMAEx_MultiBufferStart+0x260>)
24006a92:	4293      	cmp	r3, r2
24006a94:	d045      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006a96:	68fb      	ldr	r3, [r7, #12]
24006a98:	681b      	ldr	r3, [r3, #0]
24006a9a:	4a7c      	ldr	r2, [pc, #496]	; (24006c8c <HAL_DMAEx_MultiBufferStart+0x264>)
24006a9c:	4293      	cmp	r3, r2
24006a9e:	d040      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006aa0:	68fb      	ldr	r3, [r7, #12]
24006aa2:	681b      	ldr	r3, [r3, #0]
24006aa4:	4a7a      	ldr	r2, [pc, #488]	; (24006c90 <HAL_DMAEx_MultiBufferStart+0x268>)
24006aa6:	4293      	cmp	r3, r2
24006aa8:	d03b      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006aaa:	68fb      	ldr	r3, [r7, #12]
24006aac:	681b      	ldr	r3, [r3, #0]
24006aae:	4a79      	ldr	r2, [pc, #484]	; (24006c94 <HAL_DMAEx_MultiBufferStart+0x26c>)
24006ab0:	4293      	cmp	r3, r2
24006ab2:	d036      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006ab4:	68fb      	ldr	r3, [r7, #12]
24006ab6:	681b      	ldr	r3, [r3, #0]
24006ab8:	4a77      	ldr	r2, [pc, #476]	; (24006c98 <HAL_DMAEx_MultiBufferStart+0x270>)
24006aba:	4293      	cmp	r3, r2
24006abc:	d031      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006abe:	68fb      	ldr	r3, [r7, #12]
24006ac0:	681b      	ldr	r3, [r3, #0]
24006ac2:	4a76      	ldr	r2, [pc, #472]	; (24006c9c <HAL_DMAEx_MultiBufferStart+0x274>)
24006ac4:	4293      	cmp	r3, r2
24006ac6:	d02c      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006ac8:	68fb      	ldr	r3, [r7, #12]
24006aca:	681b      	ldr	r3, [r3, #0]
24006acc:	4a74      	ldr	r2, [pc, #464]	; (24006ca0 <HAL_DMAEx_MultiBufferStart+0x278>)
24006ace:	4293      	cmp	r3, r2
24006ad0:	d027      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006ad2:	68fb      	ldr	r3, [r7, #12]
24006ad4:	681b      	ldr	r3, [r3, #0]
24006ad6:	4a73      	ldr	r2, [pc, #460]	; (24006ca4 <HAL_DMAEx_MultiBufferStart+0x27c>)
24006ad8:	4293      	cmp	r3, r2
24006ada:	d022      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006adc:	68fb      	ldr	r3, [r7, #12]
24006ade:	681b      	ldr	r3, [r3, #0]
24006ae0:	4a71      	ldr	r2, [pc, #452]	; (24006ca8 <HAL_DMAEx_MultiBufferStart+0x280>)
24006ae2:	4293      	cmp	r3, r2
24006ae4:	d01d      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006ae6:	68fb      	ldr	r3, [r7, #12]
24006ae8:	681b      	ldr	r3, [r3, #0]
24006aea:	4a70      	ldr	r2, [pc, #448]	; (24006cac <HAL_DMAEx_MultiBufferStart+0x284>)
24006aec:	4293      	cmp	r3, r2
24006aee:	d018      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006af0:	68fb      	ldr	r3, [r7, #12]
24006af2:	681b      	ldr	r3, [r3, #0]
24006af4:	4a6e      	ldr	r2, [pc, #440]	; (24006cb0 <HAL_DMAEx_MultiBufferStart+0x288>)
24006af6:	4293      	cmp	r3, r2
24006af8:	d013      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006afa:	68fb      	ldr	r3, [r7, #12]
24006afc:	681b      	ldr	r3, [r3, #0]
24006afe:	4a6d      	ldr	r2, [pc, #436]	; (24006cb4 <HAL_DMAEx_MultiBufferStart+0x28c>)
24006b00:	4293      	cmp	r3, r2
24006b02:	d00e      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006b04:	68fb      	ldr	r3, [r7, #12]
24006b06:	681b      	ldr	r3, [r3, #0]
24006b08:	4a6b      	ldr	r2, [pc, #428]	; (24006cb8 <HAL_DMAEx_MultiBufferStart+0x290>)
24006b0a:	4293      	cmp	r3, r2
24006b0c:	d009      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006b0e:	68fb      	ldr	r3, [r7, #12]
24006b10:	681b      	ldr	r3, [r3, #0]
24006b12:	4a6a      	ldr	r2, [pc, #424]	; (24006cbc <HAL_DMAEx_MultiBufferStart+0x294>)
24006b14:	4293      	cmp	r3, r2
24006b16:	d004      	beq.n	24006b22 <HAL_DMAEx_MultiBufferStart+0xfa>
24006b18:	68fb      	ldr	r3, [r7, #12]
24006b1a:	681b      	ldr	r3, [r3, #0]
24006b1c:	4a68      	ldr	r2, [pc, #416]	; (24006cc0 <HAL_DMAEx_MultiBufferStart+0x298>)
24006b1e:	4293      	cmp	r3, r2
24006b20:	d101      	bne.n	24006b26 <HAL_DMAEx_MultiBufferStart+0xfe>
24006b22:	2301      	movs	r3, #1
24006b24:	e000      	b.n	24006b28 <HAL_DMAEx_MultiBufferStart+0x100>
24006b26:	2300      	movs	r3, #0
24006b28:	2b00      	cmp	r3, #0
24006b2a:	d018      	beq.n	24006b5e <HAL_DMAEx_MultiBufferStart+0x136>
      {
        /* Enable the Double buffer mode */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24006b2c:	68fb      	ldr	r3, [r7, #12]
24006b2e:	681b      	ldr	r3, [r3, #0]
24006b30:	681a      	ldr	r2, [r3, #0]
24006b32:	68fb      	ldr	r3, [r7, #12]
24006b34:	681b      	ldr	r3, [r3, #0]
24006b36:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24006b3a:	601a      	str	r2, [r3, #0]

        /* Configure DMA Stream destination address */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24006b3c:	68fb      	ldr	r3, [r7, #12]
24006b3e:	681b      	ldr	r3, [r3, #0]
24006b40:	683a      	ldr	r2, [r7, #0]
24006b42:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
24006b44:	68fb      	ldr	r3, [r7, #12]
24006b46:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006b48:	3308      	adds	r3, #8
24006b4a:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24006b4c:	68fb      	ldr	r3, [r7, #12]
24006b4e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006b50:	f003 031f 	and.w	r3, r3, #31
24006b54:	223f      	movs	r2, #63	; 0x3f
24006b56:	409a      	lsls	r2, r3
24006b58:	693b      	ldr	r3, [r7, #16]
24006b5a:	601a      	str	r2, [r3, #0]
24006b5c:	e018      	b.n	24006b90 <HAL_DMAEx_MultiBufferStart+0x168>
      }
      else /* BDMA instance(s) */
      {
        /* Enable the Double buffer mode */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
24006b5e:	68fb      	ldr	r3, [r7, #12]
24006b60:	681b      	ldr	r3, [r3, #0]
24006b62:	6819      	ldr	r1, [r3, #0]
24006b64:	68fb      	ldr	r3, [r7, #12]
24006b66:	681a      	ldr	r2, [r3, #0]
24006b68:	f248 0320 	movw	r3, #32800	; 0x8020
24006b6c:	430b      	orrs	r3, r1
24006b6e:	6013      	str	r3, [r2, #0]

        /* Configure DMA Stream destination address */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
24006b70:	68fb      	ldr	r3, [r7, #12]
24006b72:	681b      	ldr	r3, [r3, #0]
24006b74:	683a      	ldr	r2, [r7, #0]
24006b76:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
24006b78:	68fb      	ldr	r3, [r7, #12]
24006b7a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006b7c:	3304      	adds	r3, #4
24006b7e:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24006b80:	68fb      	ldr	r3, [r7, #12]
24006b82:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006b84:	f003 031f 	and.w	r3, r3, #31
24006b88:	2201      	movs	r2, #1
24006b8a:	409a      	lsls	r2, r3
24006b8c:	693b      	ldr	r3, [r7, #16]
24006b8e:	601a      	str	r2, [r3, #0]
      }

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24006b90:	68fb      	ldr	r3, [r7, #12]
24006b92:	681b      	ldr	r3, [r3, #0]
24006b94:	4a3b      	ldr	r2, [pc, #236]	; (24006c84 <HAL_DMAEx_MultiBufferStart+0x25c>)
24006b96:	4293      	cmp	r3, r2
24006b98:	d072      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006b9a:	68fb      	ldr	r3, [r7, #12]
24006b9c:	681b      	ldr	r3, [r3, #0]
24006b9e:	4a3a      	ldr	r2, [pc, #232]	; (24006c88 <HAL_DMAEx_MultiBufferStart+0x260>)
24006ba0:	4293      	cmp	r3, r2
24006ba2:	d06d      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006ba4:	68fb      	ldr	r3, [r7, #12]
24006ba6:	681b      	ldr	r3, [r3, #0]
24006ba8:	4a38      	ldr	r2, [pc, #224]	; (24006c8c <HAL_DMAEx_MultiBufferStart+0x264>)
24006baa:	4293      	cmp	r3, r2
24006bac:	d068      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006bae:	68fb      	ldr	r3, [r7, #12]
24006bb0:	681b      	ldr	r3, [r3, #0]
24006bb2:	4a37      	ldr	r2, [pc, #220]	; (24006c90 <HAL_DMAEx_MultiBufferStart+0x268>)
24006bb4:	4293      	cmp	r3, r2
24006bb6:	d063      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006bb8:	68fb      	ldr	r3, [r7, #12]
24006bba:	681b      	ldr	r3, [r3, #0]
24006bbc:	4a35      	ldr	r2, [pc, #212]	; (24006c94 <HAL_DMAEx_MultiBufferStart+0x26c>)
24006bbe:	4293      	cmp	r3, r2
24006bc0:	d05e      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006bc2:	68fb      	ldr	r3, [r7, #12]
24006bc4:	681b      	ldr	r3, [r3, #0]
24006bc6:	4a34      	ldr	r2, [pc, #208]	; (24006c98 <HAL_DMAEx_MultiBufferStart+0x270>)
24006bc8:	4293      	cmp	r3, r2
24006bca:	d059      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006bcc:	68fb      	ldr	r3, [r7, #12]
24006bce:	681b      	ldr	r3, [r3, #0]
24006bd0:	4a32      	ldr	r2, [pc, #200]	; (24006c9c <HAL_DMAEx_MultiBufferStart+0x274>)
24006bd2:	4293      	cmp	r3, r2
24006bd4:	d054      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006bd6:	68fb      	ldr	r3, [r7, #12]
24006bd8:	681b      	ldr	r3, [r3, #0]
24006bda:	4a31      	ldr	r2, [pc, #196]	; (24006ca0 <HAL_DMAEx_MultiBufferStart+0x278>)
24006bdc:	4293      	cmp	r3, r2
24006bde:	d04f      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006be0:	68fb      	ldr	r3, [r7, #12]
24006be2:	681b      	ldr	r3, [r3, #0]
24006be4:	4a2f      	ldr	r2, [pc, #188]	; (24006ca4 <HAL_DMAEx_MultiBufferStart+0x27c>)
24006be6:	4293      	cmp	r3, r2
24006be8:	d04a      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006bea:	68fb      	ldr	r3, [r7, #12]
24006bec:	681b      	ldr	r3, [r3, #0]
24006bee:	4a2e      	ldr	r2, [pc, #184]	; (24006ca8 <HAL_DMAEx_MultiBufferStart+0x280>)
24006bf0:	4293      	cmp	r3, r2
24006bf2:	d045      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006bf4:	68fb      	ldr	r3, [r7, #12]
24006bf6:	681b      	ldr	r3, [r3, #0]
24006bf8:	4a2c      	ldr	r2, [pc, #176]	; (24006cac <HAL_DMAEx_MultiBufferStart+0x284>)
24006bfa:	4293      	cmp	r3, r2
24006bfc:	d040      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006bfe:	68fb      	ldr	r3, [r7, #12]
24006c00:	681b      	ldr	r3, [r3, #0]
24006c02:	4a2b      	ldr	r2, [pc, #172]	; (24006cb0 <HAL_DMAEx_MultiBufferStart+0x288>)
24006c04:	4293      	cmp	r3, r2
24006c06:	d03b      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c08:	68fb      	ldr	r3, [r7, #12]
24006c0a:	681b      	ldr	r3, [r3, #0]
24006c0c:	4a29      	ldr	r2, [pc, #164]	; (24006cb4 <HAL_DMAEx_MultiBufferStart+0x28c>)
24006c0e:	4293      	cmp	r3, r2
24006c10:	d036      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c12:	68fb      	ldr	r3, [r7, #12]
24006c14:	681b      	ldr	r3, [r3, #0]
24006c16:	4a28      	ldr	r2, [pc, #160]	; (24006cb8 <HAL_DMAEx_MultiBufferStart+0x290>)
24006c18:	4293      	cmp	r3, r2
24006c1a:	d031      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c1c:	68fb      	ldr	r3, [r7, #12]
24006c1e:	681b      	ldr	r3, [r3, #0]
24006c20:	4a26      	ldr	r2, [pc, #152]	; (24006cbc <HAL_DMAEx_MultiBufferStart+0x294>)
24006c22:	4293      	cmp	r3, r2
24006c24:	d02c      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c26:	68fb      	ldr	r3, [r7, #12]
24006c28:	681b      	ldr	r3, [r3, #0]
24006c2a:	4a25      	ldr	r2, [pc, #148]	; (24006cc0 <HAL_DMAEx_MultiBufferStart+0x298>)
24006c2c:	4293      	cmp	r3, r2
24006c2e:	d027      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c30:	68fb      	ldr	r3, [r7, #12]
24006c32:	681b      	ldr	r3, [r3, #0]
24006c34:	4a23      	ldr	r2, [pc, #140]	; (24006cc4 <HAL_DMAEx_MultiBufferStart+0x29c>)
24006c36:	4293      	cmp	r3, r2
24006c38:	d022      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c3a:	68fb      	ldr	r3, [r7, #12]
24006c3c:	681b      	ldr	r3, [r3, #0]
24006c3e:	4a22      	ldr	r2, [pc, #136]	; (24006cc8 <HAL_DMAEx_MultiBufferStart+0x2a0>)
24006c40:	4293      	cmp	r3, r2
24006c42:	d01d      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c44:	68fb      	ldr	r3, [r7, #12]
24006c46:	681b      	ldr	r3, [r3, #0]
24006c48:	4a20      	ldr	r2, [pc, #128]	; (24006ccc <HAL_DMAEx_MultiBufferStart+0x2a4>)
24006c4a:	4293      	cmp	r3, r2
24006c4c:	d018      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c4e:	68fb      	ldr	r3, [r7, #12]
24006c50:	681b      	ldr	r3, [r3, #0]
24006c52:	4a1f      	ldr	r2, [pc, #124]	; (24006cd0 <HAL_DMAEx_MultiBufferStart+0x2a8>)
24006c54:	4293      	cmp	r3, r2
24006c56:	d013      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c58:	68fb      	ldr	r3, [r7, #12]
24006c5a:	681b      	ldr	r3, [r3, #0]
24006c5c:	4a1d      	ldr	r2, [pc, #116]	; (24006cd4 <HAL_DMAEx_MultiBufferStart+0x2ac>)
24006c5e:	4293      	cmp	r3, r2
24006c60:	d00e      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c62:	68fb      	ldr	r3, [r7, #12]
24006c64:	681b      	ldr	r3, [r3, #0]
24006c66:	4a1c      	ldr	r2, [pc, #112]	; (24006cd8 <HAL_DMAEx_MultiBufferStart+0x2b0>)
24006c68:	4293      	cmp	r3, r2
24006c6a:	d009      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c6c:	68fb      	ldr	r3, [r7, #12]
24006c6e:	681b      	ldr	r3, [r3, #0]
24006c70:	4a1a      	ldr	r2, [pc, #104]	; (24006cdc <HAL_DMAEx_MultiBufferStart+0x2b4>)
24006c72:	4293      	cmp	r3, r2
24006c74:	d004      	beq.n	24006c80 <HAL_DMAEx_MultiBufferStart+0x258>
24006c76:	68fb      	ldr	r3, [r7, #12]
24006c78:	681b      	ldr	r3, [r3, #0]
24006c7a:	4a19      	ldr	r2, [pc, #100]	; (24006ce0 <HAL_DMAEx_MultiBufferStart+0x2b8>)
24006c7c:	4293      	cmp	r3, r2
24006c7e:	d131      	bne.n	24006ce4 <HAL_DMAEx_MultiBufferStart+0x2bc>
24006c80:	2301      	movs	r3, #1
24006c82:	e030      	b.n	24006ce6 <HAL_DMAEx_MultiBufferStart+0x2be>
24006c84:	40020010 	.word	0x40020010
24006c88:	40020028 	.word	0x40020028
24006c8c:	40020040 	.word	0x40020040
24006c90:	40020058 	.word	0x40020058
24006c94:	40020070 	.word	0x40020070
24006c98:	40020088 	.word	0x40020088
24006c9c:	400200a0 	.word	0x400200a0
24006ca0:	400200b8 	.word	0x400200b8
24006ca4:	40020410 	.word	0x40020410
24006ca8:	40020428 	.word	0x40020428
24006cac:	40020440 	.word	0x40020440
24006cb0:	40020458 	.word	0x40020458
24006cb4:	40020470 	.word	0x40020470
24006cb8:	40020488 	.word	0x40020488
24006cbc:	400204a0 	.word	0x400204a0
24006cc0:	400204b8 	.word	0x400204b8
24006cc4:	58025408 	.word	0x58025408
24006cc8:	5802541c 	.word	0x5802541c
24006ccc:	58025430 	.word	0x58025430
24006cd0:	58025444 	.word	0x58025444
24006cd4:	58025458 	.word	0x58025458
24006cd8:	5802546c 	.word	0x5802546c
24006cdc:	58025480 	.word	0x58025480
24006ce0:	58025494 	.word	0x58025494
24006ce4:	2300      	movs	r3, #0
24006ce6:	2b00      	cmp	r3, #0
24006ce8:	d013      	beq.n	24006d12 <HAL_DMAEx_MultiBufferStart+0x2ea>
      {
        /* Configure the source, destination address and the data length */
        DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
24006cea:	6a3b      	ldr	r3, [r7, #32]
24006cec:	687a      	ldr	r2, [r7, #4]
24006cee:	68b9      	ldr	r1, [r7, #8]
24006cf0:	68f8      	ldr	r0, [r7, #12]
24006cf2:	f000 fea5 	bl	24007a40 <DMA_MultiBufferSetConfig>

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24006cf6:	68fb      	ldr	r3, [r7, #12]
24006cf8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24006cfa:	68fa      	ldr	r2, [r7, #12]
24006cfc:	6e92      	ldr	r2, [r2, #104]	; 0x68
24006cfe:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
24006d00:	68fb      	ldr	r3, [r7, #12]
24006d02:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006d04:	2b00      	cmp	r3, #0
24006d06:	d004      	beq.n	24006d12 <HAL_DMAEx_MultiBufferStart+0x2ea>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24006d08:	68fb      	ldr	r3, [r7, #12]
24006d0a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24006d0c:	68fa      	ldr	r2, [r7, #12]
24006d0e:	6f52      	ldr	r2, [r2, #116]	; 0x74
24006d10:	605a      	str	r2, [r3, #4]
        }
      }

      /* Enable the peripheral */
      __HAL_DMA_ENABLE(hdma);
24006d12:	68fb      	ldr	r3, [r7, #12]
24006d14:	681b      	ldr	r3, [r3, #0]
24006d16:	4a35      	ldr	r2, [pc, #212]	; (24006dec <HAL_DMAEx_MultiBufferStart+0x3c4>)
24006d18:	4293      	cmp	r3, r2
24006d1a:	d04a      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d1c:	68fb      	ldr	r3, [r7, #12]
24006d1e:	681b      	ldr	r3, [r3, #0]
24006d20:	4a33      	ldr	r2, [pc, #204]	; (24006df0 <HAL_DMAEx_MultiBufferStart+0x3c8>)
24006d22:	4293      	cmp	r3, r2
24006d24:	d045      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d26:	68fb      	ldr	r3, [r7, #12]
24006d28:	681b      	ldr	r3, [r3, #0]
24006d2a:	4a32      	ldr	r2, [pc, #200]	; (24006df4 <HAL_DMAEx_MultiBufferStart+0x3cc>)
24006d2c:	4293      	cmp	r3, r2
24006d2e:	d040      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d30:	68fb      	ldr	r3, [r7, #12]
24006d32:	681b      	ldr	r3, [r3, #0]
24006d34:	4a30      	ldr	r2, [pc, #192]	; (24006df8 <HAL_DMAEx_MultiBufferStart+0x3d0>)
24006d36:	4293      	cmp	r3, r2
24006d38:	d03b      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d3a:	68fb      	ldr	r3, [r7, #12]
24006d3c:	681b      	ldr	r3, [r3, #0]
24006d3e:	4a2f      	ldr	r2, [pc, #188]	; (24006dfc <HAL_DMAEx_MultiBufferStart+0x3d4>)
24006d40:	4293      	cmp	r3, r2
24006d42:	d036      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d44:	68fb      	ldr	r3, [r7, #12]
24006d46:	681b      	ldr	r3, [r3, #0]
24006d48:	4a2d      	ldr	r2, [pc, #180]	; (24006e00 <HAL_DMAEx_MultiBufferStart+0x3d8>)
24006d4a:	4293      	cmp	r3, r2
24006d4c:	d031      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d4e:	68fb      	ldr	r3, [r7, #12]
24006d50:	681b      	ldr	r3, [r3, #0]
24006d52:	4a2c      	ldr	r2, [pc, #176]	; (24006e04 <HAL_DMAEx_MultiBufferStart+0x3dc>)
24006d54:	4293      	cmp	r3, r2
24006d56:	d02c      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d58:	68fb      	ldr	r3, [r7, #12]
24006d5a:	681b      	ldr	r3, [r3, #0]
24006d5c:	4a2a      	ldr	r2, [pc, #168]	; (24006e08 <HAL_DMAEx_MultiBufferStart+0x3e0>)
24006d5e:	4293      	cmp	r3, r2
24006d60:	d027      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d62:	68fb      	ldr	r3, [r7, #12]
24006d64:	681b      	ldr	r3, [r3, #0]
24006d66:	4a29      	ldr	r2, [pc, #164]	; (24006e0c <HAL_DMAEx_MultiBufferStart+0x3e4>)
24006d68:	4293      	cmp	r3, r2
24006d6a:	d022      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d6c:	68fb      	ldr	r3, [r7, #12]
24006d6e:	681b      	ldr	r3, [r3, #0]
24006d70:	4a27      	ldr	r2, [pc, #156]	; (24006e10 <HAL_DMAEx_MultiBufferStart+0x3e8>)
24006d72:	4293      	cmp	r3, r2
24006d74:	d01d      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d76:	68fb      	ldr	r3, [r7, #12]
24006d78:	681b      	ldr	r3, [r3, #0]
24006d7a:	4a26      	ldr	r2, [pc, #152]	; (24006e14 <HAL_DMAEx_MultiBufferStart+0x3ec>)
24006d7c:	4293      	cmp	r3, r2
24006d7e:	d018      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d80:	68fb      	ldr	r3, [r7, #12]
24006d82:	681b      	ldr	r3, [r3, #0]
24006d84:	4a24      	ldr	r2, [pc, #144]	; (24006e18 <HAL_DMAEx_MultiBufferStart+0x3f0>)
24006d86:	4293      	cmp	r3, r2
24006d88:	d013      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d8a:	68fb      	ldr	r3, [r7, #12]
24006d8c:	681b      	ldr	r3, [r3, #0]
24006d8e:	4a23      	ldr	r2, [pc, #140]	; (24006e1c <HAL_DMAEx_MultiBufferStart+0x3f4>)
24006d90:	4293      	cmp	r3, r2
24006d92:	d00e      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d94:	68fb      	ldr	r3, [r7, #12]
24006d96:	681b      	ldr	r3, [r3, #0]
24006d98:	4a21      	ldr	r2, [pc, #132]	; (24006e20 <HAL_DMAEx_MultiBufferStart+0x3f8>)
24006d9a:	4293      	cmp	r3, r2
24006d9c:	d009      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006d9e:	68fb      	ldr	r3, [r7, #12]
24006da0:	681b      	ldr	r3, [r3, #0]
24006da2:	4a20      	ldr	r2, [pc, #128]	; (24006e24 <HAL_DMAEx_MultiBufferStart+0x3fc>)
24006da4:	4293      	cmp	r3, r2
24006da6:	d004      	beq.n	24006db2 <HAL_DMAEx_MultiBufferStart+0x38a>
24006da8:	68fb      	ldr	r3, [r7, #12]
24006daa:	681b      	ldr	r3, [r3, #0]
24006dac:	4a1e      	ldr	r2, [pc, #120]	; (24006e28 <HAL_DMAEx_MultiBufferStart+0x400>)
24006dae:	4293      	cmp	r3, r2
24006db0:	d108      	bne.n	24006dc4 <HAL_DMAEx_MultiBufferStart+0x39c>
24006db2:	68fb      	ldr	r3, [r7, #12]
24006db4:	681b      	ldr	r3, [r3, #0]
24006db6:	681a      	ldr	r2, [r3, #0]
24006db8:	68fb      	ldr	r3, [r7, #12]
24006dba:	681b      	ldr	r3, [r3, #0]
24006dbc:	f042 0201 	orr.w	r2, r2, #1
24006dc0:	601a      	str	r2, [r3, #0]
24006dc2:	e00e      	b.n	24006de2 <HAL_DMAEx_MultiBufferStart+0x3ba>
24006dc4:	68fb      	ldr	r3, [r7, #12]
24006dc6:	681b      	ldr	r3, [r3, #0]
24006dc8:	681a      	ldr	r2, [r3, #0]
24006dca:	68fb      	ldr	r3, [r7, #12]
24006dcc:	681b      	ldr	r3, [r3, #0]
24006dce:	f042 0201 	orr.w	r2, r2, #1
24006dd2:	601a      	str	r2, [r3, #0]
24006dd4:	e005      	b.n	24006de2 <HAL_DMAEx_MultiBufferStart+0x3ba>
    }
    else
    {
      /* Set the error code to busy */
      hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24006dd6:	68fb      	ldr	r3, [r7, #12]
24006dd8:	f44f 6200 	mov.w	r2, #2048	; 0x800
24006ddc:	655a      	str	r2, [r3, #84]	; 0x54

      /* Return error status */
      status = HAL_ERROR;
24006dde:	2301      	movs	r3, #1
24006de0:	75fb      	strb	r3, [r7, #23]
    }
  }
  return status;
24006de2:	7dfb      	ldrb	r3, [r7, #23]
}
24006de4:	4618      	mov	r0, r3
24006de6:	3718      	adds	r7, #24
24006de8:	46bd      	mov	sp, r7
24006dea:	bd80      	pop	{r7, pc}
24006dec:	40020010 	.word	0x40020010
24006df0:	40020028 	.word	0x40020028
24006df4:	40020040 	.word	0x40020040
24006df8:	40020058 	.word	0x40020058
24006dfc:	40020070 	.word	0x40020070
24006e00:	40020088 	.word	0x40020088
24006e04:	400200a0 	.word	0x400200a0
24006e08:	400200b8 	.word	0x400200b8
24006e0c:	40020410 	.word	0x40020410
24006e10:	40020428 	.word	0x40020428
24006e14:	40020440 	.word	0x40020440
24006e18:	40020458 	.word	0x40020458
24006e1c:	40020470 	.word	0x40020470
24006e20:	40020488 	.word	0x40020488
24006e24:	400204a0 	.word	0x400204a0
24006e28:	400204b8 	.word	0x400204b8

24006e2c <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
24006e2c:	b580      	push	{r7, lr}
24006e2e:	b086      	sub	sp, #24
24006e30:	af00      	add	r7, sp, #0
24006e32:	60f8      	str	r0, [r7, #12]
24006e34:	60b9      	str	r1, [r7, #8]
24006e36:	607a      	str	r2, [r7, #4]
24006e38:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24006e3a:	2300      	movs	r3, #0
24006e3c:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Memory-to-memory transfer not supported in double buffering mode */
  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24006e3e:	68fb      	ldr	r3, [r7, #12]
24006e40:	689b      	ldr	r3, [r3, #8]
24006e42:	2b80      	cmp	r3, #128	; 0x80
24006e44:	d105      	bne.n	24006e52 <HAL_DMAEx_MultiBufferStart_IT+0x26>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24006e46:	68fb      	ldr	r3, [r7, #12]
24006e48:	f44f 7280 	mov.w	r2, #256	; 0x100
24006e4c:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
24006e4e:	2301      	movs	r3, #1
24006e50:	e315      	b.n	2400747e <HAL_DMAEx_MultiBufferStart_IT+0x652>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24006e52:	68fb      	ldr	r3, [r7, #12]
24006e54:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24006e58:	2b01      	cmp	r3, #1
24006e5a:	d101      	bne.n	24006e60 <HAL_DMAEx_MultiBufferStart_IT+0x34>
24006e5c:	2302      	movs	r3, #2
24006e5e:	e30e      	b.n	2400747e <HAL_DMAEx_MultiBufferStart_IT+0x652>
24006e60:	68fb      	ldr	r3, [r7, #12]
24006e62:	2201      	movs	r2, #1
24006e64:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24006e68:	68fb      	ldr	r3, [r7, #12]
24006e6a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24006e6e:	b2db      	uxtb	r3, r3
24006e70:	2b01      	cmp	r3, #1
24006e72:	f040 82fd 	bne.w	24007470 <HAL_DMAEx_MultiBufferStart_IT+0x644>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24006e76:	68fb      	ldr	r3, [r7, #12]
24006e78:	2202      	movs	r2, #2
24006e7a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24006e7e:	68fb      	ldr	r3, [r7, #12]
24006e80:	2200      	movs	r2, #0
24006e82:	655a      	str	r2, [r3, #84]	; 0x54

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24006e84:	68fb      	ldr	r3, [r7, #12]
24006e86:	681b      	ldr	r3, [r3, #0]
24006e88:	4a82      	ldr	r2, [pc, #520]	; (24007094 <HAL_DMAEx_MultiBufferStart_IT+0x268>)
24006e8a:	4293      	cmp	r3, r2
24006e8c:	d04a      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006e8e:	68fb      	ldr	r3, [r7, #12]
24006e90:	681b      	ldr	r3, [r3, #0]
24006e92:	4a81      	ldr	r2, [pc, #516]	; (24007098 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
24006e94:	4293      	cmp	r3, r2
24006e96:	d045      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006e98:	68fb      	ldr	r3, [r7, #12]
24006e9a:	681b      	ldr	r3, [r3, #0]
24006e9c:	4a7f      	ldr	r2, [pc, #508]	; (2400709c <HAL_DMAEx_MultiBufferStart_IT+0x270>)
24006e9e:	4293      	cmp	r3, r2
24006ea0:	d040      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006ea2:	68fb      	ldr	r3, [r7, #12]
24006ea4:	681b      	ldr	r3, [r3, #0]
24006ea6:	4a7e      	ldr	r2, [pc, #504]	; (240070a0 <HAL_DMAEx_MultiBufferStart_IT+0x274>)
24006ea8:	4293      	cmp	r3, r2
24006eaa:	d03b      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006eac:	68fb      	ldr	r3, [r7, #12]
24006eae:	681b      	ldr	r3, [r3, #0]
24006eb0:	4a7c      	ldr	r2, [pc, #496]	; (240070a4 <HAL_DMAEx_MultiBufferStart_IT+0x278>)
24006eb2:	4293      	cmp	r3, r2
24006eb4:	d036      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006eb6:	68fb      	ldr	r3, [r7, #12]
24006eb8:	681b      	ldr	r3, [r3, #0]
24006eba:	4a7b      	ldr	r2, [pc, #492]	; (240070a8 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
24006ebc:	4293      	cmp	r3, r2
24006ebe:	d031      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006ec0:	68fb      	ldr	r3, [r7, #12]
24006ec2:	681b      	ldr	r3, [r3, #0]
24006ec4:	4a79      	ldr	r2, [pc, #484]	; (240070ac <HAL_DMAEx_MultiBufferStart_IT+0x280>)
24006ec6:	4293      	cmp	r3, r2
24006ec8:	d02c      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006eca:	68fb      	ldr	r3, [r7, #12]
24006ecc:	681b      	ldr	r3, [r3, #0]
24006ece:	4a78      	ldr	r2, [pc, #480]	; (240070b0 <HAL_DMAEx_MultiBufferStart_IT+0x284>)
24006ed0:	4293      	cmp	r3, r2
24006ed2:	d027      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006ed4:	68fb      	ldr	r3, [r7, #12]
24006ed6:	681b      	ldr	r3, [r3, #0]
24006ed8:	4a76      	ldr	r2, [pc, #472]	; (240070b4 <HAL_DMAEx_MultiBufferStart_IT+0x288>)
24006eda:	4293      	cmp	r3, r2
24006edc:	d022      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006ede:	68fb      	ldr	r3, [r7, #12]
24006ee0:	681b      	ldr	r3, [r3, #0]
24006ee2:	4a75      	ldr	r2, [pc, #468]	; (240070b8 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
24006ee4:	4293      	cmp	r3, r2
24006ee6:	d01d      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006ee8:	68fb      	ldr	r3, [r7, #12]
24006eea:	681b      	ldr	r3, [r3, #0]
24006eec:	4a73      	ldr	r2, [pc, #460]	; (240070bc <HAL_DMAEx_MultiBufferStart_IT+0x290>)
24006eee:	4293      	cmp	r3, r2
24006ef0:	d018      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006ef2:	68fb      	ldr	r3, [r7, #12]
24006ef4:	681b      	ldr	r3, [r3, #0]
24006ef6:	4a72      	ldr	r2, [pc, #456]	; (240070c0 <HAL_DMAEx_MultiBufferStart_IT+0x294>)
24006ef8:	4293      	cmp	r3, r2
24006efa:	d013      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006efc:	68fb      	ldr	r3, [r7, #12]
24006efe:	681b      	ldr	r3, [r3, #0]
24006f00:	4a70      	ldr	r2, [pc, #448]	; (240070c4 <HAL_DMAEx_MultiBufferStart_IT+0x298>)
24006f02:	4293      	cmp	r3, r2
24006f04:	d00e      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006f06:	68fb      	ldr	r3, [r7, #12]
24006f08:	681b      	ldr	r3, [r3, #0]
24006f0a:	4a6f      	ldr	r2, [pc, #444]	; (240070c8 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
24006f0c:	4293      	cmp	r3, r2
24006f0e:	d009      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006f10:	68fb      	ldr	r3, [r7, #12]
24006f12:	681b      	ldr	r3, [r3, #0]
24006f14:	4a6d      	ldr	r2, [pc, #436]	; (240070cc <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
24006f16:	4293      	cmp	r3, r2
24006f18:	d004      	beq.n	24006f24 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24006f1a:	68fb      	ldr	r3, [r7, #12]
24006f1c:	681b      	ldr	r3, [r3, #0]
24006f1e:	4a6c      	ldr	r2, [pc, #432]	; (240070d0 <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
24006f20:	4293      	cmp	r3, r2
24006f22:	d101      	bne.n	24006f28 <HAL_DMAEx_MultiBufferStart_IT+0xfc>
24006f24:	2301      	movs	r3, #1
24006f26:	e000      	b.n	24006f2a <HAL_DMAEx_MultiBufferStart_IT+0xfe>
24006f28:	2300      	movs	r3, #0
24006f2a:	2b00      	cmp	r3, #0
24006f2c:	d018      	beq.n	24006f60 <HAL_DMAEx_MultiBufferStart_IT+0x134>
    {
      /* Enable the Double buffer mode */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24006f2e:	68fb      	ldr	r3, [r7, #12]
24006f30:	681b      	ldr	r3, [r3, #0]
24006f32:	681a      	ldr	r2, [r3, #0]
24006f34:	68fb      	ldr	r3, [r7, #12]
24006f36:	681b      	ldr	r3, [r3, #0]
24006f38:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24006f3c:	601a      	str	r2, [r3, #0]

      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24006f3e:	68fb      	ldr	r3, [r7, #12]
24006f40:	681b      	ldr	r3, [r3, #0]
24006f42:	683a      	ldr	r2, [r7, #0]
24006f44:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
24006f46:	68fb      	ldr	r3, [r7, #12]
24006f48:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006f4a:	3308      	adds	r3, #8
24006f4c:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24006f4e:	68fb      	ldr	r3, [r7, #12]
24006f50:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006f52:	f003 031f 	and.w	r3, r3, #31
24006f56:	223f      	movs	r2, #63	; 0x3f
24006f58:	409a      	lsls	r2, r3
24006f5a:	693b      	ldr	r3, [r7, #16]
24006f5c:	601a      	str	r2, [r3, #0]
24006f5e:	e018      	b.n	24006f92 <HAL_DMAEx_MultiBufferStart_IT+0x166>
    }
    else /* BDMA instance(s) */
    {
      /* Enable the Double buffer mode */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
24006f60:	68fb      	ldr	r3, [r7, #12]
24006f62:	681b      	ldr	r3, [r3, #0]
24006f64:	6819      	ldr	r1, [r3, #0]
24006f66:	68fb      	ldr	r3, [r7, #12]
24006f68:	681a      	ldr	r2, [r3, #0]
24006f6a:	f248 0320 	movw	r3, #32800	; 0x8020
24006f6e:	430b      	orrs	r3, r1
24006f70:	6013      	str	r3, [r2, #0]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
24006f72:	68fb      	ldr	r3, [r7, #12]
24006f74:	681b      	ldr	r3, [r3, #0]
24006f76:	683a      	ldr	r2, [r7, #0]
24006f78:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
24006f7a:	68fb      	ldr	r3, [r7, #12]
24006f7c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006f7e:	3304      	adds	r3, #4
24006f80:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24006f82:	68fb      	ldr	r3, [r7, #12]
24006f84:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006f86:	f003 031f 	and.w	r3, r3, #31
24006f8a:	2201      	movs	r2, #1
24006f8c:	409a      	lsls	r2, r3
24006f8e:	693b      	ldr	r3, [r7, #16]
24006f90:	601a      	str	r2, [r3, #0]
    }

    /* Configure the source, destination address and the data length */
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
24006f92:	6a3b      	ldr	r3, [r7, #32]
24006f94:	687a      	ldr	r2, [r7, #4]
24006f96:	68b9      	ldr	r1, [r7, #8]
24006f98:	68f8      	ldr	r0, [r7, #12]
24006f9a:	f000 fd51 	bl	24007a40 <DMA_MultiBufferSetConfig>

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24006f9e:	68fb      	ldr	r3, [r7, #12]
24006fa0:	681b      	ldr	r3, [r3, #0]
24006fa2:	4a3c      	ldr	r2, [pc, #240]	; (24007094 <HAL_DMAEx_MultiBufferStart_IT+0x268>)
24006fa4:	4293      	cmp	r3, r2
24006fa6:	d072      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006fa8:	68fb      	ldr	r3, [r7, #12]
24006faa:	681b      	ldr	r3, [r3, #0]
24006fac:	4a3a      	ldr	r2, [pc, #232]	; (24007098 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
24006fae:	4293      	cmp	r3, r2
24006fb0:	d06d      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006fb2:	68fb      	ldr	r3, [r7, #12]
24006fb4:	681b      	ldr	r3, [r3, #0]
24006fb6:	4a39      	ldr	r2, [pc, #228]	; (2400709c <HAL_DMAEx_MultiBufferStart_IT+0x270>)
24006fb8:	4293      	cmp	r3, r2
24006fba:	d068      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006fbc:	68fb      	ldr	r3, [r7, #12]
24006fbe:	681b      	ldr	r3, [r3, #0]
24006fc0:	4a37      	ldr	r2, [pc, #220]	; (240070a0 <HAL_DMAEx_MultiBufferStart_IT+0x274>)
24006fc2:	4293      	cmp	r3, r2
24006fc4:	d063      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006fc6:	68fb      	ldr	r3, [r7, #12]
24006fc8:	681b      	ldr	r3, [r3, #0]
24006fca:	4a36      	ldr	r2, [pc, #216]	; (240070a4 <HAL_DMAEx_MultiBufferStart_IT+0x278>)
24006fcc:	4293      	cmp	r3, r2
24006fce:	d05e      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006fd0:	68fb      	ldr	r3, [r7, #12]
24006fd2:	681b      	ldr	r3, [r3, #0]
24006fd4:	4a34      	ldr	r2, [pc, #208]	; (240070a8 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
24006fd6:	4293      	cmp	r3, r2
24006fd8:	d059      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006fda:	68fb      	ldr	r3, [r7, #12]
24006fdc:	681b      	ldr	r3, [r3, #0]
24006fde:	4a33      	ldr	r2, [pc, #204]	; (240070ac <HAL_DMAEx_MultiBufferStart_IT+0x280>)
24006fe0:	4293      	cmp	r3, r2
24006fe2:	d054      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006fe4:	68fb      	ldr	r3, [r7, #12]
24006fe6:	681b      	ldr	r3, [r3, #0]
24006fe8:	4a31      	ldr	r2, [pc, #196]	; (240070b0 <HAL_DMAEx_MultiBufferStart_IT+0x284>)
24006fea:	4293      	cmp	r3, r2
24006fec:	d04f      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006fee:	68fb      	ldr	r3, [r7, #12]
24006ff0:	681b      	ldr	r3, [r3, #0]
24006ff2:	4a30      	ldr	r2, [pc, #192]	; (240070b4 <HAL_DMAEx_MultiBufferStart_IT+0x288>)
24006ff4:	4293      	cmp	r3, r2
24006ff6:	d04a      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24006ff8:	68fb      	ldr	r3, [r7, #12]
24006ffa:	681b      	ldr	r3, [r3, #0]
24006ffc:	4a2e      	ldr	r2, [pc, #184]	; (240070b8 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
24006ffe:	4293      	cmp	r3, r2
24007000:	d045      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007002:	68fb      	ldr	r3, [r7, #12]
24007004:	681b      	ldr	r3, [r3, #0]
24007006:	4a2d      	ldr	r2, [pc, #180]	; (240070bc <HAL_DMAEx_MultiBufferStart_IT+0x290>)
24007008:	4293      	cmp	r3, r2
2400700a:	d040      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400700c:	68fb      	ldr	r3, [r7, #12]
2400700e:	681b      	ldr	r3, [r3, #0]
24007010:	4a2b      	ldr	r2, [pc, #172]	; (240070c0 <HAL_DMAEx_MultiBufferStart_IT+0x294>)
24007012:	4293      	cmp	r3, r2
24007014:	d03b      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007016:	68fb      	ldr	r3, [r7, #12]
24007018:	681b      	ldr	r3, [r3, #0]
2400701a:	4a2a      	ldr	r2, [pc, #168]	; (240070c4 <HAL_DMAEx_MultiBufferStart_IT+0x298>)
2400701c:	4293      	cmp	r3, r2
2400701e:	d036      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007020:	68fb      	ldr	r3, [r7, #12]
24007022:	681b      	ldr	r3, [r3, #0]
24007024:	4a28      	ldr	r2, [pc, #160]	; (240070c8 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
24007026:	4293      	cmp	r3, r2
24007028:	d031      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400702a:	68fb      	ldr	r3, [r7, #12]
2400702c:	681b      	ldr	r3, [r3, #0]
2400702e:	4a27      	ldr	r2, [pc, #156]	; (240070cc <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
24007030:	4293      	cmp	r3, r2
24007032:	d02c      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007034:	68fb      	ldr	r3, [r7, #12]
24007036:	681b      	ldr	r3, [r3, #0]
24007038:	4a25      	ldr	r2, [pc, #148]	; (240070d0 <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
2400703a:	4293      	cmp	r3, r2
2400703c:	d027      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400703e:	68fb      	ldr	r3, [r7, #12]
24007040:	681b      	ldr	r3, [r3, #0]
24007042:	4a24      	ldr	r2, [pc, #144]	; (240070d4 <HAL_DMAEx_MultiBufferStart_IT+0x2a8>)
24007044:	4293      	cmp	r3, r2
24007046:	d022      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007048:	68fb      	ldr	r3, [r7, #12]
2400704a:	681b      	ldr	r3, [r3, #0]
2400704c:	4a22      	ldr	r2, [pc, #136]	; (240070d8 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
2400704e:	4293      	cmp	r3, r2
24007050:	d01d      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007052:	68fb      	ldr	r3, [r7, #12]
24007054:	681b      	ldr	r3, [r3, #0]
24007056:	4a21      	ldr	r2, [pc, #132]	; (240070dc <HAL_DMAEx_MultiBufferStart_IT+0x2b0>)
24007058:	4293      	cmp	r3, r2
2400705a:	d018      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400705c:	68fb      	ldr	r3, [r7, #12]
2400705e:	681b      	ldr	r3, [r3, #0]
24007060:	4a1f      	ldr	r2, [pc, #124]	; (240070e0 <HAL_DMAEx_MultiBufferStart_IT+0x2b4>)
24007062:	4293      	cmp	r3, r2
24007064:	d013      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007066:	68fb      	ldr	r3, [r7, #12]
24007068:	681b      	ldr	r3, [r3, #0]
2400706a:	4a1e      	ldr	r2, [pc, #120]	; (240070e4 <HAL_DMAEx_MultiBufferStart_IT+0x2b8>)
2400706c:	4293      	cmp	r3, r2
2400706e:	d00e      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007070:	68fb      	ldr	r3, [r7, #12]
24007072:	681b      	ldr	r3, [r3, #0]
24007074:	4a1c      	ldr	r2, [pc, #112]	; (240070e8 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
24007076:	4293      	cmp	r3, r2
24007078:	d009      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400707a:	68fb      	ldr	r3, [r7, #12]
2400707c:	681b      	ldr	r3, [r3, #0]
2400707e:	4a1b      	ldr	r2, [pc, #108]	; (240070ec <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
24007080:	4293      	cmp	r3, r2
24007082:	d004      	beq.n	2400708e <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007084:	68fb      	ldr	r3, [r7, #12]
24007086:	681b      	ldr	r3, [r3, #0]
24007088:	4a19      	ldr	r2, [pc, #100]	; (240070f0 <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
2400708a:	4293      	cmp	r3, r2
2400708c:	d132      	bne.n	240070f4 <HAL_DMAEx_MultiBufferStart_IT+0x2c8>
2400708e:	2301      	movs	r3, #1
24007090:	e031      	b.n	240070f6 <HAL_DMAEx_MultiBufferStart_IT+0x2ca>
24007092:	bf00      	nop
24007094:	40020010 	.word	0x40020010
24007098:	40020028 	.word	0x40020028
2400709c:	40020040 	.word	0x40020040
240070a0:	40020058 	.word	0x40020058
240070a4:	40020070 	.word	0x40020070
240070a8:	40020088 	.word	0x40020088
240070ac:	400200a0 	.word	0x400200a0
240070b0:	400200b8 	.word	0x400200b8
240070b4:	40020410 	.word	0x40020410
240070b8:	40020428 	.word	0x40020428
240070bc:	40020440 	.word	0x40020440
240070c0:	40020458 	.word	0x40020458
240070c4:	40020470 	.word	0x40020470
240070c8:	40020488 	.word	0x40020488
240070cc:	400204a0 	.word	0x400204a0
240070d0:	400204b8 	.word	0x400204b8
240070d4:	58025408 	.word	0x58025408
240070d8:	5802541c 	.word	0x5802541c
240070dc:	58025430 	.word	0x58025430
240070e0:	58025444 	.word	0x58025444
240070e4:	58025458 	.word	0x58025458
240070e8:	5802546c 	.word	0x5802546c
240070ec:	58025480 	.word	0x58025480
240070f0:	58025494 	.word	0x58025494
240070f4:	2300      	movs	r3, #0
240070f6:	2b00      	cmp	r3, #0
240070f8:	d00d      	beq.n	24007116 <HAL_DMAEx_MultiBufferStart_IT+0x2ea>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240070fa:	68fb      	ldr	r3, [r7, #12]
240070fc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240070fe:	68fa      	ldr	r2, [r7, #12]
24007100:	6e92      	ldr	r2, [r2, #104]	; 0x68
24007102:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
24007104:	68fb      	ldr	r3, [r7, #12]
24007106:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007108:	2b00      	cmp	r3, #0
2400710a:	d004      	beq.n	24007116 <HAL_DMAEx_MultiBufferStart_IT+0x2ea>
      {
        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2400710c:	68fb      	ldr	r3, [r7, #12]
2400710e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24007110:	68fa      	ldr	r2, [r7, #12]
24007112:	6f52      	ldr	r2, [r2, #116]	; 0x74
24007114:	605a      	str	r2, [r3, #4]
      }
    }

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24007116:	68fb      	ldr	r3, [r7, #12]
24007118:	681b      	ldr	r3, [r3, #0]
2400711a:	4a3b      	ldr	r2, [pc, #236]	; (24007208 <HAL_DMAEx_MultiBufferStart_IT+0x3dc>)
2400711c:	4293      	cmp	r3, r2
2400711e:	d04a      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007120:	68fb      	ldr	r3, [r7, #12]
24007122:	681b      	ldr	r3, [r3, #0]
24007124:	4a39      	ldr	r2, [pc, #228]	; (2400720c <HAL_DMAEx_MultiBufferStart_IT+0x3e0>)
24007126:	4293      	cmp	r3, r2
24007128:	d045      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
2400712a:	68fb      	ldr	r3, [r7, #12]
2400712c:	681b      	ldr	r3, [r3, #0]
2400712e:	4a38      	ldr	r2, [pc, #224]	; (24007210 <HAL_DMAEx_MultiBufferStart_IT+0x3e4>)
24007130:	4293      	cmp	r3, r2
24007132:	d040      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007134:	68fb      	ldr	r3, [r7, #12]
24007136:	681b      	ldr	r3, [r3, #0]
24007138:	4a36      	ldr	r2, [pc, #216]	; (24007214 <HAL_DMAEx_MultiBufferStart_IT+0x3e8>)
2400713a:	4293      	cmp	r3, r2
2400713c:	d03b      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
2400713e:	68fb      	ldr	r3, [r7, #12]
24007140:	681b      	ldr	r3, [r3, #0]
24007142:	4a35      	ldr	r2, [pc, #212]	; (24007218 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>)
24007144:	4293      	cmp	r3, r2
24007146:	d036      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007148:	68fb      	ldr	r3, [r7, #12]
2400714a:	681b      	ldr	r3, [r3, #0]
2400714c:	4a33      	ldr	r2, [pc, #204]	; (2400721c <HAL_DMAEx_MultiBufferStart_IT+0x3f0>)
2400714e:	4293      	cmp	r3, r2
24007150:	d031      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007152:	68fb      	ldr	r3, [r7, #12]
24007154:	681b      	ldr	r3, [r3, #0]
24007156:	4a32      	ldr	r2, [pc, #200]	; (24007220 <HAL_DMAEx_MultiBufferStart_IT+0x3f4>)
24007158:	4293      	cmp	r3, r2
2400715a:	d02c      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
2400715c:	68fb      	ldr	r3, [r7, #12]
2400715e:	681b      	ldr	r3, [r3, #0]
24007160:	4a30      	ldr	r2, [pc, #192]	; (24007224 <HAL_DMAEx_MultiBufferStart_IT+0x3f8>)
24007162:	4293      	cmp	r3, r2
24007164:	d027      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007166:	68fb      	ldr	r3, [r7, #12]
24007168:	681b      	ldr	r3, [r3, #0]
2400716a:	4a2f      	ldr	r2, [pc, #188]	; (24007228 <HAL_DMAEx_MultiBufferStart_IT+0x3fc>)
2400716c:	4293      	cmp	r3, r2
2400716e:	d022      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007170:	68fb      	ldr	r3, [r7, #12]
24007172:	681b      	ldr	r3, [r3, #0]
24007174:	4a2d      	ldr	r2, [pc, #180]	; (2400722c <HAL_DMAEx_MultiBufferStart_IT+0x400>)
24007176:	4293      	cmp	r3, r2
24007178:	d01d      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
2400717a:	68fb      	ldr	r3, [r7, #12]
2400717c:	681b      	ldr	r3, [r3, #0]
2400717e:	4a2c      	ldr	r2, [pc, #176]	; (24007230 <HAL_DMAEx_MultiBufferStart_IT+0x404>)
24007180:	4293      	cmp	r3, r2
24007182:	d018      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007184:	68fb      	ldr	r3, [r7, #12]
24007186:	681b      	ldr	r3, [r3, #0]
24007188:	4a2a      	ldr	r2, [pc, #168]	; (24007234 <HAL_DMAEx_MultiBufferStart_IT+0x408>)
2400718a:	4293      	cmp	r3, r2
2400718c:	d013      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
2400718e:	68fb      	ldr	r3, [r7, #12]
24007190:	681b      	ldr	r3, [r3, #0]
24007192:	4a29      	ldr	r2, [pc, #164]	; (24007238 <HAL_DMAEx_MultiBufferStart_IT+0x40c>)
24007194:	4293      	cmp	r3, r2
24007196:	d00e      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007198:	68fb      	ldr	r3, [r7, #12]
2400719a:	681b      	ldr	r3, [r3, #0]
2400719c:	4a27      	ldr	r2, [pc, #156]	; (2400723c <HAL_DMAEx_MultiBufferStart_IT+0x410>)
2400719e:	4293      	cmp	r3, r2
240071a0:	d009      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
240071a2:	68fb      	ldr	r3, [r7, #12]
240071a4:	681b      	ldr	r3, [r3, #0]
240071a6:	4a26      	ldr	r2, [pc, #152]	; (24007240 <HAL_DMAEx_MultiBufferStart_IT+0x414>)
240071a8:	4293      	cmp	r3, r2
240071aa:	d004      	beq.n	240071b6 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
240071ac:	68fb      	ldr	r3, [r7, #12]
240071ae:	681b      	ldr	r3, [r3, #0]
240071b0:	4a24      	ldr	r2, [pc, #144]	; (24007244 <HAL_DMAEx_MultiBufferStart_IT+0x418>)
240071b2:	4293      	cmp	r3, r2
240071b4:	d101      	bne.n	240071ba <HAL_DMAEx_MultiBufferStart_IT+0x38e>
240071b6:	2301      	movs	r3, #1
240071b8:	e000      	b.n	240071bc <HAL_DMAEx_MultiBufferStart_IT+0x390>
240071ba:	2300      	movs	r3, #0
240071bc:	2b00      	cmp	r3, #0
240071be:	d043      	beq.n	24007248 <HAL_DMAEx_MultiBufferStart_IT+0x41c>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
240071c0:	68fb      	ldr	r3, [r7, #12]
240071c2:	681b      	ldr	r3, [r3, #0]
240071c4:	681b      	ldr	r3, [r3, #0]
240071c6:	f023 021e 	bic.w	r2, r3, #30
240071ca:	68fb      	ldr	r3, [r7, #12]
240071cc:	681b      	ldr	r3, [r3, #0]
240071ce:	f042 0216 	orr.w	r2, r2, #22
240071d2:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR |= DMA_IT_FE;
240071d4:	68fb      	ldr	r3, [r7, #12]
240071d6:	681b      	ldr	r3, [r3, #0]
240071d8:	695a      	ldr	r2, [r3, #20]
240071da:	68fb      	ldr	r3, [r7, #12]
240071dc:	681b      	ldr	r3, [r3, #0]
240071de:	f042 0280 	orr.w	r2, r2, #128	; 0x80
240071e2:	615a      	str	r2, [r3, #20]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
240071e4:	68fb      	ldr	r3, [r7, #12]
240071e6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240071e8:	2b00      	cmp	r3, #0
240071ea:	d103      	bne.n	240071f4 <HAL_DMAEx_MultiBufferStart_IT+0x3c8>
240071ec:	68fb      	ldr	r3, [r7, #12]
240071ee:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240071f0:	2b00      	cmp	r3, #0
240071f2:	d043      	beq.n	2400727c <HAL_DMAEx_MultiBufferStart_IT+0x450>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
240071f4:	68fb      	ldr	r3, [r7, #12]
240071f6:	681b      	ldr	r3, [r3, #0]
240071f8:	681a      	ldr	r2, [r3, #0]
240071fa:	68fb      	ldr	r3, [r7, #12]
240071fc:	681b      	ldr	r3, [r3, #0]
240071fe:	f042 0208 	orr.w	r2, r2, #8
24007202:	601a      	str	r2, [r3, #0]
24007204:	e03a      	b.n	2400727c <HAL_DMAEx_MultiBufferStart_IT+0x450>
24007206:	bf00      	nop
24007208:	40020010 	.word	0x40020010
2400720c:	40020028 	.word	0x40020028
24007210:	40020040 	.word	0x40020040
24007214:	40020058 	.word	0x40020058
24007218:	40020070 	.word	0x40020070
2400721c:	40020088 	.word	0x40020088
24007220:	400200a0 	.word	0x400200a0
24007224:	400200b8 	.word	0x400200b8
24007228:	40020410 	.word	0x40020410
2400722c:	40020428 	.word	0x40020428
24007230:	40020440 	.word	0x40020440
24007234:	40020458 	.word	0x40020458
24007238:	40020470 	.word	0x40020470
2400723c:	40020488 	.word	0x40020488
24007240:	400204a0 	.word	0x400204a0
24007244:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA instance(s) */
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24007248:	68fb      	ldr	r3, [r7, #12]
2400724a:	681b      	ldr	r3, [r3, #0]
2400724c:	681b      	ldr	r3, [r3, #0]
2400724e:	f023 020e 	bic.w	r2, r3, #14
24007252:	68fb      	ldr	r3, [r7, #12]
24007254:	681b      	ldr	r3, [r3, #0]
24007256:	f042 020a 	orr.w	r2, r2, #10
2400725a:	601a      	str	r2, [r3, #0]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
2400725c:	68fb      	ldr	r3, [r7, #12]
2400725e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24007260:	2b00      	cmp	r3, #0
24007262:	d103      	bne.n	2400726c <HAL_DMAEx_MultiBufferStart_IT+0x440>
24007264:	68fb      	ldr	r3, [r7, #12]
24007266:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24007268:	2b00      	cmp	r3, #0
2400726a:	d007      	beq.n	2400727c <HAL_DMAEx_MultiBufferStart_IT+0x450>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
2400726c:	68fb      	ldr	r3, [r7, #12]
2400726e:	681b      	ldr	r3, [r3, #0]
24007270:	681a      	ldr	r2, [r3, #0]
24007272:	68fb      	ldr	r3, [r7, #12]
24007274:	681b      	ldr	r3, [r3, #0]
24007276:	f042 0204 	orr.w	r2, r2, #4
2400727a:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400727c:	68fb      	ldr	r3, [r7, #12]
2400727e:	681b      	ldr	r3, [r3, #0]
24007280:	4a81      	ldr	r2, [pc, #516]	; (24007488 <HAL_DMAEx_MultiBufferStart_IT+0x65c>)
24007282:	4293      	cmp	r3, r2
24007284:	d072      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007286:	68fb      	ldr	r3, [r7, #12]
24007288:	681b      	ldr	r3, [r3, #0]
2400728a:	4a80      	ldr	r2, [pc, #512]	; (2400748c <HAL_DMAEx_MultiBufferStart_IT+0x660>)
2400728c:	4293      	cmp	r3, r2
2400728e:	d06d      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007290:	68fb      	ldr	r3, [r7, #12]
24007292:	681b      	ldr	r3, [r3, #0]
24007294:	4a7e      	ldr	r2, [pc, #504]	; (24007490 <HAL_DMAEx_MultiBufferStart_IT+0x664>)
24007296:	4293      	cmp	r3, r2
24007298:	d068      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400729a:	68fb      	ldr	r3, [r7, #12]
2400729c:	681b      	ldr	r3, [r3, #0]
2400729e:	4a7d      	ldr	r2, [pc, #500]	; (24007494 <HAL_DMAEx_MultiBufferStart_IT+0x668>)
240072a0:	4293      	cmp	r3, r2
240072a2:	d063      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072a4:	68fb      	ldr	r3, [r7, #12]
240072a6:	681b      	ldr	r3, [r3, #0]
240072a8:	4a7b      	ldr	r2, [pc, #492]	; (24007498 <HAL_DMAEx_MultiBufferStart_IT+0x66c>)
240072aa:	4293      	cmp	r3, r2
240072ac:	d05e      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072ae:	68fb      	ldr	r3, [r7, #12]
240072b0:	681b      	ldr	r3, [r3, #0]
240072b2:	4a7a      	ldr	r2, [pc, #488]	; (2400749c <HAL_DMAEx_MultiBufferStart_IT+0x670>)
240072b4:	4293      	cmp	r3, r2
240072b6:	d059      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072b8:	68fb      	ldr	r3, [r7, #12]
240072ba:	681b      	ldr	r3, [r3, #0]
240072bc:	4a78      	ldr	r2, [pc, #480]	; (240074a0 <HAL_DMAEx_MultiBufferStart_IT+0x674>)
240072be:	4293      	cmp	r3, r2
240072c0:	d054      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072c2:	68fb      	ldr	r3, [r7, #12]
240072c4:	681b      	ldr	r3, [r3, #0]
240072c6:	4a77      	ldr	r2, [pc, #476]	; (240074a4 <HAL_DMAEx_MultiBufferStart_IT+0x678>)
240072c8:	4293      	cmp	r3, r2
240072ca:	d04f      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072cc:	68fb      	ldr	r3, [r7, #12]
240072ce:	681b      	ldr	r3, [r3, #0]
240072d0:	4a75      	ldr	r2, [pc, #468]	; (240074a8 <HAL_DMAEx_MultiBufferStart_IT+0x67c>)
240072d2:	4293      	cmp	r3, r2
240072d4:	d04a      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072d6:	68fb      	ldr	r3, [r7, #12]
240072d8:	681b      	ldr	r3, [r3, #0]
240072da:	4a74      	ldr	r2, [pc, #464]	; (240074ac <HAL_DMAEx_MultiBufferStart_IT+0x680>)
240072dc:	4293      	cmp	r3, r2
240072de:	d045      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072e0:	68fb      	ldr	r3, [r7, #12]
240072e2:	681b      	ldr	r3, [r3, #0]
240072e4:	4a72      	ldr	r2, [pc, #456]	; (240074b0 <HAL_DMAEx_MultiBufferStart_IT+0x684>)
240072e6:	4293      	cmp	r3, r2
240072e8:	d040      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072ea:	68fb      	ldr	r3, [r7, #12]
240072ec:	681b      	ldr	r3, [r3, #0]
240072ee:	4a71      	ldr	r2, [pc, #452]	; (240074b4 <HAL_DMAEx_MultiBufferStart_IT+0x688>)
240072f0:	4293      	cmp	r3, r2
240072f2:	d03b      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072f4:	68fb      	ldr	r3, [r7, #12]
240072f6:	681b      	ldr	r3, [r3, #0]
240072f8:	4a6f      	ldr	r2, [pc, #444]	; (240074b8 <HAL_DMAEx_MultiBufferStart_IT+0x68c>)
240072fa:	4293      	cmp	r3, r2
240072fc:	d036      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
240072fe:	68fb      	ldr	r3, [r7, #12]
24007300:	681b      	ldr	r3, [r3, #0]
24007302:	4a6e      	ldr	r2, [pc, #440]	; (240074bc <HAL_DMAEx_MultiBufferStart_IT+0x690>)
24007304:	4293      	cmp	r3, r2
24007306:	d031      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007308:	68fb      	ldr	r3, [r7, #12]
2400730a:	681b      	ldr	r3, [r3, #0]
2400730c:	4a6c      	ldr	r2, [pc, #432]	; (240074c0 <HAL_DMAEx_MultiBufferStart_IT+0x694>)
2400730e:	4293      	cmp	r3, r2
24007310:	d02c      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007312:	68fb      	ldr	r3, [r7, #12]
24007314:	681b      	ldr	r3, [r3, #0]
24007316:	4a6b      	ldr	r2, [pc, #428]	; (240074c4 <HAL_DMAEx_MultiBufferStart_IT+0x698>)
24007318:	4293      	cmp	r3, r2
2400731a:	d027      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400731c:	68fb      	ldr	r3, [r7, #12]
2400731e:	681b      	ldr	r3, [r3, #0]
24007320:	4a69      	ldr	r2, [pc, #420]	; (240074c8 <HAL_DMAEx_MultiBufferStart_IT+0x69c>)
24007322:	4293      	cmp	r3, r2
24007324:	d022      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007326:	68fb      	ldr	r3, [r7, #12]
24007328:	681b      	ldr	r3, [r3, #0]
2400732a:	4a68      	ldr	r2, [pc, #416]	; (240074cc <HAL_DMAEx_MultiBufferStart_IT+0x6a0>)
2400732c:	4293      	cmp	r3, r2
2400732e:	d01d      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007330:	68fb      	ldr	r3, [r7, #12]
24007332:	681b      	ldr	r3, [r3, #0]
24007334:	4a66      	ldr	r2, [pc, #408]	; (240074d0 <HAL_DMAEx_MultiBufferStart_IT+0x6a4>)
24007336:	4293      	cmp	r3, r2
24007338:	d018      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400733a:	68fb      	ldr	r3, [r7, #12]
2400733c:	681b      	ldr	r3, [r3, #0]
2400733e:	4a65      	ldr	r2, [pc, #404]	; (240074d4 <HAL_DMAEx_MultiBufferStart_IT+0x6a8>)
24007340:	4293      	cmp	r3, r2
24007342:	d013      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007344:	68fb      	ldr	r3, [r7, #12]
24007346:	681b      	ldr	r3, [r3, #0]
24007348:	4a63      	ldr	r2, [pc, #396]	; (240074d8 <HAL_DMAEx_MultiBufferStart_IT+0x6ac>)
2400734a:	4293      	cmp	r3, r2
2400734c:	d00e      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400734e:	68fb      	ldr	r3, [r7, #12]
24007350:	681b      	ldr	r3, [r3, #0]
24007352:	4a62      	ldr	r2, [pc, #392]	; (240074dc <HAL_DMAEx_MultiBufferStart_IT+0x6b0>)
24007354:	4293      	cmp	r3, r2
24007356:	d009      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007358:	68fb      	ldr	r3, [r7, #12]
2400735a:	681b      	ldr	r3, [r3, #0]
2400735c:	4a60      	ldr	r2, [pc, #384]	; (240074e0 <HAL_DMAEx_MultiBufferStart_IT+0x6b4>)
2400735e:	4293      	cmp	r3, r2
24007360:	d004      	beq.n	2400736c <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007362:	68fb      	ldr	r3, [r7, #12]
24007364:	681b      	ldr	r3, [r3, #0]
24007366:	4a5f      	ldr	r2, [pc, #380]	; (240074e4 <HAL_DMAEx_MultiBufferStart_IT+0x6b8>)
24007368:	4293      	cmp	r3, r2
2400736a:	d101      	bne.n	24007370 <HAL_DMAEx_MultiBufferStart_IT+0x544>
2400736c:	2301      	movs	r3, #1
2400736e:	e000      	b.n	24007372 <HAL_DMAEx_MultiBufferStart_IT+0x546>
24007370:	2300      	movs	r3, #0
24007372:	2b00      	cmp	r3, #0
24007374:	d01a      	beq.n	240073ac <HAL_DMAEx_MultiBufferStart_IT+0x580>
    {
      /* Check if DMAMUX Synchronization is enabled*/
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
24007376:	68fb      	ldr	r3, [r7, #12]
24007378:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400737a:	681b      	ldr	r3, [r3, #0]
2400737c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24007380:	2b00      	cmp	r3, #0
24007382:	d007      	beq.n	24007394 <HAL_DMAEx_MultiBufferStart_IT+0x568>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
24007384:	68fb      	ldr	r3, [r7, #12]
24007386:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007388:	681a      	ldr	r2, [r3, #0]
2400738a:	68fb      	ldr	r3, [r7, #12]
2400738c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400738e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24007392:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
24007394:	68fb      	ldr	r3, [r7, #12]
24007396:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007398:	2b00      	cmp	r3, #0
2400739a:	d007      	beq.n	240073ac <HAL_DMAEx_MultiBufferStart_IT+0x580>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT*/
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
2400739c:	68fb      	ldr	r3, [r7, #12]
2400739e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240073a0:	681a      	ldr	r2, [r3, #0]
240073a2:	68fb      	ldr	r3, [r7, #12]
240073a4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240073a6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
240073aa:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the peripheral */
    __HAL_DMA_ENABLE(hdma);
240073ac:	68fb      	ldr	r3, [r7, #12]
240073ae:	681b      	ldr	r3, [r3, #0]
240073b0:	4a35      	ldr	r2, [pc, #212]	; (24007488 <HAL_DMAEx_MultiBufferStart_IT+0x65c>)
240073b2:	4293      	cmp	r3, r2
240073b4:	d04a      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
240073b6:	68fb      	ldr	r3, [r7, #12]
240073b8:	681b      	ldr	r3, [r3, #0]
240073ba:	4a34      	ldr	r2, [pc, #208]	; (2400748c <HAL_DMAEx_MultiBufferStart_IT+0x660>)
240073bc:	4293      	cmp	r3, r2
240073be:	d045      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
240073c0:	68fb      	ldr	r3, [r7, #12]
240073c2:	681b      	ldr	r3, [r3, #0]
240073c4:	4a32      	ldr	r2, [pc, #200]	; (24007490 <HAL_DMAEx_MultiBufferStart_IT+0x664>)
240073c6:	4293      	cmp	r3, r2
240073c8:	d040      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
240073ca:	68fb      	ldr	r3, [r7, #12]
240073cc:	681b      	ldr	r3, [r3, #0]
240073ce:	4a31      	ldr	r2, [pc, #196]	; (24007494 <HAL_DMAEx_MultiBufferStart_IT+0x668>)
240073d0:	4293      	cmp	r3, r2
240073d2:	d03b      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
240073d4:	68fb      	ldr	r3, [r7, #12]
240073d6:	681b      	ldr	r3, [r3, #0]
240073d8:	4a2f      	ldr	r2, [pc, #188]	; (24007498 <HAL_DMAEx_MultiBufferStart_IT+0x66c>)
240073da:	4293      	cmp	r3, r2
240073dc:	d036      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
240073de:	68fb      	ldr	r3, [r7, #12]
240073e0:	681b      	ldr	r3, [r3, #0]
240073e2:	4a2e      	ldr	r2, [pc, #184]	; (2400749c <HAL_DMAEx_MultiBufferStart_IT+0x670>)
240073e4:	4293      	cmp	r3, r2
240073e6:	d031      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
240073e8:	68fb      	ldr	r3, [r7, #12]
240073ea:	681b      	ldr	r3, [r3, #0]
240073ec:	4a2c      	ldr	r2, [pc, #176]	; (240074a0 <HAL_DMAEx_MultiBufferStart_IT+0x674>)
240073ee:	4293      	cmp	r3, r2
240073f0:	d02c      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
240073f2:	68fb      	ldr	r3, [r7, #12]
240073f4:	681b      	ldr	r3, [r3, #0]
240073f6:	4a2b      	ldr	r2, [pc, #172]	; (240074a4 <HAL_DMAEx_MultiBufferStart_IT+0x678>)
240073f8:	4293      	cmp	r3, r2
240073fa:	d027      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
240073fc:	68fb      	ldr	r3, [r7, #12]
240073fe:	681b      	ldr	r3, [r3, #0]
24007400:	4a29      	ldr	r2, [pc, #164]	; (240074a8 <HAL_DMAEx_MultiBufferStart_IT+0x67c>)
24007402:	4293      	cmp	r3, r2
24007404:	d022      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007406:	68fb      	ldr	r3, [r7, #12]
24007408:	681b      	ldr	r3, [r3, #0]
2400740a:	4a28      	ldr	r2, [pc, #160]	; (240074ac <HAL_DMAEx_MultiBufferStart_IT+0x680>)
2400740c:	4293      	cmp	r3, r2
2400740e:	d01d      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007410:	68fb      	ldr	r3, [r7, #12]
24007412:	681b      	ldr	r3, [r3, #0]
24007414:	4a26      	ldr	r2, [pc, #152]	; (240074b0 <HAL_DMAEx_MultiBufferStart_IT+0x684>)
24007416:	4293      	cmp	r3, r2
24007418:	d018      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
2400741a:	68fb      	ldr	r3, [r7, #12]
2400741c:	681b      	ldr	r3, [r3, #0]
2400741e:	4a25      	ldr	r2, [pc, #148]	; (240074b4 <HAL_DMAEx_MultiBufferStart_IT+0x688>)
24007420:	4293      	cmp	r3, r2
24007422:	d013      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007424:	68fb      	ldr	r3, [r7, #12]
24007426:	681b      	ldr	r3, [r3, #0]
24007428:	4a23      	ldr	r2, [pc, #140]	; (240074b8 <HAL_DMAEx_MultiBufferStart_IT+0x68c>)
2400742a:	4293      	cmp	r3, r2
2400742c:	d00e      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
2400742e:	68fb      	ldr	r3, [r7, #12]
24007430:	681b      	ldr	r3, [r3, #0]
24007432:	4a22      	ldr	r2, [pc, #136]	; (240074bc <HAL_DMAEx_MultiBufferStart_IT+0x690>)
24007434:	4293      	cmp	r3, r2
24007436:	d009      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007438:	68fb      	ldr	r3, [r7, #12]
2400743a:	681b      	ldr	r3, [r3, #0]
2400743c:	4a20      	ldr	r2, [pc, #128]	; (240074c0 <HAL_DMAEx_MultiBufferStart_IT+0x694>)
2400743e:	4293      	cmp	r3, r2
24007440:	d004      	beq.n	2400744c <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007442:	68fb      	ldr	r3, [r7, #12]
24007444:	681b      	ldr	r3, [r3, #0]
24007446:	4a1f      	ldr	r2, [pc, #124]	; (240074c4 <HAL_DMAEx_MultiBufferStart_IT+0x698>)
24007448:	4293      	cmp	r3, r2
2400744a:	d108      	bne.n	2400745e <HAL_DMAEx_MultiBufferStart_IT+0x632>
2400744c:	68fb      	ldr	r3, [r7, #12]
2400744e:	681b      	ldr	r3, [r3, #0]
24007450:	681a      	ldr	r2, [r3, #0]
24007452:	68fb      	ldr	r3, [r7, #12]
24007454:	681b      	ldr	r3, [r3, #0]
24007456:	f042 0201 	orr.w	r2, r2, #1
2400745a:	601a      	str	r2, [r3, #0]
2400745c:	e00e      	b.n	2400747c <HAL_DMAEx_MultiBufferStart_IT+0x650>
2400745e:	68fb      	ldr	r3, [r7, #12]
24007460:	681b      	ldr	r3, [r3, #0]
24007462:	681a      	ldr	r2, [r3, #0]
24007464:	68fb      	ldr	r3, [r7, #12]
24007466:	681b      	ldr	r3, [r3, #0]
24007468:	f042 0201 	orr.w	r2, r2, #1
2400746c:	601a      	str	r2, [r3, #0]
2400746e:	e005      	b.n	2400747c <HAL_DMAEx_MultiBufferStart_IT+0x650>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24007470:	68fb      	ldr	r3, [r7, #12]
24007472:	f44f 6200 	mov.w	r2, #2048	; 0x800
24007476:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
24007478:	2301      	movs	r3, #1
2400747a:	75fb      	strb	r3, [r7, #23]
  }
  return status;
2400747c:	7dfb      	ldrb	r3, [r7, #23]
}
2400747e:	4618      	mov	r0, r3
24007480:	3718      	adds	r7, #24
24007482:	46bd      	mov	sp, r7
24007484:	bd80      	pop	{r7, pc}
24007486:	bf00      	nop
24007488:	40020010 	.word	0x40020010
2400748c:	40020028 	.word	0x40020028
24007490:	40020040 	.word	0x40020040
24007494:	40020058 	.word	0x40020058
24007498:	40020070 	.word	0x40020070
2400749c:	40020088 	.word	0x40020088
240074a0:	400200a0 	.word	0x400200a0
240074a4:	400200b8 	.word	0x400200b8
240074a8:	40020410 	.word	0x40020410
240074ac:	40020428 	.word	0x40020428
240074b0:	40020440 	.word	0x40020440
240074b4:	40020458 	.word	0x40020458
240074b8:	40020470 	.word	0x40020470
240074bc:	40020488 	.word	0x40020488
240074c0:	400204a0 	.word	0x400204a0
240074c4:	400204b8 	.word	0x400204b8
240074c8:	58025408 	.word	0x58025408
240074cc:	5802541c 	.word	0x5802541c
240074d0:	58025430 	.word	0x58025430
240074d4:	58025444 	.word	0x58025444
240074d8:	58025458 	.word	0x58025458
240074dc:	5802546c 	.word	0x5802546c
240074e0:	58025480 	.word	0x58025480
240074e4:	58025494 	.word	0x58025494

240074e8 <HAL_DMAEx_ChangeMemory>:
  *         MEMORY1 and the MEMORY1 address can be changed only when the current
  *         transfer use MEMORY0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
240074e8:	b480      	push	{r7}
240074ea:	b085      	sub	sp, #20
240074ec:	af00      	add	r7, sp, #0
240074ee:	60f8      	str	r0, [r7, #12]
240074f0:	60b9      	str	r1, [r7, #8]
240074f2:	4613      	mov	r3, r2
240074f4:	71fb      	strb	r3, [r7, #7]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240074f6:	68fb      	ldr	r3, [r7, #12]
240074f8:	681b      	ldr	r3, [r3, #0]
240074fa:	4a39      	ldr	r2, [pc, #228]	; (240075e0 <HAL_DMAEx_ChangeMemory+0xf8>)
240074fc:	4293      	cmp	r3, r2
240074fe:	d04a      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007500:	68fb      	ldr	r3, [r7, #12]
24007502:	681b      	ldr	r3, [r3, #0]
24007504:	4a37      	ldr	r2, [pc, #220]	; (240075e4 <HAL_DMAEx_ChangeMemory+0xfc>)
24007506:	4293      	cmp	r3, r2
24007508:	d045      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
2400750a:	68fb      	ldr	r3, [r7, #12]
2400750c:	681b      	ldr	r3, [r3, #0]
2400750e:	4a36      	ldr	r2, [pc, #216]	; (240075e8 <HAL_DMAEx_ChangeMemory+0x100>)
24007510:	4293      	cmp	r3, r2
24007512:	d040      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007514:	68fb      	ldr	r3, [r7, #12]
24007516:	681b      	ldr	r3, [r3, #0]
24007518:	4a34      	ldr	r2, [pc, #208]	; (240075ec <HAL_DMAEx_ChangeMemory+0x104>)
2400751a:	4293      	cmp	r3, r2
2400751c:	d03b      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
2400751e:	68fb      	ldr	r3, [r7, #12]
24007520:	681b      	ldr	r3, [r3, #0]
24007522:	4a33      	ldr	r2, [pc, #204]	; (240075f0 <HAL_DMAEx_ChangeMemory+0x108>)
24007524:	4293      	cmp	r3, r2
24007526:	d036      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007528:	68fb      	ldr	r3, [r7, #12]
2400752a:	681b      	ldr	r3, [r3, #0]
2400752c:	4a31      	ldr	r2, [pc, #196]	; (240075f4 <HAL_DMAEx_ChangeMemory+0x10c>)
2400752e:	4293      	cmp	r3, r2
24007530:	d031      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007532:	68fb      	ldr	r3, [r7, #12]
24007534:	681b      	ldr	r3, [r3, #0]
24007536:	4a30      	ldr	r2, [pc, #192]	; (240075f8 <HAL_DMAEx_ChangeMemory+0x110>)
24007538:	4293      	cmp	r3, r2
2400753a:	d02c      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
2400753c:	68fb      	ldr	r3, [r7, #12]
2400753e:	681b      	ldr	r3, [r3, #0]
24007540:	4a2e      	ldr	r2, [pc, #184]	; (240075fc <HAL_DMAEx_ChangeMemory+0x114>)
24007542:	4293      	cmp	r3, r2
24007544:	d027      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007546:	68fb      	ldr	r3, [r7, #12]
24007548:	681b      	ldr	r3, [r3, #0]
2400754a:	4a2d      	ldr	r2, [pc, #180]	; (24007600 <HAL_DMAEx_ChangeMemory+0x118>)
2400754c:	4293      	cmp	r3, r2
2400754e:	d022      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007550:	68fb      	ldr	r3, [r7, #12]
24007552:	681b      	ldr	r3, [r3, #0]
24007554:	4a2b      	ldr	r2, [pc, #172]	; (24007604 <HAL_DMAEx_ChangeMemory+0x11c>)
24007556:	4293      	cmp	r3, r2
24007558:	d01d      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
2400755a:	68fb      	ldr	r3, [r7, #12]
2400755c:	681b      	ldr	r3, [r3, #0]
2400755e:	4a2a      	ldr	r2, [pc, #168]	; (24007608 <HAL_DMAEx_ChangeMemory+0x120>)
24007560:	4293      	cmp	r3, r2
24007562:	d018      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007564:	68fb      	ldr	r3, [r7, #12]
24007566:	681b      	ldr	r3, [r3, #0]
24007568:	4a28      	ldr	r2, [pc, #160]	; (2400760c <HAL_DMAEx_ChangeMemory+0x124>)
2400756a:	4293      	cmp	r3, r2
2400756c:	d013      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
2400756e:	68fb      	ldr	r3, [r7, #12]
24007570:	681b      	ldr	r3, [r3, #0]
24007572:	4a27      	ldr	r2, [pc, #156]	; (24007610 <HAL_DMAEx_ChangeMemory+0x128>)
24007574:	4293      	cmp	r3, r2
24007576:	d00e      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007578:	68fb      	ldr	r3, [r7, #12]
2400757a:	681b      	ldr	r3, [r3, #0]
2400757c:	4a25      	ldr	r2, [pc, #148]	; (24007614 <HAL_DMAEx_ChangeMemory+0x12c>)
2400757e:	4293      	cmp	r3, r2
24007580:	d009      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
24007582:	68fb      	ldr	r3, [r7, #12]
24007584:	681b      	ldr	r3, [r3, #0]
24007586:	4a24      	ldr	r2, [pc, #144]	; (24007618 <HAL_DMAEx_ChangeMemory+0x130>)
24007588:	4293      	cmp	r3, r2
2400758a:	d004      	beq.n	24007596 <HAL_DMAEx_ChangeMemory+0xae>
2400758c:	68fb      	ldr	r3, [r7, #12]
2400758e:	681b      	ldr	r3, [r3, #0]
24007590:	4a22      	ldr	r2, [pc, #136]	; (2400761c <HAL_DMAEx_ChangeMemory+0x134>)
24007592:	4293      	cmp	r3, r2
24007594:	d101      	bne.n	2400759a <HAL_DMAEx_ChangeMemory+0xb2>
24007596:	2301      	movs	r3, #1
24007598:	e000      	b.n	2400759c <HAL_DMAEx_ChangeMemory+0xb4>
2400759a:	2300      	movs	r3, #0
2400759c:	2b00      	cmp	r3, #0
2400759e:	d00c      	beq.n	240075ba <HAL_DMAEx_ChangeMemory+0xd2>
  {
    if(memory == MEMORY0)
240075a0:	79fb      	ldrb	r3, [r7, #7]
240075a2:	2b00      	cmp	r3, #0
240075a4:	d104      	bne.n	240075b0 <HAL_DMAEx_ChangeMemory+0xc8>
    {
      /* change the memory0 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = Address;
240075a6:	68fb      	ldr	r3, [r7, #12]
240075a8:	681b      	ldr	r3, [r3, #0]
240075aa:	68ba      	ldr	r2, [r7, #8]
240075ac:	60da      	str	r2, [r3, #12]
240075ae:	e010      	b.n	240075d2 <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = Address;
240075b0:	68fb      	ldr	r3, [r7, #12]
240075b2:	681b      	ldr	r3, [r3, #0]
240075b4:	68ba      	ldr	r2, [r7, #8]
240075b6:	611a      	str	r2, [r3, #16]
240075b8:	e00b      	b.n	240075d2 <HAL_DMAEx_ChangeMemory+0xea>
    }
  }
  else /* BDMA instance(s) */
  {
    if(memory == MEMORY0)
240075ba:	79fb      	ldrb	r3, [r7, #7]
240075bc:	2b00      	cmp	r3, #0
240075be:	d104      	bne.n	240075ca <HAL_DMAEx_ChangeMemory+0xe2>
    {
      /* change the memory0 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = Address;
240075c0:	68fb      	ldr	r3, [r7, #12]
240075c2:	681b      	ldr	r3, [r3, #0]
240075c4:	68ba      	ldr	r2, [r7, #8]
240075c6:	60da      	str	r2, [r3, #12]
240075c8:	e003      	b.n	240075d2 <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = Address;
240075ca:	68fb      	ldr	r3, [r7, #12]
240075cc:	681b      	ldr	r3, [r3, #0]
240075ce:	68ba      	ldr	r2, [r7, #8]
240075d0:	611a      	str	r2, [r3, #16]
    }
  }

  return HAL_OK;
240075d2:	2300      	movs	r3, #0
}
240075d4:	4618      	mov	r0, r3
240075d6:	3714      	adds	r7, #20
240075d8:	46bd      	mov	sp, r7
240075da:	f85d 7b04 	ldr.w	r7, [sp], #4
240075de:	4770      	bx	lr
240075e0:	40020010 	.word	0x40020010
240075e4:	40020028 	.word	0x40020028
240075e8:	40020040 	.word	0x40020040
240075ec:	40020058 	.word	0x40020058
240075f0:	40020070 	.word	0x40020070
240075f4:	40020088 	.word	0x40020088
240075f8:	400200a0 	.word	0x400200a0
240075fc:	400200b8 	.word	0x400200b8
24007600:	40020410 	.word	0x40020410
24007604:	40020428 	.word	0x40020428
24007608:	40020440 	.word	0x40020440
2400760c:	40020458 	.word	0x40020458
24007610:	40020470 	.word	0x40020470
24007614:	40020488 	.word	0x40020488
24007618:	400204a0 	.word	0x400204a0
2400761c:	400204b8 	.word	0x400204b8

24007620 <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
24007620:	b480      	push	{r7}
24007622:	b085      	sub	sp, #20
24007624:	af00      	add	r7, sp, #0
24007626:	6078      	str	r0, [r7, #4]
24007628:	6039      	str	r1, [r7, #0]
  uint32_t syncSignalID = 0;
2400762a:	2300      	movs	r3, #0
2400762c:	60fb      	str	r3, [r7, #12]
  uint32_t syncPolarity = 0;
2400762e:	2300      	movs	r3, #0
24007630:	60bb      	str	r3, [r7, #8]
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));

  if(pSyncConfig->SyncEnable == ENABLE)
24007632:	683b      	ldr	r3, [r7, #0]
24007634:	7a1b      	ldrb	r3, [r3, #8]
24007636:	2b01      	cmp	r3, #1
24007638:	d155      	bne.n	240076e6 <HAL_DMAEx_ConfigMuxSync+0xc6>
  {
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400763a:	687b      	ldr	r3, [r7, #4]
2400763c:	681b      	ldr	r3, [r3, #0]
2400763e:	4a4b      	ldr	r2, [pc, #300]	; (2400776c <HAL_DMAEx_ConfigMuxSync+0x14c>)
24007640:	4293      	cmp	r3, r2
24007642:	d049      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007644:	687b      	ldr	r3, [r7, #4]
24007646:	681b      	ldr	r3, [r3, #0]
24007648:	4a49      	ldr	r2, [pc, #292]	; (24007770 <HAL_DMAEx_ConfigMuxSync+0x150>)
2400764a:	4293      	cmp	r3, r2
2400764c:	d044      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400764e:	687b      	ldr	r3, [r7, #4]
24007650:	681b      	ldr	r3, [r3, #0]
24007652:	4a48      	ldr	r2, [pc, #288]	; (24007774 <HAL_DMAEx_ConfigMuxSync+0x154>)
24007654:	4293      	cmp	r3, r2
24007656:	d03f      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007658:	687b      	ldr	r3, [r7, #4]
2400765a:	681b      	ldr	r3, [r3, #0]
2400765c:	4a46      	ldr	r2, [pc, #280]	; (24007778 <HAL_DMAEx_ConfigMuxSync+0x158>)
2400765e:	4293      	cmp	r3, r2
24007660:	d03a      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007662:	687b      	ldr	r3, [r7, #4]
24007664:	681b      	ldr	r3, [r3, #0]
24007666:	4a45      	ldr	r2, [pc, #276]	; (2400777c <HAL_DMAEx_ConfigMuxSync+0x15c>)
24007668:	4293      	cmp	r3, r2
2400766a:	d035      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400766c:	687b      	ldr	r3, [r7, #4]
2400766e:	681b      	ldr	r3, [r3, #0]
24007670:	4a43      	ldr	r2, [pc, #268]	; (24007780 <HAL_DMAEx_ConfigMuxSync+0x160>)
24007672:	4293      	cmp	r3, r2
24007674:	d030      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007676:	687b      	ldr	r3, [r7, #4]
24007678:	681b      	ldr	r3, [r3, #0]
2400767a:	4a42      	ldr	r2, [pc, #264]	; (24007784 <HAL_DMAEx_ConfigMuxSync+0x164>)
2400767c:	4293      	cmp	r3, r2
2400767e:	d02b      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007680:	687b      	ldr	r3, [r7, #4]
24007682:	681b      	ldr	r3, [r3, #0]
24007684:	4a40      	ldr	r2, [pc, #256]	; (24007788 <HAL_DMAEx_ConfigMuxSync+0x168>)
24007686:	4293      	cmp	r3, r2
24007688:	d026      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400768a:	687b      	ldr	r3, [r7, #4]
2400768c:	681b      	ldr	r3, [r3, #0]
2400768e:	4a3f      	ldr	r2, [pc, #252]	; (2400778c <HAL_DMAEx_ConfigMuxSync+0x16c>)
24007690:	4293      	cmp	r3, r2
24007692:	d021      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007694:	687b      	ldr	r3, [r7, #4]
24007696:	681b      	ldr	r3, [r3, #0]
24007698:	4a3d      	ldr	r2, [pc, #244]	; (24007790 <HAL_DMAEx_ConfigMuxSync+0x170>)
2400769a:	4293      	cmp	r3, r2
2400769c:	d01c      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400769e:	687b      	ldr	r3, [r7, #4]
240076a0:	681b      	ldr	r3, [r3, #0]
240076a2:	4a3c      	ldr	r2, [pc, #240]	; (24007794 <HAL_DMAEx_ConfigMuxSync+0x174>)
240076a4:	4293      	cmp	r3, r2
240076a6:	d017      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
240076a8:	687b      	ldr	r3, [r7, #4]
240076aa:	681b      	ldr	r3, [r3, #0]
240076ac:	4a3a      	ldr	r2, [pc, #232]	; (24007798 <HAL_DMAEx_ConfigMuxSync+0x178>)
240076ae:	4293      	cmp	r3, r2
240076b0:	d012      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
240076b2:	687b      	ldr	r3, [r7, #4]
240076b4:	681b      	ldr	r3, [r3, #0]
240076b6:	4a39      	ldr	r2, [pc, #228]	; (2400779c <HAL_DMAEx_ConfigMuxSync+0x17c>)
240076b8:	4293      	cmp	r3, r2
240076ba:	d00d      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
240076bc:	687b      	ldr	r3, [r7, #4]
240076be:	681b      	ldr	r3, [r3, #0]
240076c0:	4a37      	ldr	r2, [pc, #220]	; (240077a0 <HAL_DMAEx_ConfigMuxSync+0x180>)
240076c2:	4293      	cmp	r3, r2
240076c4:	d008      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
240076c6:	687b      	ldr	r3, [r7, #4]
240076c8:	681b      	ldr	r3, [r3, #0]
240076ca:	4a36      	ldr	r2, [pc, #216]	; (240077a4 <HAL_DMAEx_ConfigMuxSync+0x184>)
240076cc:	4293      	cmp	r3, r2
240076ce:	d003      	beq.n	240076d8 <HAL_DMAEx_ConfigMuxSync+0xb8>
240076d0:	687b      	ldr	r3, [r7, #4]
240076d2:	681b      	ldr	r3, [r3, #0]
240076d4:	4a34      	ldr	r2, [pc, #208]	; (240077a8 <HAL_DMAEx_ConfigMuxSync+0x188>)
240076d6:	4293      	cmp	r3, r2
240076d8:	bf00      	nop
    }
    else
    {
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    }
    syncSignalID = pSyncConfig->SyncSignalID;
240076da:	683b      	ldr	r3, [r7, #0]
240076dc:	681b      	ldr	r3, [r3, #0]
240076de:	60fb      	str	r3, [r7, #12]
    syncPolarity = pSyncConfig->SyncPolarity;
240076e0:	683b      	ldr	r3, [r7, #0]
240076e2:	685b      	ldr	r3, [r3, #4]
240076e4:	60bb      	str	r3, [r7, #8]
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
240076e6:	687b      	ldr	r3, [r7, #4]
240076e8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240076ec:	b2db      	uxtb	r3, r3
240076ee:	2b01      	cmp	r3, #1
240076f0:	d131      	bne.n	24007756 <HAL_DMAEx_ConfigMuxSync+0x136>
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
240076f2:	687b      	ldr	r3, [r7, #4]
240076f4:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
240076f8:	2b01      	cmp	r3, #1
240076fa:	d101      	bne.n	24007700 <HAL_DMAEx_ConfigMuxSync+0xe0>
240076fc:	2302      	movs	r3, #2
240076fe:	e02f      	b.n	24007760 <HAL_DMAEx_ConfigMuxSync+0x140>
24007700:	687b      	ldr	r3, [r7, #4]
24007702:	2201      	movs	r2, #1
24007704:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the synchronization and event generation before applying a new config */
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
24007708:	687b      	ldr	r3, [r7, #4]
2400770a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400770c:	681a      	ldr	r2, [r3, #0]
2400770e:	687b      	ldr	r3, [r7, #4]
24007710:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007712:	f422 3281 	bic.w	r2, r2, #66048	; 0x10200
24007716:	601a      	str	r2, [r3, #0]

    /* Set the new synchronization parameters (and keep the request ID filled during the Init)*/
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
24007718:	687b      	ldr	r3, [r7, #4]
2400771a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400771c:	681b      	ldr	r3, [r3, #0]
2400771e:	b2d9      	uxtb	r1, r3
24007720:	68fb      	ldr	r3, [r7, #12]
24007722:	061a      	lsls	r2, r3, #24
24007724:	683b      	ldr	r3, [r7, #0]
24007726:	68db      	ldr	r3, [r3, #12]
24007728:	3b01      	subs	r3, #1
2400772a:	04db      	lsls	r3, r3, #19
2400772c:	431a      	orrs	r2, r3
2400772e:	68bb      	ldr	r3, [r7, #8]
24007730:	431a      	orrs	r2, r3
24007732:	683b      	ldr	r3, [r7, #0]
24007734:	7a1b      	ldrb	r3, [r3, #8]
24007736:	041b      	lsls	r3, r3, #16
24007738:	431a      	orrs	r2, r3
2400773a:	683b      	ldr	r3, [r7, #0]
2400773c:	7a5b      	ldrb	r3, [r3, #9]
2400773e:	025b      	lsls	r3, r3, #9
24007740:	431a      	orrs	r2, r3
24007742:	687b      	ldr	r3, [r7, #4]
24007744:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007746:	430a      	orrs	r2, r1
24007748:	601a      	str	r2, [r3, #0]
               ((pSyncConfig->RequestNumber - 1U) << DMAMUX_CxCR_NBREQ_Pos) | \
               syncPolarity | ((uint32_t)pSyncConfig->SyncEnable << DMAMUX_CxCR_SE_Pos)    | \
               ((uint32_t)pSyncConfig->EventEnable << DMAMUX_CxCR_EGE_Pos));

      /* Process Locked */
    __HAL_UNLOCK(hdma);
2400774a:	687b      	ldr	r3, [r7, #4]
2400774c:	2200      	movs	r2, #0
2400774e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
24007752:	2300      	movs	r3, #0
24007754:	e004      	b.n	24007760 <HAL_DMAEx_ConfigMuxSync+0x140>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24007756:	687b      	ldr	r3, [r7, #4]
24007758:	f44f 6200 	mov.w	r2, #2048	; 0x800
2400775c:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    return HAL_ERROR;
2400775e:	2301      	movs	r3, #1
  }
}
24007760:	4618      	mov	r0, r3
24007762:	3714      	adds	r7, #20
24007764:	46bd      	mov	sp, r7
24007766:	f85d 7b04 	ldr.w	r7, [sp], #4
2400776a:	4770      	bx	lr
2400776c:	40020010 	.word	0x40020010
24007770:	40020028 	.word	0x40020028
24007774:	40020040 	.word	0x40020040
24007778:	40020058 	.word	0x40020058
2400777c:	40020070 	.word	0x40020070
24007780:	40020088 	.word	0x40020088
24007784:	400200a0 	.word	0x400200a0
24007788:	400200b8 	.word	0x400200b8
2400778c:	40020410 	.word	0x40020410
24007790:	40020428 	.word	0x40020428
24007794:	40020440 	.word	0x40020440
24007798:	40020458 	.word	0x40020458
2400779c:	40020470 	.word	0x40020470
240077a0:	40020488 	.word	0x40020488
240077a4:	400204a0 	.word	0x400204a0
240077a8:	400204b8 	.word	0x400204b8

240077ac <HAL_DMAEx_ConfigMuxRequestGenerator>:
  *         contains the request generator parameters.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxRequestGenerator (DMA_HandleTypeDef *hdma, HAL_DMA_MuxRequestGeneratorConfigTypeDef *pRequestGeneratorConfig)
{
240077ac:	b480      	push	{r7}
240077ae:	b085      	sub	sp, #20
240077b0:	af00      	add	r7, sp, #0
240077b2:	6078      	str	r0, [r7, #4]
240077b4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  HAL_DMA_StateTypeDef temp_state = hdma->State;
240077b6:	687b      	ldr	r3, [r7, #4]
240077b8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240077bc:	73bb      	strb	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240077be:	687b      	ldr	r3, [r7, #4]
240077c0:	681b      	ldr	r3, [r3, #0]
240077c2:	4a47      	ldr	r2, [pc, #284]	; (240078e0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x134>)
240077c4:	4293      	cmp	r3, r2
240077c6:	d049      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240077c8:	687b      	ldr	r3, [r7, #4]
240077ca:	681b      	ldr	r3, [r3, #0]
240077cc:	4a45      	ldr	r2, [pc, #276]	; (240078e4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x138>)
240077ce:	4293      	cmp	r3, r2
240077d0:	d044      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240077d2:	687b      	ldr	r3, [r7, #4]
240077d4:	681b      	ldr	r3, [r3, #0]
240077d6:	4a44      	ldr	r2, [pc, #272]	; (240078e8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x13c>)
240077d8:	4293      	cmp	r3, r2
240077da:	d03f      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240077dc:	687b      	ldr	r3, [r7, #4]
240077de:	681b      	ldr	r3, [r3, #0]
240077e0:	4a42      	ldr	r2, [pc, #264]	; (240078ec <HAL_DMAEx_ConfigMuxRequestGenerator+0x140>)
240077e2:	4293      	cmp	r3, r2
240077e4:	d03a      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240077e6:	687b      	ldr	r3, [r7, #4]
240077e8:	681b      	ldr	r3, [r3, #0]
240077ea:	4a41      	ldr	r2, [pc, #260]	; (240078f0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x144>)
240077ec:	4293      	cmp	r3, r2
240077ee:	d035      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240077f0:	687b      	ldr	r3, [r7, #4]
240077f2:	681b      	ldr	r3, [r3, #0]
240077f4:	4a3f      	ldr	r2, [pc, #252]	; (240078f4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x148>)
240077f6:	4293      	cmp	r3, r2
240077f8:	d030      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240077fa:	687b      	ldr	r3, [r7, #4]
240077fc:	681b      	ldr	r3, [r3, #0]
240077fe:	4a3e      	ldr	r2, [pc, #248]	; (240078f8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x14c>)
24007800:	4293      	cmp	r3, r2
24007802:	d02b      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007804:	687b      	ldr	r3, [r7, #4]
24007806:	681b      	ldr	r3, [r3, #0]
24007808:	4a3c      	ldr	r2, [pc, #240]	; (240078fc <HAL_DMAEx_ConfigMuxRequestGenerator+0x150>)
2400780a:	4293      	cmp	r3, r2
2400780c:	d026      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400780e:	687b      	ldr	r3, [r7, #4]
24007810:	681b      	ldr	r3, [r3, #0]
24007812:	4a3b      	ldr	r2, [pc, #236]	; (24007900 <HAL_DMAEx_ConfigMuxRequestGenerator+0x154>)
24007814:	4293      	cmp	r3, r2
24007816:	d021      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007818:	687b      	ldr	r3, [r7, #4]
2400781a:	681b      	ldr	r3, [r3, #0]
2400781c:	4a39      	ldr	r2, [pc, #228]	; (24007904 <HAL_DMAEx_ConfigMuxRequestGenerator+0x158>)
2400781e:	4293      	cmp	r3, r2
24007820:	d01c      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007822:	687b      	ldr	r3, [r7, #4]
24007824:	681b      	ldr	r3, [r3, #0]
24007826:	4a38      	ldr	r2, [pc, #224]	; (24007908 <HAL_DMAEx_ConfigMuxRequestGenerator+0x15c>)
24007828:	4293      	cmp	r3, r2
2400782a:	d017      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400782c:	687b      	ldr	r3, [r7, #4]
2400782e:	681b      	ldr	r3, [r3, #0]
24007830:	4a36      	ldr	r2, [pc, #216]	; (2400790c <HAL_DMAEx_ConfigMuxRequestGenerator+0x160>)
24007832:	4293      	cmp	r3, r2
24007834:	d012      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007836:	687b      	ldr	r3, [r7, #4]
24007838:	681b      	ldr	r3, [r3, #0]
2400783a:	4a35      	ldr	r2, [pc, #212]	; (24007910 <HAL_DMAEx_ConfigMuxRequestGenerator+0x164>)
2400783c:	4293      	cmp	r3, r2
2400783e:	d00d      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007840:	687b      	ldr	r3, [r7, #4]
24007842:	681b      	ldr	r3, [r3, #0]
24007844:	4a33      	ldr	r2, [pc, #204]	; (24007914 <HAL_DMAEx_ConfigMuxRequestGenerator+0x168>)
24007846:	4293      	cmp	r3, r2
24007848:	d008      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400784a:	687b      	ldr	r3, [r7, #4]
2400784c:	681b      	ldr	r3, [r3, #0]
2400784e:	4a32      	ldr	r2, [pc, #200]	; (24007918 <HAL_DMAEx_ConfigMuxRequestGenerator+0x16c>)
24007850:	4293      	cmp	r3, r2
24007852:	d003      	beq.n	2400785c <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007854:	687b      	ldr	r3, [r7, #4]
24007856:	681b      	ldr	r3, [r3, #0]
24007858:	4a30      	ldr	r2, [pc, #192]	; (2400791c <HAL_DMAEx_ConfigMuxRequestGenerator+0x170>)
2400785a:	4293      	cmp	r3, r2
2400785c:	bf00      	nop
  assert_param(IS_DMAMUX_REQUEST_GEN_REQUEST_NUMBER(pRequestGeneratorConfig->RequestNumber));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block
  */
  if(hdma->DMAmuxRequestGen == 0U)
2400785e:	687b      	ldr	r3, [r7, #4]
24007860:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007862:	2b00      	cmp	r3, #0
24007864:	d105      	bne.n	24007872 <HAL_DMAEx_ConfigMuxRequestGenerator+0xc6>
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24007866:	687b      	ldr	r3, [r7, #4]
24007868:	2240      	movs	r2, #64	; 0x40
2400786a:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
2400786c:	2301      	movs	r3, #1
2400786e:	73fb      	strb	r3, [r7, #15]
24007870:	e02e      	b.n	240078d0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x124>
  }
  else if(((hdma->DMAmuxRequestGen->RGCR & DMAMUX_RGxCR_GE) == 0U) && (temp_state == HAL_DMA_STATE_READY))
24007872:	687b      	ldr	r3, [r7, #4]
24007874:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007876:	681b      	ldr	r3, [r3, #0]
24007878:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400787c:	2b00      	cmp	r3, #0
2400787e:	d121      	bne.n	240078c4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x118>
24007880:	7bbb      	ldrb	r3, [r7, #14]
24007882:	2b01      	cmp	r3, #1
24007884:	d11e      	bne.n	240078c4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x118>
  {
    /* RequestGenerator must be disable prior to the configuration i.e GE bit is 0 */

    /* Process Locked */
    __HAL_LOCK(hdma);
24007886:	687b      	ldr	r3, [r7, #4]
24007888:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
2400788c:	2b01      	cmp	r3, #1
2400788e:	d101      	bne.n	24007894 <HAL_DMAEx_ConfigMuxRequestGenerator+0xe8>
24007890:	2302      	movs	r3, #2
24007892:	e01e      	b.n	240078d2 <HAL_DMAEx_ConfigMuxRequestGenerator+0x126>
24007894:	687b      	ldr	r3, [r7, #4]
24007896:	2201      	movs	r2, #1
24007898:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the request generator new parameters */
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
2400789c:	683b      	ldr	r3, [r7, #0]
2400789e:	681a      	ldr	r2, [r3, #0]
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
240078a0:	683b      	ldr	r3, [r7, #0]
240078a2:	689b      	ldr	r3, [r3, #8]
240078a4:	3b01      	subs	r3, #1
240078a6:	04db      	lsls	r3, r3, #19
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240078a8:	ea42 0103 	orr.w	r1, r2, r3
                                  pRequestGeneratorConfig->Polarity;
240078ac:	683b      	ldr	r3, [r7, #0]
240078ae:	685a      	ldr	r2, [r3, #4]
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240078b0:	687b      	ldr	r3, [r7, #4]
240078b2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
240078b4:	430a      	orrs	r2, r1
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240078b6:	601a      	str	r2, [r3, #0]
    /* Process Locked */
    __HAL_UNLOCK(hdma);
240078b8:	687b      	ldr	r3, [r7, #4]
240078ba:	2200      	movs	r2, #0
240078bc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
240078c0:	2300      	movs	r3, #0
240078c2:	e006      	b.n	240078d2 <HAL_DMAEx_ConfigMuxRequestGenerator+0x126>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240078c4:	687b      	ldr	r3, [r7, #4]
240078c6:	f44f 6200 	mov.w	r2, #2048	; 0x800
240078ca:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
240078cc:	2301      	movs	r3, #1
240078ce:	73fb      	strb	r3, [r7, #15]
  }

  return status;
240078d0:	7bfb      	ldrb	r3, [r7, #15]
}
240078d2:	4618      	mov	r0, r3
240078d4:	3714      	adds	r7, #20
240078d6:	46bd      	mov	sp, r7
240078d8:	f85d 7b04 	ldr.w	r7, [sp], #4
240078dc:	4770      	bx	lr
240078de:	bf00      	nop
240078e0:	40020010 	.word	0x40020010
240078e4:	40020028 	.word	0x40020028
240078e8:	40020040 	.word	0x40020040
240078ec:	40020058 	.word	0x40020058
240078f0:	40020070 	.word	0x40020070
240078f4:	40020088 	.word	0x40020088
240078f8:	400200a0 	.word	0x400200a0
240078fc:	400200b8 	.word	0x400200b8
24007900:	40020410 	.word	0x40020410
24007904:	40020428 	.word	0x40020428
24007908:	40020440 	.word	0x40020440
2400790c:	40020458 	.word	0x40020458
24007910:	40020470 	.word	0x40020470
24007914:	40020488 	.word	0x40020488
24007918:	400204a0 	.word	0x400204a0
2400791c:	400204b8 	.word	0x400204b8

24007920 <HAL_DMAEx_EnableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_EnableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
24007920:	b480      	push	{r7}
24007922:	b083      	sub	sp, #12
24007924:	af00      	add	r7, sp, #0
24007926:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
24007928:	687b      	ldr	r3, [r7, #4]
2400792a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400792e:	b2db      	uxtb	r3, r3
24007930:	2b00      	cmp	r3, #0
24007932:	d00d      	beq.n	24007950 <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
24007934:	687b      	ldr	r3, [r7, #4]
24007936:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007938:	2b00      	cmp	r3, #0
2400793a:	d009      	beq.n	24007950 <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
  {
    /* Enable the request generator*/
    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;
2400793c:	687b      	ldr	r3, [r7, #4]
2400793e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007940:	681a      	ldr	r2, [r3, #0]
24007942:	687b      	ldr	r3, [r7, #4]
24007944:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007946:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400794a:	601a      	str	r2, [r3, #0]

   return HAL_OK;
2400794c:	2300      	movs	r3, #0
2400794e:	e000      	b.n	24007952 <HAL_DMAEx_EnableMuxRequestGenerator+0x32>
 }
 else
 {
   return HAL_ERROR;
24007950:	2301      	movs	r3, #1
 }
}
24007952:	4618      	mov	r0, r3
24007954:	370c      	adds	r7, #12
24007956:	46bd      	mov	sp, r7
24007958:	f85d 7b04 	ldr.w	r7, [sp], #4
2400795c:	4770      	bx	lr

2400795e <HAL_DMAEx_DisableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_DisableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
2400795e:	b480      	push	{r7}
24007960:	b083      	sub	sp, #12
24007962:	af00      	add	r7, sp, #0
24007964:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
24007966:	687b      	ldr	r3, [r7, #4]
24007968:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400796c:	b2db      	uxtb	r3, r3
2400796e:	2b00      	cmp	r3, #0
24007970:	d00d      	beq.n	2400798e <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
24007972:	687b      	ldr	r3, [r7, #4]
24007974:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007976:	2b00      	cmp	r3, #0
24007978:	d009      	beq.n	2400798e <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
  {
    /* Disable the request generator*/
    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;
2400797a:	687b      	ldr	r3, [r7, #4]
2400797c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400797e:	681a      	ldr	r2, [r3, #0]
24007980:	687b      	ldr	r3, [r7, #4]
24007982:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007984:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
24007988:	601a      	str	r2, [r3, #0]

   return HAL_OK;
2400798a:	2300      	movs	r3, #0
2400798c:	e000      	b.n	24007990 <HAL_DMAEx_DisableMuxRequestGenerator+0x32>
 }
 else
 {
   return HAL_ERROR;
2400798e:	2301      	movs	r3, #1
 }
}
24007990:	4618      	mov	r0, r3
24007992:	370c      	adds	r7, #12
24007994:	46bd      	mov	sp, r7
24007996:	f85d 7b04 	ldr.w	r7, [sp], #4
2400799a:	4770      	bx	lr

2400799c <HAL_DMAEx_MUX_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)
{
2400799c:	b580      	push	{r7, lr}
2400799e:	b082      	sub	sp, #8
240079a0:	af00      	add	r7, sp, #0
240079a2:	6078      	str	r0, [r7, #4]
  /* Check for DMAMUX Synchronization overrun */
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
240079a4:	687b      	ldr	r3, [r7, #4]
240079a6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240079a8:	681a      	ldr	r2, [r3, #0]
240079aa:	687b      	ldr	r3, [r7, #4]
240079ac:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240079ae:	4013      	ands	r3, r2
240079b0:	2b00      	cmp	r3, #0
240079b2:	d01a      	beq.n	240079ea <HAL_DMAEx_MUX_IRQHandler+0x4e>
  {
    /* Disable the synchro overrun interrupt */
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
240079b4:	687b      	ldr	r3, [r7, #4]
240079b6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240079b8:	681a      	ldr	r2, [r3, #0]
240079ba:	687b      	ldr	r3, [r7, #4]
240079bc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240079be:	f422 7280 	bic.w	r2, r2, #256	; 0x100
240079c2:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240079c4:	687b      	ldr	r3, [r7, #4]
240079c6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240079c8:	687a      	ldr	r2, [r7, #4]
240079ca:	6e92      	ldr	r2, [r2, #104]	; 0x68
240079cc:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
240079ce:	687b      	ldr	r3, [r7, #4]
240079d0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240079d2:	f443 7200 	orr.w	r2, r3, #512	; 0x200
240079d6:	687b      	ldr	r3, [r7, #4]
240079d8:	655a      	str	r2, [r3, #84]	; 0x54

    if(hdma->XferErrorCallback != NULL)
240079da:	687b      	ldr	r3, [r7, #4]
240079dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240079de:	2b00      	cmp	r3, #0
240079e0:	d003      	beq.n	240079ea <HAL_DMAEx_MUX_IRQHandler+0x4e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
240079e2:	687b      	ldr	r3, [r7, #4]
240079e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240079e6:	6878      	ldr	r0, [r7, #4]
240079e8:	4798      	blx	r3
    }
  }

  if(hdma->DMAmuxRequestGen != 0)
240079ea:	687b      	ldr	r3, [r7, #4]
240079ec:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240079ee:	2b00      	cmp	r3, #0
240079f0:	d022      	beq.n	24007a38 <HAL_DMAEx_MUX_IRQHandler+0x9c>
  {
   /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */
    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
240079f2:	687b      	ldr	r3, [r7, #4]
240079f4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240079f6:	681a      	ldr	r2, [r3, #0]
240079f8:	687b      	ldr	r3, [r7, #4]
240079fa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
240079fc:	4013      	ands	r3, r2
240079fe:	2b00      	cmp	r3, #0
24007a00:	d01a      	beq.n	24007a38 <HAL_DMAEx_MUX_IRQHandler+0x9c>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
24007a02:	687b      	ldr	r3, [r7, #4]
24007a04:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007a06:	681a      	ldr	r2, [r3, #0]
24007a08:	687b      	ldr	r3, [r7, #4]
24007a0a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007a0c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24007a10:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24007a12:	687b      	ldr	r3, [r7, #4]
24007a14:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24007a16:	687a      	ldr	r2, [r7, #4]
24007a18:	6f52      	ldr	r2, [r2, #116]	; 0x74
24007a1a:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
24007a1c:	687b      	ldr	r3, [r7, #4]
24007a1e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24007a20:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
24007a24:	687b      	ldr	r3, [r7, #4]
24007a26:	655a      	str	r2, [r3, #84]	; 0x54

      if(hdma->XferErrorCallback != NULL)
24007a28:	687b      	ldr	r3, [r7, #4]
24007a2a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24007a2c:	2b00      	cmp	r3, #0
24007a2e:	d003      	beq.n	24007a38 <HAL_DMAEx_MUX_IRQHandler+0x9c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24007a30:	687b      	ldr	r3, [r7, #4]
24007a32:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24007a34:	6878      	ldr	r0, [r7, #4]
24007a36:	4798      	blx	r3
      }
    }
  }
}
24007a38:	bf00      	nop
24007a3a:	3708      	adds	r7, #8
24007a3c:	46bd      	mov	sp, r7
24007a3e:	bd80      	pop	{r7, pc}

24007a40 <DMA_MultiBufferSetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24007a40:	b480      	push	{r7}
24007a42:	b085      	sub	sp, #20
24007a44:	af00      	add	r7, sp, #0
24007a46:	60f8      	str	r0, [r7, #12]
24007a48:	60b9      	str	r1, [r7, #8]
24007a4a:	607a      	str	r2, [r7, #4]
24007a4c:	603b      	str	r3, [r7, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24007a4e:	68fb      	ldr	r3, [r7, #12]
24007a50:	681b      	ldr	r3, [r3, #0]
24007a52:	4a46      	ldr	r2, [pc, #280]	; (24007b6c <DMA_MultiBufferSetConfig+0x12c>)
24007a54:	4293      	cmp	r3, r2
24007a56:	d04a      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007a58:	68fb      	ldr	r3, [r7, #12]
24007a5a:	681b      	ldr	r3, [r3, #0]
24007a5c:	4a44      	ldr	r2, [pc, #272]	; (24007b70 <DMA_MultiBufferSetConfig+0x130>)
24007a5e:	4293      	cmp	r3, r2
24007a60:	d045      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007a62:	68fb      	ldr	r3, [r7, #12]
24007a64:	681b      	ldr	r3, [r3, #0]
24007a66:	4a43      	ldr	r2, [pc, #268]	; (24007b74 <DMA_MultiBufferSetConfig+0x134>)
24007a68:	4293      	cmp	r3, r2
24007a6a:	d040      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007a6c:	68fb      	ldr	r3, [r7, #12]
24007a6e:	681b      	ldr	r3, [r3, #0]
24007a70:	4a41      	ldr	r2, [pc, #260]	; (24007b78 <DMA_MultiBufferSetConfig+0x138>)
24007a72:	4293      	cmp	r3, r2
24007a74:	d03b      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007a76:	68fb      	ldr	r3, [r7, #12]
24007a78:	681b      	ldr	r3, [r3, #0]
24007a7a:	4a40      	ldr	r2, [pc, #256]	; (24007b7c <DMA_MultiBufferSetConfig+0x13c>)
24007a7c:	4293      	cmp	r3, r2
24007a7e:	d036      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007a80:	68fb      	ldr	r3, [r7, #12]
24007a82:	681b      	ldr	r3, [r3, #0]
24007a84:	4a3e      	ldr	r2, [pc, #248]	; (24007b80 <DMA_MultiBufferSetConfig+0x140>)
24007a86:	4293      	cmp	r3, r2
24007a88:	d031      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007a8a:	68fb      	ldr	r3, [r7, #12]
24007a8c:	681b      	ldr	r3, [r3, #0]
24007a8e:	4a3d      	ldr	r2, [pc, #244]	; (24007b84 <DMA_MultiBufferSetConfig+0x144>)
24007a90:	4293      	cmp	r3, r2
24007a92:	d02c      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007a94:	68fb      	ldr	r3, [r7, #12]
24007a96:	681b      	ldr	r3, [r3, #0]
24007a98:	4a3b      	ldr	r2, [pc, #236]	; (24007b88 <DMA_MultiBufferSetConfig+0x148>)
24007a9a:	4293      	cmp	r3, r2
24007a9c:	d027      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007a9e:	68fb      	ldr	r3, [r7, #12]
24007aa0:	681b      	ldr	r3, [r3, #0]
24007aa2:	4a3a      	ldr	r2, [pc, #232]	; (24007b8c <DMA_MultiBufferSetConfig+0x14c>)
24007aa4:	4293      	cmp	r3, r2
24007aa6:	d022      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007aa8:	68fb      	ldr	r3, [r7, #12]
24007aaa:	681b      	ldr	r3, [r3, #0]
24007aac:	4a38      	ldr	r2, [pc, #224]	; (24007b90 <DMA_MultiBufferSetConfig+0x150>)
24007aae:	4293      	cmp	r3, r2
24007ab0:	d01d      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007ab2:	68fb      	ldr	r3, [r7, #12]
24007ab4:	681b      	ldr	r3, [r3, #0]
24007ab6:	4a37      	ldr	r2, [pc, #220]	; (24007b94 <DMA_MultiBufferSetConfig+0x154>)
24007ab8:	4293      	cmp	r3, r2
24007aba:	d018      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007abc:	68fb      	ldr	r3, [r7, #12]
24007abe:	681b      	ldr	r3, [r3, #0]
24007ac0:	4a35      	ldr	r2, [pc, #212]	; (24007b98 <DMA_MultiBufferSetConfig+0x158>)
24007ac2:	4293      	cmp	r3, r2
24007ac4:	d013      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007ac6:	68fb      	ldr	r3, [r7, #12]
24007ac8:	681b      	ldr	r3, [r3, #0]
24007aca:	4a34      	ldr	r2, [pc, #208]	; (24007b9c <DMA_MultiBufferSetConfig+0x15c>)
24007acc:	4293      	cmp	r3, r2
24007ace:	d00e      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007ad0:	68fb      	ldr	r3, [r7, #12]
24007ad2:	681b      	ldr	r3, [r3, #0]
24007ad4:	4a32      	ldr	r2, [pc, #200]	; (24007ba0 <DMA_MultiBufferSetConfig+0x160>)
24007ad6:	4293      	cmp	r3, r2
24007ad8:	d009      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007ada:	68fb      	ldr	r3, [r7, #12]
24007adc:	681b      	ldr	r3, [r3, #0]
24007ade:	4a31      	ldr	r2, [pc, #196]	; (24007ba4 <DMA_MultiBufferSetConfig+0x164>)
24007ae0:	4293      	cmp	r3, r2
24007ae2:	d004      	beq.n	24007aee <DMA_MultiBufferSetConfig+0xae>
24007ae4:	68fb      	ldr	r3, [r7, #12]
24007ae6:	681b      	ldr	r3, [r3, #0]
24007ae8:	4a2f      	ldr	r2, [pc, #188]	; (24007ba8 <DMA_MultiBufferSetConfig+0x168>)
24007aea:	4293      	cmp	r3, r2
24007aec:	d101      	bne.n	24007af2 <DMA_MultiBufferSetConfig+0xb2>
24007aee:	2301      	movs	r3, #1
24007af0:	e000      	b.n	24007af4 <DMA_MultiBufferSetConfig+0xb4>
24007af2:	2300      	movs	r3, #0
24007af4:	2b00      	cmp	r3, #0
24007af6:	d019      	beq.n	24007b2c <DMA_MultiBufferSetConfig+0xec>
  {
    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = DataLength;
24007af8:	68fb      	ldr	r3, [r7, #12]
24007afa:	681b      	ldr	r3, [r3, #0]
24007afc:	683a      	ldr	r2, [r7, #0]
24007afe:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24007b00:	68fb      	ldr	r3, [r7, #12]
24007b02:	689b      	ldr	r3, [r3, #8]
24007b04:	2b40      	cmp	r3, #64	; 0x40
24007b06:	d108      	bne.n	24007b1a <DMA_MultiBufferSetConfig+0xda>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = DstAddress;
24007b08:	68fb      	ldr	r3, [r7, #12]
24007b0a:	681b      	ldr	r3, [r3, #0]
24007b0c:	687a      	ldr	r2, [r7, #4]
24007b0e:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = SrcAddress;
24007b10:	68fb      	ldr	r3, [r7, #12]
24007b12:	681b      	ldr	r3, [r3, #0]
24007b14:	68ba      	ldr	r2, [r7, #8]
24007b16:	60da      	str	r2, [r3, #12]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
    }
  }
}
24007b18:	e021      	b.n	24007b5e <DMA_MultiBufferSetConfig+0x11e>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = SrcAddress;
24007b1a:	68fb      	ldr	r3, [r7, #12]
24007b1c:	681b      	ldr	r3, [r3, #0]
24007b1e:	68ba      	ldr	r2, [r7, #8]
24007b20:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = DstAddress;
24007b22:	68fb      	ldr	r3, [r7, #12]
24007b24:	681b      	ldr	r3, [r3, #0]
24007b26:	687a      	ldr	r2, [r7, #4]
24007b28:	60da      	str	r2, [r3, #12]
}
24007b2a:	e018      	b.n	24007b5e <DMA_MultiBufferSetConfig+0x11e>
    ((BDMA_Channel_TypeDef   *)hdma->Instance)->CNDTR = DataLength;
24007b2c:	68fb      	ldr	r3, [r7, #12]
24007b2e:	681b      	ldr	r3, [r3, #0]
24007b30:	683a      	ldr	r2, [r7, #0]
24007b32:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24007b34:	68fb      	ldr	r3, [r7, #12]
24007b36:	689b      	ldr	r3, [r3, #8]
24007b38:	2b40      	cmp	r3, #64	; 0x40
24007b3a:	d108      	bne.n	24007b4e <DMA_MultiBufferSetConfig+0x10e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = DstAddress;
24007b3c:	68fb      	ldr	r3, [r7, #12]
24007b3e:	681b      	ldr	r3, [r3, #0]
24007b40:	687a      	ldr	r2, [r7, #4]
24007b42:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = SrcAddress;
24007b44:	68fb      	ldr	r3, [r7, #12]
24007b46:	681b      	ldr	r3, [r3, #0]
24007b48:	68ba      	ldr	r2, [r7, #8]
24007b4a:	60da      	str	r2, [r3, #12]
}
24007b4c:	e007      	b.n	24007b5e <DMA_MultiBufferSetConfig+0x11e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = SrcAddress;
24007b4e:	68fb      	ldr	r3, [r7, #12]
24007b50:	681b      	ldr	r3, [r3, #0]
24007b52:	68ba      	ldr	r2, [r7, #8]
24007b54:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
24007b56:	68fb      	ldr	r3, [r7, #12]
24007b58:	681b      	ldr	r3, [r3, #0]
24007b5a:	687a      	ldr	r2, [r7, #4]
24007b5c:	60da      	str	r2, [r3, #12]
}
24007b5e:	bf00      	nop
24007b60:	3714      	adds	r7, #20
24007b62:	46bd      	mov	sp, r7
24007b64:	f85d 7b04 	ldr.w	r7, [sp], #4
24007b68:	4770      	bx	lr
24007b6a:	bf00      	nop
24007b6c:	40020010 	.word	0x40020010
24007b70:	40020028 	.word	0x40020028
24007b74:	40020040 	.word	0x40020040
24007b78:	40020058 	.word	0x40020058
24007b7c:	40020070 	.word	0x40020070
24007b80:	40020088 	.word	0x40020088
24007b84:	400200a0 	.word	0x400200a0
24007b88:	400200b8 	.word	0x400200b8
24007b8c:	40020410 	.word	0x40020410
24007b90:	40020428 	.word	0x40020428
24007b94:	40020440 	.word	0x40020440
24007b98:	40020458 	.word	0x40020458
24007b9c:	40020470 	.word	0x40020470
24007ba0:	40020488 	.word	0x40020488
24007ba4:	400204a0 	.word	0x400204a0
24007ba8:	400204b8 	.word	0x400204b8

24007bac <HAL_EXTI_SetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on EXTI configuration to be set.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
24007bac:	b480      	push	{r7}
24007bae:	b089      	sub	sp, #36	; 0x24
24007bb0:	af00      	add	r7, sp, #0
24007bb2:	6078      	str	r0, [r7, #4]
24007bb4:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
24007bb6:	687b      	ldr	r3, [r7, #4]
24007bb8:	2b00      	cmp	r3, #0
24007bba:	d002      	beq.n	24007bc2 <HAL_EXTI_SetConfigLine+0x16>
24007bbc:	683b      	ldr	r3, [r7, #0]
24007bbe:	2b00      	cmp	r3, #0
24007bc0:	d101      	bne.n	24007bc6 <HAL_EXTI_SetConfigLine+0x1a>
  {
    return HAL_ERROR;
24007bc2:	2301      	movs	r3, #1
24007bc4:	e109      	b.n	24007dda <HAL_EXTI_SetConfigLine+0x22e>
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(pExtiConfig->Line));
  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));

  /* Assign line number to handle */
  hexti->Line = pExtiConfig->Line;
24007bc6:	683b      	ldr	r3, [r7, #0]
24007bc8:	681a      	ldr	r2, [r3, #0]
24007bca:	687b      	ldr	r3, [r7, #4]
24007bcc:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24007bce:	683b      	ldr	r3, [r7, #0]
24007bd0:	681b      	ldr	r3, [r3, #0]
24007bd2:	0c1b      	lsrs	r3, r3, #16
24007bd4:	f003 0303 	and.w	r3, r3, #3
24007bd8:	613b      	str	r3, [r7, #16]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
24007bda:	683b      	ldr	r3, [r7, #0]
24007bdc:	681b      	ldr	r3, [r3, #0]
24007bde:	f003 031f 	and.w	r3, r3, #31
24007be2:	60fb      	str	r3, [r7, #12]
  maskline = (1UL << linepos);
24007be4:	2201      	movs	r2, #1
24007be6:	68fb      	ldr	r3, [r7, #12]
24007be8:	fa02 f303 	lsl.w	r3, r2, r3
24007bec:	60bb      	str	r3, [r7, #8]

  /* Configure triggers for configurable lines */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
24007bee:	683b      	ldr	r3, [r7, #0]
24007bf0:	681b      	ldr	r3, [r3, #0]
24007bf2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24007bf6:	2b00      	cmp	r3, #0
24007bf8:	d064      	beq.n	24007cc4 <HAL_EXTI_SetConfigLine+0x118>
  {
    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));

    /* Configure rising trigger */
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24007bfa:	693b      	ldr	r3, [r7, #16]
24007bfc:	015b      	lsls	r3, r3, #5
24007bfe:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
24007c02:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24007c04:	69fb      	ldr	r3, [r7, #28]
24007c06:	681b      	ldr	r3, [r3, #0]
24007c08:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00U)
24007c0a:	683b      	ldr	r3, [r7, #0]
24007c0c:	689b      	ldr	r3, [r3, #8]
24007c0e:	f003 0301 	and.w	r3, r3, #1
24007c12:	2b00      	cmp	r3, #0
24007c14:	d004      	beq.n	24007c20 <HAL_EXTI_SetConfigLine+0x74>
    {
      regval |= maskline;
24007c16:	69ba      	ldr	r2, [r7, #24]
24007c18:	68bb      	ldr	r3, [r7, #8]
24007c1a:	4313      	orrs	r3, r2
24007c1c:	61bb      	str	r3, [r7, #24]
24007c1e:	e004      	b.n	24007c2a <HAL_EXTI_SetConfigLine+0x7e>
    }
    else
    {
      regval &= ~maskline;
24007c20:	68bb      	ldr	r3, [r7, #8]
24007c22:	43db      	mvns	r3, r3
24007c24:	69ba      	ldr	r2, [r7, #24]
24007c26:	4013      	ands	r3, r2
24007c28:	61bb      	str	r3, [r7, #24]
    }

    /* Store rising trigger mode */
    *regaddr = regval;
24007c2a:	69fb      	ldr	r3, [r7, #28]
24007c2c:	69ba      	ldr	r2, [r7, #24]
24007c2e:	601a      	str	r2, [r3, #0]

    /* Configure falling trigger */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
24007c30:	693b      	ldr	r3, [r7, #16]
24007c32:	015a      	lsls	r2, r3, #5
24007c34:	4b6c      	ldr	r3, [pc, #432]	; (24007de8 <HAL_EXTI_SetConfigLine+0x23c>)
24007c36:	4413      	add	r3, r2
24007c38:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24007c3a:	69fb      	ldr	r3, [r7, #28]
24007c3c:	681b      	ldr	r3, [r3, #0]
24007c3e:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00U)
24007c40:	683b      	ldr	r3, [r7, #0]
24007c42:	689b      	ldr	r3, [r3, #8]
24007c44:	f003 0302 	and.w	r3, r3, #2
24007c48:	2b00      	cmp	r3, #0
24007c4a:	d004      	beq.n	24007c56 <HAL_EXTI_SetConfigLine+0xaa>
    {
      regval |= maskline;
24007c4c:	69ba      	ldr	r2, [r7, #24]
24007c4e:	68bb      	ldr	r3, [r7, #8]
24007c50:	4313      	orrs	r3, r2
24007c52:	61bb      	str	r3, [r7, #24]
24007c54:	e004      	b.n	24007c60 <HAL_EXTI_SetConfigLine+0xb4>
    }
    else
    {
      regval &= ~maskline;
24007c56:	68bb      	ldr	r3, [r7, #8]
24007c58:	43db      	mvns	r3, r3
24007c5a:	69ba      	ldr	r2, [r7, #24]
24007c5c:	4013      	ands	r3, r2
24007c5e:	61bb      	str	r3, [r7, #24]
    }

    /* Store falling trigger mode */
    *regaddr = regval;
24007c60:	69fb      	ldr	r3, [r7, #28]
24007c62:	69ba      	ldr	r2, [r7, #24]
24007c64:	601a      	str	r2, [r3, #0]

    /* Configure gpio port selection in case of gpio exti line */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
24007c66:	683b      	ldr	r3, [r7, #0]
24007c68:	681b      	ldr	r3, [r3, #0]
24007c6a:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
24007c6e:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
24007c72:	d127      	bne.n	24007cc4 <HAL_EXTI_SetConfigLine+0x118>
    {
      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24007c74:	4a5d      	ldr	r2, [pc, #372]	; (24007dec <HAL_EXTI_SetConfigLine+0x240>)
24007c76:	68fb      	ldr	r3, [r7, #12]
24007c78:	089b      	lsrs	r3, r3, #2
24007c7a:	f003 0303 	and.w	r3, r3, #3
24007c7e:	3302      	adds	r3, #2
24007c80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24007c84:	61bb      	str	r3, [r7, #24]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
24007c86:	68fb      	ldr	r3, [r7, #12]
24007c88:	f003 0303 	and.w	r3, r3, #3
24007c8c:	009b      	lsls	r3, r3, #2
24007c8e:	220f      	movs	r2, #15
24007c90:	fa02 f303 	lsl.w	r3, r2, r3
24007c94:	43db      	mvns	r3, r3
24007c96:	69ba      	ldr	r2, [r7, #24]
24007c98:	4013      	ands	r3, r2
24007c9a:	61bb      	str	r3, [r7, #24]
      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
24007c9c:	683b      	ldr	r3, [r7, #0]
24007c9e:	68da      	ldr	r2, [r3, #12]
24007ca0:	68fb      	ldr	r3, [r7, #12]
24007ca2:	f003 0303 	and.w	r3, r3, #3
24007ca6:	009b      	lsls	r3, r3, #2
24007ca8:	fa02 f303 	lsl.w	r3, r2, r3
24007cac:	69ba      	ldr	r2, [r7, #24]
24007cae:	4313      	orrs	r3, r2
24007cb0:	61bb      	str	r3, [r7, #24]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
24007cb2:	494e      	ldr	r1, [pc, #312]	; (24007dec <HAL_EXTI_SetConfigLine+0x240>)
24007cb4:	68fb      	ldr	r3, [r7, #12]
24007cb6:	089b      	lsrs	r3, r3, #2
24007cb8:	f003 0303 	and.w	r3, r3, #3
24007cbc:	3302      	adds	r3, #2
24007cbe:	69ba      	ldr	r2, [r7, #24]
24007cc0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* Configure interrupt mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24007cc4:	693b      	ldr	r3, [r7, #16]
24007cc6:	011a      	lsls	r2, r3, #4
24007cc8:	4b49      	ldr	r3, [pc, #292]	; (24007df0 <HAL_EXTI_SetConfigLine+0x244>)
24007cca:	4413      	add	r3, r2
24007ccc:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24007cce:	69fb      	ldr	r3, [r7, #28]
24007cd0:	681b      	ldr	r3, [r3, #0]
24007cd2:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00U)
24007cd4:	683b      	ldr	r3, [r7, #0]
24007cd6:	685b      	ldr	r3, [r3, #4]
24007cd8:	f003 0301 	and.w	r3, r3, #1
24007cdc:	2b00      	cmp	r3, #0
24007cde:	d004      	beq.n	24007cea <HAL_EXTI_SetConfigLine+0x13e>
  {
    regval |= maskline;
24007ce0:	69ba      	ldr	r2, [r7, #24]
24007ce2:	68bb      	ldr	r3, [r7, #8]
24007ce4:	4313      	orrs	r3, r2
24007ce6:	61bb      	str	r3, [r7, #24]
24007ce8:	e004      	b.n	24007cf4 <HAL_EXTI_SetConfigLine+0x148>
  }
  else
  {
    regval &= ~maskline;
24007cea:	68bb      	ldr	r3, [r7, #8]
24007cec:	43db      	mvns	r3, r3
24007cee:	69ba      	ldr	r2, [r7, #24]
24007cf0:	4013      	ands	r3, r2
24007cf2:	61bb      	str	r3, [r7, #24]
  }

  /* Store interrupt mode */
  *regaddr = regval;
24007cf4:	69fb      	ldr	r3, [r7, #28]
24007cf6:	69ba      	ldr	r2, [r7, #24]
24007cf8:	601a      	str	r2, [r3, #0]

  /* The event mode cannot be configured if the line does not support it */
  assert_param(((pExtiConfig->Line & EXTI_EVENT) == EXTI_EVENT) || ((pExtiConfig->Mode & EXTI_MODE_EVENT) != EXTI_MODE_EVENT));

  /* Configure event mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
24007cfa:	693b      	ldr	r3, [r7, #16]
24007cfc:	011a      	lsls	r2, r3, #4
24007cfe:	4b3d      	ldr	r3, [pc, #244]	; (24007df4 <HAL_EXTI_SetConfigLine+0x248>)
24007d00:	4413      	add	r3, r2
24007d02:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24007d04:	69fb      	ldr	r3, [r7, #28]
24007d06:	681b      	ldr	r3, [r3, #0]
24007d08:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00U)
24007d0a:	683b      	ldr	r3, [r7, #0]
24007d0c:	685b      	ldr	r3, [r3, #4]
24007d0e:	f003 0302 	and.w	r3, r3, #2
24007d12:	2b00      	cmp	r3, #0
24007d14:	d004      	beq.n	24007d20 <HAL_EXTI_SetConfigLine+0x174>
  {
    regval |= maskline;
24007d16:	69ba      	ldr	r2, [r7, #24]
24007d18:	68bb      	ldr	r3, [r7, #8]
24007d1a:	4313      	orrs	r3, r2
24007d1c:	61bb      	str	r3, [r7, #24]
24007d1e:	e004      	b.n	24007d2a <HAL_EXTI_SetConfigLine+0x17e>
  }
  else
  {
    regval &= ~maskline;
24007d20:	68bb      	ldr	r3, [r7, #8]
24007d22:	43db      	mvns	r3, r3
24007d24:	69ba      	ldr	r2, [r7, #24]
24007d26:	4013      	ands	r3, r2
24007d28:	61bb      	str	r3, [r7, #24]
  }

  /* Store event mode */
  *regaddr = regval;
24007d2a:	69fb      	ldr	r3, [r7, #28]
24007d2c:	69ba      	ldr	r2, [r7, #24]
24007d2e:	601a      	str	r2, [r3, #0]
  /* Store event mode */
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* Configure the D3 PendClear source in case of Wakeup target is Any */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24007d30:	683b      	ldr	r3, [r7, #0]
24007d32:	681b      	ldr	r3, [r3, #0]
24007d34:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
24007d38:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24007d3c:	d14c      	bne.n	24007dd8 <HAL_EXTI_SetConfigLine+0x22c>
  {
    assert_param(IS_EXTI_D3_PENDCLR_SRC(pExtiConfig->PendClearSource));

    /*Calc the PMR register address for the given line */
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
24007d3e:	693b      	ldr	r3, [r7, #16]
24007d40:	015a      	lsls	r2, r3, #5
24007d42:	4b2d      	ldr	r3, [pc, #180]	; (24007df8 <HAL_EXTI_SetConfigLine+0x24c>)
24007d44:	4413      	add	r3, r2
24007d46:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24007d48:	69fb      	ldr	r3, [r7, #28]
24007d4a:	681b      	ldr	r3, [r3, #0]
24007d4c:	61bb      	str	r3, [r7, #24]

    if(pExtiConfig->PendClearSource == EXTI_D3_PENDCLR_SRC_NONE)
24007d4e:	683b      	ldr	r3, [r7, #0]
24007d50:	691b      	ldr	r3, [r3, #16]
24007d52:	2b00      	cmp	r3, #0
24007d54:	d108      	bne.n	24007d68 <HAL_EXTI_SetConfigLine+0x1bc>
    {
      /* Clear D3PMRx register for the given line */
      regval &= ~maskline;
24007d56:	68bb      	ldr	r3, [r7, #8]
24007d58:	43db      	mvns	r3, r3
24007d5a:	69ba      	ldr	r2, [r7, #24]
24007d5c:	4013      	ands	r3, r2
24007d5e:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
24007d60:	69fb      	ldr	r3, [r7, #28]
24007d62:	69ba      	ldr	r2, [r7, #24]
24007d64:	601a      	str	r2, [r3, #0]
24007d66:	e037      	b.n	24007dd8 <HAL_EXTI_SetConfigLine+0x22c>
    }
    else
    {
      /* Set D3PMRx register to 1 for the given line */
      regval |= maskline;
24007d68:	69ba      	ldr	r2, [r7, #24]
24007d6a:	68bb      	ldr	r3, [r7, #8]
24007d6c:	4313      	orrs	r3, r2
24007d6e:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
24007d70:	69fb      	ldr	r3, [r7, #28]
24007d72:	69ba      	ldr	r2, [r7, #24]
24007d74:	601a      	str	r2, [r3, #0]

      if(linepos < 16UL)
24007d76:	68fb      	ldr	r3, [r7, #12]
24007d78:	2b0f      	cmp	r3, #15
24007d7a:	d80a      	bhi.n	24007d92 <HAL_EXTI_SetConfigLine+0x1e6>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
24007d7c:	693b      	ldr	r3, [r7, #16]
24007d7e:	015a      	lsls	r2, r3, #5
24007d80:	4b1e      	ldr	r3, [pc, #120]	; (24007dfc <HAL_EXTI_SetConfigLine+0x250>)
24007d82:	4413      	add	r3, r2
24007d84:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
24007d86:	2201      	movs	r2, #1
24007d88:	68fb      	ldr	r3, [r7, #12]
24007d8a:	fa02 f303 	lsl.w	r3, r2, r3
24007d8e:	617b      	str	r3, [r7, #20]
24007d90:	e00a      	b.n	24007da8 <HAL_EXTI_SetConfigLine+0x1fc>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
24007d92:	693b      	ldr	r3, [r7, #16]
24007d94:	015a      	lsls	r2, r3, #5
24007d96:	4b1a      	ldr	r3, [pc, #104]	; (24007e00 <HAL_EXTI_SetConfigLine+0x254>)
24007d98:	4413      	add	r3, r2
24007d9a:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
24007d9c:	68fb      	ldr	r3, [r7, #12]
24007d9e:	3b10      	subs	r3, #16
24007da0:	2201      	movs	r2, #1
24007da2:	fa02 f303 	lsl.w	r3, r2, r3
24007da6:	617b      	str	r3, [r7, #20]
      }

      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));
24007da8:	69fb      	ldr	r3, [r7, #28]
24007daa:	6819      	ldr	r1, [r3, #0]
24007dac:	697b      	ldr	r3, [r7, #20]
24007dae:	fb03 f203 	mul.w	r2, r3, r3
24007db2:	4613      	mov	r3, r2
24007db4:	005b      	lsls	r3, r3, #1
24007db6:	4413      	add	r3, r2
24007db8:	43db      	mvns	r3, r3
24007dba:	ea01 0203 	and.w	r2, r1, r3
24007dbe:	697b      	ldr	r3, [r7, #20]
24007dc0:	fb03 f303 	mul.w	r3, r3, r3
24007dc4:	6839      	ldr	r1, [r7, #0]
24007dc6:	6909      	ldr	r1, [r1, #16]
24007dc8:	3901      	subs	r1, #1
24007dca:	fb01 f303 	mul.w	r3, r1, r3
24007dce:	4313      	orrs	r3, r2
24007dd0:	61bb      	str	r3, [r7, #24]
      *regaddr = regval;
24007dd2:	69fb      	ldr	r3, [r7, #28]
24007dd4:	69ba      	ldr	r2, [r7, #24]
24007dd6:	601a      	str	r2, [r3, #0]
    }
  }

  return HAL_OK;
24007dd8:	2300      	movs	r3, #0
}
24007dda:	4618      	mov	r0, r3
24007ddc:	3724      	adds	r7, #36	; 0x24
24007dde:	46bd      	mov	sp, r7
24007de0:	f85d 7b04 	ldr.w	r7, [sp], #4
24007de4:	4770      	bx	lr
24007de6:	bf00      	nop
24007de8:	58000004 	.word	0x58000004
24007dec:	58000400 	.word	0x58000400
24007df0:	58000080 	.word	0x58000080
24007df4:	58000084 	.word	0x58000084
24007df8:	5800000c 	.word	0x5800000c
24007dfc:	58000010 	.word	0x58000010
24007e00:	58000014 	.word	0x58000014

24007e04 <HAL_EXTI_GetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on structure to store Exti configuration.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
24007e04:	b480      	push	{r7}
24007e06:	b089      	sub	sp, #36	; 0x24
24007e08:	af00      	add	r7, sp, #0
24007e0a:	6078      	str	r0, [r7, #4]
24007e0c:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
24007e0e:	687b      	ldr	r3, [r7, #4]
24007e10:	2b00      	cmp	r3, #0
24007e12:	d002      	beq.n	24007e1a <HAL_EXTI_GetConfigLine+0x16>
24007e14:	683b      	ldr	r3, [r7, #0]
24007e16:	2b00      	cmp	r3, #0
24007e18:	d101      	bne.n	24007e1e <HAL_EXTI_GetConfigLine+0x1a>
  {
    return HAL_ERROR;
24007e1a:	2301      	movs	r3, #1
24007e1c:	e0c4      	b.n	24007fa8 <HAL_EXTI_GetConfigLine+0x1a4>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* Store handle line number to configuration structure */
  pExtiConfig->Line = hexti->Line;
24007e1e:	687b      	ldr	r3, [r7, #4]
24007e20:	681a      	ldr	r2, [r3, #0]
24007e22:	683b      	ldr	r3, [r7, #0]
24007e24:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24007e26:	683b      	ldr	r3, [r7, #0]
24007e28:	681b      	ldr	r3, [r3, #0]
24007e2a:	0c1b      	lsrs	r3, r3, #16
24007e2c:	f003 0303 	and.w	r3, r3, #3
24007e30:	617b      	str	r3, [r7, #20]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
24007e32:	683b      	ldr	r3, [r7, #0]
24007e34:	681b      	ldr	r3, [r3, #0]
24007e36:	f003 031f 	and.w	r3, r3, #31
24007e3a:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
24007e3c:	2201      	movs	r2, #1
24007e3e:	693b      	ldr	r3, [r7, #16]
24007e40:	fa02 f303 	lsl.w	r3, r2, r3
24007e44:	60fb      	str	r3, [r7, #12]

  /* 1] Get core mode : interrupt */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24007e46:	697b      	ldr	r3, [r7, #20]
24007e48:	011a      	lsls	r2, r3, #4
24007e4a:	4b5a      	ldr	r3, [pc, #360]	; (24007fb4 <HAL_EXTI_GetConfigLine+0x1b0>)
24007e4c:	4413      	add	r3, r2
24007e4e:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24007e50:	69fb      	ldr	r3, [r7, #28]
24007e52:	681b      	ldr	r3, [r3, #0]
24007e54:	60bb      	str	r3, [r7, #8]

  pExtiConfig->Mode = EXTI_MODE_NONE;
24007e56:	683b      	ldr	r3, [r7, #0]
24007e58:	2200      	movs	r2, #0
24007e5a:	605a      	str	r2, [r3, #4]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
24007e5c:	68ba      	ldr	r2, [r7, #8]
24007e5e:	68fb      	ldr	r3, [r7, #12]
24007e60:	4013      	ands	r3, r2
24007e62:	2b00      	cmp	r3, #0
24007e64:	d002      	beq.n	24007e6c <HAL_EXTI_GetConfigLine+0x68>
  {
    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
24007e66:	683b      	ldr	r3, [r7, #0]
24007e68:	2201      	movs	r2, #1
24007e6a:	605a      	str	r2, [r3, #4]
  }

  /* Get event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
24007e6c:	697b      	ldr	r3, [r7, #20]
24007e6e:	011a      	lsls	r2, r3, #4
24007e70:	4b51      	ldr	r3, [pc, #324]	; (24007fb8 <HAL_EXTI_GetConfigLine+0x1b4>)
24007e72:	4413      	add	r3, r2
24007e74:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24007e76:	69fb      	ldr	r3, [r7, #28]
24007e78:	681b      	ldr	r3, [r3, #0]
24007e7a:	60bb      	str	r3, [r7, #8]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
24007e7c:	68ba      	ldr	r2, [r7, #8]
24007e7e:	68fb      	ldr	r3, [r7, #12]
24007e80:	4013      	ands	r3, r2
24007e82:	2b00      	cmp	r3, #0
24007e84:	d005      	beq.n	24007e92 <HAL_EXTI_GetConfigLine+0x8e>
  {
    pExtiConfig->Mode |= EXTI_MODE_EVENT;
24007e86:	683b      	ldr	r3, [r7, #0]
24007e88:	685b      	ldr	r3, [r3, #4]
24007e8a:	f043 0202 	orr.w	r2, r3, #2
24007e8e:	683b      	ldr	r3, [r7, #0]
24007e90:	605a      	str	r2, [r3, #4]
    pExtiConfig->Mode |= EXTI_MODE_CORE2_EVENT;
  }
#endif /*DUAL_CORE*/

  /* Get default Trigger and GPIOSel configuration */
  pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
24007e92:	683b      	ldr	r3, [r7, #0]
24007e94:	2200      	movs	r2, #0
24007e96:	609a      	str	r2, [r3, #8]
  pExtiConfig->GPIOSel = 0x00U;
24007e98:	683b      	ldr	r3, [r7, #0]
24007e9a:	2200      	movs	r2, #0
24007e9c:	60da      	str	r2, [r3, #12]

  /* 2] Get trigger for configurable lines : rising */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
24007e9e:	683b      	ldr	r3, [r7, #0]
24007ea0:	681b      	ldr	r3, [r3, #0]
24007ea2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24007ea6:	2b00      	cmp	r3, #0
24007ea8:	d03d      	beq.n	24007f26 <HAL_EXTI_GetConfigLine+0x122>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24007eaa:	697b      	ldr	r3, [r7, #20]
24007eac:	015b      	lsls	r3, r3, #5
24007eae:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
24007eb2:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24007eb4:	69fb      	ldr	r3, [r7, #28]
24007eb6:	681b      	ldr	r3, [r3, #0]
24007eb8:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
24007eba:	68ba      	ldr	r2, [r7, #8]
24007ebc:	68fb      	ldr	r3, [r7, #12]
24007ebe:	4013      	ands	r3, r2
24007ec0:	2b00      	cmp	r3, #0
24007ec2:	d002      	beq.n	24007eca <HAL_EXTI_GetConfigLine+0xc6>
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
24007ec4:	683b      	ldr	r3, [r7, #0]
24007ec6:	2201      	movs	r2, #1
24007ec8:	609a      	str	r2, [r3, #8]
    }

    /* Get falling configuration */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
24007eca:	697b      	ldr	r3, [r7, #20]
24007ecc:	015a      	lsls	r2, r3, #5
24007ece:	4b3b      	ldr	r3, [pc, #236]	; (24007fbc <HAL_EXTI_GetConfigLine+0x1b8>)
24007ed0:	4413      	add	r3, r2
24007ed2:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24007ed4:	69fb      	ldr	r3, [r7, #28]
24007ed6:	681b      	ldr	r3, [r3, #0]
24007ed8:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
24007eda:	68ba      	ldr	r2, [r7, #8]
24007edc:	68fb      	ldr	r3, [r7, #12]
24007ede:	4013      	ands	r3, r2
24007ee0:	2b00      	cmp	r3, #0
24007ee2:	d005      	beq.n	24007ef0 <HAL_EXTI_GetConfigLine+0xec>
    {
      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
24007ee4:	683b      	ldr	r3, [r7, #0]
24007ee6:	689b      	ldr	r3, [r3, #8]
24007ee8:	f043 0202 	orr.w	r2, r3, #2
24007eec:	683b      	ldr	r3, [r7, #0]
24007eee:	609a      	str	r2, [r3, #8]
    }

    /* Get Gpio port selection for gpio lines */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
24007ef0:	683b      	ldr	r3, [r7, #0]
24007ef2:	681b      	ldr	r3, [r3, #0]
24007ef4:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
24007ef8:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
24007efc:	d113      	bne.n	24007f26 <HAL_EXTI_GetConfigLine+0x122>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24007efe:	4a30      	ldr	r2, [pc, #192]	; (24007fc0 <HAL_EXTI_GetConfigLine+0x1bc>)
24007f00:	693b      	ldr	r3, [r7, #16]
24007f02:	089b      	lsrs	r3, r3, #2
24007f04:	f003 0303 	and.w	r3, r3, #3
24007f08:	3302      	adds	r3, #2
24007f0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24007f0e:	60bb      	str	r3, [r7, #8]
      pExtiConfig->GPIOSel = (regval >> (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u))) & SYSCFG_EXTICR1_EXTI0;
24007f10:	693b      	ldr	r3, [r7, #16]
24007f12:	f003 0303 	and.w	r3, r3, #3
24007f16:	009b      	lsls	r3, r3, #2
24007f18:	68ba      	ldr	r2, [r7, #8]
24007f1a:	fa22 f303 	lsr.w	r3, r2, r3
24007f1e:	f003 020f 	and.w	r2, r3, #15
24007f22:	683b      	ldr	r3, [r7, #0]
24007f24:	60da      	str	r2, [r3, #12]
    }
  }

  /* Get default Pend Clear Source */
  pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
24007f26:	683b      	ldr	r3, [r7, #0]
24007f28:	2200      	movs	r2, #0
24007f2a:	611a      	str	r2, [r3, #16]

  /* 3] Get D3 Pend Clear source */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24007f2c:	683b      	ldr	r3, [r7, #0]
24007f2e:	681b      	ldr	r3, [r3, #0]
24007f30:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
24007f34:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24007f38:	d135      	bne.n	24007fa6 <HAL_EXTI_GetConfigLine+0x1a2>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
24007f3a:	697b      	ldr	r3, [r7, #20]
24007f3c:	015a      	lsls	r2, r3, #5
24007f3e:	4b21      	ldr	r3, [pc, #132]	; (24007fc4 <HAL_EXTI_GetConfigLine+0x1c0>)
24007f40:	4413      	add	r3, r2
24007f42:	61fb      	str	r3, [r7, #28]
    if(((*regaddr) & linepos) != 0UL)
24007f44:	69fb      	ldr	r3, [r7, #28]
24007f46:	681a      	ldr	r2, [r3, #0]
24007f48:	693b      	ldr	r3, [r7, #16]
24007f4a:	4013      	ands	r3, r2
24007f4c:	2b00      	cmp	r3, #0
24007f4e:	d02a      	beq.n	24007fa6 <HAL_EXTI_GetConfigLine+0x1a2>
    {
      /* if wakeup target is any and PMR set, the read pend clear source from  D3PCRxL/H */
      if(linepos < 16UL)
24007f50:	693b      	ldr	r3, [r7, #16]
24007f52:	2b0f      	cmp	r3, #15
24007f54:	d80a      	bhi.n	24007f6c <HAL_EXTI_GetConfigLine+0x168>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
24007f56:	697b      	ldr	r3, [r7, #20]
24007f58:	015a      	lsls	r2, r3, #5
24007f5a:	4b1b      	ldr	r3, [pc, #108]	; (24007fc8 <HAL_EXTI_GetConfigLine+0x1c4>)
24007f5c:	4413      	add	r3, r2
24007f5e:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
24007f60:	2201      	movs	r2, #1
24007f62:	693b      	ldr	r3, [r7, #16]
24007f64:	fa02 f303 	lsl.w	r3, r2, r3
24007f68:	61bb      	str	r3, [r7, #24]
24007f6a:	e00a      	b.n	24007f82 <HAL_EXTI_GetConfigLine+0x17e>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
24007f6c:	697b      	ldr	r3, [r7, #20]
24007f6e:	015a      	lsls	r2, r3, #5
24007f70:	4b16      	ldr	r3, [pc, #88]	; (24007fcc <HAL_EXTI_GetConfigLine+0x1c8>)
24007f72:	4413      	add	r3, r2
24007f74:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
24007f76:	693b      	ldr	r3, [r7, #16]
24007f78:	3b10      	subs	r3, #16
24007f7a:	2201      	movs	r2, #1
24007f7c:	fa02 f303 	lsl.w	r3, r2, r3
24007f80:	61bb      	str	r3, [r7, #24]
      }

      pExtiConfig->PendClearSource = 1UL + ((*regaddr & (pcrlinepos * pcrlinepos * 3UL)) / (pcrlinepos * pcrlinepos));
24007f82:	69fb      	ldr	r3, [r7, #28]
24007f84:	6819      	ldr	r1, [r3, #0]
24007f86:	69bb      	ldr	r3, [r7, #24]
24007f88:	fb03 f203 	mul.w	r2, r3, r3
24007f8c:	4613      	mov	r3, r2
24007f8e:	005b      	lsls	r3, r3, #1
24007f90:	4413      	add	r3, r2
24007f92:	ea01 0203 	and.w	r2, r1, r3
24007f96:	69bb      	ldr	r3, [r7, #24]
24007f98:	fb03 f303 	mul.w	r3, r3, r3
24007f9c:	fbb2 f3f3 	udiv	r3, r2, r3
24007fa0:	1c5a      	adds	r2, r3, #1
24007fa2:	683b      	ldr	r3, [r7, #0]
24007fa4:	611a      	str	r2, [r3, #16]
    }
  }

  return HAL_OK;
24007fa6:	2300      	movs	r3, #0
}
24007fa8:	4618      	mov	r0, r3
24007faa:	3724      	adds	r7, #36	; 0x24
24007fac:	46bd      	mov	sp, r7
24007fae:	f85d 7b04 	ldr.w	r7, [sp], #4
24007fb2:	4770      	bx	lr
24007fb4:	58000080 	.word	0x58000080
24007fb8:	58000084 	.word	0x58000084
24007fbc:	58000004 	.word	0x58000004
24007fc0:	58000400 	.word	0x58000400
24007fc4:	5800000c 	.word	0x5800000c
24007fc8:	58000010 	.word	0x58000010
24007fcc:	58000014 	.word	0x58000014

24007fd0 <HAL_EXTI_ClearConfigLine>:
  * @brief  Clear whole configuration of a dedicated Exti line.
  * @param  hexti Exti handle.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
{
24007fd0:	b480      	push	{r7}
24007fd2:	b089      	sub	sp, #36	; 0x24
24007fd4:	af00      	add	r7, sp, #0
24007fd6:	6078      	str	r0, [r7, #4]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if (hexti == NULL)
24007fd8:	687b      	ldr	r3, [r7, #4]
24007fda:	2b00      	cmp	r3, #0
24007fdc:	d101      	bne.n	24007fe2 <HAL_EXTI_ClearConfigLine+0x12>
  {
    return HAL_ERROR;
24007fde:	2301      	movs	r3, #1
24007fe0:	e0ab      	b.n	2400813a <HAL_EXTI_ClearConfigLine+0x16a>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24007fe2:	687b      	ldr	r3, [r7, #4]
24007fe4:	681b      	ldr	r3, [r3, #0]
24007fe6:	0c1b      	lsrs	r3, r3, #16
24007fe8:	f003 0303 	and.w	r3, r3, #3
24007fec:	617b      	str	r3, [r7, #20]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24007fee:	687b      	ldr	r3, [r7, #4]
24007ff0:	681b      	ldr	r3, [r3, #0]
24007ff2:	f003 031f 	and.w	r3, r3, #31
24007ff6:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
24007ff8:	2201      	movs	r2, #1
24007ffa:	693b      	ldr	r3, [r7, #16]
24007ffc:	fa02 f303 	lsl.w	r3, r2, r3
24008000:	60fb      	str	r3, [r7, #12]

  /* 1] Clear interrupt mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24008002:	697b      	ldr	r3, [r7, #20]
24008004:	011a      	lsls	r2, r3, #4
24008006:	4b50      	ldr	r3, [pc, #320]	; (24008148 <HAL_EXTI_ClearConfigLine+0x178>)
24008008:	4413      	add	r3, r2
2400800a:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
2400800c:	69fb      	ldr	r3, [r7, #28]
2400800e:	681a      	ldr	r2, [r3, #0]
24008010:	68fb      	ldr	r3, [r7, #12]
24008012:	43db      	mvns	r3, r3
24008014:	4013      	ands	r3, r2
24008016:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
24008018:	69fb      	ldr	r3, [r7, #28]
2400801a:	68ba      	ldr	r2, [r7, #8]
2400801c:	601a      	str	r2, [r3, #0]

  /* 2] Clear event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
2400801e:	697b      	ldr	r3, [r7, #20]
24008020:	011a      	lsls	r2, r3, #4
24008022:	4b4a      	ldr	r3, [pc, #296]	; (2400814c <HAL_EXTI_ClearConfigLine+0x17c>)
24008024:	4413      	add	r3, r2
24008026:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
24008028:	69fb      	ldr	r3, [r7, #28]
2400802a:	681a      	ldr	r2, [r3, #0]
2400802c:	68fb      	ldr	r3, [r7, #12]
2400802e:	43db      	mvns	r3, r3
24008030:	4013      	ands	r3, r2
24008032:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
24008034:	69fb      	ldr	r3, [r7, #28]
24008036:	68ba      	ldr	r2, [r7, #8]
24008038:	601a      	str	r2, [r3, #0]
  regval = (*regaddr & ~maskline);
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* 3] Clear triggers in case of configurable lines */
  if ((hexti->Line & EXTI_CONFIG) != 0x00U)
2400803a:	687b      	ldr	r3, [r7, #4]
2400803c:	681b      	ldr	r3, [r3, #0]
2400803e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24008042:	2b00      	cmp	r3, #0
24008044:	d03f      	beq.n	240080c6 <HAL_EXTI_ClearConfigLine+0xf6>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24008046:	697b      	ldr	r3, [r7, #20]
24008048:	015b      	lsls	r3, r3, #5
2400804a:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
2400804e:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
24008050:	69fb      	ldr	r3, [r7, #28]
24008052:	681a      	ldr	r2, [r3, #0]
24008054:	68fb      	ldr	r3, [r7, #12]
24008056:	43db      	mvns	r3, r3
24008058:	4013      	ands	r3, r2
2400805a:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
2400805c:	69fb      	ldr	r3, [r7, #28]
2400805e:	68ba      	ldr	r2, [r7, #8]
24008060:	601a      	str	r2, [r3, #0]

    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
24008062:	697b      	ldr	r3, [r7, #20]
24008064:	015a      	lsls	r2, r3, #5
24008066:	4b3a      	ldr	r3, [pc, #232]	; (24008150 <HAL_EXTI_ClearConfigLine+0x180>)
24008068:	4413      	add	r3, r2
2400806a:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
2400806c:	69fb      	ldr	r3, [r7, #28]
2400806e:	681a      	ldr	r2, [r3, #0]
24008070:	68fb      	ldr	r3, [r7, #12]
24008072:	43db      	mvns	r3, r3
24008074:	4013      	ands	r3, r2
24008076:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
24008078:	69fb      	ldr	r3, [r7, #28]
2400807a:	68ba      	ldr	r2, [r7, #8]
2400807c:	601a      	str	r2, [r3, #0]

    /* Get Gpio port selection for gpio lines */
    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
2400807e:	687b      	ldr	r3, [r7, #4]
24008080:	681b      	ldr	r3, [r3, #0]
24008082:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
24008086:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
2400808a:	d11c      	bne.n	240080c6 <HAL_EXTI_ClearConfigLine+0xf6>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
2400808c:	4a31      	ldr	r2, [pc, #196]	; (24008154 <HAL_EXTI_ClearConfigLine+0x184>)
2400808e:	693b      	ldr	r3, [r7, #16]
24008090:	089b      	lsrs	r3, r3, #2
24008092:	f003 0303 	and.w	r3, r3, #3
24008096:	3302      	adds	r3, #2
24008098:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2400809c:	60bb      	str	r3, [r7, #8]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));
2400809e:	693b      	ldr	r3, [r7, #16]
240080a0:	f003 0303 	and.w	r3, r3, #3
240080a4:	009b      	lsls	r3, r3, #2
240080a6:	220f      	movs	r2, #15
240080a8:	fa02 f303 	lsl.w	r3, r2, r3
240080ac:	43db      	mvns	r3, r3
240080ae:	68ba      	ldr	r2, [r7, #8]
240080b0:	4013      	ands	r3, r2
240080b2:	60bb      	str	r3, [r7, #8]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
240080b4:	4927      	ldr	r1, [pc, #156]	; (24008154 <HAL_EXTI_ClearConfigLine+0x184>)
240080b6:	693b      	ldr	r3, [r7, #16]
240080b8:	089b      	lsrs	r3, r3, #2
240080ba:	f003 0303 	and.w	r3, r3, #3
240080be:	3302      	adds	r3, #2
240080c0:	68ba      	ldr	r2, [r7, #8]
240080c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* 4] Clear D3 Config lines */
  if ((hexti->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
240080c6:	687b      	ldr	r3, [r7, #4]
240080c8:	681b      	ldr	r3, [r3, #0]
240080ca:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
240080ce:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
240080d2:	d131      	bne.n	24008138 <HAL_EXTI_ClearConfigLine+0x168>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
240080d4:	697b      	ldr	r3, [r7, #20]
240080d6:	015a      	lsls	r2, r3, #5
240080d8:	4b1f      	ldr	r3, [pc, #124]	; (24008158 <HAL_EXTI_ClearConfigLine+0x188>)
240080da:	4413      	add	r3, r2
240080dc:	61fb      	str	r3, [r7, #28]
    *regaddr = (*regaddr & ~maskline);
240080de:	69fb      	ldr	r3, [r7, #28]
240080e0:	681a      	ldr	r2, [r3, #0]
240080e2:	68fb      	ldr	r3, [r7, #12]
240080e4:	43db      	mvns	r3, r3
240080e6:	401a      	ands	r2, r3
240080e8:	69fb      	ldr	r3, [r7, #28]
240080ea:	601a      	str	r2, [r3, #0]

    if(linepos < 16UL)
240080ec:	693b      	ldr	r3, [r7, #16]
240080ee:	2b0f      	cmp	r3, #15
240080f0:	d80a      	bhi.n	24008108 <HAL_EXTI_ClearConfigLine+0x138>
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
240080f2:	697b      	ldr	r3, [r7, #20]
240080f4:	015a      	lsls	r2, r3, #5
240080f6:	4b19      	ldr	r3, [pc, #100]	; (2400815c <HAL_EXTI_ClearConfigLine+0x18c>)
240080f8:	4413      	add	r3, r2
240080fa:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << linepos;
240080fc:	2201      	movs	r2, #1
240080fe:	693b      	ldr	r3, [r7, #16]
24008100:	fa02 f303 	lsl.w	r3, r2, r3
24008104:	61bb      	str	r3, [r7, #24]
24008106:	e00a      	b.n	2400811e <HAL_EXTI_ClearConfigLine+0x14e>
    }
    else
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
24008108:	697b      	ldr	r3, [r7, #20]
2400810a:	015a      	lsls	r2, r3, #5
2400810c:	4b14      	ldr	r3, [pc, #80]	; (24008160 <HAL_EXTI_ClearConfigLine+0x190>)
2400810e:	4413      	add	r3, r2
24008110:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << (linepos - 16UL);
24008112:	693b      	ldr	r3, [r7, #16]
24008114:	3b10      	subs	r3, #16
24008116:	2201      	movs	r2, #1
24008118:	fa02 f303 	lsl.w	r3, r2, r3
2400811c:	61bb      	str	r3, [r7, #24]
    }

    /*Clear D3 PendClear source */
    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));
2400811e:	69fb      	ldr	r3, [r7, #28]
24008120:	6819      	ldr	r1, [r3, #0]
24008122:	69bb      	ldr	r3, [r7, #24]
24008124:	fb03 f203 	mul.w	r2, r3, r3
24008128:	4613      	mov	r3, r2
2400812a:	005b      	lsls	r3, r3, #1
2400812c:	4413      	add	r3, r2
2400812e:	43db      	mvns	r3, r3
24008130:	ea01 0203 	and.w	r2, r1, r3
24008134:	69fb      	ldr	r3, [r7, #28]
24008136:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
24008138:	2300      	movs	r3, #0
}
2400813a:	4618      	mov	r0, r3
2400813c:	3724      	adds	r7, #36	; 0x24
2400813e:	46bd      	mov	sp, r7
24008140:	f85d 7b04 	ldr.w	r7, [sp], #4
24008144:	4770      	bx	lr
24008146:	bf00      	nop
24008148:	58000080 	.word	0x58000080
2400814c:	58000084 	.word	0x58000084
24008150:	58000004 	.word	0x58000004
24008154:	58000400 	.word	0x58000400
24008158:	5800000c 	.word	0x5800000c
2400815c:	58000010 	.word	0x58000010
24008160:	58000014 	.word	0x58000014

24008164 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
24008164:	b480      	push	{r7}
24008166:	b087      	sub	sp, #28
24008168:	af00      	add	r7, sp, #0
2400816a:	60f8      	str	r0, [r7, #12]
2400816c:	460b      	mov	r3, r1
2400816e:	607a      	str	r2, [r7, #4]
24008170:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
24008172:	2300      	movs	r3, #0
24008174:	75fb      	strb	r3, [r7, #23]

  /* Check null pointer */
  if (hexti == NULL)
24008176:	68fb      	ldr	r3, [r7, #12]
24008178:	2b00      	cmp	r3, #0
2400817a:	d101      	bne.n	24008180 <HAL_EXTI_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
2400817c:	2301      	movs	r3, #1
2400817e:	e00a      	b.n	24008196 <HAL_EXTI_RegisterCallback+0x32>
  }

  switch (CallbackID)
24008180:	7afb      	ldrb	r3, [r7, #11]
24008182:	2b00      	cmp	r3, #0
24008184:	d103      	bne.n	2400818e <HAL_EXTI_RegisterCallback+0x2a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
24008186:	68fb      	ldr	r3, [r7, #12]
24008188:	687a      	ldr	r2, [r7, #4]
2400818a:	605a      	str	r2, [r3, #4]
      break;
2400818c:	e002      	b.n	24008194 <HAL_EXTI_RegisterCallback+0x30>

    default:
      status = HAL_ERROR;
2400818e:	2301      	movs	r3, #1
24008190:	75fb      	strb	r3, [r7, #23]
      break;
24008192:	bf00      	nop
  }

  return status;
24008194:	7dfb      	ldrb	r3, [r7, #23]
}
24008196:	4618      	mov	r0, r3
24008198:	371c      	adds	r7, #28
2400819a:	46bd      	mov	sp, r7
2400819c:	f85d 7b04 	ldr.w	r7, [sp], #4
240081a0:	4770      	bx	lr

240081a2 <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
240081a2:	b480      	push	{r7}
240081a4:	b083      	sub	sp, #12
240081a6:	af00      	add	r7, sp, #0
240081a8:	6078      	str	r0, [r7, #4]
240081aa:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
240081ac:	687b      	ldr	r3, [r7, #4]
240081ae:	2b00      	cmp	r3, #0
240081b0:	d101      	bne.n	240081b6 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
240081b2:	2301      	movs	r3, #1
240081b4:	e003      	b.n	240081be <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
240081b6:	687b      	ldr	r3, [r7, #4]
240081b8:	683a      	ldr	r2, [r7, #0]
240081ba:	601a      	str	r2, [r3, #0]

    return HAL_OK;
240081bc:	2300      	movs	r3, #0
  }
}
240081be:	4618      	mov	r0, r3
240081c0:	370c      	adds	r7, #12
240081c2:	46bd      	mov	sp, r7
240081c4:	f85d 7b04 	ldr.w	r7, [sp], #4
240081c8:	4770      	bx	lr
	...

240081cc <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
240081cc:	b580      	push	{r7, lr}
240081ce:	b086      	sub	sp, #24
240081d0:	af00      	add	r7, sp, #0
240081d2:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240081d4:	687b      	ldr	r3, [r7, #4]
240081d6:	681b      	ldr	r3, [r3, #0]
240081d8:	0c1b      	lsrs	r3, r3, #16
240081da:	f003 0303 	and.w	r3, r3, #3
240081de:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
240081e0:	687b      	ldr	r3, [r7, #4]
240081e2:	681b      	ldr	r3, [r3, #0]
240081e4:	f003 031f 	and.w	r3, r3, #31
240081e8:	2201      	movs	r2, #1
240081ea:	fa02 f303 	lsl.w	r3, r2, r3
240081ee:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
240081f0:	697b      	ldr	r3, [r7, #20]
240081f2:	011a      	lsls	r2, r3, #4
240081f4:	4b0c      	ldr	r3, [pc, #48]	; (24008228 <HAL_EXTI_IRQHandler+0x5c>)
240081f6:	4413      	add	r3, r2
240081f8:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
240081fa:	68fb      	ldr	r3, [r7, #12]
240081fc:	681b      	ldr	r3, [r3, #0]
240081fe:	693a      	ldr	r2, [r7, #16]
24008200:	4013      	ands	r3, r2
24008202:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00U)
24008204:	68bb      	ldr	r3, [r7, #8]
24008206:	2b00      	cmp	r3, #0
24008208:	d009      	beq.n	2400821e <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
2400820a:	68fb      	ldr	r3, [r7, #12]
2400820c:	693a      	ldr	r2, [r7, #16]
2400820e:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
24008210:	687b      	ldr	r3, [r7, #4]
24008212:	685b      	ldr	r3, [r3, #4]
24008214:	2b00      	cmp	r3, #0
24008216:	d002      	beq.n	2400821e <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
24008218:	687b      	ldr	r3, [r7, #4]
2400821a:	685b      	ldr	r3, [r3, #4]
2400821c:	4798      	blx	r3
    }
  }
}
2400821e:	bf00      	nop
24008220:	3718      	adds	r7, #24
24008222:	46bd      	mov	sp, r7
24008224:	bd80      	pop	{r7, pc}
24008226:	bf00      	nop
24008228:	58000088 	.word	0x58000088

2400822c <HAL_EXTI_GetPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval 1 if interrupt is pending else 0.
  */
uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
2400822c:	b480      	push	{r7}
2400822e:	b089      	sub	sp, #36	; 0x24
24008230:	af00      	add	r7, sp, #0
24008232:	6078      	str	r0, [r7, #4]
24008234:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24008236:	687b      	ldr	r3, [r7, #4]
24008238:	681b      	ldr	r3, [r3, #0]
2400823a:	0c1b      	lsrs	r3, r3, #16
2400823c:	f003 0303 	and.w	r3, r3, #3
24008240:	61fb      	str	r3, [r7, #28]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24008242:	687b      	ldr	r3, [r7, #4]
24008244:	681b      	ldr	r3, [r3, #0]
24008246:	f003 031f 	and.w	r3, r3, #31
2400824a:	61bb      	str	r3, [r7, #24]
  maskline = (1UL << linepos);
2400824c:	2201      	movs	r2, #1
2400824e:	69bb      	ldr	r3, [r7, #24]
24008250:	fa02 f303 	lsl.w	r3, r2, r3
24008254:	617b      	str	r3, [r7, #20]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24008256:	69fb      	ldr	r3, [r7, #28]
24008258:	011a      	lsls	r2, r3, #4
2400825a:	4b09      	ldr	r3, [pc, #36]	; (24008280 <HAL_EXTI_GetPending+0x54>)
2400825c:	4413      	add	r3, r2
2400825e:	613b      	str	r3, [r7, #16]
#endif /* DUAL_CORE */

  /* return 1 if bit is set else 0 */
  regval = ((*regaddr & maskline) >> linepos);
24008260:	693b      	ldr	r3, [r7, #16]
24008262:	681a      	ldr	r2, [r3, #0]
24008264:	697b      	ldr	r3, [r7, #20]
24008266:	401a      	ands	r2, r3
24008268:	69bb      	ldr	r3, [r7, #24]
2400826a:	fa22 f303 	lsr.w	r3, r2, r3
2400826e:	60fb      	str	r3, [r7, #12]
  return regval;
24008270:	68fb      	ldr	r3, [r7, #12]
}
24008272:	4618      	mov	r0, r3
24008274:	3724      	adds	r7, #36	; 0x24
24008276:	46bd      	mov	sp, r7
24008278:	f85d 7b04 	ldr.w	r7, [sp], #4
2400827c:	4770      	bx	lr
2400827e:	bf00      	nop
24008280:	58000088 	.word	0x58000088

24008284 <HAL_EXTI_ClearPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval None.
  */
void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
24008284:	b480      	push	{r7}
24008286:	b087      	sub	sp, #28
24008288:	af00      	add	r7, sp, #0
2400828a:	6078      	str	r0, [r7, #4]
2400828c:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2400828e:	687b      	ldr	r3, [r7, #4]
24008290:	681b      	ldr	r3, [r3, #0]
24008292:	0c1b      	lsrs	r3, r3, #16
24008294:	f003 0303 	and.w	r3, r3, #3
24008298:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
2400829a:	687b      	ldr	r3, [r7, #4]
2400829c:	681b      	ldr	r3, [r3, #0]
2400829e:	f003 031f 	and.w	r3, r3, #31
240082a2:	2201      	movs	r2, #1
240082a4:	fa02 f303 	lsl.w	r3, r2, r3
240082a8:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
240082aa:	697b      	ldr	r3, [r7, #20]
240082ac:	011a      	lsls	r2, r3, #4
240082ae:	4b06      	ldr	r3, [pc, #24]	; (240082c8 <HAL_EXTI_ClearPending+0x44>)
240082b0:	4413      	add	r3, r2
240082b2:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Clear Pending bit */
  *regaddr =  maskline;
240082b4:	68fb      	ldr	r3, [r7, #12]
240082b6:	693a      	ldr	r2, [r7, #16]
240082b8:	601a      	str	r2, [r3, #0]
}
240082ba:	bf00      	nop
240082bc:	371c      	adds	r7, #28
240082be:	46bd      	mov	sp, r7
240082c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240082c4:	4770      	bx	lr
240082c6:	bf00      	nop
240082c8:	58000088 	.word	0x58000088

240082cc <HAL_EXTI_GenerateSWI>:
  * @brief  Generate a software interrupt for a dedicated line.
  * @param  hexti Exti handle.
  * @retval None.
  */
void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
{
240082cc:	b480      	push	{r7}
240082ce:	b087      	sub	sp, #28
240082d0:	af00      	add	r7, sp, #0
240082d2:	6078      	str	r0, [r7, #4]
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240082d4:	687b      	ldr	r3, [r7, #4]
240082d6:	681b      	ldr	r3, [r3, #0]
240082d8:	0c1b      	lsrs	r3, r3, #16
240082da:	f003 0303 	and.w	r3, r3, #3
240082de:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
240082e0:	687b      	ldr	r3, [r7, #4]
240082e2:	681b      	ldr	r3, [r3, #0]
240082e4:	f003 031f 	and.w	r3, r3, #31
240082e8:	2201      	movs	r2, #1
240082ea:	fa02 f303 	lsl.w	r3, r2, r3
240082ee:	613b      	str	r3, [r7, #16]

  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
240082f0:	697b      	ldr	r3, [r7, #20]
240082f2:	015a      	lsls	r2, r3, #5
240082f4:	4b05      	ldr	r3, [pc, #20]	; (2400830c <HAL_EXTI_GenerateSWI+0x40>)
240082f6:	4413      	add	r3, r2
240082f8:	60fb      	str	r3, [r7, #12]
  *regaddr = maskline;
240082fa:	68fb      	ldr	r3, [r7, #12]
240082fc:	693a      	ldr	r2, [r7, #16]
240082fe:	601a      	str	r2, [r3, #0]
}
24008300:	bf00      	nop
24008302:	371c      	adds	r7, #28
24008304:	46bd      	mov	sp, r7
24008306:	f85d 7b04 	ldr.w	r7, [sp], #4
2400830a:	4770      	bx	lr
2400830c:	58000008 	.word	0x58000008

24008310 <HAL_FLASH_Program>:
  *         This parameter shall be 32-bit aligned
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
24008310:	b580      	push	{r7, lr}
24008312:	b08a      	sub	sp, #40	; 0x28
24008314:	af00      	add	r7, sp, #0
24008316:	60f8      	str	r0, [r7, #12]
24008318:	60b9      	str	r1, [r7, #8]
2400831a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t *)FlashAddress;
2400831c:	68bb      	ldr	r3, [r7, #8]
2400831e:	623b      	str	r3, [r7, #32]
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
24008320:	687b      	ldr	r3, [r7, #4]
24008322:	61fb      	str	r3, [r7, #28]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
24008324:	2308      	movs	r3, #8
24008326:	76fb      	strb	r3, [r7, #27]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24008328:	4b2e      	ldr	r3, [pc, #184]	; (240083e4 <HAL_FLASH_Program+0xd4>)
2400832a:	7d1b      	ldrb	r3, [r3, #20]
2400832c:	2b01      	cmp	r3, #1
2400832e:	d101      	bne.n	24008334 <HAL_FLASH_Program+0x24>
24008330:	2302      	movs	r3, #2
24008332:	e053      	b.n	240083dc <HAL_FLASH_Program+0xcc>
24008334:	4b2b      	ldr	r3, [pc, #172]	; (240083e4 <HAL_FLASH_Program+0xd4>)
24008336:	2201      	movs	r2, #1
24008338:	751a      	strb	r2, [r3, #20]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
2400833a:	68bb      	ldr	r3, [r7, #8]
2400833c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24008340:	d315      	bcc.n	2400836e <HAL_FLASH_Program+0x5e>
24008342:	68bb      	ldr	r3, [r7, #8]
24008344:	4a28      	ldr	r2, [pc, #160]	; (240083e8 <HAL_FLASH_Program+0xd8>)
24008346:	4293      	cmp	r3, r2
24008348:	d811      	bhi.n	2400836e <HAL_FLASH_Program+0x5e>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
2400834a:	2301      	movs	r3, #1
2400834c:	617b      	str	r3, [r7, #20]
  {
    return HAL_ERROR;
  }

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2400834e:	4b25      	ldr	r3, [pc, #148]	; (240083e4 <HAL_FLASH_Program+0xd4>)
24008350:	2200      	movs	r2, #0
24008352:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24008354:	6979      	ldr	r1, [r7, #20]
24008356:	f24c 3050 	movw	r0, #50000	; 0xc350
2400835a:	f000 fa1d 	bl	24008798 <FLASH_WaitForLastOperation>
2400835e:	4603      	mov	r3, r0
24008360:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  if(status == HAL_OK)
24008364:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
24008368:	2b00      	cmp	r3, #0
2400836a:	d002      	beq.n	24008372 <HAL_FLASH_Program+0x62>
2400836c:	e031      	b.n	240083d2 <HAL_FLASH_Program+0xc2>
    return HAL_ERROR;
2400836e:	2301      	movs	r3, #1
24008370:	e034      	b.n	240083dc <HAL_FLASH_Program+0xcc>
      }
      else
#endif /* FLASH_OPTCR_PG_OTP */
      {
        /* Set PG bit */
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
24008372:	4b1e      	ldr	r3, [pc, #120]	; (240083ec <HAL_FLASH_Program+0xdc>)
24008374:	68db      	ldr	r3, [r3, #12]
24008376:	4a1d      	ldr	r2, [pc, #116]	; (240083ec <HAL_FLASH_Program+0xdc>)
24008378:	f043 0302 	orr.w	r3, r3, #2
2400837c:	60d3      	str	r3, [r2, #12]
  __ASM volatile ("isb 0xF":::"memory");
2400837e:	f3bf 8f6f 	isb	sy
}
24008382:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
24008384:	f3bf 8f4f 	dsb	sy
}
24008388:	bf00      	nop
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
2400838a:	69fb      	ldr	r3, [r7, #28]
2400838c:	681a      	ldr	r2, [r3, #0]
2400838e:	6a3b      	ldr	r3, [r7, #32]
24008390:	601a      	str	r2, [r3, #0]
        dest_addr++;
24008392:	6a3b      	ldr	r3, [r7, #32]
24008394:	3304      	adds	r3, #4
24008396:	623b      	str	r3, [r7, #32]
        src_addr++;
24008398:	69fb      	ldr	r3, [r7, #28]
2400839a:	3304      	adds	r3, #4
2400839c:	61fb      	str	r3, [r7, #28]
        row_index--;
2400839e:	7efb      	ldrb	r3, [r7, #27]
240083a0:	3b01      	subs	r3, #1
240083a2:	76fb      	strb	r3, [r7, #27]
     } while (row_index != 0U);
240083a4:	7efb      	ldrb	r3, [r7, #27]
240083a6:	2b00      	cmp	r3, #0
240083a8:	d1ef      	bne.n	2400838a <HAL_FLASH_Program+0x7a>
  __ASM volatile ("isb 0xF":::"memory");
240083aa:	f3bf 8f6f 	isb	sy
}
240083ae:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
240083b0:	f3bf 8f4f 	dsb	sy
}
240083b4:	bf00      	nop

    __ISB();
    __DSB();

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
240083b6:	6979      	ldr	r1, [r7, #20]
240083b8:	f24c 3050 	movw	r0, #50000	; 0xc350
240083bc:	f000 f9ec 	bl	24008798 <FLASH_WaitForLastOperation>
240083c0:	4603      	mov	r3, r0
240083c2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }
    else
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* If the program operation is completed, disable the PG */
      CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
240083c6:	4b09      	ldr	r3, [pc, #36]	; (240083ec <HAL_FLASH_Program+0xdc>)
240083c8:	68db      	ldr	r3, [r3, #12]
240083ca:	4a08      	ldr	r2, [pc, #32]	; (240083ec <HAL_FLASH_Program+0xdc>)
240083cc:	f023 0302 	bic.w	r3, r3, #2
240083d0:	60d3      	str	r3, [r2, #12]
    }
#endif /* DUAL_BANK */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
240083d2:	4b04      	ldr	r3, [pc, #16]	; (240083e4 <HAL_FLASH_Program+0xd4>)
240083d4:	2200      	movs	r2, #0
240083d6:	751a      	strb	r2, [r3, #20]

  return status;
240083d8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
240083dc:	4618      	mov	r0, r3
240083de:	3728      	adds	r7, #40	; 0x28
240083e0:	46bd      	mov	sp, r7
240083e2:	bd80      	pop	{r7, pc}
240083e4:	240005e4 	.word	0x240005e4
240083e8:	0801ffff 	.word	0x0801ffff
240083ec:	52002000 	.word	0x52002000

240083f0 <HAL_FLASH_Program_IT>:
  *         This parameter shall be 32-bit aligned
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
240083f0:	b580      	push	{r7, lr}
240083f2:	b08a      	sub	sp, #40	; 0x28
240083f4:	af00      	add	r7, sp, #0
240083f6:	60f8      	str	r0, [r7, #12]
240083f8:	60b9      	str	r1, [r7, #8]
240083fa:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t*)FlashAddress;
240083fc:	68bb      	ldr	r3, [r7, #8]
240083fe:	627b      	str	r3, [r7, #36]	; 0x24
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
24008400:	687b      	ldr	r3, [r7, #4]
24008402:	623b      	str	r3, [r7, #32]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
24008404:	2308      	movs	r3, #8
24008406:	77fb      	strb	r3, [r7, #31]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24008408:	4b2c      	ldr	r3, [pc, #176]	; (240084bc <HAL_FLASH_Program_IT+0xcc>)
2400840a:	7d1b      	ldrb	r3, [r3, #20]
2400840c:	2b01      	cmp	r3, #1
2400840e:	d101      	bne.n	24008414 <HAL_FLASH_Program_IT+0x24>
24008410:	2302      	movs	r3, #2
24008412:	e04f      	b.n	240084b4 <HAL_FLASH_Program_IT+0xc4>
24008414:	4b29      	ldr	r3, [pc, #164]	; (240084bc <HAL_FLASH_Program_IT+0xcc>)
24008416:	2201      	movs	r2, #1
24008418:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2400841a:	4b28      	ldr	r3, [pc, #160]	; (240084bc <HAL_FLASH_Program_IT+0xcc>)
2400841c:	2200      	movs	r2, #0
2400841e:	619a      	str	r2, [r3, #24]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
24008420:	68bb      	ldr	r3, [r7, #8]
24008422:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24008426:	d310      	bcc.n	2400844a <HAL_FLASH_Program_IT+0x5a>
24008428:	68bb      	ldr	r3, [r7, #8]
2400842a:	4a25      	ldr	r2, [pc, #148]	; (240084c0 <HAL_FLASH_Program_IT+0xd0>)
2400842c:	4293      	cmp	r3, r2
2400842e:	d80c      	bhi.n	2400844a <HAL_FLASH_Program_IT+0x5a>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
24008430:	2301      	movs	r3, #1
24008432:	61bb      	str	r3, [r7, #24]
  {
    return HAL_ERROR;
  }

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24008434:	69b9      	ldr	r1, [r7, #24]
24008436:	f24c 3050 	movw	r0, #50000	; 0xc350
2400843a:	f000 f9ad 	bl	24008798 <FLASH_WaitForLastOperation>
2400843e:	4603      	mov	r3, r0
24008440:	75fb      	strb	r3, [r7, #23]

  if (status != HAL_OK)
24008442:	7dfb      	ldrb	r3, [r7, #23]
24008444:	2b00      	cmp	r3, #0
24008446:	d102      	bne.n	2400844e <HAL_FLASH_Program_IT+0x5e>
24008448:	e005      	b.n	24008456 <HAL_FLASH_Program_IT+0x66>
    return HAL_ERROR;
2400844a:	2301      	movs	r3, #1
2400844c:	e032      	b.n	240084b4 <HAL_FLASH_Program_IT+0xc4>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
2400844e:	4b1b      	ldr	r3, [pc, #108]	; (240084bc <HAL_FLASH_Program_IT+0xcc>)
24008450:	2200      	movs	r2, #0
24008452:	751a      	strb	r2, [r3, #20]
24008454:	e02d      	b.n	240084b2 <HAL_FLASH_Program_IT+0xc2>
  }
  else
  {
    pFlash.Address = FlashAddress;
24008456:	4a19      	ldr	r2, [pc, #100]	; (240084bc <HAL_FLASH_Program_IT+0xcc>)
24008458:	68bb      	ldr	r3, [r7, #8]
2400845a:	6113      	str	r3, [r2, #16]
                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */
    }
#else /* Single Bank */
    /* Set internal variables used by the IRQ handler */
    pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;
2400845c:	4b17      	ldr	r3, [pc, #92]	; (240084bc <HAL_FLASH_Program_IT+0xcc>)
2400845e:	2203      	movs	r2, #3
24008460:	701a      	strb	r2, [r3, #0]
    }
    else
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Set PG bit */
      SET_BIT(FLASH->CR1, FLASH_CR_PG);
24008462:	4b18      	ldr	r3, [pc, #96]	; (240084c4 <HAL_FLASH_Program_IT+0xd4>)
24008464:	68db      	ldr	r3, [r3, #12]
24008466:	4a17      	ldr	r2, [pc, #92]	; (240084c4 <HAL_FLASH_Program_IT+0xd4>)
24008468:	f043 0302 	orr.w	r3, r3, #2
2400846c:	60d3      	str	r3, [r2, #12]
    }

      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
2400846e:	4b15      	ldr	r3, [pc, #84]	; (240084c4 <HAL_FLASH_Program_IT+0xd4>)
24008470:	68db      	ldr	r3, [r3, #12]
24008472:	4a14      	ldr	r2, [pc, #80]	; (240084c4 <HAL_FLASH_Program_IT+0xd4>)
24008474:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24008478:	60d3      	str	r3, [r2, #12]
  __ASM volatile ("isb 0xF":::"memory");
2400847a:	f3bf 8f6f 	isb	sy
}
2400847e:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
24008480:	f3bf 8f4f 	dsb	sy
}
24008484:	bf00      	nop
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
24008486:	6a3b      	ldr	r3, [r7, #32]
24008488:	681a      	ldr	r2, [r3, #0]
2400848a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2400848c:	601a      	str	r2, [r3, #0]
        dest_addr++;
2400848e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24008490:	3304      	adds	r3, #4
24008492:	627b      	str	r3, [r7, #36]	; 0x24
        src_addr++;
24008494:	6a3b      	ldr	r3, [r7, #32]
24008496:	3304      	adds	r3, #4
24008498:	623b      	str	r3, [r7, #32]
        row_index--;
2400849a:	7ffb      	ldrb	r3, [r7, #31]
2400849c:	3b01      	subs	r3, #1
2400849e:	77fb      	strb	r3, [r7, #31]
      } while (row_index != 0U);
240084a0:	7ffb      	ldrb	r3, [r7, #31]
240084a2:	2b00      	cmp	r3, #0
240084a4:	d1ef      	bne.n	24008486 <HAL_FLASH_Program_IT+0x96>
  __ASM volatile ("isb 0xF":::"memory");
240084a6:	f3bf 8f6f 	isb	sy
}
240084aa:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
240084ac:	f3bf 8f4f 	dsb	sy
}
240084b0:	bf00      	nop

    __ISB();
    __DSB();
  }

  return status;
240084b2:	7dfb      	ldrb	r3, [r7, #23]
}
240084b4:	4618      	mov	r0, r3
240084b6:	3728      	adds	r7, #40	; 0x28
240084b8:	46bd      	mov	sp, r7
240084ba:	bd80      	pop	{r7, pc}
240084bc:	240005e4 	.word	0x240005e4
240084c0:	0801ffff 	.word	0x0801ffff
240084c4:	52002000 	.word	0x52002000

240084c8 <HAL_FLASH_IRQHandler>:
/**
  * @brief This function handles FLASH interrupt request.
  * @retval None
  */
void HAL_FLASH_IRQHandler(void)
{
240084c8:	b580      	push	{r7, lr}
240084ca:	b084      	sub	sp, #16
240084cc:	af00      	add	r7, sp, #0
  uint32_t temp;
  uint32_t errorflag;
  FLASH_ProcedureTypeDef procedure;

  /* Check FLASH Bank1 End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG_BANK1(FLASH_SR_EOP) != RESET)
240084ce:	4b53      	ldr	r3, [pc, #332]	; (2400861c <HAL_FLASH_IRQHandler+0x154>)
240084d0:	691b      	ldr	r3, [r3, #16]
240084d2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240084d6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240084da:	d15c      	bne.n	24008596 <HAL_FLASH_IRQHandler+0xce>
  {
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK1)
240084dc:	4b50      	ldr	r3, [pc, #320]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240084de:	781b      	ldrb	r3, [r3, #0]
240084e0:	b2db      	uxtb	r3, r3
240084e2:	2b01      	cmp	r3, #1
240084e4:	d132      	bne.n	2400854c <HAL_FLASH_IRQHandler+0x84>
    {
      /* Nb of sector to erased can be decreased */
      pFlash.NbSectorsToErase--;
240084e6:	4b4e      	ldr	r3, [pc, #312]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240084e8:	685b      	ldr	r3, [r3, #4]
240084ea:	3b01      	subs	r3, #1
240084ec:	4a4c      	ldr	r2, [pc, #304]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240084ee:	6053      	str	r3, [r2, #4]

      /* Check if there are still sectors to erase */
      if(pFlash.NbSectorsToErase != 0U)
240084f0:	4b4b      	ldr	r3, [pc, #300]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240084f2:	685b      	ldr	r3, [r3, #4]
240084f4:	2b00      	cmp	r3, #0
240084f6:	d018      	beq.n	2400852a <HAL_FLASH_IRQHandler+0x62>
      {
        /* Indicate user which sector has been erased */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
240084f8:	4b49      	ldr	r3, [pc, #292]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240084fa:	68db      	ldr	r3, [r3, #12]
240084fc:	4618      	mov	r0, r3
240084fe:	f000 f891 	bl	24008624 <HAL_FLASH_EndOfOperationCallback>

        /* Clear bank 1 End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24008502:	4b46      	ldr	r3, [pc, #280]	; (2400861c <HAL_FLASH_IRQHandler+0x154>)
24008504:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24008508:	615a      	str	r2, [r3, #20]

        /* Increment sector number */
        pFlash.Sector++;
2400850a:	4b45      	ldr	r3, [pc, #276]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
2400850c:	68db      	ldr	r3, [r3, #12]
2400850e:	3301      	adds	r3, #1
24008510:	4a43      	ldr	r2, [pc, #268]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
24008512:	60d3      	str	r3, [r2, #12]
        temp = pFlash.Sector;
24008514:	4b42      	ldr	r3, [pc, #264]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
24008516:	68db      	ldr	r3, [r3, #12]
24008518:	60fb      	str	r3, [r7, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);
2400851a:	4b41      	ldr	r3, [pc, #260]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
2400851c:	689b      	ldr	r3, [r3, #8]
2400851e:	461a      	mov	r2, r3
24008520:	2101      	movs	r1, #1
24008522:	68f8      	ldr	r0, [r7, #12]
24008524:	f000 fcd6 	bl	24008ed4 <FLASH_Erase_Sector>
24008528:	e035      	b.n	24008596 <HAL_FLASH_IRQHandler+0xce>
      }
      else
      {
        /* No more sectors to Erase, user callback can be called */
        /* Reset Sector and stop Erase sectors procedure */
        pFlash.Sector = 0xFFFFFFFFU;
2400852a:	4b3d      	ldr	r3, [pc, #244]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
2400852c:	f04f 32ff 	mov.w	r2, #4294967295
24008530:	60da      	str	r2, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24008532:	4b3b      	ldr	r3, [pc, #236]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
24008534:	2200      	movs	r2, #0
24008536:	701a      	strb	r2, [r3, #0]

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
24008538:	4b39      	ldr	r3, [pc, #228]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
2400853a:	68db      	ldr	r3, [r3, #12]
2400853c:	4618      	mov	r0, r3
2400853e:	f000 f871 	bl	24008624 <HAL_FLASH_EndOfOperationCallback>

        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24008542:	4b36      	ldr	r3, [pc, #216]	; (2400861c <HAL_FLASH_IRQHandler+0x154>)
24008544:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24008548:	615a      	str	r2, [r3, #20]
2400854a:	e024      	b.n	24008596 <HAL_FLASH_IRQHandler+0xce>
      }
    }
    else
    {
      procedure = pFlash.ProcedureOnGoing;
2400854c:	4b34      	ldr	r3, [pc, #208]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
2400854e:	781b      	ldrb	r3, [r3, #0]
24008550:	72fb      	strb	r3, [r7, #11]

      if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24008552:	7afb      	ldrb	r3, [r7, #11]
24008554:	2b02      	cmp	r3, #2
24008556:	d002      	beq.n	2400855e <HAL_FLASH_IRQHandler+0x96>
24008558:	7afb      	ldrb	r3, [r7, #11]
2400855a:	2b07      	cmp	r3, #7
2400855c:	d103      	bne.n	24008566 <HAL_FLASH_IRQHandler+0x9e>
      {
        /* MassErase ended. Return the selected bank */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_1);
2400855e:	2001      	movs	r0, #1
24008560:	f000 f860 	bl	24008624 <HAL_FLASH_EndOfOperationCallback>
24008564:	e007      	b.n	24008576 <HAL_FLASH_IRQHandler+0xae>
      }
      else if(procedure == FLASH_PROC_PROGRAM_BANK1)
24008566:	7afb      	ldrb	r3, [r7, #11]
24008568:	2b03      	cmp	r3, #3
2400856a:	d104      	bne.n	24008576 <HAL_FLASH_IRQHandler+0xae>
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
2400856c:	4b2c      	ldr	r3, [pc, #176]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
2400856e:	691b      	ldr	r3, [r3, #16]
24008570:	4618      	mov	r0, r3
24008572:	f000 f857 	bl	24008624 <HAL_FLASH_EndOfOperationCallback>
      else
      {
        /* Nothing to do */
      }

      if((procedure != FLASH_PROC_SECTERASE_BANK2) && \
24008576:	7afb      	ldrb	r3, [r7, #11]
24008578:	2b04      	cmp	r3, #4
2400857a:	d00c      	beq.n	24008596 <HAL_FLASH_IRQHandler+0xce>
2400857c:	7afb      	ldrb	r3, [r7, #11]
2400857e:	2b05      	cmp	r3, #5
24008580:	d009      	beq.n	24008596 <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_MASSERASE_BANK2) && \
24008582:	7afb      	ldrb	r3, [r7, #11]
24008584:	2b06      	cmp	r3, #6
24008586:	d006      	beq.n	24008596 <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_PROGRAM_BANK2))
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24008588:	4b25      	ldr	r3, [pc, #148]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
2400858a:	2200      	movs	r2, #0
2400858c:	701a      	strb	r2, [r3, #0]
        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
2400858e:	4b23      	ldr	r3, [pc, #140]	; (2400861c <HAL_FLASH_IRQHandler+0x154>)
24008590:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24008594:	615a      	str	r2, [r3, #20]
  }
#endif /* DUAL_BANK */

  /* Check FLASH Bank1 operation error flags */
#if defined (FLASH_SR_OPERR)
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
24008596:	4b21      	ldr	r3, [pc, #132]	; (2400861c <HAL_FLASH_IRQHandler+0x154>)
24008598:	691b      	ldr	r3, [r3, #16]
2400859a:	f403 03dc 	and.w	r3, r3, #7208960	; 0x6e0000
2400859e:	607b      	str	r3, [r7, #4]
#else
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
                            FLASH_FLAG_INCERR_BANK1);
#endif /* FLASH_SR_OPERR */

  if(errorflag != 0U)
240085a0:	687b      	ldr	r3, [r7, #4]
240085a2:	2b00      	cmp	r3, #0
240085a4:	d028      	beq.n	240085f8 <HAL_FLASH_IRQHandler+0x130>
  {
    /* Save the error code */
    pFlash.ErrorCode |= errorflag;
240085a6:	4b1e      	ldr	r3, [pc, #120]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240085a8:	699a      	ldr	r2, [r3, #24]
240085aa:	687b      	ldr	r3, [r7, #4]
240085ac:	4313      	orrs	r3, r2
240085ae:	4a1c      	ldr	r2, [pc, #112]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240085b0:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG_BANK1(errorflag);
240085b2:	4a1a      	ldr	r2, [pc, #104]	; (2400861c <HAL_FLASH_IRQHandler+0x154>)
240085b4:	687b      	ldr	r3, [r7, #4]
240085b6:	6153      	str	r3, [r2, #20]

    procedure = pFlash.ProcedureOnGoing;
240085b8:	4b19      	ldr	r3, [pc, #100]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240085ba:	781b      	ldrb	r3, [r3, #0]
240085bc:	72fb      	strb	r3, [r7, #11]

    if(procedure == FLASH_PROC_SECTERASE_BANK1)
240085be:	7afb      	ldrb	r3, [r7, #11]
240085c0:	2b01      	cmp	r3, #1
240085c2:	d107      	bne.n	240085d4 <HAL_FLASH_IRQHandler+0x10c>
    {
      /* Return the faulty sector */
      temp = pFlash.Sector;
240085c4:	4b16      	ldr	r3, [pc, #88]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240085c6:	68db      	ldr	r3, [r3, #12]
240085c8:	60fb      	str	r3, [r7, #12]
      pFlash.Sector = 0xFFFFFFFFU;
240085ca:	4b15      	ldr	r3, [pc, #84]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240085cc:	f04f 32ff 	mov.w	r2, #4294967295
240085d0:	60da      	str	r2, [r3, #12]
240085d2:	e00b      	b.n	240085ec <HAL_FLASH_IRQHandler+0x124>
    }
    else if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
240085d4:	7afb      	ldrb	r3, [r7, #11]
240085d6:	2b02      	cmp	r3, #2
240085d8:	d002      	beq.n	240085e0 <HAL_FLASH_IRQHandler+0x118>
240085da:	7afb      	ldrb	r3, [r7, #11]
240085dc:	2b07      	cmp	r3, #7
240085de:	d102      	bne.n	240085e6 <HAL_FLASH_IRQHandler+0x11e>
    {
      /* Return the faulty bank */
      temp = FLASH_BANK_1;
240085e0:	2301      	movs	r3, #1
240085e2:	60fb      	str	r3, [r7, #12]
240085e4:	e002      	b.n	240085ec <HAL_FLASH_IRQHandler+0x124>
    }
    else
    {
      /* Return the faulty address */
      temp = pFlash.Address;
240085e6:	4b0e      	ldr	r3, [pc, #56]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240085e8:	691b      	ldr	r3, [r3, #16]
240085ea:	60fb      	str	r3, [r7, #12]
    }

    /* Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
240085ec:	4b0c      	ldr	r3, [pc, #48]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240085ee:	2200      	movs	r2, #0
240085f0:	701a      	strb	r2, [r3, #0]

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
240085f2:	68f8      	ldr	r0, [r7, #12]
240085f4:	f000 f820 	bl	24008638 <HAL_FLASH_OperationErrorCallback>
    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
  }
#endif /* DUAL_BANK */

  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
240085f8:	4b09      	ldr	r3, [pc, #36]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
240085fa:	781b      	ldrb	r3, [r3, #0]
240085fc:	b2db      	uxtb	r3, r3
240085fe:	2b00      	cmp	r3, #0
24008600:	d108      	bne.n	24008614 <HAL_FLASH_IRQHandler+0x14c>
  {
#if defined (FLASH_CR_OPERRIE)
    /* Disable Bank1 Operation and Error source interrupt */
    __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24008602:	4b06      	ldr	r3, [pc, #24]	; (2400861c <HAL_FLASH_IRQHandler+0x154>)
24008604:	68db      	ldr	r3, [r3, #12]
24008606:	4a05      	ldr	r2, [pc, #20]	; (2400861c <HAL_FLASH_IRQHandler+0x154>)
24008608:	f423 03de 	bic.w	r3, r3, #7274496	; 0x6f0000
2400860c:	60d3      	str	r3, [r2, #12]
                                 FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* DUAL_BANK */
#endif /* FLASH_CR_OPERRIE */

    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
2400860e:	4b04      	ldr	r3, [pc, #16]	; (24008620 <HAL_FLASH_IRQHandler+0x158>)
24008610:	2200      	movs	r2, #0
24008612:	751a      	strb	r2, [r3, #20]
  }
}
24008614:	bf00      	nop
24008616:	3710      	adds	r7, #16
24008618:	46bd      	mov	sp, r7
2400861a:	bd80      	pop	{r7, pc}
2400861c:	52002000 	.word	0x52002000
24008620:	240005e4 	.word	0x240005e4

24008624 <HAL_FLASH_EndOfOperationCallback>:
  *                    (if 0xFFFFFFFF, it means that all the selected sectors have been erased)
  *                  Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
{
24008624:	b480      	push	{r7}
24008626:	b083      	sub	sp, #12
24008628:	af00      	add	r7, sp, #0
2400862a:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
2400862c:	bf00      	nop
2400862e:	370c      	adds	r7, #12
24008630:	46bd      	mov	sp, r7
24008632:	f85d 7b04 	ldr.w	r7, [sp], #4
24008636:	4770      	bx	lr

24008638 <HAL_FLASH_OperationErrorCallback>:
  *                 Sectors Erase: Sector number which returned an error
  *                 Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
{
24008638:	b480      	push	{r7}
2400863a:	b083      	sub	sp, #12
2400863c:	af00      	add	r7, sp, #0
2400863e:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */
}
24008640:	bf00      	nop
24008642:	370c      	adds	r7, #12
24008644:	46bd      	mov	sp, r7
24008646:	f85d 7b04 	ldr.w	r7, [sp], #4
2400864a:	4770      	bx	lr

2400864c <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
2400864c:	b480      	push	{r7}
2400864e:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24008650:	4b0c      	ldr	r3, [pc, #48]	; (24008684 <HAL_FLASH_Unlock+0x38>)
24008652:	68db      	ldr	r3, [r3, #12]
24008654:	f003 0301 	and.w	r3, r3, #1
24008658:	2b00      	cmp	r3, #0
2400865a:	d00d      	beq.n	24008678 <HAL_FLASH_Unlock+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
2400865c:	4b09      	ldr	r3, [pc, #36]	; (24008684 <HAL_FLASH_Unlock+0x38>)
2400865e:	4a0a      	ldr	r2, [pc, #40]	; (24008688 <HAL_FLASH_Unlock+0x3c>)
24008660:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
24008662:	4b08      	ldr	r3, [pc, #32]	; (24008684 <HAL_FLASH_Unlock+0x38>)
24008664:	4a09      	ldr	r2, [pc, #36]	; (2400868c <HAL_FLASH_Unlock+0x40>)
24008666:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24008668:	4b06      	ldr	r3, [pc, #24]	; (24008684 <HAL_FLASH_Unlock+0x38>)
2400866a:	68db      	ldr	r3, [r3, #12]
2400866c:	f003 0301 	and.w	r3, r3, #1
24008670:	2b00      	cmp	r3, #0
24008672:	d001      	beq.n	24008678 <HAL_FLASH_Unlock+0x2c>
    {
      return HAL_ERROR;
24008674:	2301      	movs	r3, #1
24008676:	e000      	b.n	2400867a <HAL_FLASH_Unlock+0x2e>
      return HAL_ERROR;
    }
  }
#endif /* DUAL_BANK */

  return HAL_OK;
24008678:	2300      	movs	r3, #0
}
2400867a:	4618      	mov	r0, r3
2400867c:	46bd      	mov	sp, r7
2400867e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008682:	4770      	bx	lr
24008684:	52002000 	.word	0x52002000
24008688:	45670123 	.word	0x45670123
2400868c:	cdef89ab 	.word	0xcdef89ab

24008690 <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
24008690:	b480      	push	{r7}
24008692:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24008694:	4b09      	ldr	r3, [pc, #36]	; (240086bc <HAL_FLASH_Lock+0x2c>)
24008696:	68db      	ldr	r3, [r3, #12]
24008698:	4a08      	ldr	r2, [pc, #32]	; (240086bc <HAL_FLASH_Lock+0x2c>)
2400869a:	f043 0301 	orr.w	r3, r3, #1
2400869e:	60d3      	str	r3, [r2, #12]

  /* Verify Flash Bank1 is locked */
  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
240086a0:	4b06      	ldr	r3, [pc, #24]	; (240086bc <HAL_FLASH_Lock+0x2c>)
240086a2:	68db      	ldr	r3, [r3, #12]
240086a4:	f003 0301 	and.w	r3, r3, #1
240086a8:	2b00      	cmp	r3, #0
240086aa:	d101      	bne.n	240086b0 <HAL_FLASH_Lock+0x20>
  {
    return HAL_ERROR;
240086ac:	2301      	movs	r3, #1
240086ae:	e000      	b.n	240086b2 <HAL_FLASH_Lock+0x22>
  {
    return HAL_ERROR;
  }
#endif /* DUAL_BANK */

  return HAL_OK;
240086b0:	2300      	movs	r3, #0
}
240086b2:	4618      	mov	r0, r3
240086b4:	46bd      	mov	sp, r7
240086b6:	f85d 7b04 	ldr.w	r7, [sp], #4
240086ba:	4770      	bx	lr
240086bc:	52002000 	.word	0x52002000

240086c0 <HAL_FLASH_OB_Unlock>:
/**
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
240086c0:	b480      	push	{r7}
240086c2:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
240086c4:	4b0c      	ldr	r3, [pc, #48]	; (240086f8 <HAL_FLASH_OB_Unlock+0x38>)
240086c6:	699b      	ldr	r3, [r3, #24]
240086c8:	f003 0301 	and.w	r3, r3, #1
240086cc:	2b00      	cmp	r3, #0
240086ce:	d00d      	beq.n	240086ec <HAL_FLASH_OB_Unlock+0x2c>
  {
    /* Authorizes the Option Byte registers programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
240086d0:	4b09      	ldr	r3, [pc, #36]	; (240086f8 <HAL_FLASH_OB_Unlock+0x38>)
240086d2:	4a0a      	ldr	r2, [pc, #40]	; (240086fc <HAL_FLASH_OB_Unlock+0x3c>)
240086d4:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
240086d6:	4b08      	ldr	r3, [pc, #32]	; (240086f8 <HAL_FLASH_OB_Unlock+0x38>)
240086d8:	4a09      	ldr	r2, [pc, #36]	; (24008700 <HAL_FLASH_OB_Unlock+0x40>)
240086da:	609a      	str	r2, [r3, #8]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
240086dc:	4b06      	ldr	r3, [pc, #24]	; (240086f8 <HAL_FLASH_OB_Unlock+0x38>)
240086de:	699b      	ldr	r3, [r3, #24]
240086e0:	f003 0301 	and.w	r3, r3, #1
240086e4:	2b00      	cmp	r3, #0
240086e6:	d001      	beq.n	240086ec <HAL_FLASH_OB_Unlock+0x2c>
    {
      return HAL_ERROR;
240086e8:	2301      	movs	r3, #1
240086ea:	e000      	b.n	240086ee <HAL_FLASH_OB_Unlock+0x2e>
    }
  }

  return HAL_OK;
240086ec:	2300      	movs	r3, #0
}
240086ee:	4618      	mov	r0, r3
240086f0:	46bd      	mov	sp, r7
240086f2:	f85d 7b04 	ldr.w	r7, [sp], #4
240086f6:	4770      	bx	lr
240086f8:	52002000 	.word	0x52002000
240086fc:	08192a3b 	.word	0x08192a3b
24008700:	4c5d6e7f 	.word	0x4c5d6e7f

24008704 <HAL_FLASH_OB_Lock>:
/**
  * @brief  Lock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
24008704:	b480      	push	{r7}
24008706:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
24008708:	4b09      	ldr	r3, [pc, #36]	; (24008730 <HAL_FLASH_OB_Lock+0x2c>)
2400870a:	699b      	ldr	r3, [r3, #24]
2400870c:	4a08      	ldr	r2, [pc, #32]	; (24008730 <HAL_FLASH_OB_Lock+0x2c>)
2400870e:	f043 0301 	orr.w	r3, r3, #1
24008712:	6193      	str	r3, [r2, #24]

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
24008714:	4b06      	ldr	r3, [pc, #24]	; (24008730 <HAL_FLASH_OB_Lock+0x2c>)
24008716:	699b      	ldr	r3, [r3, #24]
24008718:	f003 0301 	and.w	r3, r3, #1
2400871c:	2b00      	cmp	r3, #0
2400871e:	d101      	bne.n	24008724 <HAL_FLASH_OB_Lock+0x20>
  {
    return HAL_ERROR;
24008720:	2301      	movs	r3, #1
24008722:	e000      	b.n	24008726 <HAL_FLASH_OB_Lock+0x22>
  }

  return HAL_OK;
24008724:	2300      	movs	r3, #0
}
24008726:	4618      	mov	r0, r3
24008728:	46bd      	mov	sp, r7
2400872a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400872e:	4770      	bx	lr
24008730:	52002000 	.word	0x52002000

24008734 <HAL_FLASH_OB_Launch>:
/**
  * @brief  Launch the option bytes loading.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
{
24008734:	b580      	push	{r7, lr}
24008736:	b082      	sub	sp, #8
24008738:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;

  /* Wait for CRC computation to be completed */
  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2400873a:	2101      	movs	r1, #1
2400873c:	f24c 3050 	movw	r0, #50000	; 0xc350
24008740:	f000 f8bc 	bl	240088bc <FLASH_CRC_WaitForLastOperation>
24008744:	4603      	mov	r3, r0
24008746:	2b00      	cmp	r3, #0
24008748:	d002      	beq.n	24008750 <HAL_FLASH_OB_Launch+0x1c>
  {
    status = HAL_ERROR;
2400874a:	2301      	movs	r3, #1
2400874c:	71fb      	strb	r3, [r7, #7]
2400874e:	e001      	b.n	24008754 <HAL_FLASH_OB_Launch+0x20>
    status = HAL_ERROR;
  }
#endif /* DUAL_BANK */
  else
  {
    status = HAL_OK;
24008750:	2300      	movs	r3, #0
24008752:	71fb      	strb	r3, [r7, #7]
  }

  if (status == HAL_OK)
24008754:	79fb      	ldrb	r3, [r7, #7]
24008756:	2b00      	cmp	r3, #0
24008758:	d10b      	bne.n	24008772 <HAL_FLASH_OB_Launch+0x3e>
  {
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
2400875a:	4b08      	ldr	r3, [pc, #32]	; (2400877c <HAL_FLASH_OB_Launch+0x48>)
2400875c:	699b      	ldr	r3, [r3, #24]
2400875e:	4a07      	ldr	r2, [pc, #28]	; (2400877c <HAL_FLASH_OB_Launch+0x48>)
24008760:	f043 0302 	orr.w	r3, r3, #2
24008764:	6193      	str	r3, [r2, #24]

    /* Wait for OB change operation to be completed */
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24008766:	f24c 3050 	movw	r0, #50000	; 0xc350
2400876a:	f000 f86b 	bl	24008844 <FLASH_OB_WaitForLastOperation>
2400876e:	4603      	mov	r3, r0
24008770:	71fb      	strb	r3, [r7, #7]
  }

  return status;
24008772:	79fb      	ldrb	r3, [r7, #7]
}
24008774:	4618      	mov	r0, r3
24008776:	3708      	adds	r7, #8
24008778:	46bd      	mov	sp, r7
2400877a:	bd80      	pop	{r7, pc}
2400877c:	52002000 	.word	0x52002000

24008780 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_DBECC_BANK2: Double Detection ECC on Bank 2
  *            @arg HAL_FLASH_ERROR_CRCRD_BANK2: CRC Read Error on Bank 2
*/

uint32_t HAL_FLASH_GetError(void)
{
24008780:	b480      	push	{r7}
24008782:	af00      	add	r7, sp, #0
   return pFlash.ErrorCode;
24008784:	4b03      	ldr	r3, [pc, #12]	; (24008794 <HAL_FLASH_GetError+0x14>)
24008786:	699b      	ldr	r3, [r3, #24]
}
24008788:	4618      	mov	r0, r3
2400878a:	46bd      	mov	sp, r7
2400878c:	f85d 7b04 	ldr.w	r7, [sp], #4
24008790:	4770      	bx	lr
24008792:	bf00      	nop
24008794:	240005e4 	.word	0x240005e4

24008798 <FLASH_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
24008798:	b580      	push	{r7, lr}
2400879a:	b086      	sub	sp, #24
2400879c:	af00      	add	r7, sp, #0
2400879e:	6078      	str	r0, [r7, #4]
240087a0:	6039      	str	r1, [r7, #0]
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag = FLASH_FLAG_QW_BANK1;
240087a2:	2304      	movs	r3, #4
240087a4:	613b      	str	r3, [r7, #16]
  uint32_t errorflag = 0;
240087a6:	2300      	movs	r3, #0
240087a8:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
240087aa:	f7f9 fc37 	bl	2400201c <HAL_GetTick>
240087ae:	60f8      	str	r0, [r7, #12]
    /* Select bsyflag depending on Bank */
    bsyflag = FLASH_FLAG_QW_BANK2;
  }
#endif /* DUAL_BANK */

  while(__HAL_FLASH_GET_FLAG(bsyflag))
240087b0:	e010      	b.n	240087d4 <FLASH_WaitForLastOperation+0x3c>
  {
    if(Timeout != HAL_MAX_DELAY)
240087b2:	687b      	ldr	r3, [r7, #4]
240087b4:	f1b3 3fff 	cmp.w	r3, #4294967295
240087b8:	d00c      	beq.n	240087d4 <FLASH_WaitForLastOperation+0x3c>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
240087ba:	f7f9 fc2f 	bl	2400201c <HAL_GetTick>
240087be:	4602      	mov	r2, r0
240087c0:	68fb      	ldr	r3, [r7, #12]
240087c2:	1ad3      	subs	r3, r2, r3
240087c4:	687a      	ldr	r2, [r7, #4]
240087c6:	429a      	cmp	r2, r3
240087c8:	d302      	bcc.n	240087d0 <FLASH_WaitForLastOperation+0x38>
240087ca:	687b      	ldr	r3, [r7, #4]
240087cc:	2b00      	cmp	r3, #0
240087ce:	d101      	bne.n	240087d4 <FLASH_WaitForLastOperation+0x3c>
      {
        return HAL_TIMEOUT;
240087d0:	2303      	movs	r3, #3
240087d2:	e02d      	b.n	24008830 <FLASH_WaitForLastOperation+0x98>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
240087d4:	4b18      	ldr	r3, [pc, #96]	; (24008838 <FLASH_WaitForLastOperation+0xa0>)
240087d6:	691a      	ldr	r2, [r3, #16]
240087d8:	693b      	ldr	r3, [r7, #16]
240087da:	4013      	ands	r3, r2
240087dc:	693a      	ldr	r2, [r7, #16]
240087de:	429a      	cmp	r2, r3
240087e0:	d0e7      	beq.n	240087b2 <FLASH_WaitForLastOperation+0x1a>
      }
    }
  }

  /* Get Error Flags */
  if (Bank == FLASH_BANK_1)
240087e2:	683b      	ldr	r3, [r7, #0]
240087e4:	2b01      	cmp	r3, #1
240087e6:	d104      	bne.n	240087f2 <FLASH_WaitForLastOperation+0x5a>
  {
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
240087e8:	4b13      	ldr	r3, [pc, #76]	; (24008838 <FLASH_WaitForLastOperation+0xa0>)
240087ea:	691a      	ldr	r2, [r3, #16]
240087ec:	4b13      	ldr	r3, [pc, #76]	; (2400883c <FLASH_WaitForLastOperation+0xa4>)
240087ee:	4013      	ands	r3, r2
240087f0:	617b      	str	r3, [r7, #20]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
  }
#endif /* DUAL_BANK */

  /* In case of error reported in Flash SR1 or SR2 register */
  if((errorflag & 0x7FFFFFFFU) != 0U)
240087f2:	697b      	ldr	r3, [r7, #20]
240087f4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
240087f8:	2b00      	cmp	r3, #0
240087fa:	d00a      	beq.n	24008812 <FLASH_WaitForLastOperation+0x7a>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= errorflag;
240087fc:	4b10      	ldr	r3, [pc, #64]	; (24008840 <FLASH_WaitForLastOperation+0xa8>)
240087fe:	699a      	ldr	r2, [r3, #24]
24008800:	697b      	ldr	r3, [r7, #20]
24008802:	4313      	orrs	r3, r2
24008804:	4a0e      	ldr	r2, [pc, #56]	; (24008840 <FLASH_WaitForLastOperation+0xa8>)
24008806:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(errorflag);
24008808:	4a0b      	ldr	r2, [pc, #44]	; (24008838 <FLASH_WaitForLastOperation+0xa0>)
2400880a:	697b      	ldr	r3, [r7, #20]
2400880c:	6153      	str	r3, [r2, #20]

    return HAL_ERROR;
2400880e:	2301      	movs	r3, #1
24008810:	e00e      	b.n	24008830 <FLASH_WaitForLastOperation+0x98>
  }

  /* Check FLASH End of Operation flag  */
  if(Bank == FLASH_BANK_1)
24008812:	683b      	ldr	r3, [r7, #0]
24008814:	2b01      	cmp	r3, #1
24008816:	d10a      	bne.n	2400882e <FLASH_WaitForLastOperation+0x96>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
24008818:	4b07      	ldr	r3, [pc, #28]	; (24008838 <FLASH_WaitForLastOperation+0xa0>)
2400881a:	691b      	ldr	r3, [r3, #16]
2400881c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24008820:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24008824:	d103      	bne.n	2400882e <FLASH_WaitForLastOperation+0x96>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24008826:	4b04      	ldr	r3, [pc, #16]	; (24008838 <FLASH_WaitForLastOperation+0xa0>)
24008828:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2400882c:	615a      	str	r2, [r3, #20]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }
#endif /* DUAL_BANK */

  return HAL_OK;
2400882e:	2300      	movs	r3, #0
}
24008830:	4618      	mov	r0, r3
24008832:	3718      	adds	r7, #24
24008834:	46bd      	mov	sp, r7
24008836:	bd80      	pop	{r7, pc}
24008838:	52002000 	.word	0x52002000
2400883c:	17ee0000 	.word	0x17ee0000
24008840:	240005e4 	.word	0x240005e4

24008844 <FLASH_OB_WaitForLastOperation>:
  * @brief  Wait for a FLASH Option Bytes change operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
{
24008844:	b580      	push	{r7, lr}
24008846:	b084      	sub	sp, #16
24008848:	af00      	add	r7, sp, #0
2400884a:	6078      	str	r0, [r7, #4]
  /* Get timeout */
  uint32_t tickstart = HAL_GetTick();
2400884c:	f7f9 fbe6 	bl	2400201c <HAL_GetTick>
24008850:	60f8      	str	r0, [r7, #12]

  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
24008852:	e010      	b.n	24008876 <FLASH_OB_WaitForLastOperation+0x32>
  {
    if(Timeout != HAL_MAX_DELAY)
24008854:	687b      	ldr	r3, [r7, #4]
24008856:	f1b3 3fff 	cmp.w	r3, #4294967295
2400885a:	d00c      	beq.n	24008876 <FLASH_OB_WaitForLastOperation+0x32>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400885c:	f7f9 fbde 	bl	2400201c <HAL_GetTick>
24008860:	4602      	mov	r2, r0
24008862:	68fb      	ldr	r3, [r7, #12]
24008864:	1ad3      	subs	r3, r2, r3
24008866:	687a      	ldr	r2, [r7, #4]
24008868:	429a      	cmp	r2, r3
2400886a:	d302      	bcc.n	24008872 <FLASH_OB_WaitForLastOperation+0x2e>
2400886c:	687b      	ldr	r3, [r7, #4]
2400886e:	2b00      	cmp	r3, #0
24008870:	d101      	bne.n	24008876 <FLASH_OB_WaitForLastOperation+0x32>
      {
        return HAL_TIMEOUT;
24008872:	2303      	movs	r3, #3
24008874:	e01a      	b.n	240088ac <FLASH_OB_WaitForLastOperation+0x68>
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
24008876:	4b0f      	ldr	r3, [pc, #60]	; (240088b4 <FLASH_OB_WaitForLastOperation+0x70>)
24008878:	69db      	ldr	r3, [r3, #28]
2400887a:	f003 0301 	and.w	r3, r3, #1
2400887e:	2b00      	cmp	r3, #0
24008880:	d1e8      	bne.n	24008854 <FLASH_OB_WaitForLastOperation+0x10>
      }
    }
  }

  /* Check option byte change error */
  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
24008882:	4b0c      	ldr	r3, [pc, #48]	; (240088b4 <FLASH_OB_WaitForLastOperation+0x70>)
24008884:	69db      	ldr	r3, [r3, #28]
24008886:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2400888a:	2b00      	cmp	r3, #0
2400888c:	d00d      	beq.n	240088aa <FLASH_OB_WaitForLastOperation+0x66>
  {
    /* Save the error code */
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
2400888e:	4b0a      	ldr	r3, [pc, #40]	; (240088b8 <FLASH_OB_WaitForLastOperation+0x74>)
24008890:	699b      	ldr	r3, [r3, #24]
24008892:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24008896:	4a08      	ldr	r2, [pc, #32]	; (240088b8 <FLASH_OB_WaitForLastOperation+0x74>)
24008898:	6193      	str	r3, [r2, #24]

    /* Clear the OB error flag */
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
2400889a:	4b06      	ldr	r3, [pc, #24]	; (240088b4 <FLASH_OB_WaitForLastOperation+0x70>)
2400889c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400889e:	4a05      	ldr	r2, [pc, #20]	; (240088b4 <FLASH_OB_WaitForLastOperation+0x70>)
240088a0:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
240088a4:	6253      	str	r3, [r2, #36]	; 0x24

    return HAL_ERROR;
240088a6:	2301      	movs	r3, #1
240088a8:	e000      	b.n	240088ac <FLASH_OB_WaitForLastOperation+0x68>
  }

  /* If there is no error flag set */
  return HAL_OK;
240088aa:	2300      	movs	r3, #0
}
240088ac:	4618      	mov	r0, r3
240088ae:	3710      	adds	r7, #16
240088b0:	46bd      	mov	sp, r7
240088b2:	bd80      	pop	{r7, pc}
240088b4:	52002000 	.word	0x52002000
240088b8:	240005e4 	.word	0x240005e4

240088bc <FLASH_CRC_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
240088bc:	b580      	push	{r7, lr}
240088be:	b084      	sub	sp, #16
240088c0:	af00      	add	r7, sp, #0
240088c2:	6078      	str	r0, [r7, #4]
240088c4:	6039      	str	r1, [r7, #0]
  uint32_t bsyflag;
  uint32_t tickstart = HAL_GetTick();
240088c6:	f7f9 fba9 	bl	2400201c <HAL_GetTick>
240088ca:	60b8      	str	r0, [r7, #8]

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
240088cc:	683b      	ldr	r3, [r7, #0]
240088ce:	2b01      	cmp	r3, #1
240088d0:	d102      	bne.n	240088d8 <FLASH_CRC_WaitForLastOperation+0x1c>
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
240088d2:	2308      	movs	r3, #8
240088d4:	60fb      	str	r3, [r7, #12]
240088d6:	e013      	b.n	24008900 <FLASH_CRC_WaitForLastOperation+0x44>
  }
  else
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
240088d8:	4b1a      	ldr	r3, [pc, #104]	; (24008944 <FLASH_CRC_WaitForLastOperation+0x88>)
240088da:	60fb      	str	r3, [r7, #12]
  }

  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
  while(__HAL_FLASH_GET_FLAG(bsyflag))
240088dc:	e010      	b.n	24008900 <FLASH_CRC_WaitForLastOperation+0x44>
  {
    if(Timeout != HAL_MAX_DELAY)
240088de:	687b      	ldr	r3, [r7, #4]
240088e0:	f1b3 3fff 	cmp.w	r3, #4294967295
240088e4:	d00c      	beq.n	24008900 <FLASH_CRC_WaitForLastOperation+0x44>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
240088e6:	f7f9 fb99 	bl	2400201c <HAL_GetTick>
240088ea:	4602      	mov	r2, r0
240088ec:	68bb      	ldr	r3, [r7, #8]
240088ee:	1ad3      	subs	r3, r2, r3
240088f0:	687a      	ldr	r2, [r7, #4]
240088f2:	429a      	cmp	r2, r3
240088f4:	d302      	bcc.n	240088fc <FLASH_CRC_WaitForLastOperation+0x40>
240088f6:	687b      	ldr	r3, [r7, #4]
240088f8:	2b00      	cmp	r3, #0
240088fa:	d101      	bne.n	24008900 <FLASH_CRC_WaitForLastOperation+0x44>
      {
        return HAL_TIMEOUT;
240088fc:	2303      	movs	r3, #3
240088fe:	e01d      	b.n	2400893c <FLASH_CRC_WaitForLastOperation+0x80>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24008900:	4b11      	ldr	r3, [pc, #68]	; (24008948 <FLASH_CRC_WaitForLastOperation+0x8c>)
24008902:	691a      	ldr	r2, [r3, #16]
24008904:	68fb      	ldr	r3, [r7, #12]
24008906:	4013      	ands	r3, r2
24008908:	68fa      	ldr	r2, [r7, #12]
2400890a:	429a      	cmp	r2, r3
2400890c:	d0e7      	beq.n	240088de <FLASH_CRC_WaitForLastOperation+0x22>
      }
    }
  }

  /* Check FLASH CRC read error flag  */
  if(Bank == FLASH_BANK_1)
2400890e:	683b      	ldr	r3, [r7, #0]
24008910:	2b01      	cmp	r3, #1
24008912:	d112      	bne.n	2400893a <FLASH_CRC_WaitForLastOperation+0x7e>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
24008914:	4b0c      	ldr	r3, [pc, #48]	; (24008948 <FLASH_CRC_WaitForLastOperation+0x8c>)
24008916:	691b      	ldr	r3, [r3, #16]
24008918:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2400891c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24008920:	d10b      	bne.n	2400893a <FLASH_CRC_WaitForLastOperation+0x7e>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
24008922:	4b0a      	ldr	r3, [pc, #40]	; (2400894c <FLASH_CRC_WaitForLastOperation+0x90>)
24008924:	699b      	ldr	r3, [r3, #24]
24008926:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
2400892a:	4a08      	ldr	r2, [pc, #32]	; (2400894c <FLASH_CRC_WaitForLastOperation+0x90>)
2400892c:	6193      	str	r3, [r2, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
2400892e:	4b06      	ldr	r3, [pc, #24]	; (24008948 <FLASH_CRC_WaitForLastOperation+0x8c>)
24008930:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
24008934:	615a      	str	r2, [r3, #20]

      return HAL_ERROR;
24008936:	2301      	movs	r3, #1
24008938:	e000      	b.n	2400893c <FLASH_CRC_WaitForLastOperation+0x80>
    }
  }
#endif /* DUAL_BANK */

  /* If there is no error flag set */
  return HAL_OK;
2400893a:	2300      	movs	r3, #0
}
2400893c:	4618      	mov	r0, r3
2400893e:	3710      	adds	r7, #16
24008940:	46bd      	mov	sp, r7
24008942:	bd80      	pop	{r7, pc}
24008944:	80000008 	.word	0x80000008
24008948:	52002000 	.word	0x52002000
2400894c:	240005e4 	.word	0x240005e4

24008950 <HAL_FLASHEx_Erase>:
  *          the sectors have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
24008950:	b580      	push	{r7, lr}
24008952:	b084      	sub	sp, #16
24008954:	af00      	add	r7, sp, #0
24008956:	6078      	str	r0, [r7, #4]
24008958:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400895a:	2300      	movs	r3, #0
2400895c:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
2400895e:	4b3f      	ldr	r3, [pc, #252]	; (24008a5c <HAL_FLASHEx_Erase+0x10c>)
24008960:	7d1b      	ldrb	r3, [r3, #20]
24008962:	2b01      	cmp	r3, #1
24008964:	d101      	bne.n	2400896a <HAL_FLASHEx_Erase+0x1a>
24008966:	2302      	movs	r3, #2
24008968:	e074      	b.n	24008a54 <HAL_FLASHEx_Erase+0x104>
2400896a:	4b3c      	ldr	r3, [pc, #240]	; (24008a5c <HAL_FLASHEx_Erase+0x10c>)
2400896c:	2201      	movs	r2, #1
2400896e:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24008970:	4b3a      	ldr	r3, [pc, #232]	; (24008a5c <HAL_FLASHEx_Erase+0x10c>)
24008972:	2200      	movs	r2, #0
24008974:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed on Bank1 */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008976:	687b      	ldr	r3, [r7, #4]
24008978:	685b      	ldr	r3, [r3, #4]
2400897a:	f003 0301 	and.w	r3, r3, #1
2400897e:	2b00      	cmp	r3, #0
24008980:	d009      	beq.n	24008996 <HAL_FLASHEx_Erase+0x46>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24008982:	2101      	movs	r1, #1
24008984:	f24c 3050 	movw	r0, #50000	; 0xc350
24008988:	f7ff ff06 	bl	24008798 <FLASH_WaitForLastOperation>
2400898c:	4603      	mov	r3, r0
2400898e:	2b00      	cmp	r3, #0
24008990:	d001      	beq.n	24008996 <HAL_FLASHEx_Erase+0x46>
    {
      status = HAL_ERROR;
24008992:	2301      	movs	r3, #1
24008994:	73fb      	strb	r3, [r7, #15]
      status = HAL_ERROR;
    }
  }
#endif /* DUAL_BANK */

  if(status == HAL_OK)
24008996:	7bfb      	ldrb	r3, [r7, #15]
24008998:	2b00      	cmp	r3, #0
2400899a:	d157      	bne.n	24008a4c <HAL_FLASHEx_Erase+0xfc>
  {
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
2400899c:	687b      	ldr	r3, [r7, #4]
2400899e:	681b      	ldr	r3, [r3, #0]
240089a0:	2b01      	cmp	r3, #1
240089a2:	d11e      	bne.n	240089e2 <HAL_FLASHEx_Erase+0x92>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
240089a4:	687b      	ldr	r3, [r7, #4]
240089a6:	691a      	ldr	r2, [r3, #16]
240089a8:	687b      	ldr	r3, [r7, #4]
240089aa:	685b      	ldr	r3, [r3, #4]
240089ac:	4619      	mov	r1, r3
240089ae:	4610      	mov	r0, r2
240089b0:	f000 fa6c 	bl	24008e8c <FLASH_MassErase>

      /* Wait for last operation to be completed on Bank 1 */
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
240089b4:	687b      	ldr	r3, [r7, #4]
240089b6:	685b      	ldr	r3, [r3, #4]
240089b8:	f003 0301 	and.w	r3, r3, #1
240089bc:	2b00      	cmp	r3, #0
240089be:	d045      	beq.n	24008a4c <HAL_FLASHEx_Erase+0xfc>
      {
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
240089c0:	2101      	movs	r1, #1
240089c2:	f24c 3050 	movw	r0, #50000	; 0xc350
240089c6:	f7ff fee7 	bl	24008798 <FLASH_WaitForLastOperation>
240089ca:	4603      	mov	r3, r0
240089cc:	2b00      	cmp	r3, #0
240089ce:	d001      	beq.n	240089d4 <HAL_FLASHEx_Erase+0x84>
        {
          status = HAL_ERROR;
240089d0:	2301      	movs	r3, #1
240089d2:	73fb      	strb	r3, [r7, #15]
        }
        /* if the erase operation is completed, disable the Bank1 BER Bit */
        FLASH->CR1 &= (~FLASH_CR_BER);
240089d4:	4b22      	ldr	r3, [pc, #136]	; (24008a60 <HAL_FLASHEx_Erase+0x110>)
240089d6:	68db      	ldr	r3, [r3, #12]
240089d8:	4a21      	ldr	r2, [pc, #132]	; (24008a60 <HAL_FLASHEx_Erase+0x110>)
240089da:	f023 0308 	bic.w	r3, r3, #8
240089de:	60d3      	str	r3, [r2, #12]
240089e0:	e034      	b.n	24008a4c <HAL_FLASHEx_Erase+0xfc>
#endif /* DUAL_BANK */
    }
    else
    {
      /*Initialization of SectorError variable*/
      *SectorError = 0xFFFFFFFFU;
240089e2:	683b      	ldr	r3, [r7, #0]
240089e4:	f04f 32ff 	mov.w	r2, #4294967295
240089e8:	601a      	str	r2, [r3, #0]

      /* Erase by sector by sector to be done*/
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
240089ea:	687b      	ldr	r3, [r7, #4]
240089ec:	689b      	ldr	r3, [r3, #8]
240089ee:	60bb      	str	r3, [r7, #8]
240089f0:	e024      	b.n	24008a3c <HAL_FLASHEx_Erase+0xec>
      {
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
240089f2:	687b      	ldr	r3, [r7, #4]
240089f4:	6859      	ldr	r1, [r3, #4]
240089f6:	687b      	ldr	r3, [r7, #4]
240089f8:	691b      	ldr	r3, [r3, #16]
240089fa:	461a      	mov	r2, r3
240089fc:	68b8      	ldr	r0, [r7, #8]
240089fe:	f000 fa69 	bl	24008ed4 <FLASH_Erase_Sector>

        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008a02:	687b      	ldr	r3, [r7, #4]
24008a04:	685b      	ldr	r3, [r3, #4]
24008a06:	f003 0301 	and.w	r3, r3, #1
24008a0a:	2b00      	cmp	r3, #0
24008a0c:	d00c      	beq.n	24008a28 <HAL_FLASHEx_Erase+0xd8>
        {
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24008a0e:	2101      	movs	r1, #1
24008a10:	f24c 3050 	movw	r0, #50000	; 0xc350
24008a14:	f7ff fec0 	bl	24008798 <FLASH_WaitForLastOperation>
24008a18:	4603      	mov	r3, r0
24008a1a:	73fb      	strb	r3, [r7, #15]

          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
24008a1c:	4b10      	ldr	r3, [pc, #64]	; (24008a60 <HAL_FLASHEx_Erase+0x110>)
24008a1e:	68da      	ldr	r2, [r3, #12]
24008a20:	490f      	ldr	r1, [pc, #60]	; (24008a60 <HAL_FLASHEx_Erase+0x110>)
24008a22:	4b10      	ldr	r3, [pc, #64]	; (24008a64 <HAL_FLASHEx_Erase+0x114>)
24008a24:	4013      	ands	r3, r2
24008a26:	60cb      	str	r3, [r1, #12]
          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
        }
#endif /* DUAL_BANK */

        if(status != HAL_OK)
24008a28:	7bfb      	ldrb	r3, [r7, #15]
24008a2a:	2b00      	cmp	r3, #0
24008a2c:	d003      	beq.n	24008a36 <HAL_FLASHEx_Erase+0xe6>
        {
          /* In case of error, stop erase procedure and return the faulty sector */
          *SectorError = sector_index;
24008a2e:	683b      	ldr	r3, [r7, #0]
24008a30:	68ba      	ldr	r2, [r7, #8]
24008a32:	601a      	str	r2, [r3, #0]
          break;
24008a34:	e00a      	b.n	24008a4c <HAL_FLASHEx_Erase+0xfc>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
24008a36:	68bb      	ldr	r3, [r7, #8]
24008a38:	3301      	adds	r3, #1
24008a3a:	60bb      	str	r3, [r7, #8]
24008a3c:	687b      	ldr	r3, [r7, #4]
24008a3e:	68da      	ldr	r2, [r3, #12]
24008a40:	687b      	ldr	r3, [r7, #4]
24008a42:	689b      	ldr	r3, [r3, #8]
24008a44:	4413      	add	r3, r2
24008a46:	68ba      	ldr	r2, [r7, #8]
24008a48:	429a      	cmp	r2, r3
24008a4a:	d3d2      	bcc.n	240089f2 <HAL_FLASHEx_Erase+0xa2>
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
24008a4c:	4b03      	ldr	r3, [pc, #12]	; (24008a5c <HAL_FLASHEx_Erase+0x10c>)
24008a4e:	2200      	movs	r2, #0
24008a50:	751a      	strb	r2, [r3, #20]

  return status;
24008a52:	7bfb      	ldrb	r3, [r7, #15]
}
24008a54:	4618      	mov	r0, r3
24008a56:	3710      	adds	r7, #16
24008a58:	46bd      	mov	sp, r7
24008a5a:	bd80      	pop	{r7, pc}
24008a5c:	240005e4 	.word	0x240005e4
24008a60:	52002000 	.word	0x52002000
24008a64:	fffff8fb 	.word	0xfffff8fb

24008a68 <HAL_FLASHEx_Erase_IT>:
  *         contains the configuration information for the erasing.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
{
24008a68:	b580      	push	{r7, lr}
24008a6a:	b084      	sub	sp, #16
24008a6c:	af00      	add	r7, sp, #0
24008a6e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24008a70:	2300      	movs	r3, #0
24008a72:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24008a74:	4b31      	ldr	r3, [pc, #196]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008a76:	7d1b      	ldrb	r3, [r3, #20]
24008a78:	2b01      	cmp	r3, #1
24008a7a:	d101      	bne.n	24008a80 <HAL_FLASHEx_Erase_IT+0x18>
24008a7c:	2302      	movs	r3, #2
24008a7e:	e059      	b.n	24008b34 <HAL_FLASHEx_Erase_IT+0xcc>
24008a80:	4b2e      	ldr	r3, [pc, #184]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008a82:	2201      	movs	r2, #1
24008a84:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24008a86:	4b2d      	ldr	r3, [pc, #180]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008a88:	2200      	movs	r2, #0
24008a8a:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed on Bank 1 */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008a8c:	687b      	ldr	r3, [r7, #4]
24008a8e:	685b      	ldr	r3, [r3, #4]
24008a90:	f003 0301 	and.w	r3, r3, #1
24008a94:	2b00      	cmp	r3, #0
24008a96:	d009      	beq.n	24008aac <HAL_FLASHEx_Erase_IT+0x44>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24008a98:	2101      	movs	r1, #1
24008a9a:	f24c 3050 	movw	r0, #50000	; 0xc350
24008a9e:	f7ff fe7b 	bl	24008798 <FLASH_WaitForLastOperation>
24008aa2:	4603      	mov	r3, r0
24008aa4:	2b00      	cmp	r3, #0
24008aa6:	d001      	beq.n	24008aac <HAL_FLASHEx_Erase_IT+0x44>
    {
      status = HAL_ERROR;
24008aa8:	2301      	movs	r3, #1
24008aaa:	73fb      	strb	r3, [r7, #15]
      status = HAL_ERROR;
    }
  }
#endif /* DUAL_BANK */

  if (status != HAL_OK)
24008aac:	7bfb      	ldrb	r3, [r7, #15]
24008aae:	2b00      	cmp	r3, #0
24008ab0:	d003      	beq.n	24008aba <HAL_FLASHEx_Erase_IT+0x52>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
24008ab2:	4b22      	ldr	r3, [pc, #136]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008ab4:	2200      	movs	r2, #0
24008ab6:	751a      	strb	r2, [r3, #20]
24008ab8:	e03b      	b.n	24008b32 <HAL_FLASHEx_Erase_IT+0xca>
  }
  else
  {
    if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008aba:	687b      	ldr	r3, [r7, #4]
24008abc:	685b      	ldr	r3, [r3, #4]
24008abe:	f003 0301 	and.w	r3, r3, #1
24008ac2:	2b00      	cmp	r3, #0
24008ac4:	d005      	beq.n	24008ad2 <HAL_FLASHEx_Erase_IT+0x6a>
    {
      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24008ac6:	4b1e      	ldr	r3, [pc, #120]	; (24008b40 <HAL_FLASHEx_Erase_IT+0xd8>)
24008ac8:	68db      	ldr	r3, [r3, #12]
24008aca:	4a1d      	ldr	r2, [pc, #116]	; (24008b40 <HAL_FLASHEx_Erase_IT+0xd8>)
24008acc:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24008ad0:	60d3      	str	r3, [r2, #12]
                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */
    }
#endif /* DUAL_BANK */

    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
24008ad2:	687b      	ldr	r3, [r7, #4]
24008ad4:	681b      	ldr	r3, [r3, #0]
24008ad6:	2b01      	cmp	r3, #1
24008ad8:	d113      	bne.n	24008b02 <HAL_FLASHEx_Erase_IT+0x9a>
    {
      /*Mass erase to be done*/
      if(pEraseInit->Banks == FLASH_BANK_1)
24008ada:	687b      	ldr	r3, [r7, #4]
24008adc:	685b      	ldr	r3, [r3, #4]
24008ade:	2b01      	cmp	r3, #1
24008ae0:	d103      	bne.n	24008aea <HAL_FLASHEx_Erase_IT+0x82>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK1;
24008ae2:	4b16      	ldr	r3, [pc, #88]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008ae4:	2202      	movs	r2, #2
24008ae6:	701a      	strb	r2, [r3, #0]
24008ae8:	e002      	b.n	24008af0 <HAL_FLASHEx_Erase_IT+0x88>
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK2;
      }
#endif /* DUAL_BANK */
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;
24008aea:	4b14      	ldr	r3, [pc, #80]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008aec:	2207      	movs	r2, #7
24008aee:	701a      	strb	r2, [r3, #0]
      }

      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
24008af0:	687b      	ldr	r3, [r7, #4]
24008af2:	691a      	ldr	r2, [r3, #16]
24008af4:	687b      	ldr	r3, [r7, #4]
24008af6:	685b      	ldr	r3, [r3, #4]
24008af8:	4619      	mov	r1, r3
24008afa:	4610      	mov	r0, r2
24008afc:	f000 f9c6 	bl	24008e8c <FLASH_MassErase>
24008b00:	e017      	b.n	24008b32 <HAL_FLASHEx_Erase_IT+0xca>
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK2;
      }
#else
      pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;
24008b02:	4b0e      	ldr	r3, [pc, #56]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008b04:	2201      	movs	r2, #1
24008b06:	701a      	strb	r2, [r3, #0]
#endif /* DUAL_BANK */

      pFlash.NbSectorsToErase = pEraseInit->NbSectors;
24008b08:	687b      	ldr	r3, [r7, #4]
24008b0a:	68db      	ldr	r3, [r3, #12]
24008b0c:	4a0b      	ldr	r2, [pc, #44]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008b0e:	6053      	str	r3, [r2, #4]
      pFlash.Sector = pEraseInit->Sector;
24008b10:	687b      	ldr	r3, [r7, #4]
24008b12:	689b      	ldr	r3, [r3, #8]
24008b14:	4a09      	ldr	r2, [pc, #36]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008b16:	60d3      	str	r3, [r2, #12]
      pFlash.VoltageForErase = pEraseInit->VoltageRange;
24008b18:	687b      	ldr	r3, [r7, #4]
24008b1a:	691b      	ldr	r3, [r3, #16]
24008b1c:	4a07      	ldr	r2, [pc, #28]	; (24008b3c <HAL_FLASHEx_Erase_IT+0xd4>)
24008b1e:	6093      	str	r3, [r2, #8]

      /* Erase first sector and wait for IT */
      FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->Banks, pEraseInit->VoltageRange);
24008b20:	687b      	ldr	r3, [r7, #4]
24008b22:	6898      	ldr	r0, [r3, #8]
24008b24:	687b      	ldr	r3, [r7, #4]
24008b26:	6859      	ldr	r1, [r3, #4]
24008b28:	687b      	ldr	r3, [r7, #4]
24008b2a:	691b      	ldr	r3, [r3, #16]
24008b2c:	461a      	mov	r2, r3
24008b2e:	f000 f9d1 	bl	24008ed4 <FLASH_Erase_Sector>
    }
  }

  return status;
24008b32:	7bfb      	ldrb	r3, [r7, #15]
}
24008b34:	4618      	mov	r0, r3
24008b36:	3710      	adds	r7, #16
24008b38:	46bd      	mov	sp, r7
24008b3a:	bd80      	pop	{r7, pc}
24008b3c:	240005e4 	.word	0x240005e4
24008b40:	52002000 	.word	0x52002000

24008b44 <HAL_FLASHEx_OBProgram>:
  *         contains the configuration information for the programming.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
24008b44:	b580      	push	{r7, lr}
24008b46:	b084      	sub	sp, #16
24008b48:	af00      	add	r7, sp, #0
24008b4a:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24008b4c:	4b48      	ldr	r3, [pc, #288]	; (24008c70 <HAL_FLASHEx_OBProgram+0x12c>)
24008b4e:	7d1b      	ldrb	r3, [r3, #20]
24008b50:	2b01      	cmp	r3, #1
24008b52:	d101      	bne.n	24008b58 <HAL_FLASHEx_OBProgram+0x14>
24008b54:	2302      	movs	r3, #2
24008b56:	e087      	b.n	24008c68 <HAL_FLASHEx_OBProgram+0x124>
24008b58:	4b45      	ldr	r3, [pc, #276]	; (24008c70 <HAL_FLASHEx_OBProgram+0x12c>)
24008b5a:	2201      	movs	r2, #1
24008b5c:	751a      	strb	r2, [r3, #20]

  /* Reset Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24008b5e:	4b44      	ldr	r3, [pc, #272]	; (24008c70 <HAL_FLASHEx_OBProgram+0x12c>)
24008b60:	2200      	movs	r2, #0
24008b62:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24008b64:	2101      	movs	r1, #1
24008b66:	f24c 3050 	movw	r0, #50000	; 0xc350
24008b6a:	f7ff fe15 	bl	24008798 <FLASH_WaitForLastOperation>
24008b6e:	4603      	mov	r3, r0
24008b70:	2b00      	cmp	r3, #0
24008b72:	d002      	beq.n	24008b7a <HAL_FLASHEx_OBProgram+0x36>
  {
    status = HAL_ERROR;
24008b74:	2301      	movs	r3, #1
24008b76:	73fb      	strb	r3, [r7, #15]
24008b78:	e001      	b.n	24008b7e <HAL_FLASHEx_OBProgram+0x3a>
    status = HAL_ERROR;
  }
#endif /* DUAL_BANK */
  else
  {
    status = HAL_OK;
24008b7a:	2300      	movs	r3, #0
24008b7c:	73fb      	strb	r3, [r7, #15]
  }

  if(status == HAL_OK)
24008b7e:	7bfb      	ldrb	r3, [r7, #15]
24008b80:	2b00      	cmp	r3, #0
24008b82:	d16d      	bne.n	24008c60 <HAL_FLASHEx_OBProgram+0x11c>
  {
    /*Write protection configuration*/
    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
24008b84:	687b      	ldr	r3, [r7, #4]
24008b86:	681b      	ldr	r3, [r3, #0]
24008b88:	f003 0301 	and.w	r3, r3, #1
24008b8c:	2b00      	cmp	r3, #0
24008b8e:	d014      	beq.n	24008bba <HAL_FLASHEx_OBProgram+0x76>
    {
      assert_param(IS_WRPSTATE(pOBInit->WRPState));

      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
24008b90:	687b      	ldr	r3, [r7, #4]
24008b92:	685b      	ldr	r3, [r3, #4]
24008b94:	2b01      	cmp	r3, #1
24008b96:	d108      	bne.n	24008baa <HAL_FLASHEx_OBProgram+0x66>
      {
        /*Enable of Write protection on the selected Sector*/
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
24008b98:	687b      	ldr	r3, [r7, #4]
24008b9a:	689a      	ldr	r2, [r3, #8]
24008b9c:	687b      	ldr	r3, [r7, #4]
24008b9e:	69db      	ldr	r3, [r3, #28]
24008ba0:	4619      	mov	r1, r3
24008ba2:	4610      	mov	r0, r2
24008ba4:	f000 f9ba 	bl	24008f1c <FLASH_OB_EnableWRP>
24008ba8:	e007      	b.n	24008bba <HAL_FLASHEx_OBProgram+0x76>
      }
      else
      {
        /*Disable of Write protection on the selected Sector*/
        FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
24008baa:	687b      	ldr	r3, [r7, #4]
24008bac:	689a      	ldr	r2, [r3, #8]
24008bae:	687b      	ldr	r3, [r7, #4]
24008bb0:	69db      	ldr	r3, [r3, #28]
24008bb2:	4619      	mov	r1, r3
24008bb4:	4610      	mov	r0, r2
24008bb6:	f000 f9cb 	bl	24008f50 <FLASH_OB_DisableWRP>
      }
    }

    /* Read protection configuration */
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
24008bba:	687b      	ldr	r3, [r7, #4]
24008bbc:	681b      	ldr	r3, [r3, #0]
24008bbe:	f003 0302 	and.w	r3, r3, #2
24008bc2:	2b00      	cmp	r3, #0
24008bc4:	d004      	beq.n	24008bd0 <HAL_FLASHEx_OBProgram+0x8c>
    {
      /* Configure the Read protection level */
      FLASH_OB_RDPConfig(pOBInit->RDPLevel);
24008bc6:	687b      	ldr	r3, [r7, #4]
24008bc8:	68db      	ldr	r3, [r3, #12]
24008bca:	4618      	mov	r0, r3
24008bcc:	f000 fa00 	bl	24008fd0 <FLASH_OB_RDPConfig>
    }

    /* User Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
24008bd0:	687b      	ldr	r3, [r7, #4]
24008bd2:	681b      	ldr	r3, [r3, #0]
24008bd4:	f003 0304 	and.w	r3, r3, #4
24008bd8:	2b00      	cmp	r3, #0
24008bda:	d007      	beq.n	24008bec <HAL_FLASHEx_OBProgram+0xa8>
    {
      /* Configure the user option bytes */
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
24008bdc:	687b      	ldr	r3, [r7, #4]
24008bde:	695a      	ldr	r2, [r3, #20]
24008be0:	687b      	ldr	r3, [r7, #4]
24008be2:	699b      	ldr	r3, [r3, #24]
24008be4:	4619      	mov	r1, r3
24008be6:	4610      	mov	r0, r2
24008be8:	f000 fa22 	bl	24009030 <FLASH_OB_UserConfig>
    }

    /* PCROP Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
24008bec:	687b      	ldr	r3, [r7, #4]
24008bee:	681b      	ldr	r3, [r3, #0]
24008bf0:	f003 0308 	and.w	r3, r3, #8
24008bf4:	2b00      	cmp	r3, #0
24008bf6:	d009      	beq.n	24008c0c <HAL_FLASHEx_OBProgram+0xc8>
    {
      assert_param(IS_FLASH_BANK(pOBInit->Banks));

      /*Configure the Proprietary code readout protection */
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
24008bf8:	687b      	ldr	r3, [r7, #4]
24008bfa:	6a18      	ldr	r0, [r3, #32]
24008bfc:	687b      	ldr	r3, [r7, #4]
24008bfe:	6a59      	ldr	r1, [r3, #36]	; 0x24
24008c00:	687b      	ldr	r3, [r7, #4]
24008c02:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24008c04:	687b      	ldr	r3, [r7, #4]
24008c06:	69db      	ldr	r3, [r3, #28]
24008c08:	f000 faba 	bl	24009180 <FLASH_OB_PCROPConfig>
    }

    /* BOR Level configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
24008c0c:	687b      	ldr	r3, [r7, #4]
24008c0e:	681b      	ldr	r3, [r3, #0]
24008c10:	f003 0310 	and.w	r3, r3, #16
24008c14:	2b00      	cmp	r3, #0
24008c16:	d004      	beq.n	24008c22 <HAL_FLASHEx_OBProgram+0xde>
    {
      FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
24008c18:	687b      	ldr	r3, [r7, #4]
24008c1a:	691b      	ldr	r3, [r3, #16]
24008c1c:	4618      	mov	r0, r3
24008c1e:	f000 fb09 	bl	24009234 <FLASH_OB_BOR_LevelConfig>
    {
      FLASH_OB_CM4BootAddConfig(pOBInit->CM4BootConfig, pOBInit->CM4BootAddr0, pOBInit->CM4BootAddr1);
    }
#else /* Single Core*/
    /* Boot Address  configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)
24008c22:	687b      	ldr	r3, [r7, #4]
24008c24:	681b      	ldr	r3, [r3, #0]
24008c26:	f003 0340 	and.w	r3, r3, #64	; 0x40
24008c2a:	2b00      	cmp	r3, #0
24008c2c:	d008      	beq.n	24008c40 <HAL_FLASHEx_OBProgram+0xfc>
    {
      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);
24008c2e:	687b      	ldr	r3, [r7, #4]
24008c30:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
24008c32:	687b      	ldr	r3, [r7, #4]
24008c34:	6b19      	ldr	r1, [r3, #48]	; 0x30
24008c36:	687b      	ldr	r3, [r7, #4]
24008c38:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24008c3a:	461a      	mov	r2, r3
24008c3c:	f000 fb1c 	bl	24009278 <FLASH_OB_BootAddConfig>
    }
#endif /*DUAL_CORE*/

    /* Secure area configuration */
    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)
24008c40:	687b      	ldr	r3, [r7, #4]
24008c42:	681b      	ldr	r3, [r3, #0]
24008c44:	f003 0320 	and.w	r3, r3, #32
24008c48:	2b00      	cmp	r3, #0
24008c4a:	d009      	beq.n	24008c60 <HAL_FLASHEx_OBProgram+0x11c>
    {
      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);
24008c4c:	687b      	ldr	r3, [r7, #4]
24008c4e:	6b98      	ldr	r0, [r3, #56]	; 0x38
24008c50:	687b      	ldr	r3, [r7, #4]
24008c52:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
24008c54:	687b      	ldr	r3, [r7, #4]
24008c56:	6c1a      	ldr	r2, [r3, #64]	; 0x40
24008c58:	687b      	ldr	r3, [r7, #4]
24008c5a:	69db      	ldr	r3, [r3, #28]
24008c5c:	f000 fb52 	bl	24009304 <FLASH_OB_SecureAreaConfig>
    }
#endif /* FLASH_OPTSR2_CPUFREQ_BOOST */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
24008c60:	4b03      	ldr	r3, [pc, #12]	; (24008c70 <HAL_FLASHEx_OBProgram+0x12c>)
24008c62:	2200      	movs	r2, #0
24008c64:	751a      	strb	r2, [r3, #20]

  return status;
24008c66:	7bfb      	ldrb	r3, [r7, #15]
}
24008c68:	4618      	mov	r0, r3
24008c6a:	3710      	adds	r7, #16
24008c6c:	46bd      	mov	sp, r7
24008c6e:	bd80      	pop	{r7, pc}
24008c70:	240005e4 	.word	0x240005e4

24008c74 <HAL_FLASHEx_OBGetConfig>:
  *         as this parameter is use to get the given Bank WRP, PCROP and secured area configuration.
  *
  * @retval None
  */
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
24008c74:	b580      	push	{r7, lr}
24008c76:	b082      	sub	sp, #8
24008c78:	af00      	add	r7, sp, #0
24008c7a:	6078      	str	r0, [r7, #4]
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
24008c7c:	687b      	ldr	r3, [r7, #4]
24008c7e:	2216      	movs	r2, #22
24008c80:	601a      	str	r2, [r3, #0]

  /* Get Read protection level */
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
24008c82:	f000 f9b9 	bl	24008ff8 <FLASH_OB_GetRDP>
24008c86:	4602      	mov	r2, r0
24008c88:	687b      	ldr	r3, [r7, #4]
24008c8a:	60da      	str	r2, [r3, #12]

  /* Get the user option bytes */
  pOBInit->USERConfig = FLASH_OB_GetUser();
24008c8c:	f000 fa62 	bl	24009154 <FLASH_OB_GetUser>
24008c90:	4602      	mov	r2, r0
24008c92:	687b      	ldr	r3, [r7, #4]
24008c94:	619a      	str	r2, [r3, #24]

  /*Get BOR Level*/
  pOBInit->BORLevel = FLASH_OB_GetBOR();
24008c96:	f000 fae1 	bl	2400925c <FLASH_OB_GetBOR>
24008c9a:	4602      	mov	r2, r0
24008c9c:	687b      	ldr	r3, [r7, #4]
24008c9e:	611a      	str	r2, [r3, #16]

#if defined (DUAL_BANK)
  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
#else
  if (pOBInit->Banks == FLASH_BANK_1)
24008ca0:	687b      	ldr	r3, [r7, #4]
24008ca2:	69db      	ldr	r3, [r3, #28]
24008ca4:	2b01      	cmp	r3, #1
24008ca6:	d129      	bne.n	24008cfc <HAL_FLASHEx_OBGetConfig+0x88>
#endif /* DUAL_BANK */
  {
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
24008ca8:	687b      	ldr	r3, [r7, #4]
24008caa:	681b      	ldr	r3, [r3, #0]
24008cac:	f043 0229 	orr.w	r2, r3, #41	; 0x29
24008cb0:	687b      	ldr	r3, [r7, #4]
24008cb2:	601a      	str	r2, [r3, #0]

    /* Get write protection on the selected area */
    FLASH_OB_GetWRP(&(pOBInit->WRPState), &(pOBInit->WRPSector), pOBInit->Banks);
24008cb4:	687b      	ldr	r3, [r7, #4]
24008cb6:	1d18      	adds	r0, r3, #4
24008cb8:	687b      	ldr	r3, [r7, #4]
24008cba:	f103 0108 	add.w	r1, r3, #8
24008cbe:	687b      	ldr	r3, [r7, #4]
24008cc0:	69db      	ldr	r3, [r3, #28]
24008cc2:	461a      	mov	r2, r3
24008cc4:	f000 f95e 	bl	24008f84 <FLASH_OB_GetWRP>

    /* Get the Proprietary code readout protection */
    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr), pOBInit->Banks);
24008cc8:	687b      	ldr	r3, [r7, #4]
24008cca:	f103 0020 	add.w	r0, r3, #32
24008cce:	687b      	ldr	r3, [r7, #4]
24008cd0:	f103 0124 	add.w	r1, r3, #36	; 0x24
24008cd4:	687b      	ldr	r3, [r7, #4]
24008cd6:	f103 0228 	add.w	r2, r3, #40	; 0x28
24008cda:	687b      	ldr	r3, [r7, #4]
24008cdc:	69db      	ldr	r3, [r3, #28]
24008cde:	f000 fa71 	bl	240091c4 <FLASH_OB_GetPCROP>

    /*Get Bank Secure area*/
    FLASH_OB_GetSecureArea(&(pOBInit->SecureAreaConfig), &(pOBInit->SecureAreaStartAddr), &(pOBInit->SecureAreaEndAddr), pOBInit->Banks);
24008ce2:	687b      	ldr	r3, [r7, #4]
24008ce4:	f103 0038 	add.w	r0, r3, #56	; 0x38
24008ce8:	687b      	ldr	r3, [r7, #4]
24008cea:	f103 013c 	add.w	r1, r3, #60	; 0x3c
24008cee:	687b      	ldr	r3, [r7, #4]
24008cf0:	f103 0240 	add.w	r2, r3, #64	; 0x40
24008cf4:	687b      	ldr	r3, [r7, #4]
24008cf6:	69db      	ldr	r3, [r3, #28]
24008cf8:	f000 fb28 	bl	2400934c <FLASH_OB_GetSecureArea>
  }

  /*Get Boot Address*/
  FLASH_OB_GetBootAdd(&(pOBInit->BootAddr0), &(pOBInit->BootAddr1));
24008cfc:	687b      	ldr	r3, [r7, #4]
24008cfe:	f103 0230 	add.w	r2, r3, #48	; 0x30
24008d02:	687b      	ldr	r3, [r7, #4]
24008d04:	3334      	adds	r3, #52	; 0x34
24008d06:	4619      	mov	r1, r3
24008d08:	4610      	mov	r0, r2
24008d0a:	f000 fadf 	bl	240092cc <FLASH_OB_GetBootAdd>
  pOBInit->OptionType |= OPTIONBYTE_CM7_BOOTADD | OPTIONBYTE_CM4_BOOTADD;

  /*Get CM4 Boot Address*/
  FLASH_OB_GetCM4BootAdd(&(pOBInit->CM4BootAddr0), &(pOBInit->CM4BootAddr1));
#else
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
24008d0e:	687b      	ldr	r3, [r7, #4]
24008d10:	681b      	ldr	r3, [r3, #0]
24008d12:	f043 0240 	orr.w	r2, r3, #64	; 0x40
24008d16:	687b      	ldr	r3, [r7, #4]
24008d18:	601a      	str	r2, [r3, #0]
  pOBInit->OptionType |= OPTIONBYTE_FREQ_BOOST;

  /* Get CPU Frequency Boost */
  pOBInit->FreqBoostState = FLASH_OB_CPUFreq_GetBoost();
#endif /* FLASH_OPTSR2_CPUFREQ_BOOST */
}
24008d1a:	bf00      	nop
24008d1c:	3708      	adds	r7, #8
24008d1e:	46bd      	mov	sp, r7
24008d20:	bd80      	pop	{r7, pc}
	...

24008d24 <HAL_FLASHEx_Unlock_Bank1>:
/**
  * @brief  Unlock the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank1(void)
{
24008d24:	b480      	push	{r7}
24008d26:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24008d28:	4b0c      	ldr	r3, [pc, #48]	; (24008d5c <HAL_FLASHEx_Unlock_Bank1+0x38>)
24008d2a:	68db      	ldr	r3, [r3, #12]
24008d2c:	f003 0301 	and.w	r3, r3, #1
24008d30:	2b00      	cmp	r3, #0
24008d32:	d00d      	beq.n	24008d50 <HAL_FLASHEx_Unlock_Bank1+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
24008d34:	4b09      	ldr	r3, [pc, #36]	; (24008d5c <HAL_FLASHEx_Unlock_Bank1+0x38>)
24008d36:	4a0a      	ldr	r2, [pc, #40]	; (24008d60 <HAL_FLASHEx_Unlock_Bank1+0x3c>)
24008d38:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
24008d3a:	4b08      	ldr	r3, [pc, #32]	; (24008d5c <HAL_FLASHEx_Unlock_Bank1+0x38>)
24008d3c:	4a09      	ldr	r2, [pc, #36]	; (24008d64 <HAL_FLASHEx_Unlock_Bank1+0x40>)
24008d3e:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24008d40:	4b06      	ldr	r3, [pc, #24]	; (24008d5c <HAL_FLASHEx_Unlock_Bank1+0x38>)
24008d42:	68db      	ldr	r3, [r3, #12]
24008d44:	f003 0301 	and.w	r3, r3, #1
24008d48:	2b00      	cmp	r3, #0
24008d4a:	d001      	beq.n	24008d50 <HAL_FLASHEx_Unlock_Bank1+0x2c>
    {
      return HAL_ERROR;
24008d4c:	2301      	movs	r3, #1
24008d4e:	e000      	b.n	24008d52 <HAL_FLASHEx_Unlock_Bank1+0x2e>
    }
  }

  return HAL_OK;
24008d50:	2300      	movs	r3, #0
}
24008d52:	4618      	mov	r0, r3
24008d54:	46bd      	mov	sp, r7
24008d56:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d5a:	4770      	bx	lr
24008d5c:	52002000 	.word	0x52002000
24008d60:	45670123 	.word	0x45670123
24008d64:	cdef89ab 	.word	0xcdef89ab

24008d68 <HAL_FLASHEx_Lock_Bank1>:
/**
  * @brief  Locks the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Lock_Bank1(void)
{
24008d68:	b480      	push	{r7}
24008d6a:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Registers access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24008d6c:	4b05      	ldr	r3, [pc, #20]	; (24008d84 <HAL_FLASHEx_Lock_Bank1+0x1c>)
24008d6e:	68db      	ldr	r3, [r3, #12]
24008d70:	4a04      	ldr	r2, [pc, #16]	; (24008d84 <HAL_FLASHEx_Lock_Bank1+0x1c>)
24008d72:	f043 0301 	orr.w	r3, r3, #1
24008d76:	60d3      	str	r3, [r2, #12]
  return HAL_OK;
24008d78:	2300      	movs	r3, #0
}
24008d7a:	4618      	mov	r0, r3
24008d7c:	46bd      	mov	sp, r7
24008d7e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d82:	4770      	bx	lr
24008d84:	52002000 	.word	0x52002000

24008d88 <HAL_FLASHEx_ComputeCRC>:
  *         A special error flag (CRC read error: CRCRDERR) can be used to
  *         detect such a case.
  * @retval HAL Status
*/
HAL_StatusTypeDef HAL_FLASHEx_ComputeCRC(FLASH_CRCInitTypeDef *pCRCInit, uint32_t *CRC_Result)
{
24008d88:	b580      	push	{r7, lr}
24008d8a:	b084      	sub	sp, #16
24008d8c:	af00      	add	r7, sp, #0
24008d8e:	6078      	str	r0, [r7, #4]
24008d90:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pCRCInit->Bank));
  assert_param(IS_FLASH_TYPECRC(pCRCInit->TypeCRC));

  /* Wait for OB change operation to be completed */
  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24008d92:	f24c 3050 	movw	r0, #50000	; 0xc350
24008d96:	f7ff fd55 	bl	24008844 <FLASH_OB_WaitForLastOperation>
24008d9a:	4603      	mov	r3, r0
24008d9c:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
24008d9e:	7bfb      	ldrb	r3, [r7, #15]
24008da0:	2b00      	cmp	r3, #0
24008da2:	d169      	bne.n	24008e78 <HAL_FLASHEx_ComputeCRC+0xf0>
  {
    if (pCRCInit->Bank == FLASH_BANK_1)
24008da4:	687b      	ldr	r3, [r7, #4]
24008da6:	689b      	ldr	r3, [r3, #8]
24008da8:	2b01      	cmp	r3, #1
24008daa:	d165      	bne.n	24008e78 <HAL_FLASHEx_ComputeCRC+0xf0>
    {
      /* Enable CRC feature */
      FLASH->CR1 |= FLASH_CR_CRC_EN;
24008dac:	4b35      	ldr	r3, [pc, #212]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008dae:	68db      	ldr	r3, [r3, #12]
24008db0:	4a34      	ldr	r2, [pc, #208]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008db2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
24008db6:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */
      FLASH->CCR1 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
24008db8:	4b32      	ldr	r3, [pc, #200]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008dba:	695b      	ldr	r3, [r3, #20]
24008dbc:	4a31      	ldr	r2, [pc, #196]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008dbe:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
24008dc2:	6153      	str	r3, [r2, #20]

      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */
      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24008dc4:	4b2f      	ldr	r3, [pc, #188]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008dc6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
24008dc8:	687b      	ldr	r3, [r7, #4]
24008dca:	6859      	ldr	r1, [r3, #4]
24008dcc:	687b      	ldr	r3, [r7, #4]
24008dce:	681b      	ldr	r3, [r3, #0]
24008dd0:	430b      	orrs	r3, r1
24008dd2:	4313      	orrs	r3, r2
24008dd4:	4a2b      	ldr	r2, [pc, #172]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008dd6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24008dda:	6513      	str	r3, [r2, #80]	; 0x50

      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24008ddc:	687b      	ldr	r3, [r7, #4]
24008dde:	681b      	ldr	r3, [r3, #0]
24008de0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24008de4:	d119      	bne.n	24008e1a <HAL_FLASHEx_ComputeCRC+0x92>
      {
        /* Clear sectors list */
        FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_SECT;
24008de6:	4b27      	ldr	r3, [pc, #156]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008de8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24008dea:	4a26      	ldr	r2, [pc, #152]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008dec:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
24008df0:	6513      	str	r3, [r2, #80]	; 0x50

        /* Select CRC sectors */
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24008df2:	687b      	ldr	r3, [r7, #4]
24008df4:	68db      	ldr	r3, [r3, #12]
24008df6:	60bb      	str	r3, [r7, #8]
24008df8:	e006      	b.n	24008e08 <HAL_FLASHEx_ComputeCRC+0x80>
        {
          FLASH_CRC_AddSector(sector_index, FLASH_BANK_1);
24008dfa:	2101      	movs	r1, #1
24008dfc:	68b8      	ldr	r0, [r7, #8]
24008dfe:	f000 fadd 	bl	240093bc <FLASH_CRC_AddSector>
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24008e02:	68bb      	ldr	r3, [r7, #8]
24008e04:	3301      	adds	r3, #1
24008e06:	60bb      	str	r3, [r7, #8]
24008e08:	687b      	ldr	r3, [r7, #4]
24008e0a:	691a      	ldr	r2, [r3, #16]
24008e0c:	687b      	ldr	r3, [r7, #4]
24008e0e:	68db      	ldr	r3, [r3, #12]
24008e10:	4413      	add	r3, r2
24008e12:	68ba      	ldr	r2, [r7, #8]
24008e14:	429a      	cmp	r2, r3
24008e16:	d3f0      	bcc.n	24008dfa <HAL_FLASHEx_ComputeCRC+0x72>
24008e18:	e013      	b.n	24008e42 <HAL_FLASHEx_ComputeCRC+0xba>
        }
      }
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
24008e1a:	687b      	ldr	r3, [r7, #4]
24008e1c:	681b      	ldr	r3, [r3, #0]
24008e1e:	4a1a      	ldr	r2, [pc, #104]	; (24008e88 <HAL_FLASHEx_ComputeCRC+0x100>)
24008e20:	4293      	cmp	r3, r2
24008e22:	d106      	bne.n	24008e32 <HAL_FLASHEx_ComputeCRC+0xaa>
      {
        /* Enable Bank 1 CRC select bit */
        FLASH->CRCCR1 |= FLASH_CRCCR_ALL_BANK;
24008e24:	4b17      	ldr	r3, [pc, #92]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008e26:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24008e28:	4a16      	ldr	r2, [pc, #88]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008e2a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24008e2e:	6513      	str	r3, [r2, #80]	; 0x50
24008e30:	e007      	b.n	24008e42 <HAL_FLASHEx_ComputeCRC+0xba>
      }
      else
      {
        /* Select CRC start and end addresses */
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_1);
24008e32:	687b      	ldr	r3, [r7, #4]
24008e34:	6958      	ldr	r0, [r3, #20]
24008e36:	687b      	ldr	r3, [r7, #4]
24008e38:	699b      	ldr	r3, [r3, #24]
24008e3a:	2201      	movs	r2, #1
24008e3c:	4619      	mov	r1, r3
24008e3e:	f000 fadb 	bl	240093f8 <FLASH_CRC_SelectAddress>
      }

      /* Start the CRC calculation */
      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;
24008e42:	4b10      	ldr	r3, [pc, #64]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008e44:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24008e46:	4a0f      	ldr	r2, [pc, #60]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008e48:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24008e4c:	6513      	str	r3, [r2, #80]	; 0x50

      /* Wait on CRC busy flag */
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24008e4e:	2101      	movs	r1, #1
24008e50:	f24c 3050 	movw	r0, #50000	; 0xc350
24008e54:	f7ff fd32 	bl	240088bc <FLASH_CRC_WaitForLastOperation>
24008e58:	4603      	mov	r3, r0
24008e5a:	73fb      	strb	r3, [r7, #15]

      /* Return CRC result */
      (*CRC_Result) = FLASH->CRCDATA;
24008e5c:	4b09      	ldr	r3, [pc, #36]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008e5e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
24008e60:	683b      	ldr	r3, [r7, #0]
24008e62:	601a      	str	r2, [r3, #0]

      /* Disable CRC feature */
      FLASH->CR1 &= (~FLASH_CR_CRC_EN);
24008e64:	4b07      	ldr	r3, [pc, #28]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008e66:	68db      	ldr	r3, [r3, #12]
24008e68:	4a06      	ldr	r2, [pc, #24]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008e6a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24008e6e:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCEND_BANK1 | FLASH_FLAG_CRCRDERR_BANK1);
24008e70:	4b04      	ldr	r3, [pc, #16]	; (24008e84 <HAL_FLASHEx_ComputeCRC+0xfc>)
24008e72:	f04f 52c0 	mov.w	r2, #402653184	; 0x18000000
24008e76:	615a      	str	r2, [r3, #20]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCEND_BANK2 | FLASH_FLAG_CRCRDERR_BANK2);
    }
#endif /* DUAL_BANK */
  }

  return status;
24008e78:	7bfb      	ldrb	r3, [r7, #15]
}
24008e7a:	4618      	mov	r0, r3
24008e7c:	3710      	adds	r7, #16
24008e7e:	46bd      	mov	sp, r7
24008e80:	bd80      	pop	{r7, pc}
24008e82:	bf00      	nop
24008e84:	52002000 	.word	0x52002000
24008e88:	00400100 	.word	0x00400100

24008e8c <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
24008e8c:	b480      	push	{r7}
24008e8e:	b083      	sub	sp, #12
24008e90:	af00      	add	r7, sp, #0
24008e92:	6078      	str	r0, [r7, #4]
24008e94:	6039      	str	r1, [r7, #0]
  }
  else
#endif /* DUAL_BANK */
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008e96:	683b      	ldr	r3, [r7, #0]
24008e98:	f003 0301 	and.w	r3, r3, #1
24008e9c:	2b00      	cmp	r3, #0
24008e9e:	d011      	beq.n	24008ec4 <FLASH_MassErase+0x38>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
24008ea0:	4b0b      	ldr	r3, [pc, #44]	; (24008ed0 <FLASH_MassErase+0x44>)
24008ea2:	68db      	ldr	r3, [r3, #12]
24008ea4:	4a0a      	ldr	r2, [pc, #40]	; (24008ed0 <FLASH_MassErase+0x44>)
24008ea6:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24008eaa:	60d3      	str	r3, [r2, #12]
      FLASH->CR1 |=  VoltageRange;
24008eac:	4b08      	ldr	r3, [pc, #32]	; (24008ed0 <FLASH_MassErase+0x44>)
24008eae:	68da      	ldr	r2, [r3, #12]
24008eb0:	4907      	ldr	r1, [pc, #28]	; (24008ed0 <FLASH_MassErase+0x44>)
24008eb2:	687b      	ldr	r3, [r7, #4]
24008eb4:	4313      	orrs	r3, r2
24008eb6:	60cb      	str	r3, [r1, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
24008eb8:	4b05      	ldr	r3, [pc, #20]	; (24008ed0 <FLASH_MassErase+0x44>)
24008eba:	68db      	ldr	r3, [r3, #12]
24008ebc:	4a04      	ldr	r2, [pc, #16]	; (24008ed0 <FLASH_MassErase+0x44>)
24008ebe:	f043 0388 	orr.w	r3, r3, #136	; 0x88
24008ec2:	60d3      	str	r3, [r2, #12]
      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
    }
#endif /* DUAL_BANK */
  }
}
24008ec4:	bf00      	nop
24008ec6:	370c      	adds	r7, #12
24008ec8:	46bd      	mov	sp, r7
24008eca:	f85d 7b04 	ldr.w	r7, [sp], #4
24008ece:	4770      	bx	lr
24008ed0:	52002000 	.word	0x52002000

24008ed4 <FLASH_Erase_Sector>:
  *            @arg FLASH_VOLTAGE_RANGE_4 : Flash program/erase by 64 bits
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
24008ed4:	b480      	push	{r7}
24008ed6:	b085      	sub	sp, #20
24008ed8:	af00      	add	r7, sp, #0
24008eda:	60f8      	str	r0, [r7, #12]
24008edc:	60b9      	str	r1, [r7, #8]
24008ede:	607a      	str	r2, [r7, #4]
  assert_param(IS_VOLTAGERANGE(VoltageRange));
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008ee0:	68bb      	ldr	r3, [r7, #8]
24008ee2:	f003 0301 	and.w	r3, r3, #1
24008ee6:	2b00      	cmp	r3, #0
24008ee8:	d010      	beq.n	24008f0c <FLASH_Erase_Sector+0x38>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
24008eea:	4b0b      	ldr	r3, [pc, #44]	; (24008f18 <FLASH_Erase_Sector+0x44>)
24008eec:	68db      	ldr	r3, [r3, #12]
24008eee:	4a0a      	ldr	r2, [pc, #40]	; (24008f18 <FLASH_Erase_Sector+0x44>)
24008ef0:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
24008ef4:	60d3      	str	r3, [r2, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
24008ef6:	4b08      	ldr	r3, [pc, #32]	; (24008f18 <FLASH_Erase_Sector+0x44>)
24008ef8:	68da      	ldr	r2, [r3, #12]
24008efa:	68fb      	ldr	r3, [r7, #12]
24008efc:	0219      	lsls	r1, r3, #8
24008efe:	687b      	ldr	r3, [r7, #4]
24008f00:	430b      	orrs	r3, r1
24008f02:	4313      	orrs	r3, r2
24008f04:	4a04      	ldr	r2, [pc, #16]	; (24008f18 <FLASH_Erase_Sector+0x44>)
24008f06:	f043 0384 	orr.w	r3, r3, #132	; 0x84
24008f0a:	60d3      	str	r3, [r2, #12]

    FLASH->CR2 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }
#endif /* DUAL_BANK */
}
24008f0c:	bf00      	nop
24008f0e:	3714      	adds	r7, #20
24008f10:	46bd      	mov	sp, r7
24008f12:	f85d 7b04 	ldr.w	r7, [sp], #4
24008f16:	4770      	bx	lr
24008f18:	52002000 	.word	0x52002000

24008f1c <FLASH_OB_EnableWRP>:
  *            @arg FLASH_BANK_BOTH: enable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
{
24008f1c:	b480      	push	{r7}
24008f1e:	b083      	sub	sp, #12
24008f20:	af00      	add	r7, sp, #0
24008f22:	6078      	str	r0, [r7, #4]
24008f24:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008f26:	683b      	ldr	r3, [r7, #0]
24008f28:	f003 0301 	and.w	r3, r3, #1
24008f2c:	2b00      	cmp	r3, #0
24008f2e:	d007      	beq.n	24008f40 <FLASH_OB_EnableWRP+0x24>
  {
    /* Enable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));
24008f30:	4b06      	ldr	r3, [pc, #24]	; (24008f4c <FLASH_OB_EnableWRP+0x30>)
24008f32:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24008f34:	687b      	ldr	r3, [r7, #4]
24008f36:	b2db      	uxtb	r3, r3
24008f38:	43db      	mvns	r3, r3
24008f3a:	4904      	ldr	r1, [pc, #16]	; (24008f4c <FLASH_OB_EnableWRP+0x30>)
24008f3c:	4013      	ands	r3, r2
24008f3e:	63cb      	str	r3, [r1, #60]	; 0x3c
  {
    /* Enable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));
  }
#endif /* DUAL_BANK */
}
24008f40:	bf00      	nop
24008f42:	370c      	adds	r7, #12
24008f44:	46bd      	mov	sp, r7
24008f46:	f85d 7b04 	ldr.w	r7, [sp], #4
24008f4a:	4770      	bx	lr
24008f4c:	52002000 	.word	0x52002000

24008f50 <FLASH_OB_DisableWRP>:
  *            @arg FLASH_BANK_BOTH: disable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
{
24008f50:	b480      	push	{r7}
24008f52:	b083      	sub	sp, #12
24008f54:	af00      	add	r7, sp, #0
24008f56:	6078      	str	r0, [r7, #4]
24008f58:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008f5a:	683b      	ldr	r3, [r7, #0]
24008f5c:	f003 0301 	and.w	r3, r3, #1
24008f60:	2b00      	cmp	r3, #0
24008f62:	d006      	beq.n	24008f72 <FLASH_OB_DisableWRP+0x22>
  {
    /* Disable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);
24008f64:	4b06      	ldr	r3, [pc, #24]	; (24008f80 <FLASH_OB_DisableWRP+0x30>)
24008f66:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24008f68:	687b      	ldr	r3, [r7, #4]
24008f6a:	b2db      	uxtb	r3, r3
24008f6c:	4904      	ldr	r1, [pc, #16]	; (24008f80 <FLASH_OB_DisableWRP+0x30>)
24008f6e:	4313      	orrs	r3, r2
24008f70:	63cb      	str	r3, [r1, #60]	; 0x3c
  {
    /* Disable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);
  }
#endif /* DUAL_BANK */
}
24008f72:	bf00      	nop
24008f74:	370c      	adds	r7, #12
24008f76:	46bd      	mov	sp, r7
24008f78:	f85d 7b04 	ldr.w	r7, [sp], #4
24008f7c:	4770      	bx	lr
24008f7e:	bf00      	nop
24008f80:	52002000 	.word	0x52002000

24008f84 <FLASH_OB_GetWRP>:
  *            @arg FLASH_BANK_BOTH: note allowed in this functions
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank)
{
24008f84:	b480      	push	{r7}
24008f86:	b087      	sub	sp, #28
24008f88:	af00      	add	r7, sp, #0
24008f8a:	60f8      	str	r0, [r7, #12]
24008f8c:	60b9      	str	r1, [r7, #8]
24008f8e:	607a      	str	r2, [r7, #4]
  uint32_t regvalue = 0U;
24008f90:	2300      	movs	r3, #0
24008f92:	617b      	str	r3, [r7, #20]

  if(Bank == FLASH_BANK_1)
24008f94:	687b      	ldr	r3, [r7, #4]
24008f96:	2b01      	cmp	r3, #1
24008f98:	d102      	bne.n	24008fa0 <FLASH_OB_GetWRP+0x1c>
  {
    regvalue = FLASH->WPSN_CUR1;
24008f9a:	4b0c      	ldr	r3, [pc, #48]	; (24008fcc <FLASH_OB_GetWRP+0x48>)
24008f9c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24008f9e:	617b      	str	r3, [r7, #20]
  {
    regvalue = FLASH->WPSN_CUR2;
  }
#endif /* DUAL_BANK */

  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;
24008fa0:	697b      	ldr	r3, [r7, #20]
24008fa2:	43db      	mvns	r3, r3
24008fa4:	b2da      	uxtb	r2, r3
24008fa6:	68bb      	ldr	r3, [r7, #8]
24008fa8:	601a      	str	r2, [r3, #0]

  if(*WRPSector == 0U)
24008faa:	68bb      	ldr	r3, [r7, #8]
24008fac:	681b      	ldr	r3, [r3, #0]
24008fae:	2b00      	cmp	r3, #0
24008fb0:	d103      	bne.n	24008fba <FLASH_OB_GetWRP+0x36>
  {
    (*WRPState) = OB_WRPSTATE_DISABLE;
24008fb2:	68fb      	ldr	r3, [r7, #12]
24008fb4:	2200      	movs	r2, #0
24008fb6:	601a      	str	r2, [r3, #0]
  }
  else
  {
    (*WRPState) = OB_WRPSTATE_ENABLE;
  }
}
24008fb8:	e002      	b.n	24008fc0 <FLASH_OB_GetWRP+0x3c>
    (*WRPState) = OB_WRPSTATE_ENABLE;
24008fba:	68fb      	ldr	r3, [r7, #12]
24008fbc:	2201      	movs	r2, #1
24008fbe:	601a      	str	r2, [r3, #0]
}
24008fc0:	bf00      	nop
24008fc2:	371c      	adds	r7, #28
24008fc4:	46bd      	mov	sp, r7
24008fc6:	f85d 7b04 	ldr.w	r7, [sp], #4
24008fca:	4770      	bx	lr
24008fcc:	52002000 	.word	0x52002000

24008fd0 <FLASH_OB_RDPConfig>:
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *
  * @retval HAL status
  */
static void FLASH_OB_RDPConfig(uint32_t RDPLevel)
{
24008fd0:	b480      	push	{r7}
24008fd2:	b083      	sub	sp, #12
24008fd4:	af00      	add	r7, sp, #0
24008fd6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);
24008fd8:	4b06      	ldr	r3, [pc, #24]	; (24008ff4 <FLASH_OB_RDPConfig+0x24>)
24008fda:	6a1b      	ldr	r3, [r3, #32]
24008fdc:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
24008fe0:	4904      	ldr	r1, [pc, #16]	; (24008ff4 <FLASH_OB_RDPConfig+0x24>)
24008fe2:	687b      	ldr	r3, [r7, #4]
24008fe4:	4313      	orrs	r3, r2
24008fe6:	620b      	str	r3, [r1, #32]
}
24008fe8:	bf00      	nop
24008fea:	370c      	adds	r7, #12
24008fec:	46bd      	mov	sp, r7
24008fee:	f85d 7b04 	ldr.w	r7, [sp], #4
24008ff2:	4770      	bx	lr
24008ff4:	52002000 	.word	0x52002000

24008ff8 <FLASH_OB_GetRDP>:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
24008ff8:	b480      	push	{r7}
24008ffa:	b083      	sub	sp, #12
24008ffc:	af00      	add	r7, sp, #0
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
24008ffe:	4b0b      	ldr	r3, [pc, #44]	; (2400902c <FLASH_OB_GetRDP+0x34>)
24009000:	69db      	ldr	r3, [r3, #28]
24009002:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
24009006:	607b      	str	r3, [r7, #4]
  
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
24009008:	687b      	ldr	r3, [r7, #4]
2400900a:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400900e:	d006      	beq.n	2400901e <FLASH_OB_GetRDP+0x26>
24009010:	687b      	ldr	r3, [r7, #4]
24009012:	f5b3 4f4c 	cmp.w	r3, #52224	; 0xcc00
24009016:	d002      	beq.n	2400901e <FLASH_OB_GetRDP+0x26>
  {
    return (OB_RDP_LEVEL_1);
24009018:	f44f 43aa 	mov.w	r3, #21760	; 0x5500
2400901c:	e000      	b.n	24009020 <FLASH_OB_GetRDP+0x28>
  }
  else
  {
    return rdp_level;
2400901e:	687b      	ldr	r3, [r7, #4]
  }
}
24009020:	4618      	mov	r0, r3
24009022:	370c      	adds	r7, #12
24009024:	46bd      	mov	sp, r7
24009026:	f85d 7b04 	ldr.w	r7, [sp], #4
2400902a:	4770      	bx	lr
2400902c:	52002000 	.word	0x52002000

24009030 <FLASH_OB_UserConfig>:
  *
  * @retval HAL status
  */
#endif /*DUAL_CORE*/
static void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)
{
24009030:	b480      	push	{r7}
24009032:	b085      	sub	sp, #20
24009034:	af00      	add	r7, sp, #0
24009036:	6078      	str	r0, [r7, #4]
24009038:	6039      	str	r1, [r7, #0]
  uint32_t optr_reg_val = 0;
2400903a:	2300      	movs	r3, #0
2400903c:	60fb      	str	r3, [r7, #12]
  uint32_t optr_reg_mask = 0;
2400903e:	2300      	movs	r3, #0
24009040:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_IWDG1_SW) != 0U)
24009042:	687b      	ldr	r3, [r7, #4]
24009044:	f003 0301 	and.w	r3, r3, #1
24009048:	2b00      	cmp	r3, #0
2400904a:	d009      	beq.n	24009060 <FLASH_OB_UserConfig+0x30>
  {
    /* IWDG_HW option byte should be modified */
    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));

    /* Set value and mask for IWDG_HW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);
2400904c:	683b      	ldr	r3, [r7, #0]
2400904e:	f003 0310 	and.w	r3, r3, #16
24009052:	68fa      	ldr	r2, [r7, #12]
24009054:	4313      	orrs	r3, r2
24009056:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;
24009058:	68bb      	ldr	r3, [r7, #8]
2400905a:	f043 0310 	orr.w	r3, r3, #16
2400905e:	60bb      	str	r3, [r7, #8]
    /* Set value and mask for IWDG2_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);
    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;
  }
#endif /*DUAL_CORE*/
  if((UserType & OB_USER_NRST_STOP_D1) != 0U)
24009060:	687b      	ldr	r3, [r7, #4]
24009062:	f003 0302 	and.w	r3, r3, #2
24009066:	2b00      	cmp	r3, #0
24009068:	d009      	beq.n	2400907e <FLASH_OB_UserConfig+0x4e>
  {
    /* NRST_STOP option byte should be modified */
    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));

    /* Set value and mask for NRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
2400906a:	683b      	ldr	r3, [r7, #0]
2400906c:	f003 0340 	and.w	r3, r3, #64	; 0x40
24009070:	68fa      	ldr	r2, [r7, #12]
24009072:	4313      	orrs	r3, r2
24009074:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;
24009076:	68bb      	ldr	r3, [r7, #8]
24009078:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400907c:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)
2400907e:	687b      	ldr	r3, [r7, #4]
24009080:	f003 0304 	and.w	r3, r3, #4
24009084:	2b00      	cmp	r3, #0
24009086:	d009      	beq.n	2400909c <FLASH_OB_UserConfig+0x6c>
  {
    /* NRST_STDBY option byte should be modified */
    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));

    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
24009088:	683b      	ldr	r3, [r7, #0]
2400908a:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400908e:	68fa      	ldr	r2, [r7, #12]
24009090:	4313      	orrs	r3, r2
24009092:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;
24009094:	68bb      	ldr	r3, [r7, #8]
24009096:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2400909a:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
2400909c:	687b      	ldr	r3, [r7, #4]
2400909e:	f003 0308 	and.w	r3, r3, #8
240090a2:	2b00      	cmp	r3, #0
240090a4:	d009      	beq.n	240090ba <FLASH_OB_UserConfig+0x8a>
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
240090a6:	683b      	ldr	r3, [r7, #0]
240090a8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240090ac:	68fa      	ldr	r2, [r7, #12]
240090ae:	4313      	orrs	r3, r2
240090b0:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;
240090b2:	68bb      	ldr	r3, [r7, #8]
240090b4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240090b8:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
240090ba:	687b      	ldr	r3, [r7, #4]
240090bc:	f003 0310 	and.w	r3, r3, #16
240090c0:	2b00      	cmp	r3, #0
240090c2:	d009      	beq.n	240090d8 <FLASH_OB_UserConfig+0xa8>
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
240090c4:	683b      	ldr	r3, [r7, #0]
240090c6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
240090ca:	68fa      	ldr	r2, [r7, #12]
240090cc:	4313      	orrs	r3, r2
240090ce:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;
240090d0:	68bb      	ldr	r3, [r7, #8]
240090d2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
240090d6:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)
240090d8:	687b      	ldr	r3, [r7, #4]
240090da:	f003 0320 	and.w	r3, r3, #32
240090de:	2b00      	cmp	r3, #0
240090e0:	d009      	beq.n	240090f6 <FLASH_OB_UserConfig+0xc6>
  {
    /* ST_RAM_SIZE option byte should be modified */
    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));

    /* Set value and mask for ST_RAM_SIZE option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
240090e2:	683b      	ldr	r3, [r7, #0]
240090e4:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
240090e8:	68fa      	ldr	r2, [r7, #12]
240090ea:	4313      	orrs	r3, r2
240090ec:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;
240090ee:	68bb      	ldr	r3, [r7, #8]
240090f0:	f443 13c0 	orr.w	r3, r3, #1572864	; 0x180000
240090f4:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_SECURITY) != 0U)
240090f6:	687b      	ldr	r3, [r7, #4]
240090f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
240090fc:	2b00      	cmp	r3, #0
240090fe:	d009      	beq.n	24009114 <FLASH_OB_UserConfig+0xe4>
  {
    /* SECURITY option byte should be modified */
    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));

    /* Set value and mask for SECURITY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
24009100:	683b      	ldr	r3, [r7, #0]
24009102:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24009106:	68fa      	ldr	r2, [r7, #12]
24009108:	4313      	orrs	r3, r2
2400910a:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_SECURITY;
2400910c:	68bb      	ldr	r3, [r7, #8]
2400910e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
24009112:	60bb      	str	r3, [r7, #8]
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;
  }
#endif /* DUAL_BANK */

  if((UserType & OB_USER_IOHSLV) != 0U)
24009114:	687b      	ldr	r3, [r7, #4]
24009116:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400911a:	2b00      	cmp	r3, #0
2400911c:	d009      	beq.n	24009132 <FLASH_OB_UserConfig+0x102>
  {
    /* IOHSLV_OPT option byte should be modified */
    assert_param(IS_OB_USER_IOHSLV(UserConfig & FLASH_OPTSR_IO_HSLV));

    /* Set value and mask for IOHSLV_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
2400911e:	683b      	ldr	r3, [r7, #0]
24009120:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24009124:	68fa      	ldr	r2, [r7, #12]
24009126:	4313      	orrs	r3, r2
24009128:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;
2400912a:	68bb      	ldr	r3, [r7, #8]
2400912c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
24009130:	60bb      	str	r3, [r7, #8]
    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;
  }
#endif /* FLASH_OPTSR_VDDMMC_HSLV */

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
24009132:	4b07      	ldr	r3, [pc, #28]	; (24009150 <FLASH_OB_UserConfig+0x120>)
24009134:	6a1a      	ldr	r2, [r3, #32]
24009136:	68bb      	ldr	r3, [r7, #8]
24009138:	43db      	mvns	r3, r3
2400913a:	401a      	ands	r2, r3
2400913c:	4904      	ldr	r1, [pc, #16]	; (24009150 <FLASH_OB_UserConfig+0x120>)
2400913e:	68fb      	ldr	r3, [r7, #12]
24009140:	4313      	orrs	r3, r2
24009142:	620b      	str	r3, [r1, #32]
}
24009144:	bf00      	nop
24009146:	3714      	adds	r7, #20
24009148:	46bd      	mov	sp, r7
2400914a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400914e:	4770      	bx	lr
24009150:	52002000 	.word	0x52002000

24009154 <FLASH_OB_GetUser>:
  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),
  *         SECURITY(Bit 21), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).
  */
#endif /*DUAL_CORE*/
static uint32_t FLASH_OB_GetUser(void)
{
24009154:	b480      	push	{r7}
24009156:	b083      	sub	sp, #12
24009158:	af00      	add	r7, sp, #0
  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);
2400915a:	4b07      	ldr	r3, [pc, #28]	; (24009178 <FLASH_OB_GetUser+0x24>)
2400915c:	69db      	ldr	r3, [r3, #28]
2400915e:	607b      	str	r3, [r7, #4]
  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));
24009160:	687a      	ldr	r2, [r7, #4]
24009162:	4b06      	ldr	r3, [pc, #24]	; (2400917c <FLASH_OB_GetUser+0x28>)
24009164:	4013      	ands	r3, r2
24009166:	607b      	str	r3, [r7, #4]

  return userConfig;
24009168:	687b      	ldr	r3, [r7, #4]
}
2400916a:	4618      	mov	r0, r3
2400916c:	370c      	adds	r7, #12
2400916e:	46bd      	mov	sp, r7
24009170:	f85d 7b04 	ldr.w	r7, [sp], #4
24009174:	4770      	bx	lr
24009176:	bf00      	nop
24009178:	52002000 	.word	0x52002000
2400917c:	ffff00f3 	.word	0xffff00f3

24009180 <FLASH_OB_PCROPConfig>:
  *            @arg FLASH_BANK_BOTH: PCROP on specified bank1 and bank2 area (same config will be applied on both banks)
  *
  * @retval None
  */
static void FLASH_OB_PCROPConfig(uint32_t PCROPConfig, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks)
{
24009180:	b480      	push	{r7}
24009182:	b085      	sub	sp, #20
24009184:	af00      	add	r7, sp, #0
24009186:	60f8      	str	r0, [r7, #12]
24009188:	60b9      	str	r1, [r7, #8]
2400918a:	607a      	str	r2, [r7, #4]
2400918c:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_PCROP_RDP(PCROPConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400918e:	683b      	ldr	r3, [r7, #0]
24009190:	f003 0301 	and.w	r3, r3, #1
24009194:	2b00      	cmp	r3, #0
24009196:	d00d      	beq.n	240091b4 <FLASH_OB_PCROPConfig+0x34>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
24009198:	68bb      	ldr	r3, [r7, #8]
2400919a:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2400919e:	0a1a      	lsrs	r2, r3, #8
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
240091a0:	687b      	ldr	r3, [r7, #4]
240091a2:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
240091a6:	0a1b      	lsrs	r3, r3, #8
240091a8:	041b      	lsls	r3, r3, #16
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
240091aa:	431a      	orrs	r2, r3
240091ac:	4904      	ldr	r1, [pc, #16]	; (240091c0 <FLASH_OB_PCROPConfig+0x40>)
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
240091ae:	68fb      	ldr	r3, [r7, #12]
240091b0:	4313      	orrs	r3, r2
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
240091b2:	62cb      	str	r3, [r1, #44]	; 0x2c
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
                       PCROPConfig;
  }
#endif /* DUAL_BANK */
}
240091b4:	bf00      	nop
240091b6:	3714      	adds	r7, #20
240091b8:	46bd      	mov	sp, r7
240091ba:	f85d 7b04 	ldr.w	r7, [sp], #4
240091be:	4770      	bx	lr
240091c0:	52002000 	.word	0x52002000

240091c4 <FLASH_OB_GetPCROP>:
  *            @arg FLASH_BANK_BOTH: is  not allowed here
  *
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr, uint32_t *PCROPEndAddr, uint32_t Bank)
{
240091c4:	b480      	push	{r7}
240091c6:	b087      	sub	sp, #28
240091c8:	af00      	add	r7, sp, #0
240091ca:	60f8      	str	r0, [r7, #12]
240091cc:	60b9      	str	r1, [r7, #8]
240091ce:	607a      	str	r2, [r7, #4]
240091d0:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
240091d2:	2300      	movs	r3, #0
240091d4:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
240091d6:	2300      	movs	r3, #0
240091d8:	613b      	str	r3, [r7, #16]

  if(Bank == FLASH_BANK_1)
240091da:	683b      	ldr	r3, [r7, #0]
240091dc:	2b01      	cmp	r3, #1
240091de:	d105      	bne.n	240091ec <FLASH_OB_GetPCROP+0x28>
  {
    regvalue = FLASH->PRAR_CUR1;
240091e0:	4b12      	ldr	r3, [pc, #72]	; (2400922c <FLASH_OB_GetPCROP+0x68>)
240091e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240091e4:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
240091e6:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
240091ea:	613b      	str	r3, [r7, #16]
    regvalue = FLASH->PRAR_CUR2;
    bankBase = FLASH_BANK2_BASE;
  }
#endif /* DUAL_BANK */

  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
240091ec:	697b      	ldr	r3, [r7, #20]
240091ee:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
240091f2:	68fb      	ldr	r3, [r7, #12]
240091f4:	601a      	str	r2, [r3, #0]

  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
240091f6:	697b      	ldr	r3, [r7, #20]
240091f8:	021a      	lsls	r2, r3, #8
240091fa:	4b0d      	ldr	r3, [pc, #52]	; (24009230 <FLASH_OB_GetPCROP+0x6c>)
240091fc:	4013      	ands	r3, r2
240091fe:	693a      	ldr	r2, [r7, #16]
24009200:	441a      	add	r2, r3
24009202:	68bb      	ldr	r3, [r7, #8]
24009204:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = (regvalue & FLASH_PRAR_PROT_AREA_END) >> FLASH_PRAR_PROT_AREA_END_Pos;
24009206:	697b      	ldr	r3, [r7, #20]
24009208:	0c1b      	lsrs	r3, r3, #16
2400920a:	f3c3 020b 	ubfx	r2, r3, #0, #12
2400920e:	687b      	ldr	r3, [r7, #4]
24009210:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
24009212:	687b      	ldr	r3, [r7, #4]
24009214:	681b      	ldr	r3, [r3, #0]
24009216:	021a      	lsls	r2, r3, #8
24009218:	693b      	ldr	r3, [r7, #16]
2400921a:	441a      	add	r2, r3
2400921c:	687b      	ldr	r3, [r7, #4]
2400921e:	601a      	str	r2, [r3, #0]
}
24009220:	bf00      	nop
24009222:	371c      	adds	r7, #28
24009224:	46bd      	mov	sp, r7
24009226:	f85d 7b04 	ldr.w	r7, [sp], #4
2400922a:	4770      	bx	lr
2400922c:	52002000 	.word	0x52002000
24009230:	000fff00 	.word	0x000fff00

24009234 <FLASH_OB_BOR_LevelConfig>:
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  * @retval None
  */
static void FLASH_OB_BOR_LevelConfig(uint32_t Level)
{
24009234:	b480      	push	{r7}
24009236:	b083      	sub	sp, #12
24009238:	af00      	add	r7, sp, #0
2400923a:	6078      	str	r0, [r7, #4]
  assert_param(IS_OB_BOR_LEVEL(Level));

  /* Configure BOR_LEV option byte */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);
2400923c:	4b06      	ldr	r3, [pc, #24]	; (24009258 <FLASH_OB_BOR_LevelConfig+0x24>)
2400923e:	6a1b      	ldr	r3, [r3, #32]
24009240:	f023 020c 	bic.w	r2, r3, #12
24009244:	4904      	ldr	r1, [pc, #16]	; (24009258 <FLASH_OB_BOR_LevelConfig+0x24>)
24009246:	687b      	ldr	r3, [r7, #4]
24009248:	4313      	orrs	r3, r2
2400924a:	620b      	str	r3, [r1, #32]
}
2400924c:	bf00      	nop
2400924e:	370c      	adds	r7, #12
24009250:	46bd      	mov	sp, r7
24009252:	f85d 7b04 	ldr.w	r7, [sp], #4
24009256:	4770      	bx	lr
24009258:	52002000 	.word	0x52002000

2400925c <FLASH_OB_GetBOR>:
  *            @arg OB_BOR_LEVEL1: Reset level threshold is set to 2.1V
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  */
static uint32_t FLASH_OB_GetBOR(void)
{
2400925c:	b480      	push	{r7}
2400925e:	af00      	add	r7, sp, #0
  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);
24009260:	4b04      	ldr	r3, [pc, #16]	; (24009274 <FLASH_OB_GetBOR+0x18>)
24009262:	69db      	ldr	r3, [r3, #28]
24009264:	f003 030c 	and.w	r3, r3, #12
}
24009268:	4618      	mov	r0, r3
2400926a:	46bd      	mov	sp, r7
2400926c:	f85d 7b04 	ldr.w	r7, [sp], #4
24009270:	4770      	bx	lr
24009272:	bf00      	nop
24009274:	52002000 	.word	0x52002000

24009278 <FLASH_OB_BootAddConfig>:
  * @param  BootAddress0 Specifies the Boot Address 0
  * @param  BootAddress1 Specifies the Boot Address 1
  * @retval HAL Status
  */
static void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)
{
24009278:	b480      	push	{r7}
2400927a:	b085      	sub	sp, #20
2400927c:	af00      	add	r7, sp, #0
2400927e:	60f8      	str	r0, [r7, #12]
24009280:	60b9      	str	r1, [r7, #8]
24009282:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));

  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)
24009284:	68fb      	ldr	r3, [r7, #12]
24009286:	f003 0301 	and.w	r3, r3, #1
2400928a:	2b00      	cmp	r3, #0
2400928c:	d008      	beq.n	240092a0 <FLASH_OB_BootAddConfig+0x28>

    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));
2400928e:	4b0d      	ldr	r3, [pc, #52]	; (240092c4 <FLASH_OB_BootAddConfig+0x4c>)
24009290:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24009292:	4b0d      	ldr	r3, [pc, #52]	; (240092c8 <FLASH_OB_BootAddConfig+0x50>)
24009294:	4013      	ands	r3, r2
24009296:	68ba      	ldr	r2, [r7, #8]
24009298:	0c12      	lsrs	r2, r2, #16
2400929a:	490a      	ldr	r1, [pc, #40]	; (240092c4 <FLASH_OB_BootAddConfig+0x4c>)
2400929c:	4313      	orrs	r3, r2
2400929e:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }

  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)
240092a0:	68fb      	ldr	r3, [r7, #12]
240092a2:	f003 0302 	and.w	r3, r3, #2
240092a6:	2b00      	cmp	r3, #0
240092a8:	d006      	beq.n	240092b8 <FLASH_OB_BootAddConfig+0x40>

    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);
240092aa:	4b06      	ldr	r3, [pc, #24]	; (240092c4 <FLASH_OB_BootAddConfig+0x4c>)
240092ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240092ae:	b29a      	uxth	r2, r3
240092b0:	4904      	ldr	r1, [pc, #16]	; (240092c4 <FLASH_OB_BootAddConfig+0x4c>)
240092b2:	687b      	ldr	r3, [r7, #4]
240092b4:	4313      	orrs	r3, r2
240092b6:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }
}
240092b8:	bf00      	nop
240092ba:	3714      	adds	r7, #20
240092bc:	46bd      	mov	sp, r7
240092be:	f85d 7b04 	ldr.w	r7, [sp], #4
240092c2:	4770      	bx	lr
240092c4:	52002000 	.word	0x52002000
240092c8:	ffff0000 	.word	0xffff0000

240092cc <FLASH_OB_GetBootAdd>:
  * @param  BootAddress0 Specifies the Boot Address 0.
  * @param  BootAddress1 Specifies the Boot Address 1.
  * @retval HAL Status
  */
static void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)
{
240092cc:	b480      	push	{r7}
240092ce:	b085      	sub	sp, #20
240092d0:	af00      	add	r7, sp, #0
240092d2:	6078      	str	r0, [r7, #4]
240092d4:	6039      	str	r1, [r7, #0]
  regvalue = FLASH->BOOT7_CUR;

  (*BootAddress0) = (regvalue & FLASH_BOOT7_BCM7_ADD0) << 16;
  (*BootAddress1) = (regvalue & FLASH_BOOT7_BCM7_ADD1);
#else /* Single Core */
  regvalue = FLASH->BOOT_CUR;
240092d6:	4b09      	ldr	r3, [pc, #36]	; (240092fc <FLASH_OB_GetBootAdd+0x30>)
240092d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240092da:	60fb      	str	r3, [r7, #12]

  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
240092dc:	68fb      	ldr	r3, [r7, #12]
240092de:	041a      	lsls	r2, r3, #16
240092e0:	687b      	ldr	r3, [r7, #4]
240092e2:	601a      	str	r2, [r3, #0]
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
240092e4:	68fa      	ldr	r2, [r7, #12]
240092e6:	4b06      	ldr	r3, [pc, #24]	; (24009300 <FLASH_OB_GetBootAdd+0x34>)
240092e8:	4013      	ands	r3, r2
240092ea:	683a      	ldr	r2, [r7, #0]
240092ec:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE */
}
240092ee:	bf00      	nop
240092f0:	3714      	adds	r7, #20
240092f2:	46bd      	mov	sp, r7
240092f4:	f85d 7b04 	ldr.w	r7, [sp], #4
240092f8:	4770      	bx	lr
240092fa:	bf00      	nop
240092fc:	52002000 	.word	0x52002000
24009300:	ffff0000 	.word	0xffff0000

24009304 <FLASH_OB_SecureAreaConfig>:
  *            @arg FLASH_BANK_2: Secure area on specified bank2 area
  *            @arg FLASH_BANK_BOTH: Secure area on specified bank1 and bank2 area (same config will be applied on both banks)
  * @retval None
  */
static void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks)
{
24009304:	b480      	push	{r7}
24009306:	b085      	sub	sp, #20
24009308:	af00      	add	r7, sp, #0
2400930a:	60f8      	str	r0, [r7, #12]
2400930c:	60b9      	str	r1, [r7, #8]
2400930e:	607a      	str	r2, [r7, #4]
24009310:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24009312:	683b      	ldr	r3, [r7, #0]
24009314:	f003 0301 	and.w	r3, r3, #1
24009318:	2b00      	cmp	r3, #0
2400931a:	d00f      	beq.n	2400933c <FLASH_OB_SecureAreaConfig+0x38>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400931c:	68bb      	ldr	r3, [r7, #8]
2400931e:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
24009322:	0a1a      	lsrs	r2, r3, #8
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24009324:	687b      	ldr	r3, [r7, #4]
24009326:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2400932a:	0a1b      	lsrs	r3, r3, #8
2400932c:	041b      	lsls	r3, r3, #16
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400932e:	431a      	orrs	r2, r3
                       (SecureAreaConfig & FLASH_SCAR_DMES);
24009330:	68fb      	ldr	r3, [r7, #12]
24009332:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
24009336:	4904      	ldr	r1, [pc, #16]	; (24009348 <FLASH_OB_SecureAreaConfig+0x44>)
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24009338:	4313      	orrs	r3, r2
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400933a:	634b      	str	r3, [r1, #52]	; 0x34
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
                       (SecureAreaConfig & FLASH_SCAR_DMES);
  }
#endif /* DUAL_BANK */
}
2400933c:	bf00      	nop
2400933e:	3714      	adds	r7, #20
24009340:	46bd      	mov	sp, r7
24009342:	f85d 7b04 	ldr.w	r7, [sp], #4
24009346:	4770      	bx	lr
24009348:	52002000 	.word	0x52002000

2400934c <FLASH_OB_GetSecureArea>:
  * @param  SecureAreaEndAddr gives the secure area end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank)
{
2400934c:	b480      	push	{r7}
2400934e:	b087      	sub	sp, #28
24009350:	af00      	add	r7, sp, #0
24009352:	60f8      	str	r0, [r7, #12]
24009354:	60b9      	str	r1, [r7, #8]
24009356:	607a      	str	r2, [r7, #4]
24009358:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
2400935a:	2300      	movs	r3, #0
2400935c:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
2400935e:	2300      	movs	r3, #0
24009360:	613b      	str	r3, [r7, #16]

  /* Check Bank parameter value */
  if(Bank == FLASH_BANK_1)
24009362:	683b      	ldr	r3, [r7, #0]
24009364:	2b01      	cmp	r3, #1
24009366:	d105      	bne.n	24009374 <FLASH_OB_GetSecureArea+0x28>
  {
    regvalue = FLASH->SCAR_CUR1;
24009368:	4b12      	ldr	r3, [pc, #72]	; (240093b4 <FLASH_OB_GetSecureArea+0x68>)
2400936a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400936c:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
2400936e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
24009372:	613b      	str	r3, [r7, #16]
    bankBase = FLASH_BANK2_BASE;
  }
#endif /* DUAL_BANK */

  /* Get the secure area settings */
  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);
24009374:	697b      	ldr	r3, [r7, #20]
24009376:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
2400937a:	68fb      	ldr	r3, [r7, #12]
2400937c:	601a      	str	r2, [r3, #0]
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
2400937e:	697b      	ldr	r3, [r7, #20]
24009380:	021a      	lsls	r2, r3, #8
24009382:	4b0d      	ldr	r3, [pc, #52]	; (240093b8 <FLASH_OB_GetSecureArea+0x6c>)
24009384:	4013      	ands	r3, r2
24009386:	693a      	ldr	r2, [r7, #16]
24009388:	441a      	add	r2, r3
2400938a:	68bb      	ldr	r3, [r7, #8]
2400938c:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;
2400938e:	697b      	ldr	r3, [r7, #20]
24009390:	0c1b      	lsrs	r3, r3, #16
24009392:	f3c3 020b 	ubfx	r2, r3, #0, #12
24009396:	687b      	ldr	r3, [r7, #4]
24009398:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
2400939a:	687b      	ldr	r3, [r7, #4]
2400939c:	681b      	ldr	r3, [r3, #0]
2400939e:	021a      	lsls	r2, r3, #8
240093a0:	693b      	ldr	r3, [r7, #16]
240093a2:	441a      	add	r2, r3
240093a4:	687b      	ldr	r3, [r7, #4]
240093a6:	601a      	str	r2, [r3, #0]
}
240093a8:	bf00      	nop
240093aa:	371c      	adds	r7, #28
240093ac:	46bd      	mov	sp, r7
240093ae:	f85d 7b04 	ldr.w	r7, [sp], #4
240093b2:	4770      	bx	lr
240093b4:	52002000 	.word	0x52002000
240093b8:	000fff00 	.word	0x000fff00

240093bc <FLASH_CRC_AddSector>:
  * @param  Sector Specifies the CRC sector number
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank)
{
240093bc:	b480      	push	{r7}
240093be:	b083      	sub	sp, #12
240093c0:	af00      	add	r7, sp, #0
240093c2:	6078      	str	r0, [r7, #4]
240093c4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));

  if (Bank == FLASH_BANK_1)
240093c6:	683b      	ldr	r3, [r7, #0]
240093c8:	2b01      	cmp	r3, #1
240093ca:	d10d      	bne.n	240093e8 <FLASH_CRC_AddSector+0x2c>
  {
    /* Clear CRC sector */
    FLASH->CRCCR1 &= (~FLASH_CRCCR_CRC_SECT);
240093cc:	4b09      	ldr	r3, [pc, #36]	; (240093f4 <FLASH_CRC_AddSector+0x38>)
240093ce:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240093d0:	4a08      	ldr	r2, [pc, #32]	; (240093f4 <FLASH_CRC_AddSector+0x38>)
240093d2:	f023 0307 	bic.w	r3, r3, #7
240093d6:	6513      	str	r3, [r2, #80]	; 0x50

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;
240093d8:	4b06      	ldr	r3, [pc, #24]	; (240093f4 <FLASH_CRC_AddSector+0x38>)
240093da:	6d1a      	ldr	r2, [r3, #80]	; 0x50
240093dc:	687b      	ldr	r3, [r7, #4]
240093de:	4313      	orrs	r3, r2
240093e0:	4a04      	ldr	r2, [pc, #16]	; (240093f4 <FLASH_CRC_AddSector+0x38>)
240093e2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
240093e6:	6513      	str	r3, [r2, #80]	; 0x50

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
  }
#endif /* DUAL_BANK */
}
240093e8:	bf00      	nop
240093ea:	370c      	adds	r7, #12
240093ec:	46bd      	mov	sp, r7
240093ee:	f85d 7b04 	ldr.w	r7, [sp], #4
240093f2:	4770      	bx	lr
240093f4:	52002000 	.word	0x52002000

240093f8 <FLASH_CRC_SelectAddress>:
  * @param  CRCEndAddr Specifies the CRC end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank)
{
240093f8:	b480      	push	{r7}
240093fa:	b085      	sub	sp, #20
240093fc:	af00      	add	r7, sp, #0
240093fe:	60f8      	str	r0, [r7, #12]
24009400:	60b9      	str	r1, [r7, #8]
24009402:	607a      	str	r2, [r7, #4]
  if (Bank == FLASH_BANK_1)
24009404:	687b      	ldr	r3, [r7, #4]
24009406:	2b01      	cmp	r3, #1
24009408:	d105      	bne.n	24009416 <FLASH_CRC_SelectAddress+0x1e>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCEndAddr));

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD1 = CRCStartAddr;
2400940a:	4a06      	ldr	r2, [pc, #24]	; (24009424 <FLASH_CRC_SelectAddress+0x2c>)
2400940c:	68fb      	ldr	r3, [r7, #12]
2400940e:	6553      	str	r3, [r2, #84]	; 0x54
    FLASH->CRCEADD1 = CRCEndAddr;
24009410:	4a04      	ldr	r2, [pc, #16]	; (24009424 <FLASH_CRC_SelectAddress+0x2c>)
24009412:	68bb      	ldr	r3, [r7, #8]
24009414:	6593      	str	r3, [r2, #88]	; 0x58
    /* Write CRC Start and End addresses */
    FLASH->CRCSADD2 = CRCStartAddr;
    FLASH->CRCEADD2 = CRCEndAddr;
  }
#endif /* DUAL_BANK */
}
24009416:	bf00      	nop
24009418:	3714      	adds	r7, #20
2400941a:	46bd      	mov	sp, r7
2400941c:	f85d 7b04 	ldr.w	r7, [sp], #4
24009420:	4770      	bx	lr
24009422:	bf00      	nop
24009424:	52002000 	.word	0x52002000

24009428 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
24009428:	b480      	push	{r7}
2400942a:	b089      	sub	sp, #36	; 0x24
2400942c:	af00      	add	r7, sp, #0
2400942e:	6078      	str	r0, [r7, #4]
24009430:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
24009432:	2300      	movs	r3, #0
24009434:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
24009436:	4b89      	ldr	r3, [pc, #548]	; (2400965c <HAL_GPIO_Init+0x234>)
24009438:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
2400943a:	e194      	b.n	24009766 <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
2400943c:	683b      	ldr	r3, [r7, #0]
2400943e:	681a      	ldr	r2, [r3, #0]
24009440:	2101      	movs	r1, #1
24009442:	69fb      	ldr	r3, [r7, #28]
24009444:	fa01 f303 	lsl.w	r3, r1, r3
24009448:	4013      	ands	r3, r2
2400944a:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
2400944c:	693b      	ldr	r3, [r7, #16]
2400944e:	2b00      	cmp	r3, #0
24009450:	f000 8186 	beq.w	24009760 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
24009454:	683b      	ldr	r3, [r7, #0]
24009456:	685b      	ldr	r3, [r3, #4]
24009458:	f003 0303 	and.w	r3, r3, #3
2400945c:	2b01      	cmp	r3, #1
2400945e:	d005      	beq.n	2400946c <HAL_GPIO_Init+0x44>
24009460:	683b      	ldr	r3, [r7, #0]
24009462:	685b      	ldr	r3, [r3, #4]
24009464:	f003 0303 	and.w	r3, r3, #3
24009468:	2b02      	cmp	r3, #2
2400946a:	d130      	bne.n	240094ce <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
2400946c:	687b      	ldr	r3, [r7, #4]
2400946e:	689b      	ldr	r3, [r3, #8]
24009470:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
24009472:	69fb      	ldr	r3, [r7, #28]
24009474:	005b      	lsls	r3, r3, #1
24009476:	2203      	movs	r2, #3
24009478:	fa02 f303 	lsl.w	r3, r2, r3
2400947c:	43db      	mvns	r3, r3
2400947e:	69ba      	ldr	r2, [r7, #24]
24009480:	4013      	ands	r3, r2
24009482:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
24009484:	683b      	ldr	r3, [r7, #0]
24009486:	68da      	ldr	r2, [r3, #12]
24009488:	69fb      	ldr	r3, [r7, #28]
2400948a:	005b      	lsls	r3, r3, #1
2400948c:	fa02 f303 	lsl.w	r3, r2, r3
24009490:	69ba      	ldr	r2, [r7, #24]
24009492:	4313      	orrs	r3, r2
24009494:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
24009496:	687b      	ldr	r3, [r7, #4]
24009498:	69ba      	ldr	r2, [r7, #24]
2400949a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
2400949c:	687b      	ldr	r3, [r7, #4]
2400949e:	685b      	ldr	r3, [r3, #4]
240094a0:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
240094a2:	2201      	movs	r2, #1
240094a4:	69fb      	ldr	r3, [r7, #28]
240094a6:	fa02 f303 	lsl.w	r3, r2, r3
240094aa:	43db      	mvns	r3, r3
240094ac:	69ba      	ldr	r2, [r7, #24]
240094ae:	4013      	ands	r3, r2
240094b0:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
240094b2:	683b      	ldr	r3, [r7, #0]
240094b4:	685b      	ldr	r3, [r3, #4]
240094b6:	091b      	lsrs	r3, r3, #4
240094b8:	f003 0201 	and.w	r2, r3, #1
240094bc:	69fb      	ldr	r3, [r7, #28]
240094be:	fa02 f303 	lsl.w	r3, r2, r3
240094c2:	69ba      	ldr	r2, [r7, #24]
240094c4:	4313      	orrs	r3, r2
240094c6:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
240094c8:	687b      	ldr	r3, [r7, #4]
240094ca:	69ba      	ldr	r2, [r7, #24]
240094cc:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
240094ce:	683b      	ldr	r3, [r7, #0]
240094d0:	685b      	ldr	r3, [r3, #4]
240094d2:	f003 0303 	and.w	r3, r3, #3
240094d6:	2b03      	cmp	r3, #3
240094d8:	d017      	beq.n	2400950a <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
240094da:	687b      	ldr	r3, [r7, #4]
240094dc:	68db      	ldr	r3, [r3, #12]
240094de:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
240094e0:	69fb      	ldr	r3, [r7, #28]
240094e2:	005b      	lsls	r3, r3, #1
240094e4:	2203      	movs	r2, #3
240094e6:	fa02 f303 	lsl.w	r3, r2, r3
240094ea:	43db      	mvns	r3, r3
240094ec:	69ba      	ldr	r2, [r7, #24]
240094ee:	4013      	ands	r3, r2
240094f0:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
240094f2:	683b      	ldr	r3, [r7, #0]
240094f4:	689a      	ldr	r2, [r3, #8]
240094f6:	69fb      	ldr	r3, [r7, #28]
240094f8:	005b      	lsls	r3, r3, #1
240094fa:	fa02 f303 	lsl.w	r3, r2, r3
240094fe:	69ba      	ldr	r2, [r7, #24]
24009500:	4313      	orrs	r3, r2
24009502:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
24009504:	687b      	ldr	r3, [r7, #4]
24009506:	69ba      	ldr	r2, [r7, #24]
24009508:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
2400950a:	683b      	ldr	r3, [r7, #0]
2400950c:	685b      	ldr	r3, [r3, #4]
2400950e:	f003 0303 	and.w	r3, r3, #3
24009512:	2b02      	cmp	r3, #2
24009514:	d123      	bne.n	2400955e <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
24009516:	69fb      	ldr	r3, [r7, #28]
24009518:	08da      	lsrs	r2, r3, #3
2400951a:	687b      	ldr	r3, [r7, #4]
2400951c:	3208      	adds	r2, #8
2400951e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
24009522:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
24009524:	69fb      	ldr	r3, [r7, #28]
24009526:	f003 0307 	and.w	r3, r3, #7
2400952a:	009b      	lsls	r3, r3, #2
2400952c:	220f      	movs	r2, #15
2400952e:	fa02 f303 	lsl.w	r3, r2, r3
24009532:	43db      	mvns	r3, r3
24009534:	69ba      	ldr	r2, [r7, #24]
24009536:	4013      	ands	r3, r2
24009538:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
2400953a:	683b      	ldr	r3, [r7, #0]
2400953c:	691a      	ldr	r2, [r3, #16]
2400953e:	69fb      	ldr	r3, [r7, #28]
24009540:	f003 0307 	and.w	r3, r3, #7
24009544:	009b      	lsls	r3, r3, #2
24009546:	fa02 f303 	lsl.w	r3, r2, r3
2400954a:	69ba      	ldr	r2, [r7, #24]
2400954c:	4313      	orrs	r3, r2
2400954e:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
24009550:	69fb      	ldr	r3, [r7, #28]
24009552:	08da      	lsrs	r2, r3, #3
24009554:	687b      	ldr	r3, [r7, #4]
24009556:	3208      	adds	r2, #8
24009558:	69b9      	ldr	r1, [r7, #24]
2400955a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
2400955e:	687b      	ldr	r3, [r7, #4]
24009560:	681b      	ldr	r3, [r3, #0]
24009562:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
24009564:	69fb      	ldr	r3, [r7, #28]
24009566:	005b      	lsls	r3, r3, #1
24009568:	2203      	movs	r2, #3
2400956a:	fa02 f303 	lsl.w	r3, r2, r3
2400956e:	43db      	mvns	r3, r3
24009570:	69ba      	ldr	r2, [r7, #24]
24009572:	4013      	ands	r3, r2
24009574:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
24009576:	683b      	ldr	r3, [r7, #0]
24009578:	685b      	ldr	r3, [r3, #4]
2400957a:	f003 0203 	and.w	r2, r3, #3
2400957e:	69fb      	ldr	r3, [r7, #28]
24009580:	005b      	lsls	r3, r3, #1
24009582:	fa02 f303 	lsl.w	r3, r2, r3
24009586:	69ba      	ldr	r2, [r7, #24]
24009588:	4313      	orrs	r3, r2
2400958a:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
2400958c:	687b      	ldr	r3, [r7, #4]
2400958e:	69ba      	ldr	r2, [r7, #24]
24009590:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
24009592:	683b      	ldr	r3, [r7, #0]
24009594:	685b      	ldr	r3, [r3, #4]
24009596:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
2400959a:	2b00      	cmp	r3, #0
2400959c:	f000 80e0 	beq.w	24009760 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
240095a0:	4b2f      	ldr	r3, [pc, #188]	; (24009660 <HAL_GPIO_Init+0x238>)
240095a2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
240095a6:	4a2e      	ldr	r2, [pc, #184]	; (24009660 <HAL_GPIO_Init+0x238>)
240095a8:	f043 0302 	orr.w	r3, r3, #2
240095ac:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
240095b0:	4b2b      	ldr	r3, [pc, #172]	; (24009660 <HAL_GPIO_Init+0x238>)
240095b2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
240095b6:	f003 0302 	and.w	r3, r3, #2
240095ba:	60fb      	str	r3, [r7, #12]
240095bc:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
240095be:	4a29      	ldr	r2, [pc, #164]	; (24009664 <HAL_GPIO_Init+0x23c>)
240095c0:	69fb      	ldr	r3, [r7, #28]
240095c2:	089b      	lsrs	r3, r3, #2
240095c4:	3302      	adds	r3, #2
240095c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
240095ca:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
240095cc:	69fb      	ldr	r3, [r7, #28]
240095ce:	f003 0303 	and.w	r3, r3, #3
240095d2:	009b      	lsls	r3, r3, #2
240095d4:	220f      	movs	r2, #15
240095d6:	fa02 f303 	lsl.w	r3, r2, r3
240095da:	43db      	mvns	r3, r3
240095dc:	69ba      	ldr	r2, [r7, #24]
240095de:	4013      	ands	r3, r2
240095e0:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
240095e2:	687b      	ldr	r3, [r7, #4]
240095e4:	4a20      	ldr	r2, [pc, #128]	; (24009668 <HAL_GPIO_Init+0x240>)
240095e6:	4293      	cmp	r3, r2
240095e8:	d052      	beq.n	24009690 <HAL_GPIO_Init+0x268>
240095ea:	687b      	ldr	r3, [r7, #4]
240095ec:	4a1f      	ldr	r2, [pc, #124]	; (2400966c <HAL_GPIO_Init+0x244>)
240095ee:	4293      	cmp	r3, r2
240095f0:	d031      	beq.n	24009656 <HAL_GPIO_Init+0x22e>
240095f2:	687b      	ldr	r3, [r7, #4]
240095f4:	4a1e      	ldr	r2, [pc, #120]	; (24009670 <HAL_GPIO_Init+0x248>)
240095f6:	4293      	cmp	r3, r2
240095f8:	d02b      	beq.n	24009652 <HAL_GPIO_Init+0x22a>
240095fa:	687b      	ldr	r3, [r7, #4]
240095fc:	4a1d      	ldr	r2, [pc, #116]	; (24009674 <HAL_GPIO_Init+0x24c>)
240095fe:	4293      	cmp	r3, r2
24009600:	d025      	beq.n	2400964e <HAL_GPIO_Init+0x226>
24009602:	687b      	ldr	r3, [r7, #4]
24009604:	4a1c      	ldr	r2, [pc, #112]	; (24009678 <HAL_GPIO_Init+0x250>)
24009606:	4293      	cmp	r3, r2
24009608:	d01f      	beq.n	2400964a <HAL_GPIO_Init+0x222>
2400960a:	687b      	ldr	r3, [r7, #4]
2400960c:	4a1b      	ldr	r2, [pc, #108]	; (2400967c <HAL_GPIO_Init+0x254>)
2400960e:	4293      	cmp	r3, r2
24009610:	d019      	beq.n	24009646 <HAL_GPIO_Init+0x21e>
24009612:	687b      	ldr	r3, [r7, #4]
24009614:	4a1a      	ldr	r2, [pc, #104]	; (24009680 <HAL_GPIO_Init+0x258>)
24009616:	4293      	cmp	r3, r2
24009618:	d013      	beq.n	24009642 <HAL_GPIO_Init+0x21a>
2400961a:	687b      	ldr	r3, [r7, #4]
2400961c:	4a19      	ldr	r2, [pc, #100]	; (24009684 <HAL_GPIO_Init+0x25c>)
2400961e:	4293      	cmp	r3, r2
24009620:	d00d      	beq.n	2400963e <HAL_GPIO_Init+0x216>
24009622:	687b      	ldr	r3, [r7, #4]
24009624:	4a18      	ldr	r2, [pc, #96]	; (24009688 <HAL_GPIO_Init+0x260>)
24009626:	4293      	cmp	r3, r2
24009628:	d007      	beq.n	2400963a <HAL_GPIO_Init+0x212>
2400962a:	687b      	ldr	r3, [r7, #4]
2400962c:	4a17      	ldr	r2, [pc, #92]	; (2400968c <HAL_GPIO_Init+0x264>)
2400962e:	4293      	cmp	r3, r2
24009630:	d101      	bne.n	24009636 <HAL_GPIO_Init+0x20e>
24009632:	2309      	movs	r3, #9
24009634:	e02d      	b.n	24009692 <HAL_GPIO_Init+0x26a>
24009636:	230a      	movs	r3, #10
24009638:	e02b      	b.n	24009692 <HAL_GPIO_Init+0x26a>
2400963a:	2308      	movs	r3, #8
2400963c:	e029      	b.n	24009692 <HAL_GPIO_Init+0x26a>
2400963e:	2307      	movs	r3, #7
24009640:	e027      	b.n	24009692 <HAL_GPIO_Init+0x26a>
24009642:	2306      	movs	r3, #6
24009644:	e025      	b.n	24009692 <HAL_GPIO_Init+0x26a>
24009646:	2305      	movs	r3, #5
24009648:	e023      	b.n	24009692 <HAL_GPIO_Init+0x26a>
2400964a:	2304      	movs	r3, #4
2400964c:	e021      	b.n	24009692 <HAL_GPIO_Init+0x26a>
2400964e:	2303      	movs	r3, #3
24009650:	e01f      	b.n	24009692 <HAL_GPIO_Init+0x26a>
24009652:	2302      	movs	r3, #2
24009654:	e01d      	b.n	24009692 <HAL_GPIO_Init+0x26a>
24009656:	2301      	movs	r3, #1
24009658:	e01b      	b.n	24009692 <HAL_GPIO_Init+0x26a>
2400965a:	bf00      	nop
2400965c:	58000080 	.word	0x58000080
24009660:	58024400 	.word	0x58024400
24009664:	58000400 	.word	0x58000400
24009668:	58020000 	.word	0x58020000
2400966c:	58020400 	.word	0x58020400
24009670:	58020800 	.word	0x58020800
24009674:	58020c00 	.word	0x58020c00
24009678:	58021000 	.word	0x58021000
2400967c:	58021400 	.word	0x58021400
24009680:	58021800 	.word	0x58021800
24009684:	58021c00 	.word	0x58021c00
24009688:	58022000 	.word	0x58022000
2400968c:	58022400 	.word	0x58022400
24009690:	2300      	movs	r3, #0
24009692:	69fa      	ldr	r2, [r7, #28]
24009694:	f002 0203 	and.w	r2, r2, #3
24009698:	0092      	lsls	r2, r2, #2
2400969a:	4093      	lsls	r3, r2
2400969c:	69ba      	ldr	r2, [r7, #24]
2400969e:	4313      	orrs	r3, r2
240096a0:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
240096a2:	4938      	ldr	r1, [pc, #224]	; (24009784 <HAL_GPIO_Init+0x35c>)
240096a4:	69fb      	ldr	r3, [r7, #28]
240096a6:	089b      	lsrs	r3, r3, #2
240096a8:	3302      	adds	r3, #2
240096aa:	69ba      	ldr	r2, [r7, #24]
240096ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
240096b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240096b4:	681b      	ldr	r3, [r3, #0]
240096b6:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
240096b8:	693b      	ldr	r3, [r7, #16]
240096ba:	43db      	mvns	r3, r3
240096bc:	69ba      	ldr	r2, [r7, #24]
240096be:	4013      	ands	r3, r2
240096c0:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
240096c2:	683b      	ldr	r3, [r7, #0]
240096c4:	685b      	ldr	r3, [r3, #4]
240096c6:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
240096ca:	2b00      	cmp	r3, #0
240096cc:	d003      	beq.n	240096d6 <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
240096ce:	69ba      	ldr	r2, [r7, #24]
240096d0:	693b      	ldr	r3, [r7, #16]
240096d2:	4313      	orrs	r3, r2
240096d4:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
240096d6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240096da:	69bb      	ldr	r3, [r7, #24]
240096dc:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
240096de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240096e2:	685b      	ldr	r3, [r3, #4]
240096e4:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
240096e6:	693b      	ldr	r3, [r7, #16]
240096e8:	43db      	mvns	r3, r3
240096ea:	69ba      	ldr	r2, [r7, #24]
240096ec:	4013      	ands	r3, r2
240096ee:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
240096f0:	683b      	ldr	r3, [r7, #0]
240096f2:	685b      	ldr	r3, [r3, #4]
240096f4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
240096f8:	2b00      	cmp	r3, #0
240096fa:	d003      	beq.n	24009704 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
240096fc:	69ba      	ldr	r2, [r7, #24]
240096fe:	693b      	ldr	r3, [r7, #16]
24009700:	4313      	orrs	r3, r2
24009702:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
24009704:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24009708:	69bb      	ldr	r3, [r7, #24]
2400970a:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
2400970c:	697b      	ldr	r3, [r7, #20]
2400970e:	685b      	ldr	r3, [r3, #4]
24009710:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
24009712:	693b      	ldr	r3, [r7, #16]
24009714:	43db      	mvns	r3, r3
24009716:	69ba      	ldr	r2, [r7, #24]
24009718:	4013      	ands	r3, r2
2400971a:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
2400971c:	683b      	ldr	r3, [r7, #0]
2400971e:	685b      	ldr	r3, [r3, #4]
24009720:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24009724:	2b00      	cmp	r3, #0
24009726:	d003      	beq.n	24009730 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
24009728:	69ba      	ldr	r2, [r7, #24]
2400972a:	693b      	ldr	r3, [r7, #16]
2400972c:	4313      	orrs	r3, r2
2400972e:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
24009730:	697b      	ldr	r3, [r7, #20]
24009732:	69ba      	ldr	r2, [r7, #24]
24009734:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
24009736:	697b      	ldr	r3, [r7, #20]
24009738:	681b      	ldr	r3, [r3, #0]
2400973a:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2400973c:	693b      	ldr	r3, [r7, #16]
2400973e:	43db      	mvns	r3, r3
24009740:	69ba      	ldr	r2, [r7, #24]
24009742:	4013      	ands	r3, r2
24009744:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
24009746:	683b      	ldr	r3, [r7, #0]
24009748:	685b      	ldr	r3, [r3, #4]
2400974a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400974e:	2b00      	cmp	r3, #0
24009750:	d003      	beq.n	2400975a <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
24009752:	69ba      	ldr	r2, [r7, #24]
24009754:	693b      	ldr	r3, [r7, #16]
24009756:	4313      	orrs	r3, r2
24009758:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
2400975a:	697b      	ldr	r3, [r7, #20]
2400975c:	69ba      	ldr	r2, [r7, #24]
2400975e:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
24009760:	69fb      	ldr	r3, [r7, #28]
24009762:	3301      	adds	r3, #1
24009764:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
24009766:	683b      	ldr	r3, [r7, #0]
24009768:	681a      	ldr	r2, [r3, #0]
2400976a:	69fb      	ldr	r3, [r7, #28]
2400976c:	fa22 f303 	lsr.w	r3, r2, r3
24009770:	2b00      	cmp	r3, #0
24009772:	f47f ae63 	bne.w	2400943c <HAL_GPIO_Init+0x14>
  }
}
24009776:	bf00      	nop
24009778:	bf00      	nop
2400977a:	3724      	adds	r7, #36	; 0x24
2400977c:	46bd      	mov	sp, r7
2400977e:	f85d 7b04 	ldr.w	r7, [sp], #4
24009782:	4770      	bx	lr
24009784:	58000400 	.word	0x58000400

24009788 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
24009788:	b480      	push	{r7}
2400978a:	b087      	sub	sp, #28
2400978c:	af00      	add	r7, sp, #0
2400978e:	6078      	str	r0, [r7, #4]
24009790:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
24009792:	2300      	movs	r3, #0
24009794:	617b      	str	r3, [r7, #20]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
24009796:	4b75      	ldr	r3, [pc, #468]	; (2400996c <HAL_GPIO_DeInit+0x1e4>)
24009798:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00U)
2400979a:	e0d9      	b.n	24009950 <HAL_GPIO_DeInit+0x1c8>
  {
    /* Get current io position */
    iocurrent = GPIO_Pin & (1UL << position) ;
2400979c:	2201      	movs	r2, #1
2400979e:	697b      	ldr	r3, [r7, #20]
240097a0:	fa02 f303 	lsl.w	r3, r2, r3
240097a4:	683a      	ldr	r2, [r7, #0]
240097a6:	4013      	ands	r3, r2
240097a8:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00U)
240097aa:	68fb      	ldr	r3, [r7, #12]
240097ac:	2b00      	cmp	r3, #0
240097ae:	f000 80cc 	beq.w	2400994a <HAL_GPIO_DeInit+0x1c2>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
240097b2:	4a6f      	ldr	r2, [pc, #444]	; (24009970 <HAL_GPIO_DeInit+0x1e8>)
240097b4:	697b      	ldr	r3, [r7, #20]
240097b6:	089b      	lsrs	r3, r3, #2
240097b8:	3302      	adds	r3, #2
240097ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
240097be:	60bb      	str	r3, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
240097c0:	697b      	ldr	r3, [r7, #20]
240097c2:	f003 0303 	and.w	r3, r3, #3
240097c6:	009b      	lsls	r3, r3, #2
240097c8:	220f      	movs	r2, #15
240097ca:	fa02 f303 	lsl.w	r3, r2, r3
240097ce:	68ba      	ldr	r2, [r7, #8]
240097d0:	4013      	ands	r3, r2
240097d2:	60bb      	str	r3, [r7, #8]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
240097d4:	687b      	ldr	r3, [r7, #4]
240097d6:	4a67      	ldr	r2, [pc, #412]	; (24009974 <HAL_GPIO_DeInit+0x1ec>)
240097d8:	4293      	cmp	r3, r2
240097da:	d037      	beq.n	2400984c <HAL_GPIO_DeInit+0xc4>
240097dc:	687b      	ldr	r3, [r7, #4]
240097de:	4a66      	ldr	r2, [pc, #408]	; (24009978 <HAL_GPIO_DeInit+0x1f0>)
240097e0:	4293      	cmp	r3, r2
240097e2:	d031      	beq.n	24009848 <HAL_GPIO_DeInit+0xc0>
240097e4:	687b      	ldr	r3, [r7, #4]
240097e6:	4a65      	ldr	r2, [pc, #404]	; (2400997c <HAL_GPIO_DeInit+0x1f4>)
240097e8:	4293      	cmp	r3, r2
240097ea:	d02b      	beq.n	24009844 <HAL_GPIO_DeInit+0xbc>
240097ec:	687b      	ldr	r3, [r7, #4]
240097ee:	4a64      	ldr	r2, [pc, #400]	; (24009980 <HAL_GPIO_DeInit+0x1f8>)
240097f0:	4293      	cmp	r3, r2
240097f2:	d025      	beq.n	24009840 <HAL_GPIO_DeInit+0xb8>
240097f4:	687b      	ldr	r3, [r7, #4]
240097f6:	4a63      	ldr	r2, [pc, #396]	; (24009984 <HAL_GPIO_DeInit+0x1fc>)
240097f8:	4293      	cmp	r3, r2
240097fa:	d01f      	beq.n	2400983c <HAL_GPIO_DeInit+0xb4>
240097fc:	687b      	ldr	r3, [r7, #4]
240097fe:	4a62      	ldr	r2, [pc, #392]	; (24009988 <HAL_GPIO_DeInit+0x200>)
24009800:	4293      	cmp	r3, r2
24009802:	d019      	beq.n	24009838 <HAL_GPIO_DeInit+0xb0>
24009804:	687b      	ldr	r3, [r7, #4]
24009806:	4a61      	ldr	r2, [pc, #388]	; (2400998c <HAL_GPIO_DeInit+0x204>)
24009808:	4293      	cmp	r3, r2
2400980a:	d013      	beq.n	24009834 <HAL_GPIO_DeInit+0xac>
2400980c:	687b      	ldr	r3, [r7, #4]
2400980e:	4a60      	ldr	r2, [pc, #384]	; (24009990 <HAL_GPIO_DeInit+0x208>)
24009810:	4293      	cmp	r3, r2
24009812:	d00d      	beq.n	24009830 <HAL_GPIO_DeInit+0xa8>
24009814:	687b      	ldr	r3, [r7, #4]
24009816:	4a5f      	ldr	r2, [pc, #380]	; (24009994 <HAL_GPIO_DeInit+0x20c>)
24009818:	4293      	cmp	r3, r2
2400981a:	d007      	beq.n	2400982c <HAL_GPIO_DeInit+0xa4>
2400981c:	687b      	ldr	r3, [r7, #4]
2400981e:	4a5e      	ldr	r2, [pc, #376]	; (24009998 <HAL_GPIO_DeInit+0x210>)
24009820:	4293      	cmp	r3, r2
24009822:	d101      	bne.n	24009828 <HAL_GPIO_DeInit+0xa0>
24009824:	2309      	movs	r3, #9
24009826:	e012      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
24009828:	230a      	movs	r3, #10
2400982a:	e010      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
2400982c:	2308      	movs	r3, #8
2400982e:	e00e      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
24009830:	2307      	movs	r3, #7
24009832:	e00c      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
24009834:	2306      	movs	r3, #6
24009836:	e00a      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
24009838:	2305      	movs	r3, #5
2400983a:	e008      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
2400983c:	2304      	movs	r3, #4
2400983e:	e006      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
24009840:	2303      	movs	r3, #3
24009842:	e004      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
24009844:	2302      	movs	r3, #2
24009846:	e002      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
24009848:	2301      	movs	r3, #1
2400984a:	e000      	b.n	2400984e <HAL_GPIO_DeInit+0xc6>
2400984c:	2300      	movs	r3, #0
2400984e:	697a      	ldr	r2, [r7, #20]
24009850:	f002 0203 	and.w	r2, r2, #3
24009854:	0092      	lsls	r2, r2, #2
24009856:	4093      	lsls	r3, r2
24009858:	68ba      	ldr	r2, [r7, #8]
2400985a:	429a      	cmp	r2, r3
2400985c:	d136      	bne.n	240098cc <HAL_GPIO_DeInit+0x144>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
2400985e:	693b      	ldr	r3, [r7, #16]
24009860:	681a      	ldr	r2, [r3, #0]
24009862:	68fb      	ldr	r3, [r7, #12]
24009864:	43db      	mvns	r3, r3
24009866:	401a      	ands	r2, r3
24009868:	693b      	ldr	r3, [r7, #16]
2400986a:	601a      	str	r2, [r3, #0]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
2400986c:	693b      	ldr	r3, [r7, #16]
2400986e:	685a      	ldr	r2, [r3, #4]
24009870:	68fb      	ldr	r3, [r7, #12]
24009872:	43db      	mvns	r3, r3
24009874:	401a      	ands	r2, r3
24009876:	693b      	ldr	r3, [r7, #16]
24009878:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->FTSR1 &= ~(iocurrent);
2400987a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400987e:	685a      	ldr	r2, [r3, #4]
24009880:	68fb      	ldr	r3, [r7, #12]
24009882:	43db      	mvns	r3, r3
24009884:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
24009888:	4013      	ands	r3, r2
2400988a:	604b      	str	r3, [r1, #4]
        EXTI->RTSR1 &= ~(iocurrent);
2400988c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24009890:	681a      	ldr	r2, [r3, #0]
24009892:	68fb      	ldr	r3, [r7, #12]
24009894:	43db      	mvns	r3, r3
24009896:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
2400989a:	4013      	ands	r3, r2
2400989c:	600b      	str	r3, [r1, #0]

        tmp = 0x0FUL << (4U * (position & 0x03U));
2400989e:	697b      	ldr	r3, [r7, #20]
240098a0:	f003 0303 	and.w	r3, r3, #3
240098a4:	009b      	lsls	r3, r3, #2
240098a6:	220f      	movs	r2, #15
240098a8:	fa02 f303 	lsl.w	r3, r2, r3
240098ac:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
240098ae:	4a30      	ldr	r2, [pc, #192]	; (24009970 <HAL_GPIO_DeInit+0x1e8>)
240098b0:	697b      	ldr	r3, [r7, #20]
240098b2:	089b      	lsrs	r3, r3, #2
240098b4:	3302      	adds	r3, #2
240098b6:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
240098ba:	68bb      	ldr	r3, [r7, #8]
240098bc:	43da      	mvns	r2, r3
240098be:	482c      	ldr	r0, [pc, #176]	; (24009970 <HAL_GPIO_DeInit+0x1e8>)
240098c0:	697b      	ldr	r3, [r7, #20]
240098c2:	089b      	lsrs	r3, r3, #2
240098c4:	400a      	ands	r2, r1
240098c6:	3302      	adds	r3, #2
240098c8:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
240098cc:	687b      	ldr	r3, [r7, #4]
240098ce:	681a      	ldr	r2, [r3, #0]
240098d0:	697b      	ldr	r3, [r7, #20]
240098d2:	005b      	lsls	r3, r3, #1
240098d4:	2103      	movs	r1, #3
240098d6:	fa01 f303 	lsl.w	r3, r1, r3
240098da:	431a      	orrs	r2, r3
240098dc:	687b      	ldr	r3, [r7, #4]
240098de:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
240098e0:	697b      	ldr	r3, [r7, #20]
240098e2:	08da      	lsrs	r2, r3, #3
240098e4:	687b      	ldr	r3, [r7, #4]
240098e6:	3208      	adds	r2, #8
240098e8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
240098ec:	697b      	ldr	r3, [r7, #20]
240098ee:	f003 0307 	and.w	r3, r3, #7
240098f2:	009b      	lsls	r3, r3, #2
240098f4:	220f      	movs	r2, #15
240098f6:	fa02 f303 	lsl.w	r3, r2, r3
240098fa:	43db      	mvns	r3, r3
240098fc:	697a      	ldr	r2, [r7, #20]
240098fe:	08d2      	lsrs	r2, r2, #3
24009900:	4019      	ands	r1, r3
24009902:	687b      	ldr	r3, [r7, #4]
24009904:	3208      	adds	r2, #8
24009906:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
2400990a:	687b      	ldr	r3, [r7, #4]
2400990c:	68da      	ldr	r2, [r3, #12]
2400990e:	697b      	ldr	r3, [r7, #20]
24009910:	005b      	lsls	r3, r3, #1
24009912:	2103      	movs	r1, #3
24009914:	fa01 f303 	lsl.w	r3, r1, r3
24009918:	43db      	mvns	r3, r3
2400991a:	401a      	ands	r2, r3
2400991c:	687b      	ldr	r3, [r7, #4]
2400991e:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
24009920:	687b      	ldr	r3, [r7, #4]
24009922:	685a      	ldr	r2, [r3, #4]
24009924:	2101      	movs	r1, #1
24009926:	697b      	ldr	r3, [r7, #20]
24009928:	fa01 f303 	lsl.w	r3, r1, r3
2400992c:	43db      	mvns	r3, r3
2400992e:	401a      	ands	r2, r3
24009930:	687b      	ldr	r3, [r7, #4]
24009932:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
24009934:	687b      	ldr	r3, [r7, #4]
24009936:	689a      	ldr	r2, [r3, #8]
24009938:	697b      	ldr	r3, [r7, #20]
2400993a:	005b      	lsls	r3, r3, #1
2400993c:	2103      	movs	r1, #3
2400993e:	fa01 f303 	lsl.w	r3, r1, r3
24009942:	43db      	mvns	r3, r3
24009944:	401a      	ands	r2, r3
24009946:	687b      	ldr	r3, [r7, #4]
24009948:	609a      	str	r2, [r3, #8]
    }

    position++;
2400994a:	697b      	ldr	r3, [r7, #20]
2400994c:	3301      	adds	r3, #1
2400994e:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00U)
24009950:	683a      	ldr	r2, [r7, #0]
24009952:	697b      	ldr	r3, [r7, #20]
24009954:	fa22 f303 	lsr.w	r3, r2, r3
24009958:	2b00      	cmp	r3, #0
2400995a:	f47f af1f 	bne.w	2400979c <HAL_GPIO_DeInit+0x14>
  }
}
2400995e:	bf00      	nop
24009960:	bf00      	nop
24009962:	371c      	adds	r7, #28
24009964:	46bd      	mov	sp, r7
24009966:	f85d 7b04 	ldr.w	r7, [sp], #4
2400996a:	4770      	bx	lr
2400996c:	58000080 	.word	0x58000080
24009970:	58000400 	.word	0x58000400
24009974:	58020000 	.word	0x58020000
24009978:	58020400 	.word	0x58020400
2400997c:	58020800 	.word	0x58020800
24009980:	58020c00 	.word	0x58020c00
24009984:	58021000 	.word	0x58021000
24009988:	58021400 	.word	0x58021400
2400998c:	58021800 	.word	0x58021800
24009990:	58021c00 	.word	0x58021c00
24009994:	58022000 	.word	0x58022000
24009998:	58022400 	.word	0x58022400

2400999c <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
2400999c:	b480      	push	{r7}
2400999e:	b085      	sub	sp, #20
240099a0:	af00      	add	r7, sp, #0
240099a2:	6078      	str	r0, [r7, #4]
240099a4:	460b      	mov	r3, r1
240099a6:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
240099a8:	687b      	ldr	r3, [r7, #4]
240099aa:	691a      	ldr	r2, [r3, #16]
240099ac:	887b      	ldrh	r3, [r7, #2]
240099ae:	4013      	ands	r3, r2
240099b0:	2b00      	cmp	r3, #0
240099b2:	d002      	beq.n	240099ba <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
240099b4:	2301      	movs	r3, #1
240099b6:	73fb      	strb	r3, [r7, #15]
240099b8:	e001      	b.n	240099be <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
240099ba:	2300      	movs	r3, #0
240099bc:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
240099be:	7bfb      	ldrb	r3, [r7, #15]
}
240099c0:	4618      	mov	r0, r3
240099c2:	3714      	adds	r7, #20
240099c4:	46bd      	mov	sp, r7
240099c6:	f85d 7b04 	ldr.w	r7, [sp], #4
240099ca:	4770      	bx	lr

240099cc <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
240099cc:	b480      	push	{r7}
240099ce:	b083      	sub	sp, #12
240099d0:	af00      	add	r7, sp, #0
240099d2:	6078      	str	r0, [r7, #4]
240099d4:	460b      	mov	r3, r1
240099d6:	807b      	strh	r3, [r7, #2]
240099d8:	4613      	mov	r3, r2
240099da:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
240099dc:	787b      	ldrb	r3, [r7, #1]
240099de:	2b00      	cmp	r3, #0
240099e0:	d003      	beq.n	240099ea <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
240099e2:	887a      	ldrh	r2, [r7, #2]
240099e4:	687b      	ldr	r3, [r7, #4]
240099e6:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
240099e8:	e003      	b.n	240099f2 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
240099ea:	887b      	ldrh	r3, [r7, #2]
240099ec:	041a      	lsls	r2, r3, #16
240099ee:	687b      	ldr	r3, [r7, #4]
240099f0:	619a      	str	r2, [r3, #24]
}
240099f2:	bf00      	nop
240099f4:	370c      	adds	r7, #12
240099f6:	46bd      	mov	sp, r7
240099f8:	f85d 7b04 	ldr.w	r7, [sp], #4
240099fc:	4770      	bx	lr

240099fe <HAL_GPIO_TogglePin>:
  * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
240099fe:	b480      	push	{r7}
24009a00:	b085      	sub	sp, #20
24009a02:	af00      	add	r7, sp, #0
24009a04:	6078      	str	r0, [r7, #4]
24009a06:	460b      	mov	r3, r1
24009a08:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
24009a0a:	687b      	ldr	r3, [r7, #4]
24009a0c:	695b      	ldr	r3, [r3, #20]
24009a0e:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
24009a10:	887a      	ldrh	r2, [r7, #2]
24009a12:	68fb      	ldr	r3, [r7, #12]
24009a14:	4013      	ands	r3, r2
24009a16:	041a      	lsls	r2, r3, #16
24009a18:	68fb      	ldr	r3, [r7, #12]
24009a1a:	43d9      	mvns	r1, r3
24009a1c:	887b      	ldrh	r3, [r7, #2]
24009a1e:	400b      	ands	r3, r1
24009a20:	431a      	orrs	r2, r3
24009a22:	687b      	ldr	r3, [r7, #4]
24009a24:	619a      	str	r2, [r3, #24]
}
24009a26:	bf00      	nop
24009a28:	3714      	adds	r7, #20
24009a2a:	46bd      	mov	sp, r7
24009a2c:	f85d 7b04 	ldr.w	r7, [sp], #4
24009a30:	4770      	bx	lr

24009a32 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24009a32:	b480      	push	{r7}
24009a34:	b085      	sub	sp, #20
24009a36:	af00      	add	r7, sp, #0
24009a38:	6078      	str	r0, [r7, #4]
24009a3a:	460b      	mov	r3, r1
24009a3c:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
24009a3e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
24009a42:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
24009a44:	887a      	ldrh	r2, [r7, #2]
24009a46:	68fb      	ldr	r3, [r7, #12]
24009a48:	4313      	orrs	r3, r2
24009a4a:	60fb      	str	r3, [r7, #12]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
24009a4c:	68fa      	ldr	r2, [r7, #12]
24009a4e:	687b      	ldr	r3, [r7, #4]
24009a50:	61da      	str	r2, [r3, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
24009a52:	887a      	ldrh	r2, [r7, #2]
24009a54:	687b      	ldr	r3, [r7, #4]
24009a56:	61da      	str	r2, [r3, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
24009a58:	68fa      	ldr	r2, [r7, #12]
24009a5a:	687b      	ldr	r3, [r7, #4]
24009a5c:	61da      	str	r2, [r3, #28]
  /* Read LCKK register. This read is mandatory to complete key lock sequence*/
  tmp = GPIOx->LCKR;
24009a5e:	687b      	ldr	r3, [r7, #4]
24009a60:	69db      	ldr	r3, [r3, #28]
24009a62:	60fb      	str	r3, [r7, #12]

  /* read again in order to confirm lock is active */
  if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00U)
24009a64:	687b      	ldr	r3, [r7, #4]
24009a66:	69db      	ldr	r3, [r3, #28]
24009a68:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24009a6c:	2b00      	cmp	r3, #0
24009a6e:	d001      	beq.n	24009a74 <HAL_GPIO_LockPin+0x42>
  {
    return HAL_OK;
24009a70:	2300      	movs	r3, #0
24009a72:	e000      	b.n	24009a76 <HAL_GPIO_LockPin+0x44>
  }
  else
  {
    return HAL_ERROR;
24009a74:	2301      	movs	r3, #1
  }
}
24009a76:	4618      	mov	r0, r3
24009a78:	3714      	adds	r7, #20
24009a7a:	46bd      	mov	sp, r7
24009a7c:	f85d 7b04 	ldr.w	r7, [sp], #4
24009a80:	4770      	bx	lr

24009a82 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
24009a82:	b580      	push	{r7, lr}
24009a84:	b082      	sub	sp, #8
24009a86:	af00      	add	r7, sp, #0
24009a88:	4603      	mov	r3, r0
24009a8a:	80fb      	strh	r3, [r7, #6]
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#else
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
24009a8c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24009a90:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
24009a94:	88fb      	ldrh	r3, [r7, #6]
24009a96:	4013      	ands	r3, r2
24009a98:	2b00      	cmp	r3, #0
24009a9a:	d008      	beq.n	24009aae <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
24009a9c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24009aa0:	88fb      	ldrh	r3, [r7, #6]
24009aa2:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
24009aa6:	88fb      	ldrh	r3, [r7, #6]
24009aa8:	4618      	mov	r0, r3
24009aaa:	f000 f804 	bl	24009ab6 <HAL_GPIO_EXTI_Callback>
  }
#endif
}
24009aae:	bf00      	nop
24009ab0:	3708      	adds	r7, #8
24009ab2:	46bd      	mov	sp, r7
24009ab4:	bd80      	pop	{r7, pc}

24009ab6 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
24009ab6:	b480      	push	{r7}
24009ab8:	b083      	sub	sp, #12
24009aba:	af00      	add	r7, sp, #0
24009abc:	4603      	mov	r3, r0
24009abe:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
24009ac0:	bf00      	nop
24009ac2:	370c      	adds	r7, #12
24009ac4:	46bd      	mov	sp, r7
24009ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
24009aca:	4770      	bx	lr

24009acc <HAL_HSEM_Take>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  HAL_HSEM_Take(uint32_t SemID, uint32_t ProcessID)
{
24009acc:	b480      	push	{r7}
24009ace:	b083      	sub	sp, #12
24009ad0:	af00      	add	r7, sp, #0
24009ad2:	6078      	str	r0, [r7, #4]
24009ad4:	6039      	str	r1, [r7, #0]
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
  }
#else
  /* First step  write R register with MasterID, processID and take bit=1*/
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK);
24009ad6:	490c      	ldr	r1, [pc, #48]	; (24009b08 <HAL_HSEM_Take+0x3c>)
24009ad8:	683a      	ldr	r2, [r7, #0]
24009ada:	4b0c      	ldr	r3, [pc, #48]	; (24009b0c <HAL_HSEM_Take+0x40>)
24009adc:	4313      	orrs	r3, r2
24009ade:	687a      	ldr	r2, [r7, #4]
24009ae0:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

  /* second step : read the R register . Take achieved if MasterID and processID match and take bit set to 1 */
  if (HSEM->R[SemID] == (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK))
24009ae4:	4a08      	ldr	r2, [pc, #32]	; (24009b08 <HAL_HSEM_Take+0x3c>)
24009ae6:	687b      	ldr	r3, [r7, #4]
24009ae8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24009aec:	6839      	ldr	r1, [r7, #0]
24009aee:	4b07      	ldr	r3, [pc, #28]	; (24009b0c <HAL_HSEM_Take+0x40>)
24009af0:	430b      	orrs	r3, r1
24009af2:	429a      	cmp	r2, r3
24009af4:	d101      	bne.n	24009afa <HAL_HSEM_Take+0x2e>
  {
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
24009af6:	2300      	movs	r3, #0
24009af8:	e000      	b.n	24009afc <HAL_HSEM_Take+0x30>
  }
#endif

  /* Semaphore take fails*/
  return HAL_ERROR;
24009afa:	2301      	movs	r3, #1
}
24009afc:	4618      	mov	r0, r3
24009afe:	370c      	adds	r7, #12
24009b00:	46bd      	mov	sp, r7
24009b02:	f85d 7b04 	ldr.w	r7, [sp], #4
24009b06:	4770      	bx	lr
24009b08:	58026400 	.word	0x58026400
24009b0c:	80000300 	.word	0x80000300

24009b10 <HAL_HSEM_FastTake>:
  * @brief  Fast Take a semaphore with 1 Step mode.
  * @param  SemID: semaphore ID from 0 to 31
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)
{
24009b10:	b480      	push	{r7}
24009b12:	b083      	sub	sp, #12
24009b14:	af00      	add	r7, sp, #0
24009b16:	6078      	str	r0, [r7, #4]
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else  
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
24009b18:	4a08      	ldr	r2, [pc, #32]	; (24009b3c <HAL_HSEM_FastTake+0x2c>)
24009b1a:	687b      	ldr	r3, [r7, #4]
24009b1c:	3320      	adds	r3, #32
24009b1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24009b22:	4a07      	ldr	r2, [pc, #28]	; (24009b40 <HAL_HSEM_FastTake+0x30>)
24009b24:	4293      	cmp	r3, r2
24009b26:	d101      	bne.n	24009b2c <HAL_HSEM_FastTake+0x1c>
  {
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
24009b28:	2300      	movs	r3, #0
24009b2a:	e000      	b.n	24009b2e <HAL_HSEM_FastTake+0x1e>
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
24009b2c:	2301      	movs	r3, #1
}
24009b2e:	4618      	mov	r0, r3
24009b30:	370c      	adds	r7, #12
24009b32:	46bd      	mov	sp, r7
24009b34:	f85d 7b04 	ldr.w	r7, [sp], #4
24009b38:	4770      	bx	lr
24009b3a:	bf00      	nop
24009b3c:	58026400 	.word	0x58026400
24009b40:	80000300 	.word	0x80000300

24009b44 <HAL_HSEM_IsSemTaken>:
  * @brief  Check semaphore state Taken or not.
  * @param  SemID: semaphore ID
  * @retval HAL HSEM state
  */
uint32_t HAL_HSEM_IsSemTaken(uint32_t SemID)
{
24009b44:	b480      	push	{r7}
24009b46:	b083      	sub	sp, #12
24009b48:	af00      	add	r7, sp, #0
24009b4a:	6078      	str	r0, [r7, #4]
  return (((HSEM->R[SemID] & HSEM_R_LOCK) != 0U) ? 1UL : 0UL);
24009b4c:	4a07      	ldr	r2, [pc, #28]	; (24009b6c <HAL_HSEM_IsSemTaken+0x28>)
24009b4e:	687b      	ldr	r3, [r7, #4]
24009b50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24009b54:	2b00      	cmp	r3, #0
24009b56:	da01      	bge.n	24009b5c <HAL_HSEM_IsSemTaken+0x18>
24009b58:	2301      	movs	r3, #1
24009b5a:	e000      	b.n	24009b5e <HAL_HSEM_IsSemTaken+0x1a>
24009b5c:	2300      	movs	r3, #0
}
24009b5e:	4618      	mov	r0, r3
24009b60:	370c      	adds	r7, #12
24009b62:	46bd      	mov	sp, r7
24009b64:	f85d 7b04 	ldr.w	r7, [sp], #4
24009b68:	4770      	bx	lr
24009b6a:	bf00      	nop
24009b6c:	58026400 	.word	0x58026400

24009b70 <HAL_HSEM_Release>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval None
  */
void  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)
{
24009b70:	b480      	push	{r7}
24009b72:	b083      	sub	sp, #12
24009b74:	af00      	add	r7, sp, #0
24009b76:	6078      	str	r0, [r7, #4]
24009b78:	6039      	str	r1, [r7, #0]

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
24009b7a:	4906      	ldr	r1, [pc, #24]	; (24009b94 <HAL_HSEM_Release+0x24>)
24009b7c:	683b      	ldr	r3, [r7, #0]
24009b7e:	f443 7240 	orr.w	r2, r3, #768	; 0x300
24009b82:	687b      	ldr	r3, [r7, #4]
24009b84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
24009b88:	bf00      	nop
24009b8a:	370c      	adds	r7, #12
24009b8c:	46bd      	mov	sp, r7
24009b8e:	f85d 7b04 	ldr.w	r7, [sp], #4
24009b92:	4770      	bx	lr
24009b94:	58026400 	.word	0x58026400

24009b98 <HAL_HSEM_ReleaseAll>:
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @param  CoreID: CoreID of the CPU that is using semaphores to be released
  * @retval None
  */
void HAL_HSEM_ReleaseAll(uint32_t Key, uint32_t CoreID)
{
24009b98:	b480      	push	{r7}
24009b9a:	b083      	sub	sp, #12
24009b9c:	af00      	add	r7, sp, #0
24009b9e:	6078      	str	r0, [r7, #4]
24009ba0:	6039      	str	r1, [r7, #0]
  assert_param(IS_HSEM_KEY(Key));
  assert_param(IS_HSEM_COREID(CoreID));

  HSEM->CR = ((Key << HSEM_CR_KEY_Pos) | (CoreID << HSEM_CR_COREID_Pos));
24009ba2:	687b      	ldr	r3, [r7, #4]
24009ba4:	041a      	lsls	r2, r3, #16
24009ba6:	683b      	ldr	r3, [r7, #0]
24009ba8:	021b      	lsls	r3, r3, #8
24009baa:	4905      	ldr	r1, [pc, #20]	; (24009bc0 <HAL_HSEM_ReleaseAll+0x28>)
24009bac:	4313      	orrs	r3, r2
24009bae:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
}
24009bb2:	bf00      	nop
24009bb4:	370c      	adds	r7, #12
24009bb6:	46bd      	mov	sp, r7
24009bb8:	f85d 7b04 	ldr.w	r7, [sp], #4
24009bbc:	4770      	bx	lr
24009bbe:	bf00      	nop
24009bc0:	58026400 	.word	0x58026400

24009bc4 <HAL_HSEM_SetClearKey>:
  * @brief  Set semaphore Key .
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @retval None
  */
void  HAL_HSEM_SetClearKey(uint32_t Key)
{
24009bc4:	b480      	push	{r7}
24009bc6:	b083      	sub	sp, #12
24009bc8:	af00      	add	r7, sp, #0
24009bca:	6078      	str	r0, [r7, #4]
  assert_param(IS_HSEM_KEY(Key));

  MODIFY_REG(HSEM->KEYR, HSEM_KEYR_KEY, (Key << HSEM_KEYR_KEY_Pos));
24009bcc:	4b07      	ldr	r3, [pc, #28]	; (24009bec <HAL_HSEM_SetClearKey+0x28>)
24009bce:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
24009bd2:	b29a      	uxth	r2, r3
24009bd4:	687b      	ldr	r3, [r7, #4]
24009bd6:	041b      	lsls	r3, r3, #16
24009bd8:	4904      	ldr	r1, [pc, #16]	; (24009bec <HAL_HSEM_SetClearKey+0x28>)
24009bda:	4313      	orrs	r3, r2
24009bdc:	f8c1 3144 	str.w	r3, [r1, #324]	; 0x144

}
24009be0:	bf00      	nop
24009be2:	370c      	adds	r7, #12
24009be4:	46bd      	mov	sp, r7
24009be6:	f85d 7b04 	ldr.w	r7, [sp], #4
24009bea:	4770      	bx	lr
24009bec:	58026400 	.word	0x58026400

24009bf0 <HAL_HSEM_GetClearKey>:
/**
  * @brief  Get semaphore Key .
  * @retval Semaphore Key , value from 0 to 0xFFFF
  */
uint32_t HAL_HSEM_GetClearKey(void)
{
24009bf0:	b480      	push	{r7}
24009bf2:	af00      	add	r7, sp, #0
  return (HSEM->KEYR >> HSEM_KEYR_KEY_Pos);
24009bf4:	4b04      	ldr	r3, [pc, #16]	; (24009c08 <HAL_HSEM_GetClearKey+0x18>)
24009bf6:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
24009bfa:	0c1b      	lsrs	r3, r3, #16
}
24009bfc:	4618      	mov	r0, r3
24009bfe:	46bd      	mov	sp, r7
24009c00:	f85d 7b04 	ldr.w	r7, [sp], #4
24009c04:	4770      	bx	lr
24009c06:	bf00      	nop
24009c08:	58026400 	.word	0x58026400

24009c0c <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
24009c0c:	b480      	push	{r7}
24009c0e:	b083      	sub	sp, #12
24009c10:	af00      	add	r7, sp, #0
24009c12:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
24009c14:	4b05      	ldr	r3, [pc, #20]	; (24009c2c <HAL_HSEM_ActivateNotification+0x20>)
24009c16:	681a      	ldr	r2, [r3, #0]
24009c18:	4904      	ldr	r1, [pc, #16]	; (24009c2c <HAL_HSEM_ActivateNotification+0x20>)
24009c1a:	687b      	ldr	r3, [r7, #4]
24009c1c:	4313      	orrs	r3, r2
24009c1e:	600b      	str	r3, [r1, #0]
#endif
}
24009c20:	bf00      	nop
24009c22:	370c      	adds	r7, #12
24009c24:	46bd      	mov	sp, r7
24009c26:	f85d 7b04 	ldr.w	r7, [sp], #4
24009c2a:	4770      	bx	lr
24009c2c:	58026500 	.word	0x58026500

24009c30 <HAL_HSEM_DeactivateNotification>:
  * @brief  Deactivate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_DeactivateNotification(uint32_t SemMask)
{
24009c30:	b480      	push	{r7}
24009c32:	b083      	sub	sp, #12
24009c34:	af00      	add	r7, sp, #0
24009c36:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER &= ~SemMask;
  }
#else
  HSEM_COMMON->IER &= ~SemMask;
24009c38:	4b06      	ldr	r3, [pc, #24]	; (24009c54 <HAL_HSEM_DeactivateNotification+0x24>)
24009c3a:	681a      	ldr	r2, [r3, #0]
24009c3c:	687b      	ldr	r3, [r7, #4]
24009c3e:	43db      	mvns	r3, r3
24009c40:	4904      	ldr	r1, [pc, #16]	; (24009c54 <HAL_HSEM_DeactivateNotification+0x24>)
24009c42:	4013      	ands	r3, r2
24009c44:	600b      	str	r3, [r1, #0]
#endif
}
24009c46:	bf00      	nop
24009c48:	370c      	adds	r7, #12
24009c4a:	46bd      	mov	sp, r7
24009c4c:	f85d 7b04 	ldr.w	r7, [sp], #4
24009c50:	4770      	bx	lr
24009c52:	bf00      	nop
24009c54:	58026500 	.word	0x58026500

24009c58 <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
24009c58:	b580      	push	{r7, lr}
24009c5a:	b082      	sub	sp, #8
24009c5c:	af00      	add	r7, sp, #0
    /*Clear Flags*/
    HSEM->C2ICR = ((uint32_t)statusreg);
  }
#else
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
24009c5e:	4b0a      	ldr	r3, [pc, #40]	; (24009c88 <HAL_HSEM_IRQHandler+0x30>)
24009c60:	68db      	ldr	r3, [r3, #12]
24009c62:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
24009c64:	4b08      	ldr	r3, [pc, #32]	; (24009c88 <HAL_HSEM_IRQHandler+0x30>)
24009c66:	681a      	ldr	r2, [r3, #0]
24009c68:	687b      	ldr	r3, [r7, #4]
24009c6a:	43db      	mvns	r3, r3
24009c6c:	4906      	ldr	r1, [pc, #24]	; (24009c88 <HAL_HSEM_IRQHandler+0x30>)
24009c6e:	4013      	ands	r3, r2
24009c70:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
24009c72:	4a05      	ldr	r2, [pc, #20]	; (24009c88 <HAL_HSEM_IRQHandler+0x30>)
24009c74:	687b      	ldr	r3, [r7, #4]
24009c76:	6053      	str	r3, [r2, #4]

#endif
  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
24009c78:	6878      	ldr	r0, [r7, #4]
24009c7a:	f000 f807 	bl	24009c8c <HAL_HSEM_FreeCallback>
}
24009c7e:	bf00      	nop
24009c80:	3708      	adds	r7, #8
24009c82:	46bd      	mov	sp, r7
24009c84:	bd80      	pop	{r7, pc}
24009c86:	bf00      	nop
24009c88:	58026500 	.word	0x58026500

24009c8c <HAL_HSEM_FreeCallback>:
  * @brief Semaphore Released Callback.
  * @param SemMask: Mask of Released semaphores
  * @retval None
  */
__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
24009c8c:	b480      	push	{r7}
24009c8e:	b083      	sub	sp, #12
24009c90:	af00      	add	r7, sp, #0
24009c92:	6078      	str	r0, [r7, #4]
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
24009c94:	bf00      	nop
24009c96:	370c      	adds	r7, #12
24009c98:	46bd      	mov	sp, r7
24009c9a:	f85d 7b04 	ldr.w	r7, [sp], #4
24009c9e:	4770      	bx	lr

24009ca0 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
24009ca0:	b580      	push	{r7, lr}
24009ca2:	b082      	sub	sp, #8
24009ca4:	af00      	add	r7, sp, #0
24009ca6:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
24009ca8:	687b      	ldr	r3, [r7, #4]
24009caa:	2b00      	cmp	r3, #0
24009cac:	d101      	bne.n	24009cb2 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
24009cae:	2301      	movs	r3, #1
24009cb0:	e07f      	b.n	24009db2 <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
24009cb2:	687b      	ldr	r3, [r7, #4]
24009cb4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009cb8:	b2db      	uxtb	r3, r3
24009cba:	2b00      	cmp	r3, #0
24009cbc:	d106      	bne.n	24009ccc <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
24009cbe:	687b      	ldr	r3, [r7, #4]
24009cc0:	2200      	movs	r2, #0
24009cc2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
24009cc6:	6878      	ldr	r0, [r7, #4]
24009cc8:	f000 f8a9 	bl	24009e1e <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
24009ccc:	687b      	ldr	r3, [r7, #4]
24009cce:	2224      	movs	r2, #36	; 0x24
24009cd0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
24009cd4:	687b      	ldr	r3, [r7, #4]
24009cd6:	681b      	ldr	r3, [r3, #0]
24009cd8:	681a      	ldr	r2, [r3, #0]
24009cda:	687b      	ldr	r3, [r7, #4]
24009cdc:	681b      	ldr	r3, [r3, #0]
24009cde:	f022 0201 	bic.w	r2, r2, #1
24009ce2:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
24009ce4:	687b      	ldr	r3, [r7, #4]
24009ce6:	685a      	ldr	r2, [r3, #4]
24009ce8:	687b      	ldr	r3, [r7, #4]
24009cea:	681b      	ldr	r3, [r3, #0]
24009cec:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
24009cf0:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
24009cf2:	687b      	ldr	r3, [r7, #4]
24009cf4:	681b      	ldr	r3, [r3, #0]
24009cf6:	689a      	ldr	r2, [r3, #8]
24009cf8:	687b      	ldr	r3, [r7, #4]
24009cfa:	681b      	ldr	r3, [r3, #0]
24009cfc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24009d00:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
24009d02:	687b      	ldr	r3, [r7, #4]
24009d04:	68db      	ldr	r3, [r3, #12]
24009d06:	2b01      	cmp	r3, #1
24009d08:	d107      	bne.n	24009d1a <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
24009d0a:	687b      	ldr	r3, [r7, #4]
24009d0c:	689a      	ldr	r2, [r3, #8]
24009d0e:	687b      	ldr	r3, [r7, #4]
24009d10:	681b      	ldr	r3, [r3, #0]
24009d12:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009d16:	609a      	str	r2, [r3, #8]
24009d18:	e006      	b.n	24009d28 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
24009d1a:	687b      	ldr	r3, [r7, #4]
24009d1c:	689a      	ldr	r2, [r3, #8]
24009d1e:	687b      	ldr	r3, [r7, #4]
24009d20:	681b      	ldr	r3, [r3, #0]
24009d22:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
24009d26:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24009d28:	687b      	ldr	r3, [r7, #4]
24009d2a:	68db      	ldr	r3, [r3, #12]
24009d2c:	2b02      	cmp	r3, #2
24009d2e:	d104      	bne.n	24009d3a <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
24009d30:	687b      	ldr	r3, [r7, #4]
24009d32:	681b      	ldr	r3, [r3, #0]
24009d34:	f44f 6200 	mov.w	r2, #2048	; 0x800
24009d38:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
24009d3a:	687b      	ldr	r3, [r7, #4]
24009d3c:	681b      	ldr	r3, [r3, #0]
24009d3e:	6859      	ldr	r1, [r3, #4]
24009d40:	687b      	ldr	r3, [r7, #4]
24009d42:	681a      	ldr	r2, [r3, #0]
24009d44:	4b1d      	ldr	r3, [pc, #116]	; (24009dbc <HAL_I2C_Init+0x11c>)
24009d46:	430b      	orrs	r3, r1
24009d48:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
24009d4a:	687b      	ldr	r3, [r7, #4]
24009d4c:	681b      	ldr	r3, [r3, #0]
24009d4e:	68da      	ldr	r2, [r3, #12]
24009d50:	687b      	ldr	r3, [r7, #4]
24009d52:	681b      	ldr	r3, [r3, #0]
24009d54:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24009d58:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
24009d5a:	687b      	ldr	r3, [r7, #4]
24009d5c:	691a      	ldr	r2, [r3, #16]
24009d5e:	687b      	ldr	r3, [r7, #4]
24009d60:	695b      	ldr	r3, [r3, #20]
24009d62:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
24009d66:	687b      	ldr	r3, [r7, #4]
24009d68:	699b      	ldr	r3, [r3, #24]
24009d6a:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
24009d6c:	687b      	ldr	r3, [r7, #4]
24009d6e:	681b      	ldr	r3, [r3, #0]
24009d70:	430a      	orrs	r2, r1
24009d72:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
24009d74:	687b      	ldr	r3, [r7, #4]
24009d76:	69d9      	ldr	r1, [r3, #28]
24009d78:	687b      	ldr	r3, [r7, #4]
24009d7a:	6a1a      	ldr	r2, [r3, #32]
24009d7c:	687b      	ldr	r3, [r7, #4]
24009d7e:	681b      	ldr	r3, [r3, #0]
24009d80:	430a      	orrs	r2, r1
24009d82:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
24009d84:	687b      	ldr	r3, [r7, #4]
24009d86:	681b      	ldr	r3, [r3, #0]
24009d88:	681a      	ldr	r2, [r3, #0]
24009d8a:	687b      	ldr	r3, [r7, #4]
24009d8c:	681b      	ldr	r3, [r3, #0]
24009d8e:	f042 0201 	orr.w	r2, r2, #1
24009d92:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24009d94:	687b      	ldr	r3, [r7, #4]
24009d96:	2200      	movs	r2, #0
24009d98:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
24009d9a:	687b      	ldr	r3, [r7, #4]
24009d9c:	2220      	movs	r2, #32
24009d9e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
24009da2:	687b      	ldr	r3, [r7, #4]
24009da4:	2200      	movs	r2, #0
24009da6:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
24009da8:	687b      	ldr	r3, [r7, #4]
24009daa:	2200      	movs	r2, #0
24009dac:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
24009db0:	2300      	movs	r3, #0
}
24009db2:	4618      	mov	r0, r3
24009db4:	3708      	adds	r7, #8
24009db6:	46bd      	mov	sp, r7
24009db8:	bd80      	pop	{r7, pc}
24009dba:	bf00      	nop
24009dbc:	02008000 	.word	0x02008000

24009dc0 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
24009dc0:	b580      	push	{r7, lr}
24009dc2:	b082      	sub	sp, #8
24009dc4:	af00      	add	r7, sp, #0
24009dc6:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
24009dc8:	687b      	ldr	r3, [r7, #4]
24009dca:	2b00      	cmp	r3, #0
24009dcc:	d101      	bne.n	24009dd2 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
24009dce:	2301      	movs	r3, #1
24009dd0:	e021      	b.n	24009e16 <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
24009dd2:	687b      	ldr	r3, [r7, #4]
24009dd4:	2224      	movs	r2, #36	; 0x24
24009dd6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
24009dda:	687b      	ldr	r3, [r7, #4]
24009ddc:	681b      	ldr	r3, [r3, #0]
24009dde:	681a      	ldr	r2, [r3, #0]
24009de0:	687b      	ldr	r3, [r7, #4]
24009de2:	681b      	ldr	r3, [r3, #0]
24009de4:	f022 0201 	bic.w	r2, r2, #1
24009de8:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
24009dea:	6878      	ldr	r0, [r7, #4]
24009dec:	f000 f821 	bl	24009e32 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24009df0:	687b      	ldr	r3, [r7, #4]
24009df2:	2200      	movs	r2, #0
24009df4:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
24009df6:	687b      	ldr	r3, [r7, #4]
24009df8:	2200      	movs	r2, #0
24009dfa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
24009dfe:	687b      	ldr	r3, [r7, #4]
24009e00:	2200      	movs	r2, #0
24009e02:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
24009e04:	687b      	ldr	r3, [r7, #4]
24009e06:	2200      	movs	r2, #0
24009e08:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
24009e0c:	687b      	ldr	r3, [r7, #4]
24009e0e:	2200      	movs	r2, #0
24009e10:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
24009e14:	2300      	movs	r3, #0
}
24009e16:	4618      	mov	r0, r3
24009e18:	3708      	adds	r7, #8
24009e1a:	46bd      	mov	sp, r7
24009e1c:	bd80      	pop	{r7, pc}

24009e1e <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
24009e1e:	b480      	push	{r7}
24009e20:	b083      	sub	sp, #12
24009e22:	af00      	add	r7, sp, #0
24009e24:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
24009e26:	bf00      	nop
24009e28:	370c      	adds	r7, #12
24009e2a:	46bd      	mov	sp, r7
24009e2c:	f85d 7b04 	ldr.w	r7, [sp], #4
24009e30:	4770      	bx	lr

24009e32 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
24009e32:	b480      	push	{r7}
24009e34:	b083      	sub	sp, #12
24009e36:	af00      	add	r7, sp, #0
24009e38:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
24009e3a:	bf00      	nop
24009e3c:	370c      	adds	r7, #12
24009e3e:	46bd      	mov	sp, r7
24009e40:	f85d 7b04 	ldr.w	r7, [sp], #4
24009e44:	4770      	bx	lr
	...

24009e48 <HAL_I2C_Master_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                          uint16_t Size, uint32_t Timeout)
{
24009e48:	b580      	push	{r7, lr}
24009e4a:	b088      	sub	sp, #32
24009e4c:	af02      	add	r7, sp, #8
24009e4e:	60f8      	str	r0, [r7, #12]
24009e50:	607a      	str	r2, [r7, #4]
24009e52:	461a      	mov	r2, r3
24009e54:	460b      	mov	r3, r1
24009e56:	817b      	strh	r3, [r7, #10]
24009e58:	4613      	mov	r3, r2
24009e5a:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009e5c:	68fb      	ldr	r3, [r7, #12]
24009e5e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009e62:	b2db      	uxtb	r3, r3
24009e64:	2b20      	cmp	r3, #32
24009e66:	f040 80da 	bne.w	2400a01e <HAL_I2C_Master_Transmit+0x1d6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
24009e6a:	68fb      	ldr	r3, [r7, #12]
24009e6c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009e70:	2b01      	cmp	r3, #1
24009e72:	d101      	bne.n	24009e78 <HAL_I2C_Master_Transmit+0x30>
24009e74:	2302      	movs	r3, #2
24009e76:	e0d3      	b.n	2400a020 <HAL_I2C_Master_Transmit+0x1d8>
24009e78:	68fb      	ldr	r3, [r7, #12]
24009e7a:	2201      	movs	r2, #1
24009e7c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
24009e80:	f7f8 f8cc 	bl	2400201c <HAL_GetTick>
24009e84:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24009e86:	697b      	ldr	r3, [r7, #20]
24009e88:	9300      	str	r3, [sp, #0]
24009e8a:	2319      	movs	r3, #25
24009e8c:	2201      	movs	r2, #1
24009e8e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
24009e92:	68f8      	ldr	r0, [r7, #12]
24009e94:	f005 f80c 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
24009e98:	4603      	mov	r3, r0
24009e9a:	2b00      	cmp	r3, #0
24009e9c:	d001      	beq.n	24009ea2 <HAL_I2C_Master_Transmit+0x5a>
    {
      return HAL_ERROR;
24009e9e:	2301      	movs	r3, #1
24009ea0:	e0be      	b.n	2400a020 <HAL_I2C_Master_Transmit+0x1d8>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24009ea2:	68fb      	ldr	r3, [r7, #12]
24009ea4:	2221      	movs	r2, #33	; 0x21
24009ea6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
24009eaa:	68fb      	ldr	r3, [r7, #12]
24009eac:	2210      	movs	r2, #16
24009eae:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24009eb2:	68fb      	ldr	r3, [r7, #12]
24009eb4:	2200      	movs	r2, #0
24009eb6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
24009eb8:	68fb      	ldr	r3, [r7, #12]
24009eba:	687a      	ldr	r2, [r7, #4]
24009ebc:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
24009ebe:	68fb      	ldr	r3, [r7, #12]
24009ec0:	893a      	ldrh	r2, [r7, #8]
24009ec2:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
24009ec4:	68fb      	ldr	r3, [r7, #12]
24009ec6:	2200      	movs	r2, #0
24009ec8:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009eca:	68fb      	ldr	r3, [r7, #12]
24009ecc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009ece:	b29b      	uxth	r3, r3
24009ed0:	2bff      	cmp	r3, #255	; 0xff
24009ed2:	d90e      	bls.n	24009ef2 <HAL_I2C_Master_Transmit+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009ed4:	68fb      	ldr	r3, [r7, #12]
24009ed6:	22ff      	movs	r2, #255	; 0xff
24009ed8:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
24009eda:	68fb      	ldr	r3, [r7, #12]
24009edc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009ede:	b2da      	uxtb	r2, r3
24009ee0:	8979      	ldrh	r1, [r7, #10]
24009ee2:	4b51      	ldr	r3, [pc, #324]	; (2400a028 <HAL_I2C_Master_Transmit+0x1e0>)
24009ee4:	9300      	str	r3, [sp, #0]
24009ee6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009eea:	68f8      	ldr	r0, [r7, #12]
24009eec:	f005 fa1c 	bl	2400f328 <I2C_TransferConfig>
24009ef0:	e06c      	b.n	24009fcc <HAL_I2C_Master_Transmit+0x184>
                         I2C_GENERATE_START_WRITE);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009ef2:	68fb      	ldr	r3, [r7, #12]
24009ef4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009ef6:	b29a      	uxth	r2, r3
24009ef8:	68fb      	ldr	r3, [r7, #12]
24009efa:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
24009efc:	68fb      	ldr	r3, [r7, #12]
24009efe:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009f00:	b2da      	uxtb	r2, r3
24009f02:	8979      	ldrh	r1, [r7, #10]
24009f04:	4b48      	ldr	r3, [pc, #288]	; (2400a028 <HAL_I2C_Master_Transmit+0x1e0>)
24009f06:	9300      	str	r3, [sp, #0]
24009f08:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009f0c:	68f8      	ldr	r0, [r7, #12]
24009f0e:	f005 fa0b 	bl	2400f328 <I2C_TransferConfig>
                         I2C_GENERATE_START_WRITE);
    }

    while (hi2c->XferCount > 0U)
24009f12:	e05b      	b.n	24009fcc <HAL_I2C_Master_Transmit+0x184>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009f14:	697a      	ldr	r2, [r7, #20]
24009f16:	6a39      	ldr	r1, [r7, #32]
24009f18:	68f8      	ldr	r0, [r7, #12]
24009f1a:	f005 f818 	bl	2400ef4e <I2C_WaitOnTXISFlagUntilTimeout>
24009f1e:	4603      	mov	r3, r0
24009f20:	2b00      	cmp	r3, #0
24009f22:	d001      	beq.n	24009f28 <HAL_I2C_Master_Transmit+0xe0>
      {
        return HAL_ERROR;
24009f24:	2301      	movs	r3, #1
24009f26:	e07b      	b.n	2400a020 <HAL_I2C_Master_Transmit+0x1d8>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
24009f28:	68fb      	ldr	r3, [r7, #12]
24009f2a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24009f2c:	781a      	ldrb	r2, [r3, #0]
24009f2e:	68fb      	ldr	r3, [r7, #12]
24009f30:	681b      	ldr	r3, [r3, #0]
24009f32:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
24009f34:	68fb      	ldr	r3, [r7, #12]
24009f36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24009f38:	1c5a      	adds	r2, r3, #1
24009f3a:	68fb      	ldr	r3, [r7, #12]
24009f3c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
24009f3e:	68fb      	ldr	r3, [r7, #12]
24009f40:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009f42:	b29b      	uxth	r3, r3
24009f44:	3b01      	subs	r3, #1
24009f46:	b29a      	uxth	r2, r3
24009f48:	68fb      	ldr	r3, [r7, #12]
24009f4a:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
24009f4c:	68fb      	ldr	r3, [r7, #12]
24009f4e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009f50:	3b01      	subs	r3, #1
24009f52:	b29a      	uxth	r2, r3
24009f54:	68fb      	ldr	r3, [r7, #12]
24009f56:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
24009f58:	68fb      	ldr	r3, [r7, #12]
24009f5a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009f5c:	b29b      	uxth	r3, r3
24009f5e:	2b00      	cmp	r3, #0
24009f60:	d034      	beq.n	24009fcc <HAL_I2C_Master_Transmit+0x184>
24009f62:	68fb      	ldr	r3, [r7, #12]
24009f64:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009f66:	2b00      	cmp	r3, #0
24009f68:	d130      	bne.n	24009fcc <HAL_I2C_Master_Transmit+0x184>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
24009f6a:	697b      	ldr	r3, [r7, #20]
24009f6c:	9300      	str	r3, [sp, #0]
24009f6e:	6a3b      	ldr	r3, [r7, #32]
24009f70:	2200      	movs	r2, #0
24009f72:	2180      	movs	r1, #128	; 0x80
24009f74:	68f8      	ldr	r0, [r7, #12]
24009f76:	f004 ff9b 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
24009f7a:	4603      	mov	r3, r0
24009f7c:	2b00      	cmp	r3, #0
24009f7e:	d001      	beq.n	24009f84 <HAL_I2C_Master_Transmit+0x13c>
        {
          return HAL_ERROR;
24009f80:	2301      	movs	r3, #1
24009f82:	e04d      	b.n	2400a020 <HAL_I2C_Master_Transmit+0x1d8>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009f84:	68fb      	ldr	r3, [r7, #12]
24009f86:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009f88:	b29b      	uxth	r3, r3
24009f8a:	2bff      	cmp	r3, #255	; 0xff
24009f8c:	d90e      	bls.n	24009fac <HAL_I2C_Master_Transmit+0x164>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
24009f8e:	68fb      	ldr	r3, [r7, #12]
24009f90:	22ff      	movs	r2, #255	; 0xff
24009f92:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
24009f94:	68fb      	ldr	r3, [r7, #12]
24009f96:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009f98:	b2da      	uxtb	r2, r3
24009f9a:	8979      	ldrh	r1, [r7, #10]
24009f9c:	2300      	movs	r3, #0
24009f9e:	9300      	str	r3, [sp, #0]
24009fa0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009fa4:	68f8      	ldr	r0, [r7, #12]
24009fa6:	f005 f9bf 	bl	2400f328 <I2C_TransferConfig>
24009faa:	e00f      	b.n	24009fcc <HAL_I2C_Master_Transmit+0x184>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
24009fac:	68fb      	ldr	r3, [r7, #12]
24009fae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009fb0:	b29a      	uxth	r2, r3
24009fb2:	68fb      	ldr	r3, [r7, #12]
24009fb4:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
24009fb6:	68fb      	ldr	r3, [r7, #12]
24009fb8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009fba:	b2da      	uxtb	r2, r3
24009fbc:	8979      	ldrh	r1, [r7, #10]
24009fbe:	2300      	movs	r3, #0
24009fc0:	9300      	str	r3, [sp, #0]
24009fc2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009fc6:	68f8      	ldr	r0, [r7, #12]
24009fc8:	f005 f9ae 	bl	2400f328 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
24009fcc:	68fb      	ldr	r3, [r7, #12]
24009fce:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009fd0:	b29b      	uxth	r3, r3
24009fd2:	2b00      	cmp	r3, #0
24009fd4:	d19e      	bne.n	24009f14 <HAL_I2C_Master_Transmit+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009fd6:	697a      	ldr	r2, [r7, #20]
24009fd8:	6a39      	ldr	r1, [r7, #32]
24009fda:	68f8      	ldr	r0, [r7, #12]
24009fdc:	f004 fffe 	bl	2400efdc <I2C_WaitOnSTOPFlagUntilTimeout>
24009fe0:	4603      	mov	r3, r0
24009fe2:	2b00      	cmp	r3, #0
24009fe4:	d001      	beq.n	24009fea <HAL_I2C_Master_Transmit+0x1a2>
    {
      return HAL_ERROR;
24009fe6:	2301      	movs	r3, #1
24009fe8:	e01a      	b.n	2400a020 <HAL_I2C_Master_Transmit+0x1d8>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24009fea:	68fb      	ldr	r3, [r7, #12]
24009fec:	681b      	ldr	r3, [r3, #0]
24009fee:	2220      	movs	r2, #32
24009ff0:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
24009ff2:	68fb      	ldr	r3, [r7, #12]
24009ff4:	681b      	ldr	r3, [r3, #0]
24009ff6:	6859      	ldr	r1, [r3, #4]
24009ff8:	68fb      	ldr	r3, [r7, #12]
24009ffa:	681a      	ldr	r2, [r3, #0]
24009ffc:	4b0b      	ldr	r3, [pc, #44]	; (2400a02c <HAL_I2C_Master_Transmit+0x1e4>)
24009ffe:	400b      	ands	r3, r1
2400a000:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a002:	68fb      	ldr	r3, [r7, #12]
2400a004:	2220      	movs	r2, #32
2400a006:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a00a:	68fb      	ldr	r3, [r7, #12]
2400a00c:	2200      	movs	r2, #0
2400a00e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a012:	68fb      	ldr	r3, [r7, #12]
2400a014:	2200      	movs	r2, #0
2400a016:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a01a:	2300      	movs	r3, #0
2400a01c:	e000      	b.n	2400a020 <HAL_I2C_Master_Transmit+0x1d8>
  }
  else
  {
    return HAL_BUSY;
2400a01e:	2302      	movs	r3, #2
  }
}
2400a020:	4618      	mov	r0, r3
2400a022:	3718      	adds	r7, #24
2400a024:	46bd      	mov	sp, r7
2400a026:	bd80      	pop	{r7, pc}
2400a028:	80002000 	.word	0x80002000
2400a02c:	fe00e800 	.word	0xfe00e800

2400a030 <HAL_I2C_Master_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                         uint16_t Size, uint32_t Timeout)
{
2400a030:	b580      	push	{r7, lr}
2400a032:	b088      	sub	sp, #32
2400a034:	af02      	add	r7, sp, #8
2400a036:	60f8      	str	r0, [r7, #12]
2400a038:	607a      	str	r2, [r7, #4]
2400a03a:	461a      	mov	r2, r3
2400a03c:	460b      	mov	r3, r1
2400a03e:	817b      	strh	r3, [r7, #10]
2400a040:	4613      	mov	r3, r2
2400a042:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a044:	68fb      	ldr	r3, [r7, #12]
2400a046:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a04a:	b2db      	uxtb	r3, r3
2400a04c:	2b20      	cmp	r3, #32
2400a04e:	f040 80db 	bne.w	2400a208 <HAL_I2C_Master_Receive+0x1d8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a052:	68fb      	ldr	r3, [r7, #12]
2400a054:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a058:	2b01      	cmp	r3, #1
2400a05a:	d101      	bne.n	2400a060 <HAL_I2C_Master_Receive+0x30>
2400a05c:	2302      	movs	r3, #2
2400a05e:	e0d4      	b.n	2400a20a <HAL_I2C_Master_Receive+0x1da>
2400a060:	68fb      	ldr	r3, [r7, #12]
2400a062:	2201      	movs	r2, #1
2400a064:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a068:	f7f7 ffd8 	bl	2400201c <HAL_GetTick>
2400a06c:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400a06e:	697b      	ldr	r3, [r7, #20]
2400a070:	9300      	str	r3, [sp, #0]
2400a072:	2319      	movs	r3, #25
2400a074:	2201      	movs	r2, #1
2400a076:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a07a:	68f8      	ldr	r0, [r7, #12]
2400a07c:	f004 ff18 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a080:	4603      	mov	r3, r0
2400a082:	2b00      	cmp	r3, #0
2400a084:	d001      	beq.n	2400a08a <HAL_I2C_Master_Receive+0x5a>
    {
      return HAL_ERROR;
2400a086:	2301      	movs	r3, #1
2400a088:	e0bf      	b.n	2400a20a <HAL_I2C_Master_Receive+0x1da>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400a08a:	68fb      	ldr	r3, [r7, #12]
2400a08c:	2222      	movs	r2, #34	; 0x22
2400a08e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400a092:	68fb      	ldr	r3, [r7, #12]
2400a094:	2210      	movs	r2, #16
2400a096:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a09a:	68fb      	ldr	r3, [r7, #12]
2400a09c:	2200      	movs	r2, #0
2400a09e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a0a0:	68fb      	ldr	r3, [r7, #12]
2400a0a2:	687a      	ldr	r2, [r7, #4]
2400a0a4:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a0a6:	68fb      	ldr	r3, [r7, #12]
2400a0a8:	893a      	ldrh	r2, [r7, #8]
2400a0aa:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a0ac:	68fb      	ldr	r3, [r7, #12]
2400a0ae:	2200      	movs	r2, #0
2400a0b0:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a0b2:	68fb      	ldr	r3, [r7, #12]
2400a0b4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a0b6:	b29b      	uxth	r3, r3
2400a0b8:	2bff      	cmp	r3, #255	; 0xff
2400a0ba:	d90e      	bls.n	2400a0da <HAL_I2C_Master_Receive+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a0bc:	68fb      	ldr	r3, [r7, #12]
2400a0be:	22ff      	movs	r2, #255	; 0xff
2400a0c0:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400a0c2:	68fb      	ldr	r3, [r7, #12]
2400a0c4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a0c6:	b2da      	uxtb	r2, r3
2400a0c8:	8979      	ldrh	r1, [r7, #10]
2400a0ca:	4b52      	ldr	r3, [pc, #328]	; (2400a214 <HAL_I2C_Master_Receive+0x1e4>)
2400a0cc:	9300      	str	r3, [sp, #0]
2400a0ce:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a0d2:	68f8      	ldr	r0, [r7, #12]
2400a0d4:	f005 f928 	bl	2400f328 <I2C_TransferConfig>
2400a0d8:	e06d      	b.n	2400a1b6 <HAL_I2C_Master_Receive+0x186>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a0da:	68fb      	ldr	r3, [r7, #12]
2400a0dc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a0de:	b29a      	uxth	r2, r3
2400a0e0:	68fb      	ldr	r3, [r7, #12]
2400a0e2:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400a0e4:	68fb      	ldr	r3, [r7, #12]
2400a0e6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a0e8:	b2da      	uxtb	r2, r3
2400a0ea:	8979      	ldrh	r1, [r7, #10]
2400a0ec:	4b49      	ldr	r3, [pc, #292]	; (2400a214 <HAL_I2C_Master_Receive+0x1e4>)
2400a0ee:	9300      	str	r3, [sp, #0]
2400a0f0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a0f4:	68f8      	ldr	r0, [r7, #12]
2400a0f6:	f005 f917 	bl	2400f328 <I2C_TransferConfig>
                         I2C_GENERATE_START_READ);
    }

    while (hi2c->XferCount > 0U)
2400a0fa:	e05c      	b.n	2400a1b6 <HAL_I2C_Master_Receive+0x186>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a0fc:	697a      	ldr	r2, [r7, #20]
2400a0fe:	6a39      	ldr	r1, [r7, #32]
2400a100:	68f8      	ldr	r0, [r7, #12]
2400a102:	f004 ffaf 	bl	2400f064 <I2C_WaitOnRXNEFlagUntilTimeout>
2400a106:	4603      	mov	r3, r0
2400a108:	2b00      	cmp	r3, #0
2400a10a:	d001      	beq.n	2400a110 <HAL_I2C_Master_Receive+0xe0>
      {
        return HAL_ERROR;
2400a10c:	2301      	movs	r3, #1
2400a10e:	e07c      	b.n	2400a20a <HAL_I2C_Master_Receive+0x1da>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400a110:	68fb      	ldr	r3, [r7, #12]
2400a112:	681b      	ldr	r3, [r3, #0]
2400a114:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400a116:	68fb      	ldr	r3, [r7, #12]
2400a118:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a11a:	b2d2      	uxtb	r2, r2
2400a11c:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a11e:	68fb      	ldr	r3, [r7, #12]
2400a120:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a122:	1c5a      	adds	r2, r3, #1
2400a124:	68fb      	ldr	r3, [r7, #12]
2400a126:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400a128:	68fb      	ldr	r3, [r7, #12]
2400a12a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a12c:	3b01      	subs	r3, #1
2400a12e:	b29a      	uxth	r2, r3
2400a130:	68fb      	ldr	r3, [r7, #12]
2400a132:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400a134:	68fb      	ldr	r3, [r7, #12]
2400a136:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a138:	b29b      	uxth	r3, r3
2400a13a:	3b01      	subs	r3, #1
2400a13c:	b29a      	uxth	r2, r3
2400a13e:	68fb      	ldr	r3, [r7, #12]
2400a140:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400a142:	68fb      	ldr	r3, [r7, #12]
2400a144:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a146:	b29b      	uxth	r3, r3
2400a148:	2b00      	cmp	r3, #0
2400a14a:	d034      	beq.n	2400a1b6 <HAL_I2C_Master_Receive+0x186>
2400a14c:	68fb      	ldr	r3, [r7, #12]
2400a14e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a150:	2b00      	cmp	r3, #0
2400a152:	d130      	bne.n	2400a1b6 <HAL_I2C_Master_Receive+0x186>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400a154:	697b      	ldr	r3, [r7, #20]
2400a156:	9300      	str	r3, [sp, #0]
2400a158:	6a3b      	ldr	r3, [r7, #32]
2400a15a:	2200      	movs	r2, #0
2400a15c:	2180      	movs	r1, #128	; 0x80
2400a15e:	68f8      	ldr	r0, [r7, #12]
2400a160:	f004 fea6 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a164:	4603      	mov	r3, r0
2400a166:	2b00      	cmp	r3, #0
2400a168:	d001      	beq.n	2400a16e <HAL_I2C_Master_Receive+0x13e>
        {
          return HAL_ERROR;
2400a16a:	2301      	movs	r3, #1
2400a16c:	e04d      	b.n	2400a20a <HAL_I2C_Master_Receive+0x1da>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a16e:	68fb      	ldr	r3, [r7, #12]
2400a170:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a172:	b29b      	uxth	r3, r3
2400a174:	2bff      	cmp	r3, #255	; 0xff
2400a176:	d90e      	bls.n	2400a196 <HAL_I2C_Master_Receive+0x166>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400a178:	68fb      	ldr	r3, [r7, #12]
2400a17a:	22ff      	movs	r2, #255	; 0xff
2400a17c:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400a17e:	68fb      	ldr	r3, [r7, #12]
2400a180:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a182:	b2da      	uxtb	r2, r3
2400a184:	8979      	ldrh	r1, [r7, #10]
2400a186:	2300      	movs	r3, #0
2400a188:	9300      	str	r3, [sp, #0]
2400a18a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a18e:	68f8      	ldr	r0, [r7, #12]
2400a190:	f005 f8ca 	bl	2400f328 <I2C_TransferConfig>
2400a194:	e00f      	b.n	2400a1b6 <HAL_I2C_Master_Receive+0x186>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400a196:	68fb      	ldr	r3, [r7, #12]
2400a198:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a19a:	b29a      	uxth	r2, r3
2400a19c:	68fb      	ldr	r3, [r7, #12]
2400a19e:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400a1a0:	68fb      	ldr	r3, [r7, #12]
2400a1a2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a1a4:	b2da      	uxtb	r2, r3
2400a1a6:	8979      	ldrh	r1, [r7, #10]
2400a1a8:	2300      	movs	r3, #0
2400a1aa:	9300      	str	r3, [sp, #0]
2400a1ac:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a1b0:	68f8      	ldr	r0, [r7, #12]
2400a1b2:	f005 f8b9 	bl	2400f328 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
2400a1b6:	68fb      	ldr	r3, [r7, #12]
2400a1b8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a1ba:	b29b      	uxth	r3, r3
2400a1bc:	2b00      	cmp	r3, #0
2400a1be:	d19d      	bne.n	2400a0fc <HAL_I2C_Master_Receive+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a1c0:	697a      	ldr	r2, [r7, #20]
2400a1c2:	6a39      	ldr	r1, [r7, #32]
2400a1c4:	68f8      	ldr	r0, [r7, #12]
2400a1c6:	f004 ff09 	bl	2400efdc <I2C_WaitOnSTOPFlagUntilTimeout>
2400a1ca:	4603      	mov	r3, r0
2400a1cc:	2b00      	cmp	r3, #0
2400a1ce:	d001      	beq.n	2400a1d4 <HAL_I2C_Master_Receive+0x1a4>
    {
      return HAL_ERROR;
2400a1d0:	2301      	movs	r3, #1
2400a1d2:	e01a      	b.n	2400a20a <HAL_I2C_Master_Receive+0x1da>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a1d4:	68fb      	ldr	r3, [r7, #12]
2400a1d6:	681b      	ldr	r3, [r3, #0]
2400a1d8:	2220      	movs	r2, #32
2400a1da:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400a1dc:	68fb      	ldr	r3, [r7, #12]
2400a1de:	681b      	ldr	r3, [r3, #0]
2400a1e0:	6859      	ldr	r1, [r3, #4]
2400a1e2:	68fb      	ldr	r3, [r7, #12]
2400a1e4:	681a      	ldr	r2, [r3, #0]
2400a1e6:	4b0c      	ldr	r3, [pc, #48]	; (2400a218 <HAL_I2C_Master_Receive+0x1e8>)
2400a1e8:	400b      	ands	r3, r1
2400a1ea:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a1ec:	68fb      	ldr	r3, [r7, #12]
2400a1ee:	2220      	movs	r2, #32
2400a1f0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a1f4:	68fb      	ldr	r3, [r7, #12]
2400a1f6:	2200      	movs	r2, #0
2400a1f8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a1fc:	68fb      	ldr	r3, [r7, #12]
2400a1fe:	2200      	movs	r2, #0
2400a200:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a204:	2300      	movs	r3, #0
2400a206:	e000      	b.n	2400a20a <HAL_I2C_Master_Receive+0x1da>
  }
  else
  {
    return HAL_BUSY;
2400a208:	2302      	movs	r3, #2
  }
}
2400a20a:	4618      	mov	r0, r3
2400a20c:	3718      	adds	r7, #24
2400a20e:	46bd      	mov	sp, r7
2400a210:	bd80      	pop	{r7, pc}
2400a212:	bf00      	nop
2400a214:	80002400 	.word	0x80002400
2400a218:	fe00e800 	.word	0xfe00e800

2400a21c <HAL_I2C_Slave_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
2400a21c:	b580      	push	{r7, lr}
2400a21e:	b088      	sub	sp, #32
2400a220:	af02      	add	r7, sp, #8
2400a222:	60f8      	str	r0, [r7, #12]
2400a224:	60b9      	str	r1, [r7, #8]
2400a226:	603b      	str	r3, [r7, #0]
2400a228:	4613      	mov	r3, r2
2400a22a:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a22c:	68fb      	ldr	r3, [r7, #12]
2400a22e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a232:	b2db      	uxtb	r3, r3
2400a234:	2b20      	cmp	r3, #32
2400a236:	f040 8120 	bne.w	2400a47a <HAL_I2C_Slave_Transmit+0x25e>
  {
    if ((pData == NULL) || (Size == 0U))
2400a23a:	68bb      	ldr	r3, [r7, #8]
2400a23c:	2b00      	cmp	r3, #0
2400a23e:	d002      	beq.n	2400a246 <HAL_I2C_Slave_Transmit+0x2a>
2400a240:	88fb      	ldrh	r3, [r7, #6]
2400a242:	2b00      	cmp	r3, #0
2400a244:	d105      	bne.n	2400a252 <HAL_I2C_Slave_Transmit+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a246:	68fb      	ldr	r3, [r7, #12]
2400a248:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a24c:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a24e:	2301      	movs	r3, #1
2400a250:	e114      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a252:	68fb      	ldr	r3, [r7, #12]
2400a254:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a258:	2b01      	cmp	r3, #1
2400a25a:	d101      	bne.n	2400a260 <HAL_I2C_Slave_Transmit+0x44>
2400a25c:	2302      	movs	r3, #2
2400a25e:	e10d      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
2400a260:	68fb      	ldr	r3, [r7, #12]
2400a262:	2201      	movs	r2, #1
2400a264:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a268:	f7f7 fed8 	bl	2400201c <HAL_GetTick>
2400a26c:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400a26e:	68fb      	ldr	r3, [r7, #12]
2400a270:	2221      	movs	r2, #33	; 0x21
2400a272:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400a276:	68fb      	ldr	r3, [r7, #12]
2400a278:	2220      	movs	r2, #32
2400a27a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a27e:	68fb      	ldr	r3, [r7, #12]
2400a280:	2200      	movs	r2, #0
2400a282:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a284:	68fb      	ldr	r3, [r7, #12]
2400a286:	68ba      	ldr	r2, [r7, #8]
2400a288:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a28a:	68fb      	ldr	r3, [r7, #12]
2400a28c:	88fa      	ldrh	r2, [r7, #6]
2400a28e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a290:	68fb      	ldr	r3, [r7, #12]
2400a292:	2200      	movs	r2, #0
2400a294:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400a296:	68fb      	ldr	r3, [r7, #12]
2400a298:	681b      	ldr	r3, [r3, #0]
2400a29a:	685a      	ldr	r2, [r3, #4]
2400a29c:	68fb      	ldr	r3, [r7, #12]
2400a29e:	681b      	ldr	r3, [r3, #0]
2400a2a0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a2a4:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400a2a6:	697b      	ldr	r3, [r7, #20]
2400a2a8:	9300      	str	r3, [sp, #0]
2400a2aa:	683b      	ldr	r3, [r7, #0]
2400a2ac:	2200      	movs	r2, #0
2400a2ae:	2108      	movs	r1, #8
2400a2b0:	68f8      	ldr	r0, [r7, #12]
2400a2b2:	f004 fdfd 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a2b6:	4603      	mov	r3, r0
2400a2b8:	2b00      	cmp	r3, #0
2400a2ba:	d009      	beq.n	2400a2d0 <HAL_I2C_Slave_Transmit+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a2bc:	68fb      	ldr	r3, [r7, #12]
2400a2be:	681b      	ldr	r3, [r3, #0]
2400a2c0:	685a      	ldr	r2, [r3, #4]
2400a2c2:	68fb      	ldr	r3, [r7, #12]
2400a2c4:	681b      	ldr	r3, [r3, #0]
2400a2c6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a2ca:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a2cc:	2301      	movs	r3, #1
2400a2ce:	e0d5      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
    }

    /* Preload TX data if no stretch enable */
    if (hi2c->Init.NoStretchMode == I2C_NOSTRETCH_ENABLE)
2400a2d0:	68fb      	ldr	r3, [r7, #12]
2400a2d2:	6a1b      	ldr	r3, [r3, #32]
2400a2d4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2400a2d8:	d111      	bne.n	2400a2fe <HAL_I2C_Slave_Transmit+0xe2>
    {
      /* Preload TX register */
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400a2da:	68fb      	ldr	r3, [r7, #12]
2400a2dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a2de:	781a      	ldrb	r2, [r3, #0]
2400a2e0:	68fb      	ldr	r3, [r7, #12]
2400a2e2:	681b      	ldr	r3, [r3, #0]
2400a2e4:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a2e6:	68fb      	ldr	r3, [r7, #12]
2400a2e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a2ea:	1c5a      	adds	r2, r3, #1
2400a2ec:	68fb      	ldr	r3, [r7, #12]
2400a2ee:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a2f0:	68fb      	ldr	r3, [r7, #12]
2400a2f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2f4:	b29b      	uxth	r3, r3
2400a2f6:	3b01      	subs	r3, #1
2400a2f8:	b29a      	uxth	r2, r3
2400a2fa:	68fb      	ldr	r3, [r7, #12]
2400a2fc:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400a2fe:	68fb      	ldr	r3, [r7, #12]
2400a300:	681b      	ldr	r3, [r3, #0]
2400a302:	2208      	movs	r2, #8
2400a304:	61da      	str	r2, [r3, #28]

    /* If 10bit addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400a306:	68fb      	ldr	r3, [r7, #12]
2400a308:	68db      	ldr	r3, [r3, #12]
2400a30a:	2b02      	cmp	r3, #2
2400a30c:	d118      	bne.n	2400a340 <HAL_I2C_Slave_Transmit+0x124>
    {
      /* Wait until ADDR flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400a30e:	697b      	ldr	r3, [r7, #20]
2400a310:	9300      	str	r3, [sp, #0]
2400a312:	683b      	ldr	r3, [r7, #0]
2400a314:	2200      	movs	r2, #0
2400a316:	2108      	movs	r1, #8
2400a318:	68f8      	ldr	r0, [r7, #12]
2400a31a:	f004 fdc9 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a31e:	4603      	mov	r3, r0
2400a320:	2b00      	cmp	r3, #0
2400a322:	d009      	beq.n	2400a338 <HAL_I2C_Slave_Transmit+0x11c>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a324:	68fb      	ldr	r3, [r7, #12]
2400a326:	681b      	ldr	r3, [r3, #0]
2400a328:	685a      	ldr	r2, [r3, #4]
2400a32a:	68fb      	ldr	r3, [r7, #12]
2400a32c:	681b      	ldr	r3, [r3, #0]
2400a32e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a332:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2400a334:	2301      	movs	r3, #1
2400a336:	e0a1      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
      }

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400a338:	68fb      	ldr	r3, [r7, #12]
2400a33a:	681b      	ldr	r3, [r3, #0]
2400a33c:	2208      	movs	r2, #8
2400a33e:	61da      	str	r2, [r3, #28]
    }

    /* Wait until DIR flag is set Transmitter mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
2400a340:	697b      	ldr	r3, [r7, #20]
2400a342:	9300      	str	r3, [sp, #0]
2400a344:	683b      	ldr	r3, [r7, #0]
2400a346:	2200      	movs	r2, #0
2400a348:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2400a34c:	68f8      	ldr	r0, [r7, #12]
2400a34e:	f004 fdaf 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a352:	4603      	mov	r3, r0
2400a354:	2b00      	cmp	r3, #0
2400a356:	d02d      	beq.n	2400a3b4 <HAL_I2C_Slave_Transmit+0x198>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a358:	68fb      	ldr	r3, [r7, #12]
2400a35a:	681b      	ldr	r3, [r3, #0]
2400a35c:	685a      	ldr	r2, [r3, #4]
2400a35e:	68fb      	ldr	r3, [r7, #12]
2400a360:	681b      	ldr	r3, [r3, #0]
2400a362:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a366:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a368:	2301      	movs	r3, #1
2400a36a:	e087      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a36c:	697a      	ldr	r2, [r7, #20]
2400a36e:	6839      	ldr	r1, [r7, #0]
2400a370:	68f8      	ldr	r0, [r7, #12]
2400a372:	f004 fdec 	bl	2400ef4e <I2C_WaitOnTXISFlagUntilTimeout>
2400a376:	4603      	mov	r3, r0
2400a378:	2b00      	cmp	r3, #0
2400a37a:	d009      	beq.n	2400a390 <HAL_I2C_Slave_Transmit+0x174>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a37c:	68fb      	ldr	r3, [r7, #12]
2400a37e:	681b      	ldr	r3, [r3, #0]
2400a380:	685a      	ldr	r2, [r3, #4]
2400a382:	68fb      	ldr	r3, [r7, #12]
2400a384:	681b      	ldr	r3, [r3, #0]
2400a386:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a38a:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2400a38c:	2301      	movs	r3, #1
2400a38e:	e075      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400a390:	68fb      	ldr	r3, [r7, #12]
2400a392:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a394:	781a      	ldrb	r2, [r3, #0]
2400a396:	68fb      	ldr	r3, [r7, #12]
2400a398:	681b      	ldr	r3, [r3, #0]
2400a39a:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a39c:	68fb      	ldr	r3, [r7, #12]
2400a39e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a3a0:	1c5a      	adds	r2, r3, #1
2400a3a2:	68fb      	ldr	r3, [r7, #12]
2400a3a4:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a3a6:	68fb      	ldr	r3, [r7, #12]
2400a3a8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a3aa:	b29b      	uxth	r3, r3
2400a3ac:	3b01      	subs	r3, #1
2400a3ae:	b29a      	uxth	r2, r3
2400a3b0:	68fb      	ldr	r3, [r7, #12]
2400a3b2:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
2400a3b4:	68fb      	ldr	r3, [r7, #12]
2400a3b6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a3b8:	b29b      	uxth	r3, r3
2400a3ba:	2b00      	cmp	r3, #0
2400a3bc:	d1d6      	bne.n	2400a36c <HAL_I2C_Slave_Transmit+0x150>
    }

    /* Wait until AF flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
2400a3be:	697b      	ldr	r3, [r7, #20]
2400a3c0:	9300      	str	r3, [sp, #0]
2400a3c2:	683b      	ldr	r3, [r7, #0]
2400a3c4:	2200      	movs	r2, #0
2400a3c6:	2110      	movs	r1, #16
2400a3c8:	68f8      	ldr	r0, [r7, #12]
2400a3ca:	f004 fd71 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a3ce:	4603      	mov	r3, r0
2400a3d0:	2b00      	cmp	r3, #0
2400a3d2:	d009      	beq.n	2400a3e8 <HAL_I2C_Slave_Transmit+0x1cc>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a3d4:	68fb      	ldr	r3, [r7, #12]
2400a3d6:	681b      	ldr	r3, [r3, #0]
2400a3d8:	685a      	ldr	r2, [r3, #4]
2400a3da:	68fb      	ldr	r3, [r7, #12]
2400a3dc:	681b      	ldr	r3, [r3, #0]
2400a3de:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a3e2:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a3e4:	2301      	movs	r3, #1
2400a3e6:	e049      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
    }

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400a3e8:	68f8      	ldr	r0, [r7, #12]
2400a3ea:	f004 fa7c 	bl	2400e8e6 <I2C_Flush_TXDR>

    /* Clear AF flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400a3ee:	68fb      	ldr	r3, [r7, #12]
2400a3f0:	681b      	ldr	r3, [r3, #0]
2400a3f2:	2210      	movs	r2, #16
2400a3f4:	61da      	str	r2, [r3, #28]

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a3f6:	697a      	ldr	r2, [r7, #20]
2400a3f8:	6839      	ldr	r1, [r7, #0]
2400a3fa:	68f8      	ldr	r0, [r7, #12]
2400a3fc:	f004 fdee 	bl	2400efdc <I2C_WaitOnSTOPFlagUntilTimeout>
2400a400:	4603      	mov	r3, r0
2400a402:	2b00      	cmp	r3, #0
2400a404:	d009      	beq.n	2400a41a <HAL_I2C_Slave_Transmit+0x1fe>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a406:	68fb      	ldr	r3, [r7, #12]
2400a408:	681b      	ldr	r3, [r3, #0]
2400a40a:	685a      	ldr	r2, [r3, #4]
2400a40c:	68fb      	ldr	r3, [r7, #12]
2400a40e:	681b      	ldr	r3, [r3, #0]
2400a410:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a414:	605a      	str	r2, [r3, #4]

      return HAL_ERROR;
2400a416:	2301      	movs	r3, #1
2400a418:	e030      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a41a:	68fb      	ldr	r3, [r7, #12]
2400a41c:	681b      	ldr	r3, [r3, #0]
2400a41e:	2220      	movs	r2, #32
2400a420:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
2400a422:	697b      	ldr	r3, [r7, #20]
2400a424:	9300      	str	r3, [sp, #0]
2400a426:	683b      	ldr	r3, [r7, #0]
2400a428:	2201      	movs	r2, #1
2400a42a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a42e:	68f8      	ldr	r0, [r7, #12]
2400a430:	f004 fd3e 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a434:	4603      	mov	r3, r0
2400a436:	2b00      	cmp	r3, #0
2400a438:	d009      	beq.n	2400a44e <HAL_I2C_Slave_Transmit+0x232>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a43a:	68fb      	ldr	r3, [r7, #12]
2400a43c:	681b      	ldr	r3, [r3, #0]
2400a43e:	685a      	ldr	r2, [r3, #4]
2400a440:	68fb      	ldr	r3, [r7, #12]
2400a442:	681b      	ldr	r3, [r3, #0]
2400a444:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a448:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a44a:	2301      	movs	r3, #1
2400a44c:	e016      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a44e:	68fb      	ldr	r3, [r7, #12]
2400a450:	681b      	ldr	r3, [r3, #0]
2400a452:	685a      	ldr	r2, [r3, #4]
2400a454:	68fb      	ldr	r3, [r7, #12]
2400a456:	681b      	ldr	r3, [r3, #0]
2400a458:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a45c:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a45e:	68fb      	ldr	r3, [r7, #12]
2400a460:	2220      	movs	r2, #32
2400a462:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a466:	68fb      	ldr	r3, [r7, #12]
2400a468:	2200      	movs	r2, #0
2400a46a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a46e:	68fb      	ldr	r3, [r7, #12]
2400a470:	2200      	movs	r2, #0
2400a472:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a476:	2300      	movs	r3, #0
2400a478:	e000      	b.n	2400a47c <HAL_I2C_Slave_Transmit+0x260>
  }
  else
  {
    return HAL_BUSY;
2400a47a:	2302      	movs	r3, #2
  }
}
2400a47c:	4618      	mov	r0, r3
2400a47e:	3718      	adds	r7, #24
2400a480:	46bd      	mov	sp, r7
2400a482:	bd80      	pop	{r7, pc}

2400a484 <HAL_I2C_Slave_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                        uint32_t Timeout)
{
2400a484:	b580      	push	{r7, lr}
2400a486:	b088      	sub	sp, #32
2400a488:	af02      	add	r7, sp, #8
2400a48a:	60f8      	str	r0, [r7, #12]
2400a48c:	60b9      	str	r1, [r7, #8]
2400a48e:	603b      	str	r3, [r7, #0]
2400a490:	4613      	mov	r3, r2
2400a492:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a494:	68fb      	ldr	r3, [r7, #12]
2400a496:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a49a:	b2db      	uxtb	r3, r3
2400a49c:	2b20      	cmp	r3, #32
2400a49e:	f040 80fc 	bne.w	2400a69a <HAL_I2C_Slave_Receive+0x216>
  {
    if ((pData == NULL) || (Size == 0U))
2400a4a2:	68bb      	ldr	r3, [r7, #8]
2400a4a4:	2b00      	cmp	r3, #0
2400a4a6:	d002      	beq.n	2400a4ae <HAL_I2C_Slave_Receive+0x2a>
2400a4a8:	88fb      	ldrh	r3, [r7, #6]
2400a4aa:	2b00      	cmp	r3, #0
2400a4ac:	d105      	bne.n	2400a4ba <HAL_I2C_Slave_Receive+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a4ae:	68fb      	ldr	r3, [r7, #12]
2400a4b0:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a4b4:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a4b6:	2301      	movs	r3, #1
2400a4b8:	e0f0      	b.n	2400a69c <HAL_I2C_Slave_Receive+0x218>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a4ba:	68fb      	ldr	r3, [r7, #12]
2400a4bc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a4c0:	2b01      	cmp	r3, #1
2400a4c2:	d101      	bne.n	2400a4c8 <HAL_I2C_Slave_Receive+0x44>
2400a4c4:	2302      	movs	r3, #2
2400a4c6:	e0e9      	b.n	2400a69c <HAL_I2C_Slave_Receive+0x218>
2400a4c8:	68fb      	ldr	r3, [r7, #12]
2400a4ca:	2201      	movs	r2, #1
2400a4cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a4d0:	f7f7 fda4 	bl	2400201c <HAL_GetTick>
2400a4d4:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400a4d6:	68fb      	ldr	r3, [r7, #12]
2400a4d8:	2222      	movs	r2, #34	; 0x22
2400a4da:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400a4de:	68fb      	ldr	r3, [r7, #12]
2400a4e0:	2220      	movs	r2, #32
2400a4e2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a4e6:	68fb      	ldr	r3, [r7, #12]
2400a4e8:	2200      	movs	r2, #0
2400a4ea:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a4ec:	68fb      	ldr	r3, [r7, #12]
2400a4ee:	68ba      	ldr	r2, [r7, #8]
2400a4f0:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a4f2:	68fb      	ldr	r3, [r7, #12]
2400a4f4:	88fa      	ldrh	r2, [r7, #6]
2400a4f6:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize = hi2c->XferCount;
2400a4f8:	68fb      	ldr	r3, [r7, #12]
2400a4fa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4fc:	b29a      	uxth	r2, r3
2400a4fe:	68fb      	ldr	r3, [r7, #12]
2400a500:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferISR   = NULL;
2400a502:	68fb      	ldr	r3, [r7, #12]
2400a504:	2200      	movs	r2, #0
2400a506:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400a508:	68fb      	ldr	r3, [r7, #12]
2400a50a:	681b      	ldr	r3, [r3, #0]
2400a50c:	685a      	ldr	r2, [r3, #4]
2400a50e:	68fb      	ldr	r3, [r7, #12]
2400a510:	681b      	ldr	r3, [r3, #0]
2400a512:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a516:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400a518:	697b      	ldr	r3, [r7, #20]
2400a51a:	9300      	str	r3, [sp, #0]
2400a51c:	683b      	ldr	r3, [r7, #0]
2400a51e:	2200      	movs	r2, #0
2400a520:	2108      	movs	r1, #8
2400a522:	68f8      	ldr	r0, [r7, #12]
2400a524:	f004 fcc4 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a528:	4603      	mov	r3, r0
2400a52a:	2b00      	cmp	r3, #0
2400a52c:	d009      	beq.n	2400a542 <HAL_I2C_Slave_Receive+0xbe>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a52e:	68fb      	ldr	r3, [r7, #12]
2400a530:	681b      	ldr	r3, [r3, #0]
2400a532:	685a      	ldr	r2, [r3, #4]
2400a534:	68fb      	ldr	r3, [r7, #12]
2400a536:	681b      	ldr	r3, [r3, #0]
2400a538:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a53c:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a53e:	2301      	movs	r3, #1
2400a540:	e0ac      	b.n	2400a69c <HAL_I2C_Slave_Receive+0x218>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400a542:	68fb      	ldr	r3, [r7, #12]
2400a544:	681b      	ldr	r3, [r3, #0]
2400a546:	2208      	movs	r2, #8
2400a548:	61da      	str	r2, [r3, #28]

    /* Wait until DIR flag is reset Receiver mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
2400a54a:	697b      	ldr	r3, [r7, #20]
2400a54c:	9300      	str	r3, [sp, #0]
2400a54e:	683b      	ldr	r3, [r7, #0]
2400a550:	2201      	movs	r2, #1
2400a552:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2400a556:	68f8      	ldr	r0, [r7, #12]
2400a558:	f004 fcaa 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a55c:	4603      	mov	r3, r0
2400a55e:	2b00      	cmp	r3, #0
2400a560:	d054      	beq.n	2400a60c <HAL_I2C_Slave_Receive+0x188>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a562:	68fb      	ldr	r3, [r7, #12]
2400a564:	681b      	ldr	r3, [r3, #0]
2400a566:	685a      	ldr	r2, [r3, #4]
2400a568:	68fb      	ldr	r3, [r7, #12]
2400a56a:	681b      	ldr	r3, [r3, #0]
2400a56c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a570:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a572:	2301      	movs	r3, #1
2400a574:	e092      	b.n	2400a69c <HAL_I2C_Slave_Receive+0x218>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a576:	697a      	ldr	r2, [r7, #20]
2400a578:	6839      	ldr	r1, [r7, #0]
2400a57a:	68f8      	ldr	r0, [r7, #12]
2400a57c:	f004 fd72 	bl	2400f064 <I2C_WaitOnRXNEFlagUntilTimeout>
2400a580:	4603      	mov	r3, r0
2400a582:	2b00      	cmp	r3, #0
2400a584:	d029      	beq.n	2400a5da <HAL_I2C_Slave_Receive+0x156>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a586:	68fb      	ldr	r3, [r7, #12]
2400a588:	681b      	ldr	r3, [r3, #0]
2400a58a:	685a      	ldr	r2, [r3, #4]
2400a58c:	68fb      	ldr	r3, [r7, #12]
2400a58e:	681b      	ldr	r3, [r3, #0]
2400a590:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a594:	605a      	str	r2, [r3, #4]

        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
2400a596:	68fb      	ldr	r3, [r7, #12]
2400a598:	681b      	ldr	r3, [r3, #0]
2400a59a:	699b      	ldr	r3, [r3, #24]
2400a59c:	f003 0304 	and.w	r3, r3, #4
2400a5a0:	2b04      	cmp	r3, #4
2400a5a2:	d118      	bne.n	2400a5d6 <HAL_I2C_Slave_Receive+0x152>
        {
          /* Read data from RXDR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400a5a4:	68fb      	ldr	r3, [r7, #12]
2400a5a6:	681b      	ldr	r3, [r3, #0]
2400a5a8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400a5aa:	68fb      	ldr	r3, [r7, #12]
2400a5ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a5ae:	b2d2      	uxtb	r2, r2
2400a5b0:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
2400a5b2:	68fb      	ldr	r3, [r7, #12]
2400a5b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a5b6:	1c5a      	adds	r2, r3, #1
2400a5b8:	68fb      	ldr	r3, [r7, #12]
2400a5ba:	625a      	str	r2, [r3, #36]	; 0x24

          hi2c->XferCount--;
2400a5bc:	68fb      	ldr	r3, [r7, #12]
2400a5be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a5c0:	b29b      	uxth	r3, r3
2400a5c2:	3b01      	subs	r3, #1
2400a5c4:	b29a      	uxth	r2, r3
2400a5c6:	68fb      	ldr	r3, [r7, #12]
2400a5c8:	855a      	strh	r2, [r3, #42]	; 0x2a
          hi2c->XferSize--;
2400a5ca:	68fb      	ldr	r3, [r7, #12]
2400a5cc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a5ce:	3b01      	subs	r3, #1
2400a5d0:	b29a      	uxth	r2, r3
2400a5d2:	68fb      	ldr	r3, [r7, #12]
2400a5d4:	851a      	strh	r2, [r3, #40]	; 0x28
        }

        return HAL_ERROR;
2400a5d6:	2301      	movs	r3, #1
2400a5d8:	e060      	b.n	2400a69c <HAL_I2C_Slave_Receive+0x218>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400a5da:	68fb      	ldr	r3, [r7, #12]
2400a5dc:	681b      	ldr	r3, [r3, #0]
2400a5de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400a5e0:	68fb      	ldr	r3, [r7, #12]
2400a5e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a5e4:	b2d2      	uxtb	r2, r2
2400a5e6:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a5e8:	68fb      	ldr	r3, [r7, #12]
2400a5ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a5ec:	1c5a      	adds	r2, r3, #1
2400a5ee:	68fb      	ldr	r3, [r7, #12]
2400a5f0:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a5f2:	68fb      	ldr	r3, [r7, #12]
2400a5f4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a5f6:	b29b      	uxth	r3, r3
2400a5f8:	3b01      	subs	r3, #1
2400a5fa:	b29a      	uxth	r2, r3
2400a5fc:	68fb      	ldr	r3, [r7, #12]
2400a5fe:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400a600:	68fb      	ldr	r3, [r7, #12]
2400a602:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a604:	3b01      	subs	r3, #1
2400a606:	b29a      	uxth	r2, r3
2400a608:	68fb      	ldr	r3, [r7, #12]
2400a60a:	851a      	strh	r2, [r3, #40]	; 0x28
    while (hi2c->XferCount > 0U)
2400a60c:	68fb      	ldr	r3, [r7, #12]
2400a60e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a610:	b29b      	uxth	r3, r3
2400a612:	2b00      	cmp	r3, #0
2400a614:	d1af      	bne.n	2400a576 <HAL_I2C_Slave_Receive+0xf2>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a616:	697a      	ldr	r2, [r7, #20]
2400a618:	6839      	ldr	r1, [r7, #0]
2400a61a:	68f8      	ldr	r0, [r7, #12]
2400a61c:	f004 fcde 	bl	2400efdc <I2C_WaitOnSTOPFlagUntilTimeout>
2400a620:	4603      	mov	r3, r0
2400a622:	2b00      	cmp	r3, #0
2400a624:	d009      	beq.n	2400a63a <HAL_I2C_Slave_Receive+0x1b6>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a626:	68fb      	ldr	r3, [r7, #12]
2400a628:	681b      	ldr	r3, [r3, #0]
2400a62a:	685a      	ldr	r2, [r3, #4]
2400a62c:	68fb      	ldr	r3, [r7, #12]
2400a62e:	681b      	ldr	r3, [r3, #0]
2400a630:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a634:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a636:	2301      	movs	r3, #1
2400a638:	e030      	b.n	2400a69c <HAL_I2C_Slave_Receive+0x218>
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a63a:	68fb      	ldr	r3, [r7, #12]
2400a63c:	681b      	ldr	r3, [r3, #0]
2400a63e:	2220      	movs	r2, #32
2400a640:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
2400a642:	697b      	ldr	r3, [r7, #20]
2400a644:	9300      	str	r3, [sp, #0]
2400a646:	683b      	ldr	r3, [r7, #0]
2400a648:	2201      	movs	r2, #1
2400a64a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a64e:	68f8      	ldr	r0, [r7, #12]
2400a650:	f004 fc2e 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400a654:	4603      	mov	r3, r0
2400a656:	2b00      	cmp	r3, #0
2400a658:	d009      	beq.n	2400a66e <HAL_I2C_Slave_Receive+0x1ea>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a65a:	68fb      	ldr	r3, [r7, #12]
2400a65c:	681b      	ldr	r3, [r3, #0]
2400a65e:	685a      	ldr	r2, [r3, #4]
2400a660:	68fb      	ldr	r3, [r7, #12]
2400a662:	681b      	ldr	r3, [r3, #0]
2400a664:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a668:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a66a:	2301      	movs	r3, #1
2400a66c:	e016      	b.n	2400a69c <HAL_I2C_Slave_Receive+0x218>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a66e:	68fb      	ldr	r3, [r7, #12]
2400a670:	681b      	ldr	r3, [r3, #0]
2400a672:	685a      	ldr	r2, [r3, #4]
2400a674:	68fb      	ldr	r3, [r7, #12]
2400a676:	681b      	ldr	r3, [r3, #0]
2400a678:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a67c:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a67e:	68fb      	ldr	r3, [r7, #12]
2400a680:	2220      	movs	r2, #32
2400a682:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a686:	68fb      	ldr	r3, [r7, #12]
2400a688:	2200      	movs	r2, #0
2400a68a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a68e:	68fb      	ldr	r3, [r7, #12]
2400a690:	2200      	movs	r2, #0
2400a692:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a696:	2300      	movs	r3, #0
2400a698:	e000      	b.n	2400a69c <HAL_I2C_Slave_Receive+0x218>
  }
  else
  {
    return HAL_BUSY;
2400a69a:	2302      	movs	r3, #2
  }
}
2400a69c:	4618      	mov	r0, r3
2400a69e:	3718      	adds	r7, #24
2400a6a0:	46bd      	mov	sp, r7
2400a6a2:	bd80      	pop	{r7, pc}

2400a6a4 <HAL_I2C_Master_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                             uint16_t Size)
{
2400a6a4:	b580      	push	{r7, lr}
2400a6a6:	b088      	sub	sp, #32
2400a6a8:	af02      	add	r7, sp, #8
2400a6aa:	60f8      	str	r0, [r7, #12]
2400a6ac:	607a      	str	r2, [r7, #4]
2400a6ae:	461a      	mov	r2, r3
2400a6b0:	460b      	mov	r3, r1
2400a6b2:	817b      	strh	r3, [r7, #10]
2400a6b4:	4613      	mov	r3, r2
2400a6b6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a6b8:	68fb      	ldr	r3, [r7, #12]
2400a6ba:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a6be:	b2db      	uxtb	r3, r3
2400a6c0:	2b20      	cmp	r3, #32
2400a6c2:	d153      	bne.n	2400a76c <HAL_I2C_Master_Transmit_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a6c4:	68fb      	ldr	r3, [r7, #12]
2400a6c6:	681b      	ldr	r3, [r3, #0]
2400a6c8:	699b      	ldr	r3, [r3, #24]
2400a6ca:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a6ce:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a6d2:	d101      	bne.n	2400a6d8 <HAL_I2C_Master_Transmit_IT+0x34>
    {
      return HAL_BUSY;
2400a6d4:	2302      	movs	r3, #2
2400a6d6:	e04a      	b.n	2400a76e <HAL_I2C_Master_Transmit_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a6d8:	68fb      	ldr	r3, [r7, #12]
2400a6da:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a6de:	2b01      	cmp	r3, #1
2400a6e0:	d101      	bne.n	2400a6e6 <HAL_I2C_Master_Transmit_IT+0x42>
2400a6e2:	2302      	movs	r3, #2
2400a6e4:	e043      	b.n	2400a76e <HAL_I2C_Master_Transmit_IT+0xca>
2400a6e6:	68fb      	ldr	r3, [r7, #12]
2400a6e8:	2201      	movs	r2, #1
2400a6ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400a6ee:	68fb      	ldr	r3, [r7, #12]
2400a6f0:	2221      	movs	r2, #33	; 0x21
2400a6f2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400a6f6:	68fb      	ldr	r3, [r7, #12]
2400a6f8:	2210      	movs	r2, #16
2400a6fa:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a6fe:	68fb      	ldr	r3, [r7, #12]
2400a700:	2200      	movs	r2, #0
2400a702:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a704:	68fb      	ldr	r3, [r7, #12]
2400a706:	687a      	ldr	r2, [r7, #4]
2400a708:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a70a:	68fb      	ldr	r3, [r7, #12]
2400a70c:	893a      	ldrh	r2, [r7, #8]
2400a70e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a710:	68fb      	ldr	r3, [r7, #12]
2400a712:	4a19      	ldr	r2, [pc, #100]	; (2400a778 <HAL_I2C_Master_Transmit_IT+0xd4>)
2400a714:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400a716:	68fb      	ldr	r3, [r7, #12]
2400a718:	4a18      	ldr	r2, [pc, #96]	; (2400a77c <HAL_I2C_Master_Transmit_IT+0xd8>)
2400a71a:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a71c:	68fb      	ldr	r3, [r7, #12]
2400a71e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a720:	b29b      	uxth	r3, r3
2400a722:	2bff      	cmp	r3, #255	; 0xff
2400a724:	d906      	bls.n	2400a734 <HAL_I2C_Master_Transmit_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a726:	68fb      	ldr	r3, [r7, #12]
2400a728:	22ff      	movs	r2, #255	; 0xff
2400a72a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400a72c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a730:	617b      	str	r3, [r7, #20]
2400a732:	e007      	b.n	2400a744 <HAL_I2C_Master_Transmit_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a734:	68fb      	ldr	r3, [r7, #12]
2400a736:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a738:	b29a      	uxth	r2, r3
2400a73a:	68fb      	ldr	r3, [r7, #12]
2400a73c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400a73e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a742:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
2400a744:	68fb      	ldr	r3, [r7, #12]
2400a746:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a748:	b2da      	uxtb	r2, r3
2400a74a:	8979      	ldrh	r1, [r7, #10]
2400a74c:	4b0c      	ldr	r3, [pc, #48]	; (2400a780 <HAL_I2C_Master_Transmit_IT+0xdc>)
2400a74e:	9300      	str	r3, [sp, #0]
2400a750:	697b      	ldr	r3, [r7, #20]
2400a752:	68f8      	ldr	r0, [r7, #12]
2400a754:	f004 fde8 	bl	2400f328 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a758:	68fb      	ldr	r3, [r7, #12]
2400a75a:	2200      	movs	r2, #0
2400a75c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400a760:	2101      	movs	r1, #1
2400a762:	68f8      	ldr	r0, [r7, #12]
2400a764:	f004 fe12 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400a768:	2300      	movs	r3, #0
2400a76a:	e000      	b.n	2400a76e <HAL_I2C_Master_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2400a76c:	2302      	movs	r3, #2
  }
}
2400a76e:	4618      	mov	r0, r3
2400a770:	3718      	adds	r7, #24
2400a772:	46bd      	mov	sp, r7
2400a774:	bd80      	pop	{r7, pc}
2400a776:	bf00      	nop
2400a778:	ffff0000 	.word	0xffff0000
2400a77c:	2400ce5b 	.word	0x2400ce5b
2400a780:	80002000 	.word	0x80002000

2400a784 <HAL_I2C_Master_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                            uint16_t Size)
{
2400a784:	b580      	push	{r7, lr}
2400a786:	b088      	sub	sp, #32
2400a788:	af02      	add	r7, sp, #8
2400a78a:	60f8      	str	r0, [r7, #12]
2400a78c:	607a      	str	r2, [r7, #4]
2400a78e:	461a      	mov	r2, r3
2400a790:	460b      	mov	r3, r1
2400a792:	817b      	strh	r3, [r7, #10]
2400a794:	4613      	mov	r3, r2
2400a796:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a798:	68fb      	ldr	r3, [r7, #12]
2400a79a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a79e:	b2db      	uxtb	r3, r3
2400a7a0:	2b20      	cmp	r3, #32
2400a7a2:	d153      	bne.n	2400a84c <HAL_I2C_Master_Receive_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a7a4:	68fb      	ldr	r3, [r7, #12]
2400a7a6:	681b      	ldr	r3, [r3, #0]
2400a7a8:	699b      	ldr	r3, [r3, #24]
2400a7aa:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a7ae:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a7b2:	d101      	bne.n	2400a7b8 <HAL_I2C_Master_Receive_IT+0x34>
    {
      return HAL_BUSY;
2400a7b4:	2302      	movs	r3, #2
2400a7b6:	e04a      	b.n	2400a84e <HAL_I2C_Master_Receive_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a7b8:	68fb      	ldr	r3, [r7, #12]
2400a7ba:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a7be:	2b01      	cmp	r3, #1
2400a7c0:	d101      	bne.n	2400a7c6 <HAL_I2C_Master_Receive_IT+0x42>
2400a7c2:	2302      	movs	r3, #2
2400a7c4:	e043      	b.n	2400a84e <HAL_I2C_Master_Receive_IT+0xca>
2400a7c6:	68fb      	ldr	r3, [r7, #12]
2400a7c8:	2201      	movs	r2, #1
2400a7ca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400a7ce:	68fb      	ldr	r3, [r7, #12]
2400a7d0:	2222      	movs	r2, #34	; 0x22
2400a7d2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400a7d6:	68fb      	ldr	r3, [r7, #12]
2400a7d8:	2210      	movs	r2, #16
2400a7da:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a7de:	68fb      	ldr	r3, [r7, #12]
2400a7e0:	2200      	movs	r2, #0
2400a7e2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a7e4:	68fb      	ldr	r3, [r7, #12]
2400a7e6:	687a      	ldr	r2, [r7, #4]
2400a7e8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a7ea:	68fb      	ldr	r3, [r7, #12]
2400a7ec:	893a      	ldrh	r2, [r7, #8]
2400a7ee:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a7f0:	68fb      	ldr	r3, [r7, #12]
2400a7f2:	4a19      	ldr	r2, [pc, #100]	; (2400a858 <HAL_I2C_Master_Receive_IT+0xd4>)
2400a7f4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400a7f6:	68fb      	ldr	r3, [r7, #12]
2400a7f8:	4a18      	ldr	r2, [pc, #96]	; (2400a85c <HAL_I2C_Master_Receive_IT+0xd8>)
2400a7fa:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a7fc:	68fb      	ldr	r3, [r7, #12]
2400a7fe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a800:	b29b      	uxth	r3, r3
2400a802:	2bff      	cmp	r3, #255	; 0xff
2400a804:	d906      	bls.n	2400a814 <HAL_I2C_Master_Receive_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a806:	68fb      	ldr	r3, [r7, #12]
2400a808:	22ff      	movs	r2, #255	; 0xff
2400a80a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400a80c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a810:	617b      	str	r3, [r7, #20]
2400a812:	e007      	b.n	2400a824 <HAL_I2C_Master_Receive_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a814:	68fb      	ldr	r3, [r7, #12]
2400a816:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a818:	b29a      	uxth	r2, r3
2400a81a:	68fb      	ldr	r3, [r7, #12]
2400a81c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400a81e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a822:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400a824:	68fb      	ldr	r3, [r7, #12]
2400a826:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a828:	b2da      	uxtb	r2, r3
2400a82a:	8979      	ldrh	r1, [r7, #10]
2400a82c:	4b0c      	ldr	r3, [pc, #48]	; (2400a860 <HAL_I2C_Master_Receive_IT+0xdc>)
2400a82e:	9300      	str	r3, [sp, #0]
2400a830:	697b      	ldr	r3, [r7, #20]
2400a832:	68f8      	ldr	r0, [r7, #12]
2400a834:	f004 fd78 	bl	2400f328 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a838:	68fb      	ldr	r3, [r7, #12]
2400a83a:	2200      	movs	r2, #0
2400a83c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400a840:	2102      	movs	r1, #2
2400a842:	68f8      	ldr	r0, [r7, #12]
2400a844:	f004 fda2 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400a848:	2300      	movs	r3, #0
2400a84a:	e000      	b.n	2400a84e <HAL_I2C_Master_Receive_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2400a84c:	2302      	movs	r3, #2
  }
}
2400a84e:	4618      	mov	r0, r3
2400a850:	3718      	adds	r7, #24
2400a852:	46bd      	mov	sp, r7
2400a854:	bd80      	pop	{r7, pc}
2400a856:	bf00      	nop
2400a858:	ffff0000 	.word	0xffff0000
2400a85c:	2400ce5b 	.word	0x2400ce5b
2400a860:	80002400 	.word	0x80002400

2400a864 <HAL_I2C_Slave_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2400a864:	b580      	push	{r7, lr}
2400a866:	b084      	sub	sp, #16
2400a868:	af00      	add	r7, sp, #0
2400a86a:	60f8      	str	r0, [r7, #12]
2400a86c:	60b9      	str	r1, [r7, #8]
2400a86e:	4613      	mov	r3, r2
2400a870:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400a872:	68fb      	ldr	r3, [r7, #12]
2400a874:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a878:	b2db      	uxtb	r3, r3
2400a87a:	2b20      	cmp	r3, #32
2400a87c:	d156      	bne.n	2400a92c <HAL_I2C_Slave_Transmit_IT+0xc8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a87e:	68fb      	ldr	r3, [r7, #12]
2400a880:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a884:	2b01      	cmp	r3, #1
2400a886:	d101      	bne.n	2400a88c <HAL_I2C_Slave_Transmit_IT+0x28>
2400a888:	2302      	movs	r3, #2
2400a88a:	e050      	b.n	2400a92e <HAL_I2C_Slave_Transmit_IT+0xca>
2400a88c:	68fb      	ldr	r3, [r7, #12]
2400a88e:	2201      	movs	r2, #1
2400a890:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400a894:	68fb      	ldr	r3, [r7, #12]
2400a896:	2221      	movs	r2, #33	; 0x21
2400a898:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400a89c:	68fb      	ldr	r3, [r7, #12]
2400a89e:	2220      	movs	r2, #32
2400a8a0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a8a4:	68fb      	ldr	r3, [r7, #12]
2400a8a6:	2200      	movs	r2, #0
2400a8a8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400a8aa:	68fb      	ldr	r3, [r7, #12]
2400a8ac:	681b      	ldr	r3, [r3, #0]
2400a8ae:	685a      	ldr	r2, [r3, #4]
2400a8b0:	68fb      	ldr	r3, [r7, #12]
2400a8b2:	681b      	ldr	r3, [r3, #0]
2400a8b4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a8b8:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a8ba:	68fb      	ldr	r3, [r7, #12]
2400a8bc:	68ba      	ldr	r2, [r7, #8]
2400a8be:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a8c0:	68fb      	ldr	r3, [r7, #12]
2400a8c2:	88fa      	ldrh	r2, [r7, #6]
2400a8c4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400a8c6:	68fb      	ldr	r3, [r7, #12]
2400a8c8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a8ca:	b29a      	uxth	r2, r3
2400a8cc:	68fb      	ldr	r3, [r7, #12]
2400a8ce:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a8d0:	68fb      	ldr	r3, [r7, #12]
2400a8d2:	4a19      	ldr	r2, [pc, #100]	; (2400a938 <HAL_I2C_Slave_Transmit_IT+0xd4>)
2400a8d4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400a8d6:	68fb      	ldr	r3, [r7, #12]
2400a8d8:	4a18      	ldr	r2, [pc, #96]	; (2400a93c <HAL_I2C_Slave_Transmit_IT+0xd8>)
2400a8da:	635a      	str	r2, [r3, #52]	; 0x34

    /* Preload TX data if no stretch enable */
    if (hi2c->Init.NoStretchMode == I2C_NOSTRETCH_ENABLE)
2400a8dc:	68fb      	ldr	r3, [r7, #12]
2400a8de:	6a1b      	ldr	r3, [r3, #32]
2400a8e0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2400a8e4:	d117      	bne.n	2400a916 <HAL_I2C_Slave_Transmit_IT+0xb2>
    {
      /* Preload TX register */
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400a8e6:	68fb      	ldr	r3, [r7, #12]
2400a8e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a8ea:	781a      	ldrb	r2, [r3, #0]
2400a8ec:	68fb      	ldr	r3, [r7, #12]
2400a8ee:	681b      	ldr	r3, [r3, #0]
2400a8f0:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a8f2:	68fb      	ldr	r3, [r7, #12]
2400a8f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a8f6:	1c5a      	adds	r2, r3, #1
2400a8f8:	68fb      	ldr	r3, [r7, #12]
2400a8fa:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a8fc:	68fb      	ldr	r3, [r7, #12]
2400a8fe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a900:	b29b      	uxth	r3, r3
2400a902:	3b01      	subs	r3, #1
2400a904:	b29a      	uxth	r2, r3
2400a906:	68fb      	ldr	r3, [r7, #12]
2400a908:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400a90a:	68fb      	ldr	r3, [r7, #12]
2400a90c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a90e:	3b01      	subs	r3, #1
2400a910:	b29a      	uxth	r2, r3
2400a912:	68fb      	ldr	r3, [r7, #12]
2400a914:	851a      	strh	r2, [r3, #40]	; 0x28
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a916:	68fb      	ldr	r3, [r7, #12]
2400a918:	2200      	movs	r2, #0
2400a91a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2400a91e:	f248 0101 	movw	r1, #32769	; 0x8001
2400a922:	68f8      	ldr	r0, [r7, #12]
2400a924:	f004 fd32 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400a928:	2300      	movs	r3, #0
2400a92a:	e000      	b.n	2400a92e <HAL_I2C_Slave_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2400a92c:	2302      	movs	r3, #2
  }
}
2400a92e:	4618      	mov	r0, r3
2400a930:	3710      	adds	r7, #16
2400a932:	46bd      	mov	sp, r7
2400a934:	bd80      	pop	{r7, pc}
2400a936:	bf00      	nop
2400a938:	ffff0000 	.word	0xffff0000
2400a93c:	2400d301 	.word	0x2400d301

2400a940 <HAL_I2C_Slave_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2400a940:	b580      	push	{r7, lr}
2400a942:	b084      	sub	sp, #16
2400a944:	af00      	add	r7, sp, #0
2400a946:	60f8      	str	r0, [r7, #12]
2400a948:	60b9      	str	r1, [r7, #8]
2400a94a:	4613      	mov	r3, r2
2400a94c:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400a94e:	68fb      	ldr	r3, [r7, #12]
2400a950:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a954:	b2db      	uxtb	r3, r3
2400a956:	2b20      	cmp	r3, #32
2400a958:	d139      	bne.n	2400a9ce <HAL_I2C_Slave_Receive_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a95a:	68fb      	ldr	r3, [r7, #12]
2400a95c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a960:	2b01      	cmp	r3, #1
2400a962:	d101      	bne.n	2400a968 <HAL_I2C_Slave_Receive_IT+0x28>
2400a964:	2302      	movs	r3, #2
2400a966:	e033      	b.n	2400a9d0 <HAL_I2C_Slave_Receive_IT+0x90>
2400a968:	68fb      	ldr	r3, [r7, #12]
2400a96a:	2201      	movs	r2, #1
2400a96c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400a970:	68fb      	ldr	r3, [r7, #12]
2400a972:	2222      	movs	r2, #34	; 0x22
2400a974:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400a978:	68fb      	ldr	r3, [r7, #12]
2400a97a:	2220      	movs	r2, #32
2400a97c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a980:	68fb      	ldr	r3, [r7, #12]
2400a982:	2200      	movs	r2, #0
2400a984:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400a986:	68fb      	ldr	r3, [r7, #12]
2400a988:	681b      	ldr	r3, [r3, #0]
2400a98a:	685a      	ldr	r2, [r3, #4]
2400a98c:	68fb      	ldr	r3, [r7, #12]
2400a98e:	681b      	ldr	r3, [r3, #0]
2400a990:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a994:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a996:	68fb      	ldr	r3, [r7, #12]
2400a998:	68ba      	ldr	r2, [r7, #8]
2400a99a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a99c:	68fb      	ldr	r3, [r7, #12]
2400a99e:	88fa      	ldrh	r2, [r7, #6]
2400a9a0:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400a9a2:	68fb      	ldr	r3, [r7, #12]
2400a9a4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a9a6:	b29a      	uxth	r2, r3
2400a9a8:	68fb      	ldr	r3, [r7, #12]
2400a9aa:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a9ac:	68fb      	ldr	r3, [r7, #12]
2400a9ae:	4a0a      	ldr	r2, [pc, #40]	; (2400a9d8 <HAL_I2C_Slave_Receive_IT+0x98>)
2400a9b0:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400a9b2:	68fb      	ldr	r3, [r7, #12]
2400a9b4:	4a09      	ldr	r2, [pc, #36]	; (2400a9dc <HAL_I2C_Slave_Receive_IT+0x9c>)
2400a9b6:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a9b8:	68fb      	ldr	r3, [r7, #12]
2400a9ba:	2200      	movs	r2, #0
2400a9bc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400a9c0:	f248 0102 	movw	r1, #32770	; 0x8002
2400a9c4:	68f8      	ldr	r0, [r7, #12]
2400a9c6:	f004 fce1 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400a9ca:	2300      	movs	r3, #0
2400a9cc:	e000      	b.n	2400a9d0 <HAL_I2C_Slave_Receive_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
2400a9ce:	2302      	movs	r3, #2
  }
}
2400a9d0:	4618      	mov	r0, r3
2400a9d2:	3710      	adds	r7, #16
2400a9d4:	46bd      	mov	sp, r7
2400a9d6:	bd80      	pop	{r7, pc}
2400a9d8:	ffff0000 	.word	0xffff0000
2400a9dc:	2400d301 	.word	0x2400d301

2400a9e0 <HAL_I2C_Master_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                              uint16_t Size)
{
2400a9e0:	b580      	push	{r7, lr}
2400a9e2:	b088      	sub	sp, #32
2400a9e4:	af02      	add	r7, sp, #8
2400a9e6:	60f8      	str	r0, [r7, #12]
2400a9e8:	607a      	str	r2, [r7, #4]
2400a9ea:	461a      	mov	r2, r3
2400a9ec:	460b      	mov	r3, r1
2400a9ee:	817b      	strh	r3, [r7, #10]
2400a9f0:	4613      	mov	r3, r2
2400a9f2:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a9f4:	68fb      	ldr	r3, [r7, #12]
2400a9f6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a9fa:	b2db      	uxtb	r3, r3
2400a9fc:	2b20      	cmp	r3, #32
2400a9fe:	f040 80cd 	bne.w	2400ab9c <HAL_I2C_Master_Transmit_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400aa02:	68fb      	ldr	r3, [r7, #12]
2400aa04:	681b      	ldr	r3, [r3, #0]
2400aa06:	699b      	ldr	r3, [r3, #24]
2400aa08:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400aa0c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400aa10:	d101      	bne.n	2400aa16 <HAL_I2C_Master_Transmit_DMA+0x36>
    {
      return HAL_BUSY;
2400aa12:	2302      	movs	r3, #2
2400aa14:	e0c3      	b.n	2400ab9e <HAL_I2C_Master_Transmit_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400aa16:	68fb      	ldr	r3, [r7, #12]
2400aa18:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400aa1c:	2b01      	cmp	r3, #1
2400aa1e:	d101      	bne.n	2400aa24 <HAL_I2C_Master_Transmit_DMA+0x44>
2400aa20:	2302      	movs	r3, #2
2400aa22:	e0bc      	b.n	2400ab9e <HAL_I2C_Master_Transmit_DMA+0x1be>
2400aa24:	68fb      	ldr	r3, [r7, #12]
2400aa26:	2201      	movs	r2, #1
2400aa28:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400aa2c:	68fb      	ldr	r3, [r7, #12]
2400aa2e:	2221      	movs	r2, #33	; 0x21
2400aa30:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400aa34:	68fb      	ldr	r3, [r7, #12]
2400aa36:	2210      	movs	r2, #16
2400aa38:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400aa3c:	68fb      	ldr	r3, [r7, #12]
2400aa3e:	2200      	movs	r2, #0
2400aa40:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400aa42:	68fb      	ldr	r3, [r7, #12]
2400aa44:	687a      	ldr	r2, [r7, #4]
2400aa46:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400aa48:	68fb      	ldr	r3, [r7, #12]
2400aa4a:	893a      	ldrh	r2, [r7, #8]
2400aa4c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400aa4e:	68fb      	ldr	r3, [r7, #12]
2400aa50:	4a55      	ldr	r2, [pc, #340]	; (2400aba8 <HAL_I2C_Master_Transmit_DMA+0x1c8>)
2400aa52:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400aa54:	68fb      	ldr	r3, [r7, #12]
2400aa56:	4a55      	ldr	r2, [pc, #340]	; (2400abac <HAL_I2C_Master_Transmit_DMA+0x1cc>)
2400aa58:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400aa5a:	68fb      	ldr	r3, [r7, #12]
2400aa5c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aa5e:	b29b      	uxth	r3, r3
2400aa60:	2bff      	cmp	r3, #255	; 0xff
2400aa62:	d906      	bls.n	2400aa72 <HAL_I2C_Master_Transmit_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400aa64:	68fb      	ldr	r3, [r7, #12]
2400aa66:	22ff      	movs	r2, #255	; 0xff
2400aa68:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400aa6a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400aa6e:	617b      	str	r3, [r7, #20]
2400aa70:	e007      	b.n	2400aa82 <HAL_I2C_Master_Transmit_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400aa72:	68fb      	ldr	r3, [r7, #12]
2400aa74:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aa76:	b29a      	uxth	r2, r3
2400aa78:	68fb      	ldr	r3, [r7, #12]
2400aa7a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400aa7c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400aa80:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
2400aa82:	68fb      	ldr	r3, [r7, #12]
2400aa84:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400aa86:	2b00      	cmp	r3, #0
2400aa88:	d070      	beq.n	2400ab6c <HAL_I2C_Master_Transmit_DMA+0x18c>
    {
      if (hi2c->hdmatx != NULL)
2400aa8a:	68fb      	ldr	r3, [r7, #12]
2400aa8c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400aa8e:	2b00      	cmp	r3, #0
2400aa90:	d020      	beq.n	2400aad4 <HAL_I2C_Master_Transmit_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400aa92:	68fb      	ldr	r3, [r7, #12]
2400aa94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400aa96:	4a46      	ldr	r2, [pc, #280]	; (2400abb0 <HAL_I2C_Master_Transmit_DMA+0x1d0>)
2400aa98:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400aa9a:	68fb      	ldr	r3, [r7, #12]
2400aa9c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400aa9e:	4a45      	ldr	r2, [pc, #276]	; (2400abb4 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
2400aaa0:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400aaa2:	68fb      	ldr	r3, [r7, #12]
2400aaa4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400aaa6:	2200      	movs	r2, #0
2400aaa8:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2400aaaa:	68fb      	ldr	r3, [r7, #12]
2400aaac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400aaae:	2200      	movs	r2, #0
2400aab0:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400aab2:	68fb      	ldr	r3, [r7, #12]
2400aab4:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400aab6:	6879      	ldr	r1, [r7, #4]
2400aab8:	68fb      	ldr	r3, [r7, #12]
2400aaba:	681b      	ldr	r3, [r3, #0]
2400aabc:	3328      	adds	r3, #40	; 0x28
2400aabe:	461a      	mov	r2, r3
                                         hi2c->XferSize);
2400aac0:	68fb      	ldr	r3, [r7, #12]
2400aac2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400aac4:	f7f9 f844 	bl	24003b50 <HAL_DMA_Start_IT>
2400aac8:	4603      	mov	r3, r0
2400aaca:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400aacc:	7cfb      	ldrb	r3, [r7, #19]
2400aace:	2b00      	cmp	r3, #0
2400aad0:	d138      	bne.n	2400ab44 <HAL_I2C_Master_Transmit_DMA+0x164>
2400aad2:	e013      	b.n	2400aafc <HAL_I2C_Master_Transmit_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
2400aad4:	68fb      	ldr	r3, [r7, #12]
2400aad6:	2220      	movs	r2, #32
2400aad8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400aadc:	68fb      	ldr	r3, [r7, #12]
2400aade:	2200      	movs	r2, #0
2400aae0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400aae4:	68fb      	ldr	r3, [r7, #12]
2400aae6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400aae8:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400aaec:	68fb      	ldr	r3, [r7, #12]
2400aaee:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400aaf0:	68fb      	ldr	r3, [r7, #12]
2400aaf2:	2200      	movs	r2, #0
2400aaf4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400aaf8:	2301      	movs	r3, #1
2400aafa:	e050      	b.n	2400ab9e <HAL_I2C_Master_Transmit_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
2400aafc:	68fb      	ldr	r3, [r7, #12]
2400aafe:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ab00:	b2da      	uxtb	r2, r3
2400ab02:	8979      	ldrh	r1, [r7, #10]
2400ab04:	4b2c      	ldr	r3, [pc, #176]	; (2400abb8 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
2400ab06:	9300      	str	r3, [sp, #0]
2400ab08:	697b      	ldr	r3, [r7, #20]
2400ab0a:	68f8      	ldr	r0, [r7, #12]
2400ab0c:	f004 fc0c 	bl	2400f328 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400ab10:	68fb      	ldr	r3, [r7, #12]
2400ab12:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ab14:	b29a      	uxth	r2, r3
2400ab16:	68fb      	ldr	r3, [r7, #12]
2400ab18:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ab1a:	1ad3      	subs	r3, r2, r3
2400ab1c:	b29a      	uxth	r2, r3
2400ab1e:	68fb      	ldr	r3, [r7, #12]
2400ab20:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400ab22:	68fb      	ldr	r3, [r7, #12]
2400ab24:	2200      	movs	r2, #0
2400ab26:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400ab2a:	2110      	movs	r1, #16
2400ab2c:	68f8      	ldr	r0, [r7, #12]
2400ab2e:	f004 fc2d 	bl	2400f38c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400ab32:	68fb      	ldr	r3, [r7, #12]
2400ab34:	681b      	ldr	r3, [r3, #0]
2400ab36:	681a      	ldr	r2, [r3, #0]
2400ab38:	68fb      	ldr	r3, [r7, #12]
2400ab3a:	681b      	ldr	r3, [r3, #0]
2400ab3c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400ab40:	601a      	str	r2, [r3, #0]
2400ab42:	e029      	b.n	2400ab98 <HAL_I2C_Master_Transmit_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400ab44:	68fb      	ldr	r3, [r7, #12]
2400ab46:	2220      	movs	r2, #32
2400ab48:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ab4c:	68fb      	ldr	r3, [r7, #12]
2400ab4e:	2200      	movs	r2, #0
2400ab50:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400ab54:	68fb      	ldr	r3, [r7, #12]
2400ab56:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ab58:	f043 0210 	orr.w	r2, r3, #16
2400ab5c:	68fb      	ldr	r3, [r7, #12]
2400ab5e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400ab60:	68fb      	ldr	r3, [r7, #12]
2400ab62:	2200      	movs	r2, #0
2400ab64:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400ab68:	2301      	movs	r3, #1
2400ab6a:	e018      	b.n	2400ab9e <HAL_I2C_Master_Transmit_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400ab6c:	68fb      	ldr	r3, [r7, #12]
2400ab6e:	4a13      	ldr	r2, [pc, #76]	; (2400abbc <HAL_I2C_Master_Transmit_DMA+0x1dc>)
2400ab70:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400ab72:	68fb      	ldr	r3, [r7, #12]
2400ab74:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ab76:	b2da      	uxtb	r2, r3
2400ab78:	8979      	ldrh	r1, [r7, #10]
2400ab7a:	4b0f      	ldr	r3, [pc, #60]	; (2400abb8 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
2400ab7c:	9300      	str	r3, [sp, #0]
2400ab7e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400ab82:	68f8      	ldr	r0, [r7, #12]
2400ab84:	f004 fbd0 	bl	2400f328 <I2C_TransferConfig>
                         I2C_GENERATE_START_WRITE);

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400ab88:	68fb      	ldr	r3, [r7, #12]
2400ab8a:	2200      	movs	r2, #0
2400ab8c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400ab90:	2101      	movs	r1, #1
2400ab92:	68f8      	ldr	r0, [r7, #12]
2400ab94:	f004 fbfa 	bl	2400f38c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400ab98:	2300      	movs	r3, #0
2400ab9a:	e000      	b.n	2400ab9e <HAL_I2C_Master_Transmit_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
2400ab9c:	2302      	movs	r3, #2
  }
}
2400ab9e:	4618      	mov	r0, r3
2400aba0:	3718      	adds	r7, #24
2400aba2:	46bd      	mov	sp, r7
2400aba4:	bd80      	pop	{r7, pc}
2400aba6:	bf00      	nop
2400aba8:	ffff0000 	.word	0xffff0000
2400abac:	2400d507 	.word	0x2400d507
2400abb0:	2400e92f 	.word	0x2400e92f
2400abb4:	2400ec01 	.word	0x2400ec01
2400abb8:	80002000 	.word	0x80002000
2400abbc:	2400ce5b 	.word	0x2400ce5b

2400abc0 <HAL_I2C_Master_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                             uint16_t Size)
{
2400abc0:	b580      	push	{r7, lr}
2400abc2:	b088      	sub	sp, #32
2400abc4:	af02      	add	r7, sp, #8
2400abc6:	60f8      	str	r0, [r7, #12]
2400abc8:	607a      	str	r2, [r7, #4]
2400abca:	461a      	mov	r2, r3
2400abcc:	460b      	mov	r3, r1
2400abce:	817b      	strh	r3, [r7, #10]
2400abd0:	4613      	mov	r3, r2
2400abd2:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400abd4:	68fb      	ldr	r3, [r7, #12]
2400abd6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400abda:	b2db      	uxtb	r3, r3
2400abdc:	2b20      	cmp	r3, #32
2400abde:	f040 80cd 	bne.w	2400ad7c <HAL_I2C_Master_Receive_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400abe2:	68fb      	ldr	r3, [r7, #12]
2400abe4:	681b      	ldr	r3, [r3, #0]
2400abe6:	699b      	ldr	r3, [r3, #24]
2400abe8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400abec:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400abf0:	d101      	bne.n	2400abf6 <HAL_I2C_Master_Receive_DMA+0x36>
    {
      return HAL_BUSY;
2400abf2:	2302      	movs	r3, #2
2400abf4:	e0c3      	b.n	2400ad7e <HAL_I2C_Master_Receive_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400abf6:	68fb      	ldr	r3, [r7, #12]
2400abf8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400abfc:	2b01      	cmp	r3, #1
2400abfe:	d101      	bne.n	2400ac04 <HAL_I2C_Master_Receive_DMA+0x44>
2400ac00:	2302      	movs	r3, #2
2400ac02:	e0bc      	b.n	2400ad7e <HAL_I2C_Master_Receive_DMA+0x1be>
2400ac04:	68fb      	ldr	r3, [r7, #12]
2400ac06:	2201      	movs	r2, #1
2400ac08:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400ac0c:	68fb      	ldr	r3, [r7, #12]
2400ac0e:	2222      	movs	r2, #34	; 0x22
2400ac10:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400ac14:	68fb      	ldr	r3, [r7, #12]
2400ac16:	2210      	movs	r2, #16
2400ac18:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400ac1c:	68fb      	ldr	r3, [r7, #12]
2400ac1e:	2200      	movs	r2, #0
2400ac20:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ac22:	68fb      	ldr	r3, [r7, #12]
2400ac24:	687a      	ldr	r2, [r7, #4]
2400ac26:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ac28:	68fb      	ldr	r3, [r7, #12]
2400ac2a:	893a      	ldrh	r2, [r7, #8]
2400ac2c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400ac2e:	68fb      	ldr	r3, [r7, #12]
2400ac30:	4a55      	ldr	r2, [pc, #340]	; (2400ad88 <HAL_I2C_Master_Receive_DMA+0x1c8>)
2400ac32:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400ac34:	68fb      	ldr	r3, [r7, #12]
2400ac36:	4a55      	ldr	r2, [pc, #340]	; (2400ad8c <HAL_I2C_Master_Receive_DMA+0x1cc>)
2400ac38:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400ac3a:	68fb      	ldr	r3, [r7, #12]
2400ac3c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ac3e:	b29b      	uxth	r3, r3
2400ac40:	2bff      	cmp	r3, #255	; 0xff
2400ac42:	d906      	bls.n	2400ac52 <HAL_I2C_Master_Receive_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400ac44:	68fb      	ldr	r3, [r7, #12]
2400ac46:	22ff      	movs	r2, #255	; 0xff
2400ac48:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400ac4a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400ac4e:	617b      	str	r3, [r7, #20]
2400ac50:	e007      	b.n	2400ac62 <HAL_I2C_Master_Receive_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400ac52:	68fb      	ldr	r3, [r7, #12]
2400ac54:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ac56:	b29a      	uxth	r2, r3
2400ac58:	68fb      	ldr	r3, [r7, #12]
2400ac5a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400ac5c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400ac60:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
2400ac62:	68fb      	ldr	r3, [r7, #12]
2400ac64:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ac66:	2b00      	cmp	r3, #0
2400ac68:	d070      	beq.n	2400ad4c <HAL_I2C_Master_Receive_DMA+0x18c>
    {
      if (hi2c->hdmarx != NULL)
2400ac6a:	68fb      	ldr	r3, [r7, #12]
2400ac6c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ac6e:	2b00      	cmp	r3, #0
2400ac70:	d020      	beq.n	2400acb4 <HAL_I2C_Master_Receive_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400ac72:	68fb      	ldr	r3, [r7, #12]
2400ac74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ac76:	4a46      	ldr	r2, [pc, #280]	; (2400ad90 <HAL_I2C_Master_Receive_DMA+0x1d0>)
2400ac78:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400ac7a:	68fb      	ldr	r3, [r7, #12]
2400ac7c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ac7e:	4a45      	ldr	r2, [pc, #276]	; (2400ad94 <HAL_I2C_Master_Receive_DMA+0x1d4>)
2400ac80:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400ac82:	68fb      	ldr	r3, [r7, #12]
2400ac84:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ac86:	2200      	movs	r2, #0
2400ac88:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
2400ac8a:	68fb      	ldr	r3, [r7, #12]
2400ac8c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ac8e:	2200      	movs	r2, #0
2400ac90:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400ac92:	68fb      	ldr	r3, [r7, #12]
2400ac94:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400ac96:	68fb      	ldr	r3, [r7, #12]
2400ac98:	681b      	ldr	r3, [r3, #0]
2400ac9a:	3324      	adds	r3, #36	; 0x24
2400ac9c:	4619      	mov	r1, r3
2400ac9e:	687a      	ldr	r2, [r7, #4]
                                         hi2c->XferSize);
2400aca0:	68fb      	ldr	r3, [r7, #12]
2400aca2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400aca4:	f7f8 ff54 	bl	24003b50 <HAL_DMA_Start_IT>
2400aca8:	4603      	mov	r3, r0
2400acaa:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400acac:	7cfb      	ldrb	r3, [r7, #19]
2400acae:	2b00      	cmp	r3, #0
2400acb0:	d138      	bne.n	2400ad24 <HAL_I2C_Master_Receive_DMA+0x164>
2400acb2:	e013      	b.n	2400acdc <HAL_I2C_Master_Receive_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
2400acb4:	68fb      	ldr	r3, [r7, #12]
2400acb6:	2220      	movs	r2, #32
2400acb8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400acbc:	68fb      	ldr	r3, [r7, #12]
2400acbe:	2200      	movs	r2, #0
2400acc0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400acc4:	68fb      	ldr	r3, [r7, #12]
2400acc6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400acc8:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400accc:	68fb      	ldr	r3, [r7, #12]
2400acce:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400acd0:	68fb      	ldr	r3, [r7, #12]
2400acd2:	2200      	movs	r2, #0
2400acd4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400acd8:	2301      	movs	r3, #1
2400acda:	e050      	b.n	2400ad7e <HAL_I2C_Master_Receive_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400acdc:	68fb      	ldr	r3, [r7, #12]
2400acde:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ace0:	b2da      	uxtb	r2, r3
2400ace2:	8979      	ldrh	r1, [r7, #10]
2400ace4:	4b2c      	ldr	r3, [pc, #176]	; (2400ad98 <HAL_I2C_Master_Receive_DMA+0x1d8>)
2400ace6:	9300      	str	r3, [sp, #0]
2400ace8:	697b      	ldr	r3, [r7, #20]
2400acea:	68f8      	ldr	r0, [r7, #12]
2400acec:	f004 fb1c 	bl	2400f328 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400acf0:	68fb      	ldr	r3, [r7, #12]
2400acf2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400acf4:	b29a      	uxth	r2, r3
2400acf6:	68fb      	ldr	r3, [r7, #12]
2400acf8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400acfa:	1ad3      	subs	r3, r2, r3
2400acfc:	b29a      	uxth	r2, r3
2400acfe:	68fb      	ldr	r3, [r7, #12]
2400ad00:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400ad02:	68fb      	ldr	r3, [r7, #12]
2400ad04:	2200      	movs	r2, #0
2400ad06:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400ad0a:	2110      	movs	r1, #16
2400ad0c:	68f8      	ldr	r0, [r7, #12]
2400ad0e:	f004 fb3d 	bl	2400f38c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400ad12:	68fb      	ldr	r3, [r7, #12]
2400ad14:	681b      	ldr	r3, [r3, #0]
2400ad16:	681a      	ldr	r2, [r3, #0]
2400ad18:	68fb      	ldr	r3, [r7, #12]
2400ad1a:	681b      	ldr	r3, [r3, #0]
2400ad1c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400ad20:	601a      	str	r2, [r3, #0]
2400ad22:	e029      	b.n	2400ad78 <HAL_I2C_Master_Receive_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400ad24:	68fb      	ldr	r3, [r7, #12]
2400ad26:	2220      	movs	r2, #32
2400ad28:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ad2c:	68fb      	ldr	r3, [r7, #12]
2400ad2e:	2200      	movs	r2, #0
2400ad30:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400ad34:	68fb      	ldr	r3, [r7, #12]
2400ad36:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ad38:	f043 0210 	orr.w	r2, r3, #16
2400ad3c:	68fb      	ldr	r3, [r7, #12]
2400ad3e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400ad40:	68fb      	ldr	r3, [r7, #12]
2400ad42:	2200      	movs	r2, #0
2400ad44:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400ad48:	2301      	movs	r3, #1
2400ad4a:	e018      	b.n	2400ad7e <HAL_I2C_Master_Receive_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400ad4c:	68fb      	ldr	r3, [r7, #12]
2400ad4e:	4a13      	ldr	r2, [pc, #76]	; (2400ad9c <HAL_I2C_Master_Receive_DMA+0x1dc>)
2400ad50:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400ad52:	68fb      	ldr	r3, [r7, #12]
2400ad54:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ad56:	b2da      	uxtb	r2, r3
2400ad58:	8979      	ldrh	r1, [r7, #10]
2400ad5a:	4b0f      	ldr	r3, [pc, #60]	; (2400ad98 <HAL_I2C_Master_Receive_DMA+0x1d8>)
2400ad5c:	9300      	str	r3, [sp, #0]
2400ad5e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400ad62:	68f8      	ldr	r0, [r7, #12]
2400ad64:	f004 fae0 	bl	2400f328 <I2C_TransferConfig>
                         I2C_GENERATE_START_READ);

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400ad68:	68fb      	ldr	r3, [r7, #12]
2400ad6a:	2200      	movs	r2, #0
2400ad6c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400ad70:	2101      	movs	r1, #1
2400ad72:	68f8      	ldr	r0, [r7, #12]
2400ad74:	f004 fb0a 	bl	2400f38c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400ad78:	2300      	movs	r3, #0
2400ad7a:	e000      	b.n	2400ad7e <HAL_I2C_Master_Receive_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
2400ad7c:	2302      	movs	r3, #2
  }
}
2400ad7e:	4618      	mov	r0, r3
2400ad80:	3718      	adds	r7, #24
2400ad82:	46bd      	mov	sp, r7
2400ad84:	bd80      	pop	{r7, pc}
2400ad86:	bf00      	nop
2400ad88:	ffff0000 	.word	0xffff0000
2400ad8c:	2400d507 	.word	0x2400d507
2400ad90:	2400ea05 	.word	0x2400ea05
2400ad94:	2400ec01 	.word	0x2400ec01
2400ad98:	80002400 	.word	0x80002400
2400ad9c:	2400ce5b 	.word	0x2400ce5b

2400ada0 <HAL_I2C_Slave_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2400ada0:	b580      	push	{r7, lr}
2400ada2:	b086      	sub	sp, #24
2400ada4:	af00      	add	r7, sp, #0
2400ada6:	60f8      	str	r0, [r7, #12]
2400ada8:	60b9      	str	r1, [r7, #8]
2400adaa:	4613      	mov	r3, r2
2400adac:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400adae:	68fb      	ldr	r3, [r7, #12]
2400adb0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400adb4:	b2db      	uxtb	r3, r3
2400adb6:	2b20      	cmp	r3, #32
2400adb8:	f040 80d1 	bne.w	2400af5e <HAL_I2C_Slave_Transmit_DMA+0x1be>
  {
    if ((pData == NULL) || (Size == 0U))
2400adbc:	68bb      	ldr	r3, [r7, #8]
2400adbe:	2b00      	cmp	r3, #0
2400adc0:	d002      	beq.n	2400adc8 <HAL_I2C_Slave_Transmit_DMA+0x28>
2400adc2:	88fb      	ldrh	r3, [r7, #6]
2400adc4:	2b00      	cmp	r3, #0
2400adc6:	d105      	bne.n	2400add4 <HAL_I2C_Slave_Transmit_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400adc8:	68fb      	ldr	r3, [r7, #12]
2400adca:	f44f 7200 	mov.w	r2, #512	; 0x200
2400adce:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400add0:	2301      	movs	r3, #1
2400add2:	e0c5      	b.n	2400af60 <HAL_I2C_Slave_Transmit_DMA+0x1c0>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400add4:	68fb      	ldr	r3, [r7, #12]
2400add6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400adda:	2b01      	cmp	r3, #1
2400addc:	d101      	bne.n	2400ade2 <HAL_I2C_Slave_Transmit_DMA+0x42>
2400adde:	2302      	movs	r3, #2
2400ade0:	e0be      	b.n	2400af60 <HAL_I2C_Slave_Transmit_DMA+0x1c0>
2400ade2:	68fb      	ldr	r3, [r7, #12]
2400ade4:	2201      	movs	r2, #1
2400ade6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400adea:	68fb      	ldr	r3, [r7, #12]
2400adec:	2221      	movs	r2, #33	; 0x21
2400adee:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400adf2:	68fb      	ldr	r3, [r7, #12]
2400adf4:	2220      	movs	r2, #32
2400adf6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400adfa:	68fb      	ldr	r3, [r7, #12]
2400adfc:	2200      	movs	r2, #0
2400adfe:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ae00:	68fb      	ldr	r3, [r7, #12]
2400ae02:	68ba      	ldr	r2, [r7, #8]
2400ae04:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ae06:	68fb      	ldr	r3, [r7, #12]
2400ae08:	88fa      	ldrh	r2, [r7, #6]
2400ae0a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400ae0c:	68fb      	ldr	r3, [r7, #12]
2400ae0e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae10:	b29a      	uxth	r2, r3
2400ae12:	68fb      	ldr	r3, [r7, #12]
2400ae14:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400ae16:	68fb      	ldr	r3, [r7, #12]
2400ae18:	4a53      	ldr	r2, [pc, #332]	; (2400af68 <HAL_I2C_Slave_Transmit_DMA+0x1c8>)
2400ae1a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400ae1c:	68fb      	ldr	r3, [r7, #12]
2400ae1e:	4a53      	ldr	r2, [pc, #332]	; (2400af6c <HAL_I2C_Slave_Transmit_DMA+0x1cc>)
2400ae20:	635a      	str	r2, [r3, #52]	; 0x34

    /* Preload TX data if no stretch enable */
    if (hi2c->Init.NoStretchMode == I2C_NOSTRETCH_ENABLE)
2400ae22:	68fb      	ldr	r3, [r7, #12]
2400ae24:	6a1b      	ldr	r3, [r3, #32]
2400ae26:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2400ae2a:	d117      	bne.n	2400ae5c <HAL_I2C_Slave_Transmit_DMA+0xbc>
    {
      /* Preload TX register */
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400ae2c:	68fb      	ldr	r3, [r7, #12]
2400ae2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400ae30:	781a      	ldrb	r2, [r3, #0]
2400ae32:	68fb      	ldr	r3, [r7, #12]
2400ae34:	681b      	ldr	r3, [r3, #0]
2400ae36:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400ae38:	68fb      	ldr	r3, [r7, #12]
2400ae3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400ae3c:	1c5a      	adds	r2, r3, #1
2400ae3e:	68fb      	ldr	r3, [r7, #12]
2400ae40:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400ae42:	68fb      	ldr	r3, [r7, #12]
2400ae44:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae46:	b29b      	uxth	r3, r3
2400ae48:	3b01      	subs	r3, #1
2400ae4a:	b29a      	uxth	r2, r3
2400ae4c:	68fb      	ldr	r3, [r7, #12]
2400ae4e:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400ae50:	68fb      	ldr	r3, [r7, #12]
2400ae52:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ae54:	3b01      	subs	r3, #1
2400ae56:	b29a      	uxth	r2, r3
2400ae58:	68fb      	ldr	r3, [r7, #12]
2400ae5a:	851a      	strh	r2, [r3, #40]	; 0x28
    }

    if (hi2c->XferCount != 0U)
2400ae5c:	68fb      	ldr	r3, [r7, #12]
2400ae5e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae60:	b29b      	uxth	r3, r3
2400ae62:	2b00      	cmp	r3, #0
2400ae64:	d068      	beq.n	2400af38 <HAL_I2C_Slave_Transmit_DMA+0x198>
    {
      if (hi2c->hdmatx != NULL)
2400ae66:	68fb      	ldr	r3, [r7, #12]
2400ae68:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ae6a:	2b00      	cmp	r3, #0
2400ae6c:	d022      	beq.n	2400aeb4 <HAL_I2C_Slave_Transmit_DMA+0x114>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2400ae6e:	68fb      	ldr	r3, [r7, #12]
2400ae70:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ae72:	4a3f      	ldr	r2, [pc, #252]	; (2400af70 <HAL_I2C_Slave_Transmit_DMA+0x1d0>)
2400ae74:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400ae76:	68fb      	ldr	r3, [r7, #12]
2400ae78:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ae7a:	4a3e      	ldr	r2, [pc, #248]	; (2400af74 <HAL_I2C_Slave_Transmit_DMA+0x1d4>)
2400ae7c:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400ae7e:	68fb      	ldr	r3, [r7, #12]
2400ae80:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ae82:	2200      	movs	r2, #0
2400ae84:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2400ae86:	68fb      	ldr	r3, [r7, #12]
2400ae88:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ae8a:	2200      	movs	r2, #0
2400ae8c:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx,
2400ae8e:	68fb      	ldr	r3, [r7, #12]
2400ae90:	6b98      	ldr	r0, [r3, #56]	; 0x38
                                         (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR,
2400ae92:	68fb      	ldr	r3, [r7, #12]
2400ae94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx,
2400ae96:	4619      	mov	r1, r3
                                         (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR,
2400ae98:	68fb      	ldr	r3, [r7, #12]
2400ae9a:	681b      	ldr	r3, [r3, #0]
2400ae9c:	3328      	adds	r3, #40	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx,
2400ae9e:	461a      	mov	r2, r3
                                         hi2c->XferSize);
2400aea0:	68fb      	ldr	r3, [r7, #12]
2400aea2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx,
2400aea4:	f7f8 fe54 	bl	24003b50 <HAL_DMA_Start_IT>
2400aea8:	4603      	mov	r3, r0
2400aeaa:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400aeac:	7dfb      	ldrb	r3, [r7, #23]
2400aeae:	2b00      	cmp	r3, #0
2400aeb0:	d12e      	bne.n	2400af10 <HAL_I2C_Slave_Transmit_DMA+0x170>
2400aeb2:	e013      	b.n	2400aedc <HAL_I2C_Slave_Transmit_DMA+0x13c>
        hi2c->State     = HAL_I2C_STATE_LISTEN;
2400aeb4:	68fb      	ldr	r3, [r7, #12]
2400aeb6:	2228      	movs	r2, #40	; 0x28
2400aeb8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400aebc:	68fb      	ldr	r3, [r7, #12]
2400aebe:	2200      	movs	r2, #0
2400aec0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400aec4:	68fb      	ldr	r3, [r7, #12]
2400aec6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400aec8:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400aecc:	68fb      	ldr	r3, [r7, #12]
2400aece:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400aed0:	68fb      	ldr	r3, [r7, #12]
2400aed2:	2200      	movs	r2, #0
2400aed4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400aed8:	2301      	movs	r3, #1
2400aeda:	e041      	b.n	2400af60 <HAL_I2C_Slave_Transmit_DMA+0x1c0>
      {
        /* Enable Address Acknowledge */
        hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400aedc:	68fb      	ldr	r3, [r7, #12]
2400aede:	681b      	ldr	r3, [r3, #0]
2400aee0:	685a      	ldr	r2, [r3, #4]
2400aee2:	68fb      	ldr	r3, [r7, #12]
2400aee4:	681b      	ldr	r3, [r3, #0]
2400aee6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400aeea:	605a      	str	r2, [r3, #4]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400aeec:	68fb      	ldr	r3, [r7, #12]
2400aeee:	2200      	movs	r2, #0
2400aef0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR, STOP, NACK, ADDR interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400aef4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400aef8:	68f8      	ldr	r0, [r7, #12]
2400aefa:	f004 fa47 	bl	2400f38c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400aefe:	68fb      	ldr	r3, [r7, #12]
2400af00:	681b      	ldr	r3, [r3, #0]
2400af02:	681a      	ldr	r2, [r3, #0]
2400af04:	68fb      	ldr	r3, [r7, #12]
2400af06:	681b      	ldr	r3, [r3, #0]
2400af08:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400af0c:	601a      	str	r2, [r3, #0]
2400af0e:	e024      	b.n	2400af5a <HAL_I2C_Slave_Transmit_DMA+0x1ba>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_LISTEN;
2400af10:	68fb      	ldr	r3, [r7, #12]
2400af12:	2228      	movs	r2, #40	; 0x28
2400af14:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400af18:	68fb      	ldr	r3, [r7, #12]
2400af1a:	2200      	movs	r2, #0
2400af1c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400af20:	68fb      	ldr	r3, [r7, #12]
2400af22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400af24:	f043 0210 	orr.w	r2, r3, #16
2400af28:	68fb      	ldr	r3, [r7, #12]
2400af2a:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400af2c:	68fb      	ldr	r3, [r7, #12]
2400af2e:	2200      	movs	r2, #0
2400af30:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400af34:	2301      	movs	r3, #1
2400af36:	e013      	b.n	2400af60 <HAL_I2C_Slave_Transmit_DMA+0x1c0>
      }
    }
    else
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400af38:	68fb      	ldr	r3, [r7, #12]
2400af3a:	681b      	ldr	r3, [r3, #0]
2400af3c:	685a      	ldr	r2, [r3, #4]
2400af3e:	68fb      	ldr	r3, [r7, #12]
2400af40:	681b      	ldr	r3, [r3, #0]
2400af42:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400af46:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400af48:	68fb      	ldr	r3, [r7, #12]
2400af4a:	2200      	movs	r2, #0
2400af4c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400af50:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400af54:	68f8      	ldr	r0, [r7, #12]
2400af56:	f004 fa19 	bl	2400f38c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400af5a:	2300      	movs	r3, #0
2400af5c:	e000      	b.n	2400af60 <HAL_I2C_Slave_Transmit_DMA+0x1c0>
  }
  else
  {
    return HAL_BUSY;
2400af5e:	2302      	movs	r3, #2
  }
}
2400af60:	4618      	mov	r0, r3
2400af62:	3718      	adds	r7, #24
2400af64:	46bd      	mov	sp, r7
2400af66:	bd80      	pop	{r7, pc}
2400af68:	ffff0000 	.word	0xffff0000
2400af6c:	2400d935 	.word	0x2400d935
2400af70:	2400e9c5 	.word	0x2400e9c5
2400af74:	2400ec01 	.word	0x2400ec01

2400af78 <HAL_I2C_Slave_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2400af78:	b580      	push	{r7, lr}
2400af7a:	b086      	sub	sp, #24
2400af7c:	af00      	add	r7, sp, #0
2400af7e:	60f8      	str	r0, [r7, #12]
2400af80:	60b9      	str	r1, [r7, #8]
2400af82:	4613      	mov	r3, r2
2400af84:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400af86:	68fb      	ldr	r3, [r7, #12]
2400af88:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400af8c:	b2db      	uxtb	r3, r3
2400af8e:	2b20      	cmp	r3, #32
2400af90:	f040 809b 	bne.w	2400b0ca <HAL_I2C_Slave_Receive_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
2400af94:	68bb      	ldr	r3, [r7, #8]
2400af96:	2b00      	cmp	r3, #0
2400af98:	d002      	beq.n	2400afa0 <HAL_I2C_Slave_Receive_DMA+0x28>
2400af9a:	88fb      	ldrh	r3, [r7, #6]
2400af9c:	2b00      	cmp	r3, #0
2400af9e:	d105      	bne.n	2400afac <HAL_I2C_Slave_Receive_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400afa0:	68fb      	ldr	r3, [r7, #12]
2400afa2:	f44f 7200 	mov.w	r2, #512	; 0x200
2400afa6:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400afa8:	2301      	movs	r3, #1
2400afaa:	e08f      	b.n	2400b0cc <HAL_I2C_Slave_Receive_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400afac:	68fb      	ldr	r3, [r7, #12]
2400afae:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400afb2:	2b01      	cmp	r3, #1
2400afb4:	d101      	bne.n	2400afba <HAL_I2C_Slave_Receive_DMA+0x42>
2400afb6:	2302      	movs	r3, #2
2400afb8:	e088      	b.n	2400b0cc <HAL_I2C_Slave_Receive_DMA+0x154>
2400afba:	68fb      	ldr	r3, [r7, #12]
2400afbc:	2201      	movs	r2, #1
2400afbe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400afc2:	68fb      	ldr	r3, [r7, #12]
2400afc4:	2222      	movs	r2, #34	; 0x22
2400afc6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400afca:	68fb      	ldr	r3, [r7, #12]
2400afcc:	2220      	movs	r2, #32
2400afce:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400afd2:	68fb      	ldr	r3, [r7, #12]
2400afd4:	2200      	movs	r2, #0
2400afd6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400afd8:	68fb      	ldr	r3, [r7, #12]
2400afda:	68ba      	ldr	r2, [r7, #8]
2400afdc:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400afde:	68fb      	ldr	r3, [r7, #12]
2400afe0:	88fa      	ldrh	r2, [r7, #6]
2400afe2:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400afe4:	68fb      	ldr	r3, [r7, #12]
2400afe6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400afe8:	b29a      	uxth	r2, r3
2400afea:	68fb      	ldr	r3, [r7, #12]
2400afec:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400afee:	68fb      	ldr	r3, [r7, #12]
2400aff0:	4a38      	ldr	r2, [pc, #224]	; (2400b0d4 <HAL_I2C_Slave_Receive_DMA+0x15c>)
2400aff2:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400aff4:	68fb      	ldr	r3, [r7, #12]
2400aff6:	4a38      	ldr	r2, [pc, #224]	; (2400b0d8 <HAL_I2C_Slave_Receive_DMA+0x160>)
2400aff8:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2400affa:	68fb      	ldr	r3, [r7, #12]
2400affc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400affe:	2b00      	cmp	r3, #0
2400b000:	d020      	beq.n	2400b044 <HAL_I2C_Slave_Receive_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400b002:	68fb      	ldr	r3, [r7, #12]
2400b004:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b006:	4a35      	ldr	r2, [pc, #212]	; (2400b0dc <HAL_I2C_Slave_Receive_DMA+0x164>)
2400b008:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400b00a:	68fb      	ldr	r3, [r7, #12]
2400b00c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b00e:	4a34      	ldr	r2, [pc, #208]	; (2400b0e0 <HAL_I2C_Slave_Receive_DMA+0x168>)
2400b010:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400b012:	68fb      	ldr	r3, [r7, #12]
2400b014:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b016:	2200      	movs	r2, #0
2400b018:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400b01a:	68fb      	ldr	r3, [r7, #12]
2400b01c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b01e:	2200      	movs	r2, #0
2400b020:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400b022:	68fb      	ldr	r3, [r7, #12]
2400b024:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400b026:	68fb      	ldr	r3, [r7, #12]
2400b028:	681b      	ldr	r3, [r3, #0]
2400b02a:	3324      	adds	r3, #36	; 0x24
2400b02c:	4619      	mov	r1, r3
2400b02e:	68ba      	ldr	r2, [r7, #8]
                                       hi2c->XferSize);
2400b030:	68fb      	ldr	r3, [r7, #12]
2400b032:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400b034:	f7f8 fd8c 	bl	24003b50 <HAL_DMA_Start_IT>
2400b038:	4603      	mov	r3, r0
2400b03a:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400b03c:	7dfb      	ldrb	r3, [r7, #23]
2400b03e:	2b00      	cmp	r3, #0
2400b040:	d12f      	bne.n	2400b0a2 <HAL_I2C_Slave_Receive_DMA+0x12a>
2400b042:	e013      	b.n	2400b06c <HAL_I2C_Slave_Receive_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b044:	68fb      	ldr	r3, [r7, #12]
2400b046:	2228      	movs	r2, #40	; 0x28
2400b048:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b04c:	68fb      	ldr	r3, [r7, #12]
2400b04e:	2200      	movs	r2, #0
2400b050:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b054:	68fb      	ldr	r3, [r7, #12]
2400b056:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b058:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b05c:	68fb      	ldr	r3, [r7, #12]
2400b05e:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b060:	68fb      	ldr	r3, [r7, #12]
2400b062:	2200      	movs	r2, #0
2400b064:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b068:	2301      	movs	r3, #1
2400b06a:	e02f      	b.n	2400b0cc <HAL_I2C_Slave_Receive_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b06c:	68fb      	ldr	r3, [r7, #12]
2400b06e:	681b      	ldr	r3, [r3, #0]
2400b070:	685a      	ldr	r2, [r3, #4]
2400b072:	68fb      	ldr	r3, [r7, #12]
2400b074:	681b      	ldr	r3, [r3, #0]
2400b076:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b07a:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b07c:	68fb      	ldr	r3, [r7, #12]
2400b07e:	2200      	movs	r2, #0
2400b080:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400b084:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b088:	68f8      	ldr	r0, [r7, #12]
2400b08a:	f004 f97f 	bl	2400f38c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400b08e:	68fb      	ldr	r3, [r7, #12]
2400b090:	681b      	ldr	r3, [r3, #0]
2400b092:	681a      	ldr	r2, [r3, #0]
2400b094:	68fb      	ldr	r3, [r7, #12]
2400b096:	681b      	ldr	r3, [r3, #0]
2400b098:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400b09c:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400b09e:	2300      	movs	r3, #0
2400b0a0:	e014      	b.n	2400b0cc <HAL_I2C_Slave_Receive_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b0a2:	68fb      	ldr	r3, [r7, #12]
2400b0a4:	2228      	movs	r2, #40	; 0x28
2400b0a6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b0aa:	68fb      	ldr	r3, [r7, #12]
2400b0ac:	2200      	movs	r2, #0
2400b0ae:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b0b2:	68fb      	ldr	r3, [r7, #12]
2400b0b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b0b6:	f043 0210 	orr.w	r2, r3, #16
2400b0ba:	68fb      	ldr	r3, [r7, #12]
2400b0bc:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b0be:	68fb      	ldr	r3, [r7, #12]
2400b0c0:	2200      	movs	r2, #0
2400b0c2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b0c6:	2301      	movs	r3, #1
2400b0c8:	e000      	b.n	2400b0cc <HAL_I2C_Slave_Receive_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
2400b0ca:	2302      	movs	r3, #2
  }
}
2400b0cc:	4618      	mov	r0, r3
2400b0ce:	3718      	adds	r7, #24
2400b0d0:	46bd      	mov	sp, r7
2400b0d2:	bd80      	pop	{r7, pc}
2400b0d4:	ffff0000 	.word	0xffff0000
2400b0d8:	2400d935 	.word	0x2400d935
2400b0dc:	2400ea9d 	.word	0x2400ea9d
2400b0e0:	2400ec01 	.word	0x2400ec01

2400b0e4 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2400b0e4:	b580      	push	{r7, lr}
2400b0e6:	b088      	sub	sp, #32
2400b0e8:	af02      	add	r7, sp, #8
2400b0ea:	60f8      	str	r0, [r7, #12]
2400b0ec:	4608      	mov	r0, r1
2400b0ee:	4611      	mov	r1, r2
2400b0f0:	461a      	mov	r2, r3
2400b0f2:	4603      	mov	r3, r0
2400b0f4:	817b      	strh	r3, [r7, #10]
2400b0f6:	460b      	mov	r3, r1
2400b0f8:	813b      	strh	r3, [r7, #8]
2400b0fa:	4613      	mov	r3, r2
2400b0fc:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b0fe:	68fb      	ldr	r3, [r7, #12]
2400b100:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b104:	b2db      	uxtb	r3, r3
2400b106:	2b20      	cmp	r3, #32
2400b108:	f040 80f9 	bne.w	2400b2fe <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
2400b10c:	6a3b      	ldr	r3, [r7, #32]
2400b10e:	2b00      	cmp	r3, #0
2400b110:	d002      	beq.n	2400b118 <HAL_I2C_Mem_Write+0x34>
2400b112:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400b114:	2b00      	cmp	r3, #0
2400b116:	d105      	bne.n	2400b124 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b118:	68fb      	ldr	r3, [r7, #12]
2400b11a:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b11e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b120:	2301      	movs	r3, #1
2400b122:	e0ed      	b.n	2400b300 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b124:	68fb      	ldr	r3, [r7, #12]
2400b126:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b12a:	2b01      	cmp	r3, #1
2400b12c:	d101      	bne.n	2400b132 <HAL_I2C_Mem_Write+0x4e>
2400b12e:	2302      	movs	r3, #2
2400b130:	e0e6      	b.n	2400b300 <HAL_I2C_Mem_Write+0x21c>
2400b132:	68fb      	ldr	r3, [r7, #12]
2400b134:	2201      	movs	r2, #1
2400b136:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400b13a:	f7f6 ff6f 	bl	2400201c <HAL_GetTick>
2400b13e:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400b140:	697b      	ldr	r3, [r7, #20]
2400b142:	9300      	str	r3, [sp, #0]
2400b144:	2319      	movs	r3, #25
2400b146:	2201      	movs	r2, #1
2400b148:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b14c:	68f8      	ldr	r0, [r7, #12]
2400b14e:	f003 feaf 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400b152:	4603      	mov	r3, r0
2400b154:	2b00      	cmp	r3, #0
2400b156:	d001      	beq.n	2400b15c <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
2400b158:	2301      	movs	r3, #1
2400b15a:	e0d1      	b.n	2400b300 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400b15c:	68fb      	ldr	r3, [r7, #12]
2400b15e:	2221      	movs	r2, #33	; 0x21
2400b160:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400b164:	68fb      	ldr	r3, [r7, #12]
2400b166:	2240      	movs	r2, #64	; 0x40
2400b168:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b16c:	68fb      	ldr	r3, [r7, #12]
2400b16e:	2200      	movs	r2, #0
2400b170:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400b172:	68fb      	ldr	r3, [r7, #12]
2400b174:	6a3a      	ldr	r2, [r7, #32]
2400b176:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400b178:	68fb      	ldr	r3, [r7, #12]
2400b17a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400b17c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400b17e:	68fb      	ldr	r3, [r7, #12]
2400b180:	2200      	movs	r2, #0
2400b182:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400b184:	88f8      	ldrh	r0, [r7, #6]
2400b186:	893a      	ldrh	r2, [r7, #8]
2400b188:	8979      	ldrh	r1, [r7, #10]
2400b18a:	697b      	ldr	r3, [r7, #20]
2400b18c:	9301      	str	r3, [sp, #4]
2400b18e:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b190:	9300      	str	r3, [sp, #0]
2400b192:	4603      	mov	r3, r0
2400b194:	68f8      	ldr	r0, [r7, #12]
2400b196:	f002 fdaf 	bl	2400dcf8 <I2C_RequestMemoryWrite>
2400b19a:	4603      	mov	r3, r0
2400b19c:	2b00      	cmp	r3, #0
2400b19e:	d005      	beq.n	2400b1ac <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b1a0:	68fb      	ldr	r3, [r7, #12]
2400b1a2:	2200      	movs	r2, #0
2400b1a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b1a8:	2301      	movs	r3, #1
2400b1aa:	e0a9      	b.n	2400b300 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b1ac:	68fb      	ldr	r3, [r7, #12]
2400b1ae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b1b0:	b29b      	uxth	r3, r3
2400b1b2:	2bff      	cmp	r3, #255	; 0xff
2400b1b4:	d90e      	bls.n	2400b1d4 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b1b6:	68fb      	ldr	r3, [r7, #12]
2400b1b8:	22ff      	movs	r2, #255	; 0xff
2400b1ba:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400b1bc:	68fb      	ldr	r3, [r7, #12]
2400b1be:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b1c0:	b2da      	uxtb	r2, r3
2400b1c2:	8979      	ldrh	r1, [r7, #10]
2400b1c4:	2300      	movs	r3, #0
2400b1c6:	9300      	str	r3, [sp, #0]
2400b1c8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b1cc:	68f8      	ldr	r0, [r7, #12]
2400b1ce:	f004 f8ab 	bl	2400f328 <I2C_TransferConfig>
2400b1d2:	e00f      	b.n	2400b1f4 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b1d4:	68fb      	ldr	r3, [r7, #12]
2400b1d6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b1d8:	b29a      	uxth	r2, r3
2400b1da:	68fb      	ldr	r3, [r7, #12]
2400b1dc:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400b1de:	68fb      	ldr	r3, [r7, #12]
2400b1e0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b1e2:	b2da      	uxtb	r2, r3
2400b1e4:	8979      	ldrh	r1, [r7, #10]
2400b1e6:	2300      	movs	r3, #0
2400b1e8:	9300      	str	r3, [sp, #0]
2400b1ea:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b1ee:	68f8      	ldr	r0, [r7, #12]
2400b1f0:	f004 f89a 	bl	2400f328 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400b1f4:	697a      	ldr	r2, [r7, #20]
2400b1f6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400b1f8:	68f8      	ldr	r0, [r7, #12]
2400b1fa:	f003 fea8 	bl	2400ef4e <I2C_WaitOnTXISFlagUntilTimeout>
2400b1fe:	4603      	mov	r3, r0
2400b200:	2b00      	cmp	r3, #0
2400b202:	d001      	beq.n	2400b208 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
2400b204:	2301      	movs	r3, #1
2400b206:	e07b      	b.n	2400b300 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400b208:	68fb      	ldr	r3, [r7, #12]
2400b20a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400b20c:	781a      	ldrb	r2, [r3, #0]
2400b20e:	68fb      	ldr	r3, [r7, #12]
2400b210:	681b      	ldr	r3, [r3, #0]
2400b212:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400b214:	68fb      	ldr	r3, [r7, #12]
2400b216:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400b218:	1c5a      	adds	r2, r3, #1
2400b21a:	68fb      	ldr	r3, [r7, #12]
2400b21c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400b21e:	68fb      	ldr	r3, [r7, #12]
2400b220:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b222:	b29b      	uxth	r3, r3
2400b224:	3b01      	subs	r3, #1
2400b226:	b29a      	uxth	r2, r3
2400b228:	68fb      	ldr	r3, [r7, #12]
2400b22a:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400b22c:	68fb      	ldr	r3, [r7, #12]
2400b22e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b230:	3b01      	subs	r3, #1
2400b232:	b29a      	uxth	r2, r3
2400b234:	68fb      	ldr	r3, [r7, #12]
2400b236:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400b238:	68fb      	ldr	r3, [r7, #12]
2400b23a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b23c:	b29b      	uxth	r3, r3
2400b23e:	2b00      	cmp	r3, #0
2400b240:	d034      	beq.n	2400b2ac <HAL_I2C_Mem_Write+0x1c8>
2400b242:	68fb      	ldr	r3, [r7, #12]
2400b244:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b246:	2b00      	cmp	r3, #0
2400b248:	d130      	bne.n	2400b2ac <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400b24a:	697b      	ldr	r3, [r7, #20]
2400b24c:	9300      	str	r3, [sp, #0]
2400b24e:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b250:	2200      	movs	r2, #0
2400b252:	2180      	movs	r1, #128	; 0x80
2400b254:	68f8      	ldr	r0, [r7, #12]
2400b256:	f003 fe2b 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400b25a:	4603      	mov	r3, r0
2400b25c:	2b00      	cmp	r3, #0
2400b25e:	d001      	beq.n	2400b264 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
2400b260:	2301      	movs	r3, #1
2400b262:	e04d      	b.n	2400b300 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b264:	68fb      	ldr	r3, [r7, #12]
2400b266:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b268:	b29b      	uxth	r3, r3
2400b26a:	2bff      	cmp	r3, #255	; 0xff
2400b26c:	d90e      	bls.n	2400b28c <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400b26e:	68fb      	ldr	r3, [r7, #12]
2400b270:	22ff      	movs	r2, #255	; 0xff
2400b272:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400b274:	68fb      	ldr	r3, [r7, #12]
2400b276:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b278:	b2da      	uxtb	r2, r3
2400b27a:	8979      	ldrh	r1, [r7, #10]
2400b27c:	2300      	movs	r3, #0
2400b27e:	9300      	str	r3, [sp, #0]
2400b280:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b284:	68f8      	ldr	r0, [r7, #12]
2400b286:	f004 f84f 	bl	2400f328 <I2C_TransferConfig>
2400b28a:	e00f      	b.n	2400b2ac <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400b28c:	68fb      	ldr	r3, [r7, #12]
2400b28e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b290:	b29a      	uxth	r2, r3
2400b292:	68fb      	ldr	r3, [r7, #12]
2400b294:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400b296:	68fb      	ldr	r3, [r7, #12]
2400b298:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b29a:	b2da      	uxtb	r2, r3
2400b29c:	8979      	ldrh	r1, [r7, #10]
2400b29e:	2300      	movs	r3, #0
2400b2a0:	9300      	str	r3, [sp, #0]
2400b2a2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b2a6:	68f8      	ldr	r0, [r7, #12]
2400b2a8:	f004 f83e 	bl	2400f328 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
2400b2ac:	68fb      	ldr	r3, [r7, #12]
2400b2ae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b2b0:	b29b      	uxth	r3, r3
2400b2b2:	2b00      	cmp	r3, #0
2400b2b4:	d19e      	bne.n	2400b1f4 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400b2b6:	697a      	ldr	r2, [r7, #20]
2400b2b8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400b2ba:	68f8      	ldr	r0, [r7, #12]
2400b2bc:	f003 fe8e 	bl	2400efdc <I2C_WaitOnSTOPFlagUntilTimeout>
2400b2c0:	4603      	mov	r3, r0
2400b2c2:	2b00      	cmp	r3, #0
2400b2c4:	d001      	beq.n	2400b2ca <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
2400b2c6:	2301      	movs	r3, #1
2400b2c8:	e01a      	b.n	2400b300 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400b2ca:	68fb      	ldr	r3, [r7, #12]
2400b2cc:	681b      	ldr	r3, [r3, #0]
2400b2ce:	2220      	movs	r2, #32
2400b2d0:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400b2d2:	68fb      	ldr	r3, [r7, #12]
2400b2d4:	681b      	ldr	r3, [r3, #0]
2400b2d6:	6859      	ldr	r1, [r3, #4]
2400b2d8:	68fb      	ldr	r3, [r7, #12]
2400b2da:	681a      	ldr	r2, [r3, #0]
2400b2dc:	4b0a      	ldr	r3, [pc, #40]	; (2400b308 <HAL_I2C_Mem_Write+0x224>)
2400b2de:	400b      	ands	r3, r1
2400b2e0:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400b2e2:	68fb      	ldr	r3, [r7, #12]
2400b2e4:	2220      	movs	r2, #32
2400b2e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400b2ea:	68fb      	ldr	r3, [r7, #12]
2400b2ec:	2200      	movs	r2, #0
2400b2ee:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b2f2:	68fb      	ldr	r3, [r7, #12]
2400b2f4:	2200      	movs	r2, #0
2400b2f6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400b2fa:	2300      	movs	r3, #0
2400b2fc:	e000      	b.n	2400b300 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
2400b2fe:	2302      	movs	r3, #2
  }
}
2400b300:	4618      	mov	r0, r3
2400b302:	3718      	adds	r7, #24
2400b304:	46bd      	mov	sp, r7
2400b306:	bd80      	pop	{r7, pc}
2400b308:	fe00e800 	.word	0xfe00e800

2400b30c <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2400b30c:	b580      	push	{r7, lr}
2400b30e:	b088      	sub	sp, #32
2400b310:	af02      	add	r7, sp, #8
2400b312:	60f8      	str	r0, [r7, #12]
2400b314:	4608      	mov	r0, r1
2400b316:	4611      	mov	r1, r2
2400b318:	461a      	mov	r2, r3
2400b31a:	4603      	mov	r3, r0
2400b31c:	817b      	strh	r3, [r7, #10]
2400b31e:	460b      	mov	r3, r1
2400b320:	813b      	strh	r3, [r7, #8]
2400b322:	4613      	mov	r3, r2
2400b324:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b326:	68fb      	ldr	r3, [r7, #12]
2400b328:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b32c:	b2db      	uxtb	r3, r3
2400b32e:	2b20      	cmp	r3, #32
2400b330:	f040 80fd 	bne.w	2400b52e <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
2400b334:	6a3b      	ldr	r3, [r7, #32]
2400b336:	2b00      	cmp	r3, #0
2400b338:	d002      	beq.n	2400b340 <HAL_I2C_Mem_Read+0x34>
2400b33a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400b33c:	2b00      	cmp	r3, #0
2400b33e:	d105      	bne.n	2400b34c <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b340:	68fb      	ldr	r3, [r7, #12]
2400b342:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b346:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b348:	2301      	movs	r3, #1
2400b34a:	e0f1      	b.n	2400b530 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b34c:	68fb      	ldr	r3, [r7, #12]
2400b34e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b352:	2b01      	cmp	r3, #1
2400b354:	d101      	bne.n	2400b35a <HAL_I2C_Mem_Read+0x4e>
2400b356:	2302      	movs	r3, #2
2400b358:	e0ea      	b.n	2400b530 <HAL_I2C_Mem_Read+0x224>
2400b35a:	68fb      	ldr	r3, [r7, #12]
2400b35c:	2201      	movs	r2, #1
2400b35e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400b362:	f7f6 fe5b 	bl	2400201c <HAL_GetTick>
2400b366:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400b368:	697b      	ldr	r3, [r7, #20]
2400b36a:	9300      	str	r3, [sp, #0]
2400b36c:	2319      	movs	r3, #25
2400b36e:	2201      	movs	r2, #1
2400b370:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b374:	68f8      	ldr	r0, [r7, #12]
2400b376:	f003 fd9b 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400b37a:	4603      	mov	r3, r0
2400b37c:	2b00      	cmp	r3, #0
2400b37e:	d001      	beq.n	2400b384 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
2400b380:	2301      	movs	r3, #1
2400b382:	e0d5      	b.n	2400b530 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400b384:	68fb      	ldr	r3, [r7, #12]
2400b386:	2222      	movs	r2, #34	; 0x22
2400b388:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400b38c:	68fb      	ldr	r3, [r7, #12]
2400b38e:	2240      	movs	r2, #64	; 0x40
2400b390:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b394:	68fb      	ldr	r3, [r7, #12]
2400b396:	2200      	movs	r2, #0
2400b398:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400b39a:	68fb      	ldr	r3, [r7, #12]
2400b39c:	6a3a      	ldr	r2, [r7, #32]
2400b39e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400b3a0:	68fb      	ldr	r3, [r7, #12]
2400b3a2:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400b3a4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400b3a6:	68fb      	ldr	r3, [r7, #12]
2400b3a8:	2200      	movs	r2, #0
2400b3aa:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400b3ac:	88f8      	ldrh	r0, [r7, #6]
2400b3ae:	893a      	ldrh	r2, [r7, #8]
2400b3b0:	8979      	ldrh	r1, [r7, #10]
2400b3b2:	697b      	ldr	r3, [r7, #20]
2400b3b4:	9301      	str	r3, [sp, #4]
2400b3b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b3b8:	9300      	str	r3, [sp, #0]
2400b3ba:	4603      	mov	r3, r0
2400b3bc:	68f8      	ldr	r0, [r7, #12]
2400b3be:	f002 fcef 	bl	2400dda0 <I2C_RequestMemoryRead>
2400b3c2:	4603      	mov	r3, r0
2400b3c4:	2b00      	cmp	r3, #0
2400b3c6:	d005      	beq.n	2400b3d4 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b3c8:	68fb      	ldr	r3, [r7, #12]
2400b3ca:	2200      	movs	r2, #0
2400b3cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b3d0:	2301      	movs	r3, #1
2400b3d2:	e0ad      	b.n	2400b530 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b3d4:	68fb      	ldr	r3, [r7, #12]
2400b3d6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b3d8:	b29b      	uxth	r3, r3
2400b3da:	2bff      	cmp	r3, #255	; 0xff
2400b3dc:	d90e      	bls.n	2400b3fc <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b3de:	68fb      	ldr	r3, [r7, #12]
2400b3e0:	22ff      	movs	r2, #255	; 0xff
2400b3e2:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400b3e4:	68fb      	ldr	r3, [r7, #12]
2400b3e6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b3e8:	b2da      	uxtb	r2, r3
2400b3ea:	8979      	ldrh	r1, [r7, #10]
2400b3ec:	4b52      	ldr	r3, [pc, #328]	; (2400b538 <HAL_I2C_Mem_Read+0x22c>)
2400b3ee:	9300      	str	r3, [sp, #0]
2400b3f0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b3f4:	68f8      	ldr	r0, [r7, #12]
2400b3f6:	f003 ff97 	bl	2400f328 <I2C_TransferConfig>
2400b3fa:	e00f      	b.n	2400b41c <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b3fc:	68fb      	ldr	r3, [r7, #12]
2400b3fe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b400:	b29a      	uxth	r2, r3
2400b402:	68fb      	ldr	r3, [r7, #12]
2400b404:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400b406:	68fb      	ldr	r3, [r7, #12]
2400b408:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b40a:	b2da      	uxtb	r2, r3
2400b40c:	8979      	ldrh	r1, [r7, #10]
2400b40e:	4b4a      	ldr	r3, [pc, #296]	; (2400b538 <HAL_I2C_Mem_Read+0x22c>)
2400b410:	9300      	str	r3, [sp, #0]
2400b412:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b416:	68f8      	ldr	r0, [r7, #12]
2400b418:	f003 ff86 	bl	2400f328 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
2400b41c:	697b      	ldr	r3, [r7, #20]
2400b41e:	9300      	str	r3, [sp, #0]
2400b420:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b422:	2200      	movs	r2, #0
2400b424:	2104      	movs	r1, #4
2400b426:	68f8      	ldr	r0, [r7, #12]
2400b428:	f003 fd42 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400b42c:	4603      	mov	r3, r0
2400b42e:	2b00      	cmp	r3, #0
2400b430:	d001      	beq.n	2400b436 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
2400b432:	2301      	movs	r3, #1
2400b434:	e07c      	b.n	2400b530 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400b436:	68fb      	ldr	r3, [r7, #12]
2400b438:	681b      	ldr	r3, [r3, #0]
2400b43a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400b43c:	68fb      	ldr	r3, [r7, #12]
2400b43e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400b440:	b2d2      	uxtb	r2, r2
2400b442:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400b444:	68fb      	ldr	r3, [r7, #12]
2400b446:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400b448:	1c5a      	adds	r2, r3, #1
2400b44a:	68fb      	ldr	r3, [r7, #12]
2400b44c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400b44e:	68fb      	ldr	r3, [r7, #12]
2400b450:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b452:	3b01      	subs	r3, #1
2400b454:	b29a      	uxth	r2, r3
2400b456:	68fb      	ldr	r3, [r7, #12]
2400b458:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400b45a:	68fb      	ldr	r3, [r7, #12]
2400b45c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b45e:	b29b      	uxth	r3, r3
2400b460:	3b01      	subs	r3, #1
2400b462:	b29a      	uxth	r2, r3
2400b464:	68fb      	ldr	r3, [r7, #12]
2400b466:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400b468:	68fb      	ldr	r3, [r7, #12]
2400b46a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b46c:	b29b      	uxth	r3, r3
2400b46e:	2b00      	cmp	r3, #0
2400b470:	d034      	beq.n	2400b4dc <HAL_I2C_Mem_Read+0x1d0>
2400b472:	68fb      	ldr	r3, [r7, #12]
2400b474:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b476:	2b00      	cmp	r3, #0
2400b478:	d130      	bne.n	2400b4dc <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400b47a:	697b      	ldr	r3, [r7, #20]
2400b47c:	9300      	str	r3, [sp, #0]
2400b47e:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b480:	2200      	movs	r2, #0
2400b482:	2180      	movs	r1, #128	; 0x80
2400b484:	68f8      	ldr	r0, [r7, #12]
2400b486:	f003 fd13 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400b48a:	4603      	mov	r3, r0
2400b48c:	2b00      	cmp	r3, #0
2400b48e:	d001      	beq.n	2400b494 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
2400b490:	2301      	movs	r3, #1
2400b492:	e04d      	b.n	2400b530 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b494:	68fb      	ldr	r3, [r7, #12]
2400b496:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b498:	b29b      	uxth	r3, r3
2400b49a:	2bff      	cmp	r3, #255	; 0xff
2400b49c:	d90e      	bls.n	2400b4bc <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400b49e:	68fb      	ldr	r3, [r7, #12]
2400b4a0:	22ff      	movs	r2, #255	; 0xff
2400b4a2:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
2400b4a4:	68fb      	ldr	r3, [r7, #12]
2400b4a6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b4a8:	b2da      	uxtb	r2, r3
2400b4aa:	8979      	ldrh	r1, [r7, #10]
2400b4ac:	2300      	movs	r3, #0
2400b4ae:	9300      	str	r3, [sp, #0]
2400b4b0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b4b4:	68f8      	ldr	r0, [r7, #12]
2400b4b6:	f003 ff37 	bl	2400f328 <I2C_TransferConfig>
2400b4ba:	e00f      	b.n	2400b4dc <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400b4bc:	68fb      	ldr	r3, [r7, #12]
2400b4be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b4c0:	b29a      	uxth	r2, r3
2400b4c2:	68fb      	ldr	r3, [r7, #12]
2400b4c4:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400b4c6:	68fb      	ldr	r3, [r7, #12]
2400b4c8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b4ca:	b2da      	uxtb	r2, r3
2400b4cc:	8979      	ldrh	r1, [r7, #10]
2400b4ce:	2300      	movs	r3, #0
2400b4d0:	9300      	str	r3, [sp, #0]
2400b4d2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b4d6:	68f8      	ldr	r0, [r7, #12]
2400b4d8:	f003 ff26 	bl	2400f328 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
2400b4dc:	68fb      	ldr	r3, [r7, #12]
2400b4de:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b4e0:	b29b      	uxth	r3, r3
2400b4e2:	2b00      	cmp	r3, #0
2400b4e4:	d19a      	bne.n	2400b41c <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400b4e6:	697a      	ldr	r2, [r7, #20]
2400b4e8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400b4ea:	68f8      	ldr	r0, [r7, #12]
2400b4ec:	f003 fd76 	bl	2400efdc <I2C_WaitOnSTOPFlagUntilTimeout>
2400b4f0:	4603      	mov	r3, r0
2400b4f2:	2b00      	cmp	r3, #0
2400b4f4:	d001      	beq.n	2400b4fa <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
2400b4f6:	2301      	movs	r3, #1
2400b4f8:	e01a      	b.n	2400b530 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400b4fa:	68fb      	ldr	r3, [r7, #12]
2400b4fc:	681b      	ldr	r3, [r3, #0]
2400b4fe:	2220      	movs	r2, #32
2400b500:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400b502:	68fb      	ldr	r3, [r7, #12]
2400b504:	681b      	ldr	r3, [r3, #0]
2400b506:	6859      	ldr	r1, [r3, #4]
2400b508:	68fb      	ldr	r3, [r7, #12]
2400b50a:	681a      	ldr	r2, [r3, #0]
2400b50c:	4b0b      	ldr	r3, [pc, #44]	; (2400b53c <HAL_I2C_Mem_Read+0x230>)
2400b50e:	400b      	ands	r3, r1
2400b510:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400b512:	68fb      	ldr	r3, [r7, #12]
2400b514:	2220      	movs	r2, #32
2400b516:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400b51a:	68fb      	ldr	r3, [r7, #12]
2400b51c:	2200      	movs	r2, #0
2400b51e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b522:	68fb      	ldr	r3, [r7, #12]
2400b524:	2200      	movs	r2, #0
2400b526:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400b52a:	2300      	movs	r3, #0
2400b52c:	e000      	b.n	2400b530 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
2400b52e:	2302      	movs	r3, #2
  }
}
2400b530:	4618      	mov	r0, r3
2400b532:	3718      	adds	r7, #24
2400b534:	46bd      	mov	sp, r7
2400b536:	bd80      	pop	{r7, pc}
2400b538:	80002400 	.word	0x80002400
2400b53c:	fe00e800 	.word	0xfe00e800

2400b540 <HAL_I2C_Mem_Write_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400b540:	b580      	push	{r7, lr}
2400b542:	b086      	sub	sp, #24
2400b544:	af02      	add	r7, sp, #8
2400b546:	60f8      	str	r0, [r7, #12]
2400b548:	4608      	mov	r0, r1
2400b54a:	4611      	mov	r1, r2
2400b54c:	461a      	mov	r2, r3
2400b54e:	4603      	mov	r3, r0
2400b550:	817b      	strh	r3, [r7, #10]
2400b552:	460b      	mov	r3, r1
2400b554:	813b      	strh	r3, [r7, #8]
2400b556:	4613      	mov	r3, r2
2400b558:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b55a:	68fb      	ldr	r3, [r7, #12]
2400b55c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b560:	b2db      	uxtb	r3, r3
2400b562:	2b20      	cmp	r3, #32
2400b564:	d167      	bne.n	2400b636 <HAL_I2C_Mem_Write_IT+0xf6>
  {
    if ((pData == NULL) || (Size == 0U))
2400b566:	69bb      	ldr	r3, [r7, #24]
2400b568:	2b00      	cmp	r3, #0
2400b56a:	d002      	beq.n	2400b572 <HAL_I2C_Mem_Write_IT+0x32>
2400b56c:	8bbb      	ldrh	r3, [r7, #28]
2400b56e:	2b00      	cmp	r3, #0
2400b570:	d105      	bne.n	2400b57e <HAL_I2C_Mem_Write_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b572:	68fb      	ldr	r3, [r7, #12]
2400b574:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b578:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b57a:	2301      	movs	r3, #1
2400b57c:	e05c      	b.n	2400b638 <HAL_I2C_Mem_Write_IT+0xf8>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400b57e:	68fb      	ldr	r3, [r7, #12]
2400b580:	681b      	ldr	r3, [r3, #0]
2400b582:	699b      	ldr	r3, [r3, #24]
2400b584:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b588:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b58c:	d101      	bne.n	2400b592 <HAL_I2C_Mem_Write_IT+0x52>
    {
      return HAL_BUSY;
2400b58e:	2302      	movs	r3, #2
2400b590:	e052      	b.n	2400b638 <HAL_I2C_Mem_Write_IT+0xf8>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b592:	68fb      	ldr	r3, [r7, #12]
2400b594:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b598:	2b01      	cmp	r3, #1
2400b59a:	d101      	bne.n	2400b5a0 <HAL_I2C_Mem_Write_IT+0x60>
2400b59c:	2302      	movs	r3, #2
2400b59e:	e04b      	b.n	2400b638 <HAL_I2C_Mem_Write_IT+0xf8>
2400b5a0:	68fb      	ldr	r3, [r7, #12]
2400b5a2:	2201      	movs	r2, #1
2400b5a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400b5a8:	68fb      	ldr	r3, [r7, #12]
2400b5aa:	2221      	movs	r2, #33	; 0x21
2400b5ac:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400b5b0:	68fb      	ldr	r3, [r7, #12]
2400b5b2:	2240      	movs	r2, #64	; 0x40
2400b5b4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400b5b8:	68fb      	ldr	r3, [r7, #12]
2400b5ba:	2200      	movs	r2, #0
2400b5bc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b5be:	68fb      	ldr	r3, [r7, #12]
2400b5c0:	69ba      	ldr	r2, [r7, #24]
2400b5c2:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b5c4:	68fb      	ldr	r3, [r7, #12]
2400b5c6:	8bba      	ldrh	r2, [r7, #28]
2400b5c8:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400b5ca:	68fb      	ldr	r3, [r7, #12]
2400b5cc:	4a1c      	ldr	r2, [pc, #112]	; (2400b640 <HAL_I2C_Mem_Write_IT+0x100>)
2400b5ce:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Mem_ISR_IT;
2400b5d0:	68fb      	ldr	r3, [r7, #12]
2400b5d2:	4a1c      	ldr	r2, [pc, #112]	; (2400b644 <HAL_I2C_Mem_Write_IT+0x104>)
2400b5d4:	635a      	str	r2, [r3, #52]	; 0x34
    hi2c->Devaddress  = DevAddress;
2400b5d6:	897a      	ldrh	r2, [r7, #10]
2400b5d8:	68fb      	ldr	r3, [r7, #12]
2400b5da:	64da      	str	r2, [r3, #76]	; 0x4c

    /* If Memory address size is 8Bit */
    if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400b5dc:	88fb      	ldrh	r3, [r7, #6]
2400b5de:	2b01      	cmp	r3, #1
2400b5e0:	d109      	bne.n	2400b5f6 <HAL_I2C_Mem_Write_IT+0xb6>
    {
      /* Prefetch Memory Address */
      hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400b5e2:	893b      	ldrh	r3, [r7, #8]
2400b5e4:	b2da      	uxtb	r2, r3
2400b5e6:	68fb      	ldr	r3, [r7, #12]
2400b5e8:	681b      	ldr	r3, [r3, #0]
2400b5ea:	629a      	str	r2, [r3, #40]	; 0x28

      /* Reset Memaddress content */
      hi2c->Memaddress = 0xFFFFFFFFU;
2400b5ec:	68fb      	ldr	r3, [r7, #12]
2400b5ee:	f04f 32ff 	mov.w	r2, #4294967295
2400b5f2:	651a      	str	r2, [r3, #80]	; 0x50
2400b5f4:	e00b      	b.n	2400b60e <HAL_I2C_Mem_Write_IT+0xce>
    }
    /* If Memory address size is 16Bit */
    else
    {
      /* Prefetch Memory Address (MSB part, LSB will be manage through interrupt) */
      hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400b5f6:	893b      	ldrh	r3, [r7, #8]
2400b5f8:	0a1b      	lsrs	r3, r3, #8
2400b5fa:	b29b      	uxth	r3, r3
2400b5fc:	b2da      	uxtb	r2, r3
2400b5fe:	68fb      	ldr	r3, [r7, #12]
2400b600:	681b      	ldr	r3, [r3, #0]
2400b602:	629a      	str	r2, [r3, #40]	; 0x28

      /* Prepare Memaddress buffer for LSB part */
      hi2c->Memaddress = I2C_MEM_ADD_LSB(MemAddress);
2400b604:	893b      	ldrh	r3, [r7, #8]
2400b606:	b2db      	uxtb	r3, r3
2400b608:	461a      	mov	r2, r3
2400b60a:	68fb      	ldr	r3, [r7, #12]
2400b60c:	651a      	str	r2, [r3, #80]	; 0x50
    }
    /* Send Slave Address and Memory Address */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2400b60e:	88fb      	ldrh	r3, [r7, #6]
2400b610:	b2da      	uxtb	r2, r3
2400b612:	8979      	ldrh	r1, [r7, #10]
2400b614:	4b0c      	ldr	r3, [pc, #48]	; (2400b648 <HAL_I2C_Mem_Write_IT+0x108>)
2400b616:	9300      	str	r3, [sp, #0]
2400b618:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b61c:	68f8      	ldr	r0, [r7, #12]
2400b61e:	f003 fe83 	bl	2400f328 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b622:	68fb      	ldr	r3, [r7, #12]
2400b624:	2200      	movs	r2, #0
2400b626:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b62a:	2101      	movs	r1, #1
2400b62c:	68f8      	ldr	r0, [r7, #12]
2400b62e:	f003 fead 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400b632:	2300      	movs	r3, #0
2400b634:	e000      	b.n	2400b638 <HAL_I2C_Mem_Write_IT+0xf8>
  }
  else
  {
    return HAL_BUSY;
2400b636:	2302      	movs	r3, #2
  }
}
2400b638:	4618      	mov	r0, r3
2400b63a:	3710      	adds	r7, #16
2400b63c:	46bd      	mov	sp, r7
2400b63e:	bd80      	pop	{r7, pc}
2400b640:	ffff0000 	.word	0xffff0000
2400b644:	2400d0ad 	.word	0x2400d0ad
2400b648:	80002000 	.word	0x80002000

2400b64c <HAL_I2C_Mem_Read_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                      uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400b64c:	b580      	push	{r7, lr}
2400b64e:	b086      	sub	sp, #24
2400b650:	af02      	add	r7, sp, #8
2400b652:	60f8      	str	r0, [r7, #12]
2400b654:	4608      	mov	r0, r1
2400b656:	4611      	mov	r1, r2
2400b658:	461a      	mov	r2, r3
2400b65a:	4603      	mov	r3, r0
2400b65c:	817b      	strh	r3, [r7, #10]
2400b65e:	460b      	mov	r3, r1
2400b660:	813b      	strh	r3, [r7, #8]
2400b662:	4613      	mov	r3, r2
2400b664:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b666:	68fb      	ldr	r3, [r7, #12]
2400b668:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b66c:	b2db      	uxtb	r3, r3
2400b66e:	2b20      	cmp	r3, #32
2400b670:	d166      	bne.n	2400b740 <HAL_I2C_Mem_Read_IT+0xf4>
  {
    if ((pData == NULL) || (Size == 0U))
2400b672:	69bb      	ldr	r3, [r7, #24]
2400b674:	2b00      	cmp	r3, #0
2400b676:	d002      	beq.n	2400b67e <HAL_I2C_Mem_Read_IT+0x32>
2400b678:	8bbb      	ldrh	r3, [r7, #28]
2400b67a:	2b00      	cmp	r3, #0
2400b67c:	d105      	bne.n	2400b68a <HAL_I2C_Mem_Read_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b67e:	68fb      	ldr	r3, [r7, #12]
2400b680:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b684:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b686:	2301      	movs	r3, #1
2400b688:	e05b      	b.n	2400b742 <HAL_I2C_Mem_Read_IT+0xf6>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400b68a:	68fb      	ldr	r3, [r7, #12]
2400b68c:	681b      	ldr	r3, [r3, #0]
2400b68e:	699b      	ldr	r3, [r3, #24]
2400b690:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b694:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b698:	d101      	bne.n	2400b69e <HAL_I2C_Mem_Read_IT+0x52>
    {
      return HAL_BUSY;
2400b69a:	2302      	movs	r3, #2
2400b69c:	e051      	b.n	2400b742 <HAL_I2C_Mem_Read_IT+0xf6>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b69e:	68fb      	ldr	r3, [r7, #12]
2400b6a0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b6a4:	2b01      	cmp	r3, #1
2400b6a6:	d101      	bne.n	2400b6ac <HAL_I2C_Mem_Read_IT+0x60>
2400b6a8:	2302      	movs	r3, #2
2400b6aa:	e04a      	b.n	2400b742 <HAL_I2C_Mem_Read_IT+0xf6>
2400b6ac:	68fb      	ldr	r3, [r7, #12]
2400b6ae:	2201      	movs	r2, #1
2400b6b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400b6b4:	68fb      	ldr	r3, [r7, #12]
2400b6b6:	2222      	movs	r2, #34	; 0x22
2400b6b8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400b6bc:	68fb      	ldr	r3, [r7, #12]
2400b6be:	2240      	movs	r2, #64	; 0x40
2400b6c0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400b6c4:	68fb      	ldr	r3, [r7, #12]
2400b6c6:	2200      	movs	r2, #0
2400b6c8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b6ca:	68fb      	ldr	r3, [r7, #12]
2400b6cc:	69ba      	ldr	r2, [r7, #24]
2400b6ce:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b6d0:	68fb      	ldr	r3, [r7, #12]
2400b6d2:	8bba      	ldrh	r2, [r7, #28]
2400b6d4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400b6d6:	68fb      	ldr	r3, [r7, #12]
2400b6d8:	4a1c      	ldr	r2, [pc, #112]	; (2400b74c <HAL_I2C_Mem_Read_IT+0x100>)
2400b6da:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Mem_ISR_IT;
2400b6dc:	68fb      	ldr	r3, [r7, #12]
2400b6de:	4a1c      	ldr	r2, [pc, #112]	; (2400b750 <HAL_I2C_Mem_Read_IT+0x104>)
2400b6e0:	635a      	str	r2, [r3, #52]	; 0x34
    hi2c->Devaddress  = DevAddress;
2400b6e2:	897a      	ldrh	r2, [r7, #10]
2400b6e4:	68fb      	ldr	r3, [r7, #12]
2400b6e6:	64da      	str	r2, [r3, #76]	; 0x4c

    /* If Memory address size is 8Bit */
    if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400b6e8:	88fb      	ldrh	r3, [r7, #6]
2400b6ea:	2b01      	cmp	r3, #1
2400b6ec:	d109      	bne.n	2400b702 <HAL_I2C_Mem_Read_IT+0xb6>
    {
      /* Prefetch Memory Address */
      hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400b6ee:	893b      	ldrh	r3, [r7, #8]
2400b6f0:	b2da      	uxtb	r2, r3
2400b6f2:	68fb      	ldr	r3, [r7, #12]
2400b6f4:	681b      	ldr	r3, [r3, #0]
2400b6f6:	629a      	str	r2, [r3, #40]	; 0x28

      /* Reset Memaddress content */
      hi2c->Memaddress = 0xFFFFFFFFU;
2400b6f8:	68fb      	ldr	r3, [r7, #12]
2400b6fa:	f04f 32ff 	mov.w	r2, #4294967295
2400b6fe:	651a      	str	r2, [r3, #80]	; 0x50
2400b700:	e00b      	b.n	2400b71a <HAL_I2C_Mem_Read_IT+0xce>
    }
    /* If Memory address size is 16Bit */
    else
    {
      /* Prefetch Memory Address (MSB part, LSB will be manage through interrupt) */
      hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400b702:	893b      	ldrh	r3, [r7, #8]
2400b704:	0a1b      	lsrs	r3, r3, #8
2400b706:	b29b      	uxth	r3, r3
2400b708:	b2da      	uxtb	r2, r3
2400b70a:	68fb      	ldr	r3, [r7, #12]
2400b70c:	681b      	ldr	r3, [r3, #0]
2400b70e:	629a      	str	r2, [r3, #40]	; 0x28

      /* Prepare Memaddress buffer for LSB part */
      hi2c->Memaddress = I2C_MEM_ADD_LSB(MemAddress);
2400b710:	893b      	ldrh	r3, [r7, #8]
2400b712:	b2db      	uxtb	r3, r3
2400b714:	461a      	mov	r2, r3
2400b716:	68fb      	ldr	r3, [r7, #12]
2400b718:	651a      	str	r2, [r3, #80]	; 0x50
    }
    /* Send Slave Address and Memory Address */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
2400b71a:	88fb      	ldrh	r3, [r7, #6]
2400b71c:	b2da      	uxtb	r2, r3
2400b71e:	8979      	ldrh	r1, [r7, #10]
2400b720:	4b0c      	ldr	r3, [pc, #48]	; (2400b754 <HAL_I2C_Mem_Read_IT+0x108>)
2400b722:	9300      	str	r3, [sp, #0]
2400b724:	2300      	movs	r3, #0
2400b726:	68f8      	ldr	r0, [r7, #12]
2400b728:	f003 fdfe 	bl	2400f328 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b72c:	68fb      	ldr	r3, [r7, #12]
2400b72e:	2200      	movs	r2, #0
2400b730:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, (I2C_XFER_TX_IT | I2C_XFER_RX_IT));
2400b734:	2103      	movs	r1, #3
2400b736:	68f8      	ldr	r0, [r7, #12]
2400b738:	f003 fe28 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400b73c:	2300      	movs	r3, #0
2400b73e:	e000      	b.n	2400b742 <HAL_I2C_Mem_Read_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400b740:	2302      	movs	r3, #2
  }
}
2400b742:	4618      	mov	r0, r3
2400b744:	3710      	adds	r7, #16
2400b746:	46bd      	mov	sp, r7
2400b748:	bd80      	pop	{r7, pc}
2400b74a:	bf00      	nop
2400b74c:	ffff0000 	.word	0xffff0000
2400b750:	2400d0ad 	.word	0x2400d0ad
2400b754:	80002000 	.word	0x80002000

2400b758 <HAL_I2C_Mem_Write_DMA>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                        uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400b758:	b580      	push	{r7, lr}
2400b75a:	b088      	sub	sp, #32
2400b75c:	af02      	add	r7, sp, #8
2400b75e:	60f8      	str	r0, [r7, #12]
2400b760:	4608      	mov	r0, r1
2400b762:	4611      	mov	r1, r2
2400b764:	461a      	mov	r2, r3
2400b766:	4603      	mov	r3, r0
2400b768:	817b      	strh	r3, [r7, #10]
2400b76a:	460b      	mov	r3, r1
2400b76c:	813b      	strh	r3, [r7, #8]
2400b76e:	4613      	mov	r3, r2
2400b770:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b772:	68fb      	ldr	r3, [r7, #12]
2400b774:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b778:	b2db      	uxtb	r3, r3
2400b77a:	2b20      	cmp	r3, #32
2400b77c:	f040 80c3 	bne.w	2400b906 <HAL_I2C_Mem_Write_DMA+0x1ae>
  {
    if ((pData == NULL) || (Size == 0U))
2400b780:	6a3b      	ldr	r3, [r7, #32]
2400b782:	2b00      	cmp	r3, #0
2400b784:	d002      	beq.n	2400b78c <HAL_I2C_Mem_Write_DMA+0x34>
2400b786:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400b788:	2b00      	cmp	r3, #0
2400b78a:	d105      	bne.n	2400b798 <HAL_I2C_Mem_Write_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b78c:	68fb      	ldr	r3, [r7, #12]
2400b78e:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b792:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b794:	2301      	movs	r3, #1
2400b796:	e0b7      	b.n	2400b908 <HAL_I2C_Mem_Write_DMA+0x1b0>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400b798:	68fb      	ldr	r3, [r7, #12]
2400b79a:	681b      	ldr	r3, [r3, #0]
2400b79c:	699b      	ldr	r3, [r3, #24]
2400b79e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b7a2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b7a6:	d101      	bne.n	2400b7ac <HAL_I2C_Mem_Write_DMA+0x54>
    {
      return HAL_BUSY;
2400b7a8:	2302      	movs	r3, #2
2400b7aa:	e0ad      	b.n	2400b908 <HAL_I2C_Mem_Write_DMA+0x1b0>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b7ac:	68fb      	ldr	r3, [r7, #12]
2400b7ae:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b7b2:	2b01      	cmp	r3, #1
2400b7b4:	d101      	bne.n	2400b7ba <HAL_I2C_Mem_Write_DMA+0x62>
2400b7b6:	2302      	movs	r3, #2
2400b7b8:	e0a6      	b.n	2400b908 <HAL_I2C_Mem_Write_DMA+0x1b0>
2400b7ba:	68fb      	ldr	r3, [r7, #12]
2400b7bc:	2201      	movs	r2, #1
2400b7be:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400b7c2:	68fb      	ldr	r3, [r7, #12]
2400b7c4:	2221      	movs	r2, #33	; 0x21
2400b7c6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400b7ca:	68fb      	ldr	r3, [r7, #12]
2400b7cc:	2240      	movs	r2, #64	; 0x40
2400b7ce:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400b7d2:	68fb      	ldr	r3, [r7, #12]
2400b7d4:	2200      	movs	r2, #0
2400b7d6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b7d8:	68fb      	ldr	r3, [r7, #12]
2400b7da:	6a3a      	ldr	r2, [r7, #32]
2400b7dc:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b7de:	68fb      	ldr	r3, [r7, #12]
2400b7e0:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400b7e2:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400b7e4:	68fb      	ldr	r3, [r7, #12]
2400b7e6:	4a4a      	ldr	r2, [pc, #296]	; (2400b910 <HAL_I2C_Mem_Write_DMA+0x1b8>)
2400b7e8:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Mem_ISR_DMA;
2400b7ea:	68fb      	ldr	r3, [r7, #12]
2400b7ec:	4a49      	ldr	r2, [pc, #292]	; (2400b914 <HAL_I2C_Mem_Write_DMA+0x1bc>)
2400b7ee:	635a      	str	r2, [r3, #52]	; 0x34
    hi2c->Devaddress  = DevAddress;
2400b7f0:	897a      	ldrh	r2, [r7, #10]
2400b7f2:	68fb      	ldr	r3, [r7, #12]
2400b7f4:	64da      	str	r2, [r3, #76]	; 0x4c

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b7f6:	68fb      	ldr	r3, [r7, #12]
2400b7f8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b7fa:	b29b      	uxth	r3, r3
2400b7fc:	2bff      	cmp	r3, #255	; 0xff
2400b7fe:	d903      	bls.n	2400b808 <HAL_I2C_Mem_Write_DMA+0xb0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b800:	68fb      	ldr	r3, [r7, #12]
2400b802:	22ff      	movs	r2, #255	; 0xff
2400b804:	851a      	strh	r2, [r3, #40]	; 0x28
2400b806:	e004      	b.n	2400b812 <HAL_I2C_Mem_Write_DMA+0xba>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b808:	68fb      	ldr	r3, [r7, #12]
2400b80a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b80c:	b29a      	uxth	r2, r3
2400b80e:	68fb      	ldr	r3, [r7, #12]
2400b810:	851a      	strh	r2, [r3, #40]	; 0x28
    }

    /* If Memory address size is 8Bit */
    if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400b812:	88fb      	ldrh	r3, [r7, #6]
2400b814:	2b01      	cmp	r3, #1
2400b816:	d109      	bne.n	2400b82c <HAL_I2C_Mem_Write_DMA+0xd4>
    {
      /* Prefetch Memory Address */
      hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400b818:	893b      	ldrh	r3, [r7, #8]
2400b81a:	b2da      	uxtb	r2, r3
2400b81c:	68fb      	ldr	r3, [r7, #12]
2400b81e:	681b      	ldr	r3, [r3, #0]
2400b820:	629a      	str	r2, [r3, #40]	; 0x28

      /* Reset Memaddress content */
      hi2c->Memaddress = 0xFFFFFFFFU;
2400b822:	68fb      	ldr	r3, [r7, #12]
2400b824:	f04f 32ff 	mov.w	r2, #4294967295
2400b828:	651a      	str	r2, [r3, #80]	; 0x50
2400b82a:	e00b      	b.n	2400b844 <HAL_I2C_Mem_Write_DMA+0xec>
    }
    /* If Memory address size is 16Bit */
    else
    {
      /* Prefetch Memory Address (MSB part, LSB will be manage through interrupt) */
      hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400b82c:	893b      	ldrh	r3, [r7, #8]
2400b82e:	0a1b      	lsrs	r3, r3, #8
2400b830:	b29b      	uxth	r3, r3
2400b832:	b2da      	uxtb	r2, r3
2400b834:	68fb      	ldr	r3, [r7, #12]
2400b836:	681b      	ldr	r3, [r3, #0]
2400b838:	629a      	str	r2, [r3, #40]	; 0x28

      /* Prepare Memaddress buffer for LSB part */
      hi2c->Memaddress = I2C_MEM_ADD_LSB(MemAddress);
2400b83a:	893b      	ldrh	r3, [r7, #8]
2400b83c:	b2db      	uxtb	r3, r3
2400b83e:	461a      	mov	r2, r3
2400b840:	68fb      	ldr	r3, [r7, #12]
2400b842:	651a      	str	r2, [r3, #80]	; 0x50
    }

    if (hi2c->hdmatx != NULL)
2400b844:	68fb      	ldr	r3, [r7, #12]
2400b846:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b848:	2b00      	cmp	r3, #0
2400b84a:	d020      	beq.n	2400b88e <HAL_I2C_Mem_Write_DMA+0x136>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400b84c:	68fb      	ldr	r3, [r7, #12]
2400b84e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b850:	4a31      	ldr	r2, [pc, #196]	; (2400b918 <HAL_I2C_Mem_Write_DMA+0x1c0>)
2400b852:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400b854:	68fb      	ldr	r3, [r7, #12]
2400b856:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b858:	4a30      	ldr	r2, [pc, #192]	; (2400b91c <HAL_I2C_Mem_Write_DMA+0x1c4>)
2400b85a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400b85c:	68fb      	ldr	r3, [r7, #12]
2400b85e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b860:	2200      	movs	r2, #0
2400b862:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400b864:	68fb      	ldr	r3, [r7, #12]
2400b866:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b868:	2200      	movs	r2, #0
2400b86a:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400b86c:	68fb      	ldr	r3, [r7, #12]
2400b86e:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400b870:	6a39      	ldr	r1, [r7, #32]
2400b872:	68fb      	ldr	r3, [r7, #12]
2400b874:	681b      	ldr	r3, [r3, #0]
2400b876:	3328      	adds	r3, #40	; 0x28
2400b878:	461a      	mov	r2, r3
                                       hi2c->XferSize);
2400b87a:	68fb      	ldr	r3, [r7, #12]
2400b87c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400b87e:	f7f8 f967 	bl	24003b50 <HAL_DMA_Start_IT>
2400b882:	4603      	mov	r3, r0
2400b884:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400b886:	7dfb      	ldrb	r3, [r7, #23]
2400b888:	2b00      	cmp	r3, #0
2400b88a:	d128      	bne.n	2400b8de <HAL_I2C_Mem_Write_DMA+0x186>
2400b88c:	e013      	b.n	2400b8b6 <HAL_I2C_Mem_Write_DMA+0x15e>
      hi2c->State     = HAL_I2C_STATE_READY;
2400b88e:	68fb      	ldr	r3, [r7, #12]
2400b890:	2220      	movs	r2, #32
2400b892:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b896:	68fb      	ldr	r3, [r7, #12]
2400b898:	2200      	movs	r2, #0
2400b89a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b89e:	68fb      	ldr	r3, [r7, #12]
2400b8a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b8a2:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b8a6:	68fb      	ldr	r3, [r7, #12]
2400b8a8:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b8aa:	68fb      	ldr	r3, [r7, #12]
2400b8ac:	2200      	movs	r2, #0
2400b8ae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b8b2:	2301      	movs	r3, #1
2400b8b4:	e028      	b.n	2400b908 <HAL_I2C_Mem_Write_DMA+0x1b0>
    {
      /* Send Slave Address and Memory Address */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2400b8b6:	88fb      	ldrh	r3, [r7, #6]
2400b8b8:	b2da      	uxtb	r2, r3
2400b8ba:	8979      	ldrh	r1, [r7, #10]
2400b8bc:	4b18      	ldr	r3, [pc, #96]	; (2400b920 <HAL_I2C_Mem_Write_DMA+0x1c8>)
2400b8be:	9300      	str	r3, [sp, #0]
2400b8c0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b8c4:	68f8      	ldr	r0, [r7, #12]
2400b8c6:	f003 fd2f 	bl	2400f328 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b8ca:	68fb      	ldr	r3, [r7, #12]
2400b8cc:	2200      	movs	r2, #0
2400b8ce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b8d2:	2101      	movs	r1, #1
2400b8d4:	68f8      	ldr	r0, [r7, #12]
2400b8d6:	f003 fd59 	bl	2400f38c <I2C_Enable_IRQ>
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400b8da:	2300      	movs	r3, #0
2400b8dc:	e014      	b.n	2400b908 <HAL_I2C_Mem_Write_DMA+0x1b0>
      hi2c->State     = HAL_I2C_STATE_READY;
2400b8de:	68fb      	ldr	r3, [r7, #12]
2400b8e0:	2220      	movs	r2, #32
2400b8e2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b8e6:	68fb      	ldr	r3, [r7, #12]
2400b8e8:	2200      	movs	r2, #0
2400b8ea:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b8ee:	68fb      	ldr	r3, [r7, #12]
2400b8f0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b8f2:	f043 0210 	orr.w	r2, r3, #16
2400b8f6:	68fb      	ldr	r3, [r7, #12]
2400b8f8:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b8fa:	68fb      	ldr	r3, [r7, #12]
2400b8fc:	2200      	movs	r2, #0
2400b8fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b902:	2301      	movs	r3, #1
2400b904:	e000      	b.n	2400b908 <HAL_I2C_Mem_Write_DMA+0x1b0>
  }
  else
  {
    return HAL_BUSY;
2400b906:	2302      	movs	r3, #2
  }
}
2400b908:	4618      	mov	r0, r3
2400b90a:	3718      	adds	r7, #24
2400b90c:	46bd      	mov	sp, r7
2400b90e:	bd80      	pop	{r7, pc}
2400b910:	ffff0000 	.word	0xffff0000
2400b914:	2400d6ed 	.word	0x2400d6ed
2400b918:	2400e92f 	.word	0x2400e92f
2400b91c:	2400ec01 	.word	0x2400ec01
2400b920:	80002000 	.word	0x80002000

2400b924 <HAL_I2C_Mem_Read_DMA>:
  * @param  Size Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400b924:	b580      	push	{r7, lr}
2400b926:	b088      	sub	sp, #32
2400b928:	af02      	add	r7, sp, #8
2400b92a:	60f8      	str	r0, [r7, #12]
2400b92c:	4608      	mov	r0, r1
2400b92e:	4611      	mov	r1, r2
2400b930:	461a      	mov	r2, r3
2400b932:	4603      	mov	r3, r0
2400b934:	817b      	strh	r3, [r7, #10]
2400b936:	460b      	mov	r3, r1
2400b938:	813b      	strh	r3, [r7, #8]
2400b93a:	4613      	mov	r3, r2
2400b93c:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b93e:	68fb      	ldr	r3, [r7, #12]
2400b940:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b944:	b2db      	uxtb	r3, r3
2400b946:	2b20      	cmp	r3, #32
2400b948:	f040 80c2 	bne.w	2400bad0 <HAL_I2C_Mem_Read_DMA+0x1ac>
  {
    if ((pData == NULL) || (Size == 0U))
2400b94c:	6a3b      	ldr	r3, [r7, #32]
2400b94e:	2b00      	cmp	r3, #0
2400b950:	d002      	beq.n	2400b958 <HAL_I2C_Mem_Read_DMA+0x34>
2400b952:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400b954:	2b00      	cmp	r3, #0
2400b956:	d105      	bne.n	2400b964 <HAL_I2C_Mem_Read_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b958:	68fb      	ldr	r3, [r7, #12]
2400b95a:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b95e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b960:	2301      	movs	r3, #1
2400b962:	e0b6      	b.n	2400bad2 <HAL_I2C_Mem_Read_DMA+0x1ae>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400b964:	68fb      	ldr	r3, [r7, #12]
2400b966:	681b      	ldr	r3, [r3, #0]
2400b968:	699b      	ldr	r3, [r3, #24]
2400b96a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b96e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b972:	d101      	bne.n	2400b978 <HAL_I2C_Mem_Read_DMA+0x54>
    {
      return HAL_BUSY;
2400b974:	2302      	movs	r3, #2
2400b976:	e0ac      	b.n	2400bad2 <HAL_I2C_Mem_Read_DMA+0x1ae>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b978:	68fb      	ldr	r3, [r7, #12]
2400b97a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b97e:	2b01      	cmp	r3, #1
2400b980:	d101      	bne.n	2400b986 <HAL_I2C_Mem_Read_DMA+0x62>
2400b982:	2302      	movs	r3, #2
2400b984:	e0a5      	b.n	2400bad2 <HAL_I2C_Mem_Read_DMA+0x1ae>
2400b986:	68fb      	ldr	r3, [r7, #12]
2400b988:	2201      	movs	r2, #1
2400b98a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400b98e:	68fb      	ldr	r3, [r7, #12]
2400b990:	2222      	movs	r2, #34	; 0x22
2400b992:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400b996:	68fb      	ldr	r3, [r7, #12]
2400b998:	2240      	movs	r2, #64	; 0x40
2400b99a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400b99e:	68fb      	ldr	r3, [r7, #12]
2400b9a0:	2200      	movs	r2, #0
2400b9a2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b9a4:	68fb      	ldr	r3, [r7, #12]
2400b9a6:	6a3a      	ldr	r2, [r7, #32]
2400b9a8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b9aa:	68fb      	ldr	r3, [r7, #12]
2400b9ac:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400b9ae:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400b9b0:	68fb      	ldr	r3, [r7, #12]
2400b9b2:	4a4a      	ldr	r2, [pc, #296]	; (2400badc <HAL_I2C_Mem_Read_DMA+0x1b8>)
2400b9b4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Mem_ISR_DMA;
2400b9b6:	68fb      	ldr	r3, [r7, #12]
2400b9b8:	4a49      	ldr	r2, [pc, #292]	; (2400bae0 <HAL_I2C_Mem_Read_DMA+0x1bc>)
2400b9ba:	635a      	str	r2, [r3, #52]	; 0x34
    hi2c->Devaddress  = DevAddress;
2400b9bc:	897a      	ldrh	r2, [r7, #10]
2400b9be:	68fb      	ldr	r3, [r7, #12]
2400b9c0:	64da      	str	r2, [r3, #76]	; 0x4c

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b9c2:	68fb      	ldr	r3, [r7, #12]
2400b9c4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b9c6:	b29b      	uxth	r3, r3
2400b9c8:	2bff      	cmp	r3, #255	; 0xff
2400b9ca:	d903      	bls.n	2400b9d4 <HAL_I2C_Mem_Read_DMA+0xb0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b9cc:	68fb      	ldr	r3, [r7, #12]
2400b9ce:	22ff      	movs	r2, #255	; 0xff
2400b9d0:	851a      	strh	r2, [r3, #40]	; 0x28
2400b9d2:	e004      	b.n	2400b9de <HAL_I2C_Mem_Read_DMA+0xba>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b9d4:	68fb      	ldr	r3, [r7, #12]
2400b9d6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b9d8:	b29a      	uxth	r2, r3
2400b9da:	68fb      	ldr	r3, [r7, #12]
2400b9dc:	851a      	strh	r2, [r3, #40]	; 0x28
    }

    /* If Memory address size is 8Bit */
    if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400b9de:	88fb      	ldrh	r3, [r7, #6]
2400b9e0:	2b01      	cmp	r3, #1
2400b9e2:	d109      	bne.n	2400b9f8 <HAL_I2C_Mem_Read_DMA+0xd4>
    {
      /* Prefetch Memory Address */
      hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400b9e4:	893b      	ldrh	r3, [r7, #8]
2400b9e6:	b2da      	uxtb	r2, r3
2400b9e8:	68fb      	ldr	r3, [r7, #12]
2400b9ea:	681b      	ldr	r3, [r3, #0]
2400b9ec:	629a      	str	r2, [r3, #40]	; 0x28

      /* Reset Memaddress content */
      hi2c->Memaddress = 0xFFFFFFFFU;
2400b9ee:	68fb      	ldr	r3, [r7, #12]
2400b9f0:	f04f 32ff 	mov.w	r2, #4294967295
2400b9f4:	651a      	str	r2, [r3, #80]	; 0x50
2400b9f6:	e00b      	b.n	2400ba10 <HAL_I2C_Mem_Read_DMA+0xec>
    }
    /* If Memory address size is 16Bit */
    else
    {
      /* Prefetch Memory Address (MSB part, LSB will be manage through interrupt) */
      hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400b9f8:	893b      	ldrh	r3, [r7, #8]
2400b9fa:	0a1b      	lsrs	r3, r3, #8
2400b9fc:	b29b      	uxth	r3, r3
2400b9fe:	b2da      	uxtb	r2, r3
2400ba00:	68fb      	ldr	r3, [r7, #12]
2400ba02:	681b      	ldr	r3, [r3, #0]
2400ba04:	629a      	str	r2, [r3, #40]	; 0x28

      /* Prepare Memaddress buffer for LSB part */
      hi2c->Memaddress = I2C_MEM_ADD_LSB(MemAddress);
2400ba06:	893b      	ldrh	r3, [r7, #8]
2400ba08:	b2db      	uxtb	r3, r3
2400ba0a:	461a      	mov	r2, r3
2400ba0c:	68fb      	ldr	r3, [r7, #12]
2400ba0e:	651a      	str	r2, [r3, #80]	; 0x50
    }

    if (hi2c->hdmarx != NULL)
2400ba10:	68fb      	ldr	r3, [r7, #12]
2400ba12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba14:	2b00      	cmp	r3, #0
2400ba16:	d020      	beq.n	2400ba5a <HAL_I2C_Mem_Read_DMA+0x136>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400ba18:	68fb      	ldr	r3, [r7, #12]
2400ba1a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba1c:	4a31      	ldr	r2, [pc, #196]	; (2400bae4 <HAL_I2C_Mem_Read_DMA+0x1c0>)
2400ba1e:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400ba20:	68fb      	ldr	r3, [r7, #12]
2400ba22:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba24:	4a30      	ldr	r2, [pc, #192]	; (2400bae8 <HAL_I2C_Mem_Read_DMA+0x1c4>)
2400ba26:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400ba28:	68fb      	ldr	r3, [r7, #12]
2400ba2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba2c:	2200      	movs	r2, #0
2400ba2e:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400ba30:	68fb      	ldr	r3, [r7, #12]
2400ba32:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba34:	2200      	movs	r2, #0
2400ba36:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400ba38:	68fb      	ldr	r3, [r7, #12]
2400ba3a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400ba3c:	68fb      	ldr	r3, [r7, #12]
2400ba3e:	681b      	ldr	r3, [r3, #0]
2400ba40:	3324      	adds	r3, #36	; 0x24
2400ba42:	4619      	mov	r1, r3
2400ba44:	6a3a      	ldr	r2, [r7, #32]
                                       hi2c->XferSize);
2400ba46:	68fb      	ldr	r3, [r7, #12]
2400ba48:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400ba4a:	f7f8 f881 	bl	24003b50 <HAL_DMA_Start_IT>
2400ba4e:	4603      	mov	r3, r0
2400ba50:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400ba52:	7dfb      	ldrb	r3, [r7, #23]
2400ba54:	2b00      	cmp	r3, #0
2400ba56:	d127      	bne.n	2400baa8 <HAL_I2C_Mem_Read_DMA+0x184>
2400ba58:	e013      	b.n	2400ba82 <HAL_I2C_Mem_Read_DMA+0x15e>
      hi2c->State     = HAL_I2C_STATE_READY;
2400ba5a:	68fb      	ldr	r3, [r7, #12]
2400ba5c:	2220      	movs	r2, #32
2400ba5e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ba62:	68fb      	ldr	r3, [r7, #12]
2400ba64:	2200      	movs	r2, #0
2400ba66:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400ba6a:	68fb      	ldr	r3, [r7, #12]
2400ba6c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ba6e:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400ba72:	68fb      	ldr	r3, [r7, #12]
2400ba74:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400ba76:	68fb      	ldr	r3, [r7, #12]
2400ba78:	2200      	movs	r2, #0
2400ba7a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400ba7e:	2301      	movs	r3, #1
2400ba80:	e027      	b.n	2400bad2 <HAL_I2C_Mem_Read_DMA+0x1ae>
    {
      /* Send Slave Address and Memory Address */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
2400ba82:	88fb      	ldrh	r3, [r7, #6]
2400ba84:	b2da      	uxtb	r2, r3
2400ba86:	8979      	ldrh	r1, [r7, #10]
2400ba88:	4b18      	ldr	r3, [pc, #96]	; (2400baec <HAL_I2C_Mem_Read_DMA+0x1c8>)
2400ba8a:	9300      	str	r3, [sp, #0]
2400ba8c:	2300      	movs	r3, #0
2400ba8e:	68f8      	ldr	r0, [r7, #12]
2400ba90:	f003 fc4a 	bl	2400f328 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400ba94:	68fb      	ldr	r3, [r7, #12]
2400ba96:	2200      	movs	r2, #0
2400ba98:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400ba9c:	2101      	movs	r1, #1
2400ba9e:	68f8      	ldr	r0, [r7, #12]
2400baa0:	f003 fc74 	bl	2400f38c <I2C_Enable_IRQ>
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400baa4:	2300      	movs	r3, #0
2400baa6:	e014      	b.n	2400bad2 <HAL_I2C_Mem_Read_DMA+0x1ae>
      hi2c->State     = HAL_I2C_STATE_READY;
2400baa8:	68fb      	ldr	r3, [r7, #12]
2400baaa:	2220      	movs	r2, #32
2400baac:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400bab0:	68fb      	ldr	r3, [r7, #12]
2400bab2:	2200      	movs	r2, #0
2400bab4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400bab8:	68fb      	ldr	r3, [r7, #12]
2400baba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400babc:	f043 0210 	orr.w	r2, r3, #16
2400bac0:	68fb      	ldr	r3, [r7, #12]
2400bac2:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400bac4:	68fb      	ldr	r3, [r7, #12]
2400bac6:	2200      	movs	r2, #0
2400bac8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bacc:	2301      	movs	r3, #1
2400bace:	e000      	b.n	2400bad2 <HAL_I2C_Mem_Read_DMA+0x1ae>
  }
  else
  {
    return HAL_BUSY;
2400bad0:	2302      	movs	r3, #2
  }
}
2400bad2:	4618      	mov	r0, r3
2400bad4:	3718      	adds	r7, #24
2400bad6:	46bd      	mov	sp, r7
2400bad8:	bd80      	pop	{r7, pc}
2400bada:	bf00      	nop
2400badc:	ffff0000 	.word	0xffff0000
2400bae0:	2400d6ed 	.word	0x2400d6ed
2400bae4:	2400ea05 	.word	0x2400ea05
2400bae8:	2400ec01 	.word	0x2400ec01
2400baec:	80002000 	.word	0x80002000

2400baf0 <HAL_I2C_IsDeviceReady>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials,
                                        uint32_t Timeout)
{
2400baf0:	b580      	push	{r7, lr}
2400baf2:	b08a      	sub	sp, #40	; 0x28
2400baf4:	af02      	add	r7, sp, #8
2400baf6:	60f8      	str	r0, [r7, #12]
2400baf8:	607a      	str	r2, [r7, #4]
2400bafa:	603b      	str	r3, [r7, #0]
2400bafc:	460b      	mov	r3, r1
2400bafe:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart;

  __IO uint32_t I2C_Trials = 0UL;
2400bb00:	2300      	movs	r3, #0
2400bb02:	617b      	str	r3, [r7, #20]

  FlagStatus tmp1;
  FlagStatus tmp2;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400bb04:	68fb      	ldr	r3, [r7, #12]
2400bb06:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bb0a:	b2db      	uxtb	r3, r3
2400bb0c:	2b20      	cmp	r3, #32
2400bb0e:	f040 80ef 	bne.w	2400bcf0 <HAL_I2C_IsDeviceReady+0x200>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400bb12:	68fb      	ldr	r3, [r7, #12]
2400bb14:	681b      	ldr	r3, [r3, #0]
2400bb16:	699b      	ldr	r3, [r3, #24]
2400bb18:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400bb1c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400bb20:	d101      	bne.n	2400bb26 <HAL_I2C_IsDeviceReady+0x36>
    {
      return HAL_BUSY;
2400bb22:	2302      	movs	r3, #2
2400bb24:	e0e5      	b.n	2400bcf2 <HAL_I2C_IsDeviceReady+0x202>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400bb26:	68fb      	ldr	r3, [r7, #12]
2400bb28:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bb2c:	2b01      	cmp	r3, #1
2400bb2e:	d101      	bne.n	2400bb34 <HAL_I2C_IsDeviceReady+0x44>
2400bb30:	2302      	movs	r3, #2
2400bb32:	e0de      	b.n	2400bcf2 <HAL_I2C_IsDeviceReady+0x202>
2400bb34:	68fb      	ldr	r3, [r7, #12]
2400bb36:	2201      	movs	r2, #1
2400bb38:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400bb3c:	68fb      	ldr	r3, [r7, #12]
2400bb3e:	2224      	movs	r2, #36	; 0x24
2400bb40:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400bb44:	68fb      	ldr	r3, [r7, #12]
2400bb46:	2200      	movs	r2, #0
2400bb48:	645a      	str	r2, [r3, #68]	; 0x44

    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
2400bb4a:	68fb      	ldr	r3, [r7, #12]
2400bb4c:	68db      	ldr	r3, [r3, #12]
2400bb4e:	2b01      	cmp	r3, #1
2400bb50:	d105      	bne.n	2400bb5e <HAL_I2C_IsDeviceReady+0x6e>
2400bb52:	897b      	ldrh	r3, [r7, #10]
2400bb54:	f3c3 0209 	ubfx	r2, r3, #0, #10
2400bb58:	4b68      	ldr	r3, [pc, #416]	; (2400bcfc <HAL_I2C_IsDeviceReady+0x20c>)
2400bb5a:	4313      	orrs	r3, r2
2400bb5c:	e004      	b.n	2400bb68 <HAL_I2C_IsDeviceReady+0x78>
2400bb5e:	897b      	ldrh	r3, [r7, #10]
2400bb60:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400bb64:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
2400bb68:	68fa      	ldr	r2, [r7, #12]
2400bb6a:	6812      	ldr	r2, [r2, #0]
2400bb6c:	6053      	str	r3, [r2, #4]

      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
      /* Wait until STOPF flag is set or a NACK flag is set*/
      tickstart = HAL_GetTick();
2400bb6e:	f7f6 fa55 	bl	2400201c <HAL_GetTick>
2400bb72:	61b8      	str	r0, [r7, #24]

      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2400bb74:	68fb      	ldr	r3, [r7, #12]
2400bb76:	681b      	ldr	r3, [r3, #0]
2400bb78:	699b      	ldr	r3, [r3, #24]
2400bb7a:	f003 0320 	and.w	r3, r3, #32
2400bb7e:	2b20      	cmp	r3, #32
2400bb80:	bf0c      	ite	eq
2400bb82:	2301      	moveq	r3, #1
2400bb84:	2300      	movne	r3, #0
2400bb86:	b2db      	uxtb	r3, r3
2400bb88:	77fb      	strb	r3, [r7, #31]
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2400bb8a:	68fb      	ldr	r3, [r7, #12]
2400bb8c:	681b      	ldr	r3, [r3, #0]
2400bb8e:	699b      	ldr	r3, [r3, #24]
2400bb90:	f003 0310 	and.w	r3, r3, #16
2400bb94:	2b10      	cmp	r3, #16
2400bb96:	bf0c      	ite	eq
2400bb98:	2301      	moveq	r3, #1
2400bb9a:	2300      	movne	r3, #0
2400bb9c:	b2db      	uxtb	r3, r3
2400bb9e:	77bb      	strb	r3, [r7, #30]

      while ((tmp1 == RESET) && (tmp2 == RESET))
2400bba0:	e034      	b.n	2400bc0c <HAL_I2C_IsDeviceReady+0x11c>
      {
        if (Timeout != HAL_MAX_DELAY)
2400bba2:	683b      	ldr	r3, [r7, #0]
2400bba4:	f1b3 3fff 	cmp.w	r3, #4294967295
2400bba8:	d01a      	beq.n	2400bbe0 <HAL_I2C_IsDeviceReady+0xf0>
        {
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400bbaa:	f7f6 fa37 	bl	2400201c <HAL_GetTick>
2400bbae:	4602      	mov	r2, r0
2400bbb0:	69bb      	ldr	r3, [r7, #24]
2400bbb2:	1ad3      	subs	r3, r2, r3
2400bbb4:	683a      	ldr	r2, [r7, #0]
2400bbb6:	429a      	cmp	r2, r3
2400bbb8:	d302      	bcc.n	2400bbc0 <HAL_I2C_IsDeviceReady+0xd0>
2400bbba:	683b      	ldr	r3, [r7, #0]
2400bbbc:	2b00      	cmp	r3, #0
2400bbbe:	d10f      	bne.n	2400bbe0 <HAL_I2C_IsDeviceReady+0xf0>
          {
            /* Update I2C state */
            hi2c->State = HAL_I2C_STATE_READY;
2400bbc0:	68fb      	ldr	r3, [r7, #12]
2400bbc2:	2220      	movs	r2, #32
2400bbc4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

            /* Update I2C error code */
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400bbc8:	68fb      	ldr	r3, [r7, #12]
2400bbca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bbcc:	f043 0220 	orr.w	r2, r3, #32
2400bbd0:	68fb      	ldr	r3, [r7, #12]
2400bbd2:	645a      	str	r2, [r3, #68]	; 0x44

            /* Process Unlocked */
            __HAL_UNLOCK(hi2c);
2400bbd4:	68fb      	ldr	r3, [r7, #12]
2400bbd6:	2200      	movs	r2, #0
2400bbd8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

            return HAL_ERROR;
2400bbdc:	2301      	movs	r3, #1
2400bbde:	e088      	b.n	2400bcf2 <HAL_I2C_IsDeviceReady+0x202>
          }
        }

        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2400bbe0:	68fb      	ldr	r3, [r7, #12]
2400bbe2:	681b      	ldr	r3, [r3, #0]
2400bbe4:	699b      	ldr	r3, [r3, #24]
2400bbe6:	f003 0320 	and.w	r3, r3, #32
2400bbea:	2b20      	cmp	r3, #32
2400bbec:	bf0c      	ite	eq
2400bbee:	2301      	moveq	r3, #1
2400bbf0:	2300      	movne	r3, #0
2400bbf2:	b2db      	uxtb	r3, r3
2400bbf4:	77fb      	strb	r3, [r7, #31]
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2400bbf6:	68fb      	ldr	r3, [r7, #12]
2400bbf8:	681b      	ldr	r3, [r3, #0]
2400bbfa:	699b      	ldr	r3, [r3, #24]
2400bbfc:	f003 0310 	and.w	r3, r3, #16
2400bc00:	2b10      	cmp	r3, #16
2400bc02:	bf0c      	ite	eq
2400bc04:	2301      	moveq	r3, #1
2400bc06:	2300      	movne	r3, #0
2400bc08:	b2db      	uxtb	r3, r3
2400bc0a:	77bb      	strb	r3, [r7, #30]
      while ((tmp1 == RESET) && (tmp2 == RESET))
2400bc0c:	7ffb      	ldrb	r3, [r7, #31]
2400bc0e:	2b00      	cmp	r3, #0
2400bc10:	d102      	bne.n	2400bc18 <HAL_I2C_IsDeviceReady+0x128>
2400bc12:	7fbb      	ldrb	r3, [r7, #30]
2400bc14:	2b00      	cmp	r3, #0
2400bc16:	d0c4      	beq.n	2400bba2 <HAL_I2C_IsDeviceReady+0xb2>
      }

      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
2400bc18:	68fb      	ldr	r3, [r7, #12]
2400bc1a:	681b      	ldr	r3, [r3, #0]
2400bc1c:	699b      	ldr	r3, [r3, #24]
2400bc1e:	f003 0310 	and.w	r3, r3, #16
2400bc22:	2b10      	cmp	r3, #16
2400bc24:	d01a      	beq.n	2400bc5c <HAL_I2C_IsDeviceReady+0x16c>
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400bc26:	69bb      	ldr	r3, [r7, #24]
2400bc28:	9300      	str	r3, [sp, #0]
2400bc2a:	683b      	ldr	r3, [r7, #0]
2400bc2c:	2200      	movs	r2, #0
2400bc2e:	2120      	movs	r1, #32
2400bc30:	68f8      	ldr	r0, [r7, #12]
2400bc32:	f003 f93d 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400bc36:	4603      	mov	r3, r0
2400bc38:	2b00      	cmp	r3, #0
2400bc3a:	d001      	beq.n	2400bc40 <HAL_I2C_IsDeviceReady+0x150>
        {
          return HAL_ERROR;
2400bc3c:	2301      	movs	r3, #1
2400bc3e:	e058      	b.n	2400bcf2 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400bc40:	68fb      	ldr	r3, [r7, #12]
2400bc42:	681b      	ldr	r3, [r3, #0]
2400bc44:	2220      	movs	r2, #32
2400bc46:	61da      	str	r2, [r3, #28]

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
2400bc48:	68fb      	ldr	r3, [r7, #12]
2400bc4a:	2220      	movs	r2, #32
2400bc4c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400bc50:	68fb      	ldr	r3, [r7, #12]
2400bc52:	2200      	movs	r2, #0
2400bc54:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_OK;
2400bc58:	2300      	movs	r3, #0
2400bc5a:	e04a      	b.n	2400bcf2 <HAL_I2C_IsDeviceReady+0x202>
      }
      else
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400bc5c:	69bb      	ldr	r3, [r7, #24]
2400bc5e:	9300      	str	r3, [sp, #0]
2400bc60:	683b      	ldr	r3, [r7, #0]
2400bc62:	2200      	movs	r2, #0
2400bc64:	2120      	movs	r1, #32
2400bc66:	68f8      	ldr	r0, [r7, #12]
2400bc68:	f003 f922 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400bc6c:	4603      	mov	r3, r0
2400bc6e:	2b00      	cmp	r3, #0
2400bc70:	d001      	beq.n	2400bc76 <HAL_I2C_IsDeviceReady+0x186>
        {
          return HAL_ERROR;
2400bc72:	2301      	movs	r3, #1
2400bc74:	e03d      	b.n	2400bcf2 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400bc76:	68fb      	ldr	r3, [r7, #12]
2400bc78:	681b      	ldr	r3, [r3, #0]
2400bc7a:	2210      	movs	r2, #16
2400bc7c:	61da      	str	r2, [r3, #28]

        /* Clear STOP Flag, auto generated with autoend*/
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400bc7e:	68fb      	ldr	r3, [r7, #12]
2400bc80:	681b      	ldr	r3, [r3, #0]
2400bc82:	2220      	movs	r2, #32
2400bc84:	61da      	str	r2, [r3, #28]
      }

      /* Check if the maximum allowed number of trials has been reached */
      if (I2C_Trials == Trials)
2400bc86:	697b      	ldr	r3, [r7, #20]
2400bc88:	687a      	ldr	r2, [r7, #4]
2400bc8a:	429a      	cmp	r2, r3
2400bc8c:	d118      	bne.n	2400bcc0 <HAL_I2C_IsDeviceReady+0x1d0>
      {
        /* Generate Stop */
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400bc8e:	68fb      	ldr	r3, [r7, #12]
2400bc90:	681b      	ldr	r3, [r3, #0]
2400bc92:	685a      	ldr	r2, [r3, #4]
2400bc94:	68fb      	ldr	r3, [r7, #12]
2400bc96:	681b      	ldr	r3, [r3, #0]
2400bc98:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400bc9c:	605a      	str	r2, [r3, #4]

        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400bc9e:	69bb      	ldr	r3, [r7, #24]
2400bca0:	9300      	str	r3, [sp, #0]
2400bca2:	683b      	ldr	r3, [r7, #0]
2400bca4:	2200      	movs	r2, #0
2400bca6:	2120      	movs	r1, #32
2400bca8:	68f8      	ldr	r0, [r7, #12]
2400bcaa:	f003 f901 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400bcae:	4603      	mov	r3, r0
2400bcb0:	2b00      	cmp	r3, #0
2400bcb2:	d001      	beq.n	2400bcb8 <HAL_I2C_IsDeviceReady+0x1c8>
        {
          return HAL_ERROR;
2400bcb4:	2301      	movs	r3, #1
2400bcb6:	e01c      	b.n	2400bcf2 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400bcb8:	68fb      	ldr	r3, [r7, #12]
2400bcba:	681b      	ldr	r3, [r3, #0]
2400bcbc:	2220      	movs	r2, #32
2400bcbe:	61da      	str	r2, [r3, #28]
      }

      /* Increment Trials */
      I2C_Trials++;
2400bcc0:	697b      	ldr	r3, [r7, #20]
2400bcc2:	3301      	adds	r3, #1
2400bcc4:	617b      	str	r3, [r7, #20]
    } while (I2C_Trials < Trials);
2400bcc6:	697b      	ldr	r3, [r7, #20]
2400bcc8:	687a      	ldr	r2, [r7, #4]
2400bcca:	429a      	cmp	r2, r3
2400bccc:	f63f af3d 	bhi.w	2400bb4a <HAL_I2C_IsDeviceReady+0x5a>

    /* Update I2C state */
    hi2c->State = HAL_I2C_STATE_READY;
2400bcd0:	68fb      	ldr	r3, [r7, #12]
2400bcd2:	2220      	movs	r2, #32
2400bcd4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Update I2C error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400bcd8:	68fb      	ldr	r3, [r7, #12]
2400bcda:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bcdc:	f043 0220 	orr.w	r2, r3, #32
2400bce0:	68fb      	ldr	r3, [r7, #12]
2400bce2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400bce4:	68fb      	ldr	r3, [r7, #12]
2400bce6:	2200      	movs	r2, #0
2400bce8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
2400bcec:	2301      	movs	r3, #1
2400bcee:	e000      	b.n	2400bcf2 <HAL_I2C_IsDeviceReady+0x202>
  }
  else
  {
    return HAL_BUSY;
2400bcf0:	2302      	movs	r3, #2
  }
}
2400bcf2:	4618      	mov	r0, r3
2400bcf4:	3720      	adds	r7, #32
2400bcf6:	46bd      	mov	sp, r7
2400bcf8:	bd80      	pop	{r7, pc}
2400bcfa:	bf00      	nop
2400bcfc:	02002000 	.word	0x02002000

2400bd00 <HAL_I2C_Master_Seq_Transmit_IT>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                                 uint16_t Size, uint32_t XferOptions)
{
2400bd00:	b580      	push	{r7, lr}
2400bd02:	b088      	sub	sp, #32
2400bd04:	af02      	add	r7, sp, #8
2400bd06:	60f8      	str	r0, [r7, #12]
2400bd08:	607a      	str	r2, [r7, #4]
2400bd0a:	461a      	mov	r2, r3
2400bd0c:	460b      	mov	r3, r1
2400bd0e:	817b      	strh	r3, [r7, #10]
2400bd10:	4613      	mov	r3, r2
2400bd12:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2400bd14:	4b3a      	ldr	r3, [pc, #232]	; (2400be00 <HAL_I2C_Master_Seq_Transmit_IT+0x100>)
2400bd16:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400bd18:	68fb      	ldr	r3, [r7, #12]
2400bd1a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bd1e:	b2db      	uxtb	r3, r3
2400bd20:	2b20      	cmp	r3, #32
2400bd22:	d167      	bne.n	2400bdf4 <HAL_I2C_Master_Seq_Transmit_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400bd24:	68fb      	ldr	r3, [r7, #12]
2400bd26:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bd2a:	2b01      	cmp	r3, #1
2400bd2c:	d101      	bne.n	2400bd32 <HAL_I2C_Master_Seq_Transmit_IT+0x32>
2400bd2e:	2302      	movs	r3, #2
2400bd30:	e061      	b.n	2400bdf6 <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
2400bd32:	68fb      	ldr	r3, [r7, #12]
2400bd34:	2201      	movs	r2, #1
2400bd36:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400bd3a:	68fb      	ldr	r3, [r7, #12]
2400bd3c:	2221      	movs	r2, #33	; 0x21
2400bd3e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400bd42:	68fb      	ldr	r3, [r7, #12]
2400bd44:	2210      	movs	r2, #16
2400bd46:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400bd4a:	68fb      	ldr	r3, [r7, #12]
2400bd4c:	2200      	movs	r2, #0
2400bd4e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400bd50:	68fb      	ldr	r3, [r7, #12]
2400bd52:	687a      	ldr	r2, [r7, #4]
2400bd54:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400bd56:	68fb      	ldr	r3, [r7, #12]
2400bd58:	893a      	ldrh	r2, [r7, #8]
2400bd5a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400bd5c:	68fb      	ldr	r3, [r7, #12]
2400bd5e:	6a3a      	ldr	r2, [r7, #32]
2400bd60:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400bd62:	68fb      	ldr	r3, [r7, #12]
2400bd64:	4a27      	ldr	r2, [pc, #156]	; (2400be04 <HAL_I2C_Master_Seq_Transmit_IT+0x104>)
2400bd66:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400bd68:	68fb      	ldr	r3, [r7, #12]
2400bd6a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bd6c:	b29b      	uxth	r3, r3
2400bd6e:	2bff      	cmp	r3, #255	; 0xff
2400bd70:	d906      	bls.n	2400bd80 <HAL_I2C_Master_Seq_Transmit_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400bd72:	68fb      	ldr	r3, [r7, #12]
2400bd74:	22ff      	movs	r2, #255	; 0xff
2400bd76:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400bd78:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400bd7c:	617b      	str	r3, [r7, #20]
2400bd7e:	e007      	b.n	2400bd90 <HAL_I2C_Master_Seq_Transmit_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400bd80:	68fb      	ldr	r3, [r7, #12]
2400bd82:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bd84:	b29a      	uxth	r2, r3
2400bd86:	68fb      	ldr	r3, [r7, #12]
2400bd88:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400bd8a:	68fb      	ldr	r3, [r7, #12]
2400bd8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400bd8e:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \
2400bd90:	68fb      	ldr	r3, [r7, #12]
2400bd92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400bd94:	2b11      	cmp	r3, #17
2400bd96:	d10e      	bne.n	2400bdb6 <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400bd98:	6a3b      	ldr	r3, [r7, #32]
2400bd9a:	2baa      	cmp	r3, #170	; 0xaa
2400bd9c:	d003      	beq.n	2400bda6 <HAL_I2C_Master_Seq_Transmit_IT+0xa6>
2400bd9e:	6a3b      	ldr	r3, [r7, #32]
2400bda0:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400bda4:	d101      	bne.n	2400bdaa <HAL_I2C_Master_Seq_Transmit_IT+0xaa>
2400bda6:	2301      	movs	r3, #1
2400bda8:	e000      	b.n	2400bdac <HAL_I2C_Master_Seq_Transmit_IT+0xac>
2400bdaa:	2300      	movs	r3, #0
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \
2400bdac:	2b00      	cmp	r3, #0
2400bdae:	d102      	bne.n	2400bdb6 <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400bdb0:	2300      	movs	r3, #0
2400bdb2:	613b      	str	r3, [r7, #16]
2400bdb4:	e00a      	b.n	2400bdcc <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400bdb6:	68f8      	ldr	r0, [r7, #12]
2400bdb8:	f003 fbb0 	bl	2400f51c <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount <= MAX_NBYTE_SIZE)
2400bdbc:	68fb      	ldr	r3, [r7, #12]
2400bdbe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bdc0:	b29b      	uxth	r3, r3
2400bdc2:	2bff      	cmp	r3, #255	; 0xff
2400bdc4:	d802      	bhi.n	2400bdcc <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2400bdc6:	68fb      	ldr	r3, [r7, #12]
2400bdc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400bdca:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to write */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400bdcc:	68fb      	ldr	r3, [r7, #12]
2400bdce:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bdd0:	b2da      	uxtb	r2, r3
2400bdd2:	8979      	ldrh	r1, [r7, #10]
2400bdd4:	693b      	ldr	r3, [r7, #16]
2400bdd6:	9300      	str	r3, [sp, #0]
2400bdd8:	697b      	ldr	r3, [r7, #20]
2400bdda:	68f8      	ldr	r0, [r7, #12]
2400bddc:	f003 faa4 	bl	2400f328 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400bde0:	68fb      	ldr	r3, [r7, #12]
2400bde2:	2200      	movs	r2, #0
2400bde4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */
    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
       I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400bde8:	2101      	movs	r1, #1
2400bdea:	68f8      	ldr	r0, [r7, #12]
2400bdec:	f003 face 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400bdf0:	2300      	movs	r3, #0
2400bdf2:	e000      	b.n	2400bdf6 <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400bdf4:	2302      	movs	r3, #2
  }
}
2400bdf6:	4618      	mov	r0, r3
2400bdf8:	3718      	adds	r7, #24
2400bdfa:	46bd      	mov	sp, r7
2400bdfc:	bd80      	pop	{r7, pc}
2400bdfe:	bf00      	nop
2400be00:	80002000 	.word	0x80002000
2400be04:	2400ce5b 	.word	0x2400ce5b

2400be08 <HAL_I2C_Master_Seq_Transmit_DMA>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                                  uint16_t Size, uint32_t XferOptions)
{
2400be08:	b580      	push	{r7, lr}
2400be0a:	b08a      	sub	sp, #40	; 0x28
2400be0c:	af02      	add	r7, sp, #8
2400be0e:	60f8      	str	r0, [r7, #12]
2400be10:	607a      	str	r2, [r7, #4]
2400be12:	461a      	mov	r2, r3
2400be14:	460b      	mov	r3, r1
2400be16:	817b      	strh	r3, [r7, #10]
2400be18:	4613      	mov	r3, r2
2400be1a:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2400be1c:	4b77      	ldr	r3, [pc, #476]	; (2400bffc <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
2400be1e:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400be20:	68fb      	ldr	r3, [r7, #12]
2400be22:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400be26:	b2db      	uxtb	r3, r3
2400be28:	2b20      	cmp	r3, #32
2400be2a:	f040 80e1 	bne.w	2400bff0 <HAL_I2C_Master_Seq_Transmit_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400be2e:	68fb      	ldr	r3, [r7, #12]
2400be30:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400be34:	2b01      	cmp	r3, #1
2400be36:	d101      	bne.n	2400be3c <HAL_I2C_Master_Seq_Transmit_DMA+0x34>
2400be38:	2302      	movs	r3, #2
2400be3a:	e0da      	b.n	2400bff2 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
2400be3c:	68fb      	ldr	r3, [r7, #12]
2400be3e:	2201      	movs	r2, #1
2400be40:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400be44:	68fb      	ldr	r3, [r7, #12]
2400be46:	2221      	movs	r2, #33	; 0x21
2400be48:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400be4c:	68fb      	ldr	r3, [r7, #12]
2400be4e:	2210      	movs	r2, #16
2400be50:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400be54:	68fb      	ldr	r3, [r7, #12]
2400be56:	2200      	movs	r2, #0
2400be58:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400be5a:	68fb      	ldr	r3, [r7, #12]
2400be5c:	687a      	ldr	r2, [r7, #4]
2400be5e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400be60:	68fb      	ldr	r3, [r7, #12]
2400be62:	893a      	ldrh	r2, [r7, #8]
2400be64:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400be66:	68fb      	ldr	r3, [r7, #12]
2400be68:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400be6a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400be6c:	68fb      	ldr	r3, [r7, #12]
2400be6e:	4a64      	ldr	r2, [pc, #400]	; (2400c000 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f8>)
2400be70:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400be72:	68fb      	ldr	r3, [r7, #12]
2400be74:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400be76:	b29b      	uxth	r3, r3
2400be78:	2bff      	cmp	r3, #255	; 0xff
2400be7a:	d906      	bls.n	2400be8a <HAL_I2C_Master_Seq_Transmit_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400be7c:	68fb      	ldr	r3, [r7, #12]
2400be7e:	22ff      	movs	r2, #255	; 0xff
2400be80:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400be82:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400be86:	61fb      	str	r3, [r7, #28]
2400be88:	e007      	b.n	2400be9a <HAL_I2C_Master_Seq_Transmit_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400be8a:	68fb      	ldr	r3, [r7, #12]
2400be8c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400be8e:	b29a      	uxth	r2, r3
2400be90:	68fb      	ldr	r3, [r7, #12]
2400be92:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400be94:	68fb      	ldr	r3, [r7, #12]
2400be96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400be98:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \
2400be9a:	68fb      	ldr	r3, [r7, #12]
2400be9c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400be9e:	2b11      	cmp	r3, #17
2400bea0:	d10e      	bne.n	2400bec0 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400bea2:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400bea4:	2baa      	cmp	r3, #170	; 0xaa
2400bea6:	d003      	beq.n	2400beb0 <HAL_I2C_Master_Seq_Transmit_DMA+0xa8>
2400bea8:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400beaa:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400beae:	d101      	bne.n	2400beb4 <HAL_I2C_Master_Seq_Transmit_DMA+0xac>
2400beb0:	2301      	movs	r3, #1
2400beb2:	e000      	b.n	2400beb6 <HAL_I2C_Master_Seq_Transmit_DMA+0xae>
2400beb4:	2300      	movs	r3, #0
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \
2400beb6:	2b00      	cmp	r3, #0
2400beb8:	d102      	bne.n	2400bec0 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400beba:	2300      	movs	r3, #0
2400bebc:	61bb      	str	r3, [r7, #24]
2400bebe:	e00a      	b.n	2400bed6 <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400bec0:	68f8      	ldr	r0, [r7, #12]
2400bec2:	f003 fb2b 	bl	2400f51c <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount <= MAX_NBYTE_SIZE)
2400bec6:	68fb      	ldr	r3, [r7, #12]
2400bec8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400beca:	b29b      	uxth	r3, r3
2400becc:	2bff      	cmp	r3, #255	; 0xff
2400bece:	d802      	bhi.n	2400bed6 <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
2400bed0:	68fb      	ldr	r3, [r7, #12]
2400bed2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400bed4:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2400bed6:	68fb      	ldr	r3, [r7, #12]
2400bed8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400beda:	2b00      	cmp	r3, #0
2400bedc:	d070      	beq.n	2400bfc0 <HAL_I2C_Master_Seq_Transmit_DMA+0x1b8>
    {
      if (hi2c->hdmatx != NULL)
2400bede:	68fb      	ldr	r3, [r7, #12]
2400bee0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400bee2:	2b00      	cmp	r3, #0
2400bee4:	d020      	beq.n	2400bf28 <HAL_I2C_Master_Seq_Transmit_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400bee6:	68fb      	ldr	r3, [r7, #12]
2400bee8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400beea:	4a46      	ldr	r2, [pc, #280]	; (2400c004 <HAL_I2C_Master_Seq_Transmit_DMA+0x1fc>)
2400beec:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400beee:	68fb      	ldr	r3, [r7, #12]
2400bef0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400bef2:	4a45      	ldr	r2, [pc, #276]	; (2400c008 <HAL_I2C_Master_Seq_Transmit_DMA+0x200>)
2400bef4:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400bef6:	68fb      	ldr	r3, [r7, #12]
2400bef8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400befa:	2200      	movs	r2, #0
2400befc:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2400befe:	68fb      	ldr	r3, [r7, #12]
2400bf00:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400bf02:	2200      	movs	r2, #0
2400bf04:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400bf06:	68fb      	ldr	r3, [r7, #12]
2400bf08:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400bf0a:	6879      	ldr	r1, [r7, #4]
2400bf0c:	68fb      	ldr	r3, [r7, #12]
2400bf0e:	681b      	ldr	r3, [r3, #0]
2400bf10:	3328      	adds	r3, #40	; 0x28
2400bf12:	461a      	mov	r2, r3
                                         hi2c->XferSize);
2400bf14:	68fb      	ldr	r3, [r7, #12]
2400bf16:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400bf18:	f7f7 fe1a 	bl	24003b50 <HAL_DMA_Start_IT>
2400bf1c:	4603      	mov	r3, r0
2400bf1e:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400bf20:	7dfb      	ldrb	r3, [r7, #23]
2400bf22:	2b00      	cmp	r3, #0
2400bf24:	d138      	bne.n	2400bf98 <HAL_I2C_Master_Seq_Transmit_DMA+0x190>
2400bf26:	e013      	b.n	2400bf50 <HAL_I2C_Master_Seq_Transmit_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
2400bf28:	68fb      	ldr	r3, [r7, #12]
2400bf2a:	2220      	movs	r2, #32
2400bf2c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400bf30:	68fb      	ldr	r3, [r7, #12]
2400bf32:	2200      	movs	r2, #0
2400bf34:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400bf38:	68fb      	ldr	r3, [r7, #12]
2400bf3a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bf3c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400bf40:	68fb      	ldr	r3, [r7, #12]
2400bf42:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400bf44:	68fb      	ldr	r3, [r7, #12]
2400bf46:	2200      	movs	r2, #0
2400bf48:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400bf4c:	2301      	movs	r3, #1
2400bf4e:	e050      	b.n	2400bff2 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to write */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400bf50:	68fb      	ldr	r3, [r7, #12]
2400bf52:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bf54:	b2da      	uxtb	r2, r3
2400bf56:	8979      	ldrh	r1, [r7, #10]
2400bf58:	69bb      	ldr	r3, [r7, #24]
2400bf5a:	9300      	str	r3, [sp, #0]
2400bf5c:	69fb      	ldr	r3, [r7, #28]
2400bf5e:	68f8      	ldr	r0, [r7, #12]
2400bf60:	f003 f9e2 	bl	2400f328 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400bf64:	68fb      	ldr	r3, [r7, #12]
2400bf66:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bf68:	b29a      	uxth	r2, r3
2400bf6a:	68fb      	ldr	r3, [r7, #12]
2400bf6c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bf6e:	1ad3      	subs	r3, r2, r3
2400bf70:	b29a      	uxth	r2, r3
2400bf72:	68fb      	ldr	r3, [r7, #12]
2400bf74:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400bf76:	68fb      	ldr	r3, [r7, #12]
2400bf78:	2200      	movs	r2, #0
2400bf7a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400bf7e:	2110      	movs	r1, #16
2400bf80:	68f8      	ldr	r0, [r7, #12]
2400bf82:	f003 fa03 	bl	2400f38c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400bf86:	68fb      	ldr	r3, [r7, #12]
2400bf88:	681b      	ldr	r3, [r3, #0]
2400bf8a:	681a      	ldr	r2, [r3, #0]
2400bf8c:	68fb      	ldr	r3, [r7, #12]
2400bf8e:	681b      	ldr	r3, [r3, #0]
2400bf90:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400bf94:	601a      	str	r2, [r3, #0]
2400bf96:	e029      	b.n	2400bfec <HAL_I2C_Master_Seq_Transmit_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400bf98:	68fb      	ldr	r3, [r7, #12]
2400bf9a:	2220      	movs	r2, #32
2400bf9c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400bfa0:	68fb      	ldr	r3, [r7, #12]
2400bfa2:	2200      	movs	r2, #0
2400bfa4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400bfa8:	68fb      	ldr	r3, [r7, #12]
2400bfaa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bfac:	f043 0210 	orr.w	r2, r3, #16
2400bfb0:	68fb      	ldr	r3, [r7, #12]
2400bfb2:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400bfb4:	68fb      	ldr	r3, [r7, #12]
2400bfb6:	2200      	movs	r2, #0
2400bfb8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400bfbc:	2301      	movs	r3, #1
2400bfbe:	e018      	b.n	2400bff2 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400bfc0:	68fb      	ldr	r3, [r7, #12]
2400bfc2:	4a12      	ldr	r2, [pc, #72]	; (2400c00c <HAL_I2C_Master_Seq_Transmit_DMA+0x204>)
2400bfc4:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400bfc6:	68fb      	ldr	r3, [r7, #12]
2400bfc8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bfca:	b2da      	uxtb	r2, r3
2400bfcc:	8979      	ldrh	r1, [r7, #10]
2400bfce:	4b0b      	ldr	r3, [pc, #44]	; (2400bffc <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
2400bfd0:	9300      	str	r3, [sp, #0]
2400bfd2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400bfd6:	68f8      	ldr	r0, [r7, #12]
2400bfd8:	f003 f9a6 	bl	2400f328 <I2C_TransferConfig>
                         I2C_GENERATE_START_WRITE);

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400bfdc:	68fb      	ldr	r3, [r7, #12]
2400bfde:	2200      	movs	r2, #0
2400bfe0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400bfe4:	2101      	movs	r1, #1
2400bfe6:	68f8      	ldr	r0, [r7, #12]
2400bfe8:	f003 f9d0 	bl	2400f38c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400bfec:	2300      	movs	r3, #0
2400bfee:	e000      	b.n	2400bff2 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2400bff0:	2302      	movs	r3, #2
  }
}
2400bff2:	4618      	mov	r0, r3
2400bff4:	3720      	adds	r7, #32
2400bff6:	46bd      	mov	sp, r7
2400bff8:	bd80      	pop	{r7, pc}
2400bffa:	bf00      	nop
2400bffc:	80002000 	.word	0x80002000
2400c000:	2400d507 	.word	0x2400d507
2400c004:	2400e92f 	.word	0x2400e92f
2400c008:	2400ec01 	.word	0x2400ec01
2400c00c:	2400ce5b 	.word	0x2400ce5b

2400c010 <HAL_I2C_Master_Seq_Receive_IT>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                                uint16_t Size, uint32_t XferOptions)
{
2400c010:	b580      	push	{r7, lr}
2400c012:	b088      	sub	sp, #32
2400c014:	af02      	add	r7, sp, #8
2400c016:	60f8      	str	r0, [r7, #12]
2400c018:	607a      	str	r2, [r7, #4]
2400c01a:	461a      	mov	r2, r3
2400c01c:	460b      	mov	r3, r1
2400c01e:	817b      	strh	r3, [r7, #10]
2400c020:	4613      	mov	r3, r2
2400c022:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2400c024:	4b3a      	ldr	r3, [pc, #232]	; (2400c110 <HAL_I2C_Master_Seq_Receive_IT+0x100>)
2400c026:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400c028:	68fb      	ldr	r3, [r7, #12]
2400c02a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c02e:	b2db      	uxtb	r3, r3
2400c030:	2b20      	cmp	r3, #32
2400c032:	d167      	bne.n	2400c104 <HAL_I2C_Master_Seq_Receive_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c034:	68fb      	ldr	r3, [r7, #12]
2400c036:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c03a:	2b01      	cmp	r3, #1
2400c03c:	d101      	bne.n	2400c042 <HAL_I2C_Master_Seq_Receive_IT+0x32>
2400c03e:	2302      	movs	r3, #2
2400c040:	e061      	b.n	2400c106 <HAL_I2C_Master_Seq_Receive_IT+0xf6>
2400c042:	68fb      	ldr	r3, [r7, #12]
2400c044:	2201      	movs	r2, #1
2400c046:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400c04a:	68fb      	ldr	r3, [r7, #12]
2400c04c:	2222      	movs	r2, #34	; 0x22
2400c04e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400c052:	68fb      	ldr	r3, [r7, #12]
2400c054:	2210      	movs	r2, #16
2400c056:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c05a:	68fb      	ldr	r3, [r7, #12]
2400c05c:	2200      	movs	r2, #0
2400c05e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c060:	68fb      	ldr	r3, [r7, #12]
2400c062:	687a      	ldr	r2, [r7, #4]
2400c064:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c066:	68fb      	ldr	r3, [r7, #12]
2400c068:	893a      	ldrh	r2, [r7, #8]
2400c06a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400c06c:	68fb      	ldr	r3, [r7, #12]
2400c06e:	6a3a      	ldr	r2, [r7, #32]
2400c070:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400c072:	68fb      	ldr	r3, [r7, #12]
2400c074:	4a27      	ldr	r2, [pc, #156]	; (2400c114 <HAL_I2C_Master_Seq_Receive_IT+0x104>)
2400c076:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c078:	68fb      	ldr	r3, [r7, #12]
2400c07a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c07c:	b29b      	uxth	r3, r3
2400c07e:	2bff      	cmp	r3, #255	; 0xff
2400c080:	d906      	bls.n	2400c090 <HAL_I2C_Master_Seq_Receive_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400c082:	68fb      	ldr	r3, [r7, #12]
2400c084:	22ff      	movs	r2, #255	; 0xff
2400c086:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400c088:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c08c:	617b      	str	r3, [r7, #20]
2400c08e:	e007      	b.n	2400c0a0 <HAL_I2C_Master_Seq_Receive_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400c090:	68fb      	ldr	r3, [r7, #12]
2400c092:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c094:	b29a      	uxth	r2, r3
2400c096:	68fb      	ldr	r3, [r7, #12]
2400c098:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400c09a:	68fb      	ldr	r3, [r7, #12]
2400c09c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c09e:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \
2400c0a0:	68fb      	ldr	r3, [r7, #12]
2400c0a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400c0a4:	2b12      	cmp	r3, #18
2400c0a6:	d10e      	bne.n	2400c0c6 <HAL_I2C_Master_Seq_Receive_IT+0xb6>
        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400c0a8:	6a3b      	ldr	r3, [r7, #32]
2400c0aa:	2baa      	cmp	r3, #170	; 0xaa
2400c0ac:	d003      	beq.n	2400c0b6 <HAL_I2C_Master_Seq_Receive_IT+0xa6>
2400c0ae:	6a3b      	ldr	r3, [r7, #32]
2400c0b0:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400c0b4:	d101      	bne.n	2400c0ba <HAL_I2C_Master_Seq_Receive_IT+0xaa>
2400c0b6:	2301      	movs	r3, #1
2400c0b8:	e000      	b.n	2400c0bc <HAL_I2C_Master_Seq_Receive_IT+0xac>
2400c0ba:	2300      	movs	r3, #0
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \
2400c0bc:	2b00      	cmp	r3, #0
2400c0be:	d102      	bne.n	2400c0c6 <HAL_I2C_Master_Seq_Receive_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400c0c0:	2300      	movs	r3, #0
2400c0c2:	613b      	str	r3, [r7, #16]
2400c0c4:	e00a      	b.n	2400c0dc <HAL_I2C_Master_Seq_Receive_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400c0c6:	68f8      	ldr	r0, [r7, #12]
2400c0c8:	f003 fa28 	bl	2400f51c <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount <= MAX_NBYTE_SIZE)
2400c0cc:	68fb      	ldr	r3, [r7, #12]
2400c0ce:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c0d0:	b29b      	uxth	r3, r3
2400c0d2:	2bff      	cmp	r3, #255	; 0xff
2400c0d4:	d802      	bhi.n	2400c0dc <HAL_I2C_Master_Seq_Receive_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2400c0d6:	68fb      	ldr	r3, [r7, #12]
2400c0d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c0da:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to read */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400c0dc:	68fb      	ldr	r3, [r7, #12]
2400c0de:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c0e0:	b2da      	uxtb	r2, r3
2400c0e2:	8979      	ldrh	r1, [r7, #10]
2400c0e4:	693b      	ldr	r3, [r7, #16]
2400c0e6:	9300      	str	r3, [sp, #0]
2400c0e8:	697b      	ldr	r3, [r7, #20]
2400c0ea:	68f8      	ldr	r0, [r7, #12]
2400c0ec:	f003 f91c 	bl	2400f328 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400c0f0:	68fb      	ldr	r3, [r7, #12]
2400c0f2:	2200      	movs	r2, #0
2400c0f4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400c0f8:	2102      	movs	r1, #2
2400c0fa:	68f8      	ldr	r0, [r7, #12]
2400c0fc:	f003 f946 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400c100:	2300      	movs	r3, #0
2400c102:	e000      	b.n	2400c106 <HAL_I2C_Master_Seq_Receive_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400c104:	2302      	movs	r3, #2
  }
}
2400c106:	4618      	mov	r0, r3
2400c108:	3718      	adds	r7, #24
2400c10a:	46bd      	mov	sp, r7
2400c10c:	bd80      	pop	{r7, pc}
2400c10e:	bf00      	nop
2400c110:	80002400 	.word	0x80002400
2400c114:	2400ce5b 	.word	0x2400ce5b

2400c118 <HAL_I2C_Master_Seq_Receive_DMA>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                                 uint16_t Size, uint32_t XferOptions)
{
2400c118:	b580      	push	{r7, lr}
2400c11a:	b08a      	sub	sp, #40	; 0x28
2400c11c:	af02      	add	r7, sp, #8
2400c11e:	60f8      	str	r0, [r7, #12]
2400c120:	607a      	str	r2, [r7, #4]
2400c122:	461a      	mov	r2, r3
2400c124:	460b      	mov	r3, r1
2400c126:	817b      	strh	r3, [r7, #10]
2400c128:	4613      	mov	r3, r2
2400c12a:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2400c12c:	4b77      	ldr	r3, [pc, #476]	; (2400c30c <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
2400c12e:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400c130:	68fb      	ldr	r3, [r7, #12]
2400c132:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c136:	b2db      	uxtb	r3, r3
2400c138:	2b20      	cmp	r3, #32
2400c13a:	f040 80e1 	bne.w	2400c300 <HAL_I2C_Master_Seq_Receive_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c13e:	68fb      	ldr	r3, [r7, #12]
2400c140:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c144:	2b01      	cmp	r3, #1
2400c146:	d101      	bne.n	2400c14c <HAL_I2C_Master_Seq_Receive_DMA+0x34>
2400c148:	2302      	movs	r3, #2
2400c14a:	e0da      	b.n	2400c302 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
2400c14c:	68fb      	ldr	r3, [r7, #12]
2400c14e:	2201      	movs	r2, #1
2400c150:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400c154:	68fb      	ldr	r3, [r7, #12]
2400c156:	2222      	movs	r2, #34	; 0x22
2400c158:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400c15c:	68fb      	ldr	r3, [r7, #12]
2400c15e:	2210      	movs	r2, #16
2400c160:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c164:	68fb      	ldr	r3, [r7, #12]
2400c166:	2200      	movs	r2, #0
2400c168:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c16a:	68fb      	ldr	r3, [r7, #12]
2400c16c:	687a      	ldr	r2, [r7, #4]
2400c16e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c170:	68fb      	ldr	r3, [r7, #12]
2400c172:	893a      	ldrh	r2, [r7, #8]
2400c174:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400c176:	68fb      	ldr	r3, [r7, #12]
2400c178:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400c17a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400c17c:	68fb      	ldr	r3, [r7, #12]
2400c17e:	4a64      	ldr	r2, [pc, #400]	; (2400c310 <HAL_I2C_Master_Seq_Receive_DMA+0x1f8>)
2400c180:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c182:	68fb      	ldr	r3, [r7, #12]
2400c184:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c186:	b29b      	uxth	r3, r3
2400c188:	2bff      	cmp	r3, #255	; 0xff
2400c18a:	d906      	bls.n	2400c19a <HAL_I2C_Master_Seq_Receive_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400c18c:	68fb      	ldr	r3, [r7, #12]
2400c18e:	22ff      	movs	r2, #255	; 0xff
2400c190:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400c192:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c196:	61fb      	str	r3, [r7, #28]
2400c198:	e007      	b.n	2400c1aa <HAL_I2C_Master_Seq_Receive_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400c19a:	68fb      	ldr	r3, [r7, #12]
2400c19c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c19e:	b29a      	uxth	r2, r3
2400c1a0:	68fb      	ldr	r3, [r7, #12]
2400c1a2:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400c1a4:	68fb      	ldr	r3, [r7, #12]
2400c1a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c1a8:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \
2400c1aa:	68fb      	ldr	r3, [r7, #12]
2400c1ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400c1ae:	2b12      	cmp	r3, #18
2400c1b0:	d10e      	bne.n	2400c1d0 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400c1b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400c1b4:	2baa      	cmp	r3, #170	; 0xaa
2400c1b6:	d003      	beq.n	2400c1c0 <HAL_I2C_Master_Seq_Receive_DMA+0xa8>
2400c1b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400c1ba:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400c1be:	d101      	bne.n	2400c1c4 <HAL_I2C_Master_Seq_Receive_DMA+0xac>
2400c1c0:	2301      	movs	r3, #1
2400c1c2:	e000      	b.n	2400c1c6 <HAL_I2C_Master_Seq_Receive_DMA+0xae>
2400c1c4:	2300      	movs	r3, #0
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \
2400c1c6:	2b00      	cmp	r3, #0
2400c1c8:	d102      	bne.n	2400c1d0 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400c1ca:	2300      	movs	r3, #0
2400c1cc:	61bb      	str	r3, [r7, #24]
2400c1ce:	e00a      	b.n	2400c1e6 <HAL_I2C_Master_Seq_Receive_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400c1d0:	68f8      	ldr	r0, [r7, #12]
2400c1d2:	f003 f9a3 	bl	2400f51c <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount <= MAX_NBYTE_SIZE)
2400c1d6:	68fb      	ldr	r3, [r7, #12]
2400c1d8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c1da:	b29b      	uxth	r3, r3
2400c1dc:	2bff      	cmp	r3, #255	; 0xff
2400c1de:	d802      	bhi.n	2400c1e6 <HAL_I2C_Master_Seq_Receive_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
2400c1e0:	68fb      	ldr	r3, [r7, #12]
2400c1e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c1e4:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2400c1e6:	68fb      	ldr	r3, [r7, #12]
2400c1e8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c1ea:	2b00      	cmp	r3, #0
2400c1ec:	d070      	beq.n	2400c2d0 <HAL_I2C_Master_Seq_Receive_DMA+0x1b8>
    {
      if (hi2c->hdmarx != NULL)
2400c1ee:	68fb      	ldr	r3, [r7, #12]
2400c1f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c1f2:	2b00      	cmp	r3, #0
2400c1f4:	d020      	beq.n	2400c238 <HAL_I2C_Master_Seq_Receive_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400c1f6:	68fb      	ldr	r3, [r7, #12]
2400c1f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c1fa:	4a46      	ldr	r2, [pc, #280]	; (2400c314 <HAL_I2C_Master_Seq_Receive_DMA+0x1fc>)
2400c1fc:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400c1fe:	68fb      	ldr	r3, [r7, #12]
2400c200:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c202:	4a45      	ldr	r2, [pc, #276]	; (2400c318 <HAL_I2C_Master_Seq_Receive_DMA+0x200>)
2400c204:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400c206:	68fb      	ldr	r3, [r7, #12]
2400c208:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c20a:	2200      	movs	r2, #0
2400c20c:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
2400c20e:	68fb      	ldr	r3, [r7, #12]
2400c210:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c212:	2200      	movs	r2, #0
2400c214:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400c216:	68fb      	ldr	r3, [r7, #12]
2400c218:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400c21a:	68fb      	ldr	r3, [r7, #12]
2400c21c:	681b      	ldr	r3, [r3, #0]
2400c21e:	3324      	adds	r3, #36	; 0x24
2400c220:	4619      	mov	r1, r3
2400c222:	687a      	ldr	r2, [r7, #4]
                                         hi2c->XferSize);
2400c224:	68fb      	ldr	r3, [r7, #12]
2400c226:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400c228:	f7f7 fc92 	bl	24003b50 <HAL_DMA_Start_IT>
2400c22c:	4603      	mov	r3, r0
2400c22e:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400c230:	7dfb      	ldrb	r3, [r7, #23]
2400c232:	2b00      	cmp	r3, #0
2400c234:	d138      	bne.n	2400c2a8 <HAL_I2C_Master_Seq_Receive_DMA+0x190>
2400c236:	e013      	b.n	2400c260 <HAL_I2C_Master_Seq_Receive_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
2400c238:	68fb      	ldr	r3, [r7, #12]
2400c23a:	2220      	movs	r2, #32
2400c23c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c240:	68fb      	ldr	r3, [r7, #12]
2400c242:	2200      	movs	r2, #0
2400c244:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400c248:	68fb      	ldr	r3, [r7, #12]
2400c24a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c24c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400c250:	68fb      	ldr	r3, [r7, #12]
2400c252:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400c254:	68fb      	ldr	r3, [r7, #12]
2400c256:	2200      	movs	r2, #0
2400c258:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400c25c:	2301      	movs	r3, #1
2400c25e:	e050      	b.n	2400c302 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to read */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400c260:	68fb      	ldr	r3, [r7, #12]
2400c262:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c264:	b2da      	uxtb	r2, r3
2400c266:	8979      	ldrh	r1, [r7, #10]
2400c268:	69bb      	ldr	r3, [r7, #24]
2400c26a:	9300      	str	r3, [sp, #0]
2400c26c:	69fb      	ldr	r3, [r7, #28]
2400c26e:	68f8      	ldr	r0, [r7, #12]
2400c270:	f003 f85a 	bl	2400f328 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400c274:	68fb      	ldr	r3, [r7, #12]
2400c276:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c278:	b29a      	uxth	r2, r3
2400c27a:	68fb      	ldr	r3, [r7, #12]
2400c27c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c27e:	1ad3      	subs	r3, r2, r3
2400c280:	b29a      	uxth	r2, r3
2400c282:	68fb      	ldr	r3, [r7, #12]
2400c284:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400c286:	68fb      	ldr	r3, [r7, #12]
2400c288:	2200      	movs	r2, #0
2400c28a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400c28e:	2110      	movs	r1, #16
2400c290:	68f8      	ldr	r0, [r7, #12]
2400c292:	f003 f87b 	bl	2400f38c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400c296:	68fb      	ldr	r3, [r7, #12]
2400c298:	681b      	ldr	r3, [r3, #0]
2400c29a:	681a      	ldr	r2, [r3, #0]
2400c29c:	68fb      	ldr	r3, [r7, #12]
2400c29e:	681b      	ldr	r3, [r3, #0]
2400c2a0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400c2a4:	601a      	str	r2, [r3, #0]
2400c2a6:	e029      	b.n	2400c2fc <HAL_I2C_Master_Seq_Receive_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400c2a8:	68fb      	ldr	r3, [r7, #12]
2400c2aa:	2220      	movs	r2, #32
2400c2ac:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c2b0:	68fb      	ldr	r3, [r7, #12]
2400c2b2:	2200      	movs	r2, #0
2400c2b4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400c2b8:	68fb      	ldr	r3, [r7, #12]
2400c2ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c2bc:	f043 0210 	orr.w	r2, r3, #16
2400c2c0:	68fb      	ldr	r3, [r7, #12]
2400c2c2:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400c2c4:	68fb      	ldr	r3, [r7, #12]
2400c2c6:	2200      	movs	r2, #0
2400c2c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400c2cc:	2301      	movs	r3, #1
2400c2ce:	e018      	b.n	2400c302 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400c2d0:	68fb      	ldr	r3, [r7, #12]
2400c2d2:	4a12      	ldr	r2, [pc, #72]	; (2400c31c <HAL_I2C_Master_Seq_Receive_DMA+0x204>)
2400c2d4:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400c2d6:	68fb      	ldr	r3, [r7, #12]
2400c2d8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c2da:	b2da      	uxtb	r2, r3
2400c2dc:	8979      	ldrh	r1, [r7, #10]
2400c2de:	4b0b      	ldr	r3, [pc, #44]	; (2400c30c <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
2400c2e0:	9300      	str	r3, [sp, #0]
2400c2e2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400c2e6:	68f8      	ldr	r0, [r7, #12]
2400c2e8:	f003 f81e 	bl	2400f328 <I2C_TransferConfig>
                         I2C_GENERATE_START_READ);

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400c2ec:	68fb      	ldr	r3, [r7, #12]
2400c2ee:	2200      	movs	r2, #0
2400c2f0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400c2f4:	2101      	movs	r1, #1
2400c2f6:	68f8      	ldr	r0, [r7, #12]
2400c2f8:	f003 f848 	bl	2400f38c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400c2fc:	2300      	movs	r3, #0
2400c2fe:	e000      	b.n	2400c302 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2400c300:	2302      	movs	r3, #2
  }
}
2400c302:	4618      	mov	r0, r3
2400c304:	3720      	adds	r7, #32
2400c306:	46bd      	mov	sp, r7
2400c308:	bd80      	pop	{r7, pc}
2400c30a:	bf00      	nop
2400c30c:	80002400 	.word	0x80002400
2400c310:	2400d507 	.word	0x2400d507
2400c314:	2400ea05 	.word	0x2400ea05
2400c318:	2400ec01 	.word	0x2400ec01
2400c31c:	2400ce5b 	.word	0x2400ce5b

2400c320 <HAL_I2C_Slave_Seq_Transmit_IT>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                                uint32_t XferOptions)
{
2400c320:	b580      	push	{r7, lr}
2400c322:	b086      	sub	sp, #24
2400c324:	af00      	add	r7, sp, #0
2400c326:	60f8      	str	r0, [r7, #12]
2400c328:	60b9      	str	r1, [r7, #8]
2400c32a:	603b      	str	r3, [r7, #0]
2400c32c:	4613      	mov	r3, r2
2400c32e:	80fb      	strh	r3, [r7, #6]
  FlagStatus tmp;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400c330:	68fb      	ldr	r3, [r7, #12]
2400c332:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c336:	b2db      	uxtb	r3, r3
2400c338:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400c33c:	2b28      	cmp	r3, #40	; 0x28
2400c33e:	f040 8098 	bne.w	2400c472 <HAL_I2C_Slave_Seq_Transmit_IT+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
2400c342:	68bb      	ldr	r3, [r7, #8]
2400c344:	2b00      	cmp	r3, #0
2400c346:	d002      	beq.n	2400c34e <HAL_I2C_Slave_Seq_Transmit_IT+0x2e>
2400c348:	88fb      	ldrh	r3, [r7, #6]
2400c34a:	2b00      	cmp	r3, #0
2400c34c:	d105      	bne.n	2400c35a <HAL_I2C_Slave_Seq_Transmit_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400c34e:	68fb      	ldr	r3, [r7, #12]
2400c350:	f44f 7200 	mov.w	r2, #512	; 0x200
2400c354:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400c356:	2301      	movs	r3, #1
2400c358:	e08c      	b.n	2400c474 <HAL_I2C_Slave_Seq_Transmit_IT+0x154>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400c35a:	f248 0101 	movw	r1, #32769	; 0x8001
2400c35e:	68f8      	ldr	r0, [r7, #12]
2400c360:	f003 f87e 	bl	2400f460 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c364:	68fb      	ldr	r3, [r7, #12]
2400c366:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c36a:	2b01      	cmp	r3, #1
2400c36c:	d101      	bne.n	2400c372 <HAL_I2C_Slave_Seq_Transmit_IT+0x52>
2400c36e:	2302      	movs	r3, #2
2400c370:	e080      	b.n	2400c474 <HAL_I2C_Slave_Seq_Transmit_IT+0x154>
2400c372:	68fb      	ldr	r3, [r7, #12]
2400c374:	2201      	movs	r2, #1
2400c376:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400c37a:	68fb      	ldr	r3, [r7, #12]
2400c37c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c380:	b2db      	uxtb	r3, r3
2400c382:	2b2a      	cmp	r3, #42	; 0x2a
2400c384:	d12a      	bne.n	2400c3dc <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400c386:	2102      	movs	r1, #2
2400c388:	68f8      	ldr	r0, [r7, #12]
2400c38a:	f003 f869 	bl	2400f460 <I2C_Disable_IRQ>

      /* Abort DMA Xfer if any */
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400c38e:	68fb      	ldr	r3, [r7, #12]
2400c390:	681b      	ldr	r3, [r3, #0]
2400c392:	681b      	ldr	r3, [r3, #0]
2400c394:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400c398:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400c39c:	d11e      	bne.n	2400c3dc <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400c39e:	68fb      	ldr	r3, [r7, #12]
2400c3a0:	681b      	ldr	r3, [r3, #0]
2400c3a2:	681a      	ldr	r2, [r3, #0]
2400c3a4:	68fb      	ldr	r3, [r7, #12]
2400c3a6:	681b      	ldr	r3, [r3, #0]
2400c3a8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c3ac:	601a      	str	r2, [r3, #0]

        if (hi2c->hdmarx != NULL)
2400c3ae:	68fb      	ldr	r3, [r7, #12]
2400c3b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c3b2:	2b00      	cmp	r3, #0
2400c3b4:	d012      	beq.n	2400c3dc <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400c3b6:	68fb      	ldr	r3, [r7, #12]
2400c3b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c3ba:	4a30      	ldr	r2, [pc, #192]	; (2400c47c <HAL_I2C_Slave_Seq_Transmit_IT+0x15c>)
2400c3bc:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400c3be:	68fb      	ldr	r3, [r7, #12]
2400c3c0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c3c2:	4618      	mov	r0, r3
2400c3c4:	f7f8 f94c 	bl	24004660 <HAL_DMA_Abort_IT>
2400c3c8:	4603      	mov	r3, r0
2400c3ca:	2b00      	cmp	r3, #0
2400c3cc:	d006      	beq.n	2400c3dc <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400c3ce:	68fb      	ldr	r3, [r7, #12]
2400c3d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c3d2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c3d4:	68fa      	ldr	r2, [r7, #12]
2400c3d6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400c3d8:	4610      	mov	r0, r2
2400c3da:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400c3dc:	68fb      	ldr	r3, [r7, #12]
2400c3de:	2229      	movs	r2, #41	; 0x29
2400c3e0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400c3e4:	68fb      	ldr	r3, [r7, #12]
2400c3e6:	2220      	movs	r2, #32
2400c3e8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c3ec:	68fb      	ldr	r3, [r7, #12]
2400c3ee:	2200      	movs	r2, #0
2400c3f0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400c3f2:	68fb      	ldr	r3, [r7, #12]
2400c3f4:	681b      	ldr	r3, [r3, #0]
2400c3f6:	685a      	ldr	r2, [r3, #4]
2400c3f8:	68fb      	ldr	r3, [r7, #12]
2400c3fa:	681b      	ldr	r3, [r3, #0]
2400c3fc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c400:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c402:	68fb      	ldr	r3, [r7, #12]
2400c404:	68ba      	ldr	r2, [r7, #8]
2400c406:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c408:	68fb      	ldr	r3, [r7, #12]
2400c40a:	88fa      	ldrh	r2, [r7, #6]
2400c40c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400c40e:	68fb      	ldr	r3, [r7, #12]
2400c410:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c412:	b29a      	uxth	r2, r3
2400c414:	68fb      	ldr	r3, [r7, #12]
2400c416:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400c418:	68fb      	ldr	r3, [r7, #12]
2400c41a:	683a      	ldr	r2, [r7, #0]
2400c41c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400c41e:	68fb      	ldr	r3, [r7, #12]
2400c420:	4a17      	ldr	r2, [pc, #92]	; (2400c480 <HAL_I2C_Slave_Seq_Transmit_IT+0x160>)
2400c422:	635a      	str	r2, [r3, #52]	; 0x34

    tmp = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
2400c424:	68fb      	ldr	r3, [r7, #12]
2400c426:	681b      	ldr	r3, [r3, #0]
2400c428:	699b      	ldr	r3, [r3, #24]
2400c42a:	f003 0308 	and.w	r3, r3, #8
2400c42e:	2b08      	cmp	r3, #8
2400c430:	bf0c      	ite	eq
2400c432:	2301      	moveq	r3, #1
2400c434:	2300      	movne	r3, #0
2400c436:	b2db      	uxtb	r3, r3
2400c438:	75fb      	strb	r3, [r7, #23]
    if ((I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE) && (tmp != RESET))
2400c43a:	68fb      	ldr	r3, [r7, #12]
2400c43c:	681b      	ldr	r3, [r3, #0]
2400c43e:	699b      	ldr	r3, [r3, #24]
2400c440:	0c1b      	lsrs	r3, r3, #16
2400c442:	b2db      	uxtb	r3, r3
2400c444:	f003 0301 	and.w	r3, r3, #1
2400c448:	b2db      	uxtb	r3, r3
2400c44a:	2b01      	cmp	r3, #1
2400c44c:	d106      	bne.n	2400c45c <HAL_I2C_Slave_Seq_Transmit_IT+0x13c>
2400c44e:	7dfb      	ldrb	r3, [r7, #23]
2400c450:	2b00      	cmp	r3, #0
2400c452:	d003      	beq.n	2400c45c <HAL_I2C_Slave_Seq_Transmit_IT+0x13c>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400c454:	68fb      	ldr	r3, [r7, #12]
2400c456:	681b      	ldr	r3, [r3, #0]
2400c458:	2208      	movs	r2, #8
2400c45a:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400c45c:	68fb      	ldr	r3, [r7, #12]
2400c45e:	2200      	movs	r2, #0
2400c460:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2400c464:	f248 0101 	movw	r1, #32769	; 0x8001
2400c468:	68f8      	ldr	r0, [r7, #12]
2400c46a:	f002 ff8f 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400c46e:	2300      	movs	r3, #0
2400c470:	e000      	b.n	2400c474 <HAL_I2C_Slave_Seq_Transmit_IT+0x154>
  }
  else
  {
    return HAL_ERROR;
2400c472:	2301      	movs	r3, #1
  }
}
2400c474:	4618      	mov	r0, r3
2400c476:	3718      	adds	r7, #24
2400c478:	46bd      	mov	sp, r7
2400c47a:	bd80      	pop	{r7, pc}
2400c47c:	2400ee75 	.word	0x2400ee75
2400c480:	2400d301 	.word	0x2400d301

2400c484 <HAL_I2C_Slave_Seq_Transmit_DMA>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                                 uint32_t XferOptions)
{
2400c484:	b580      	push	{r7, lr}
2400c486:	b086      	sub	sp, #24
2400c488:	af00      	add	r7, sp, #0
2400c48a:	60f8      	str	r0, [r7, #12]
2400c48c:	60b9      	str	r1, [r7, #8]
2400c48e:	603b      	str	r3, [r7, #0]
2400c490:	4613      	mov	r3, r2
2400c492:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400c494:	68fb      	ldr	r3, [r7, #12]
2400c496:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c49a:	b2db      	uxtb	r3, r3
2400c49c:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400c4a0:	2b28      	cmp	r3, #40	; 0x28
2400c4a2:	f040 8128 	bne.w	2400c6f6 <HAL_I2C_Slave_Seq_Transmit_DMA+0x272>
  {
    if ((pData == NULL) || (Size == 0U))
2400c4a6:	68bb      	ldr	r3, [r7, #8]
2400c4a8:	2b00      	cmp	r3, #0
2400c4aa:	d002      	beq.n	2400c4b2 <HAL_I2C_Slave_Seq_Transmit_DMA+0x2e>
2400c4ac:	88fb      	ldrh	r3, [r7, #6]
2400c4ae:	2b00      	cmp	r3, #0
2400c4b0:	d105      	bne.n	2400c4be <HAL_I2C_Slave_Seq_Transmit_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400c4b2:	68fb      	ldr	r3, [r7, #12]
2400c4b4:	f44f 7200 	mov.w	r2, #512	; 0x200
2400c4b8:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400c4ba:	2301      	movs	r3, #1
2400c4bc:	e11c      	b.n	2400c6f8 <HAL_I2C_Slave_Seq_Transmit_DMA+0x274>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c4be:	68fb      	ldr	r3, [r7, #12]
2400c4c0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c4c4:	2b01      	cmp	r3, #1
2400c4c6:	d101      	bne.n	2400c4cc <HAL_I2C_Slave_Seq_Transmit_DMA+0x48>
2400c4c8:	2302      	movs	r3, #2
2400c4ca:	e115      	b.n	2400c6f8 <HAL_I2C_Slave_Seq_Transmit_DMA+0x274>
2400c4cc:	68fb      	ldr	r3, [r7, #12]
2400c4ce:	2201      	movs	r2, #1
2400c4d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400c4d4:	f248 0101 	movw	r1, #32769	; 0x8001
2400c4d8:	68f8      	ldr	r0, [r7, #12]
2400c4da:	f002 ffc1 	bl	2400f460 <I2C_Disable_IRQ>

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400c4de:	68fb      	ldr	r3, [r7, #12]
2400c4e0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c4e4:	b2db      	uxtb	r3, r3
2400c4e6:	2b2a      	cmp	r3, #42	; 0x2a
2400c4e8:	d12b      	bne.n	2400c542 <HAL_I2C_Slave_Seq_Transmit_DMA+0xbe>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400c4ea:	2102      	movs	r1, #2
2400c4ec:	68f8      	ldr	r0, [r7, #12]
2400c4ee:	f002 ffb7 	bl	2400f460 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400c4f2:	68fb      	ldr	r3, [r7, #12]
2400c4f4:	681b      	ldr	r3, [r3, #0]
2400c4f6:	681b      	ldr	r3, [r3, #0]
2400c4f8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400c4fc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400c500:	d14c      	bne.n	2400c59c <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2400c502:	68fb      	ldr	r3, [r7, #12]
2400c504:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c506:	2b00      	cmp	r3, #0
2400c508:	d048      	beq.n	2400c59c <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400c50a:	68fb      	ldr	r3, [r7, #12]
2400c50c:	681b      	ldr	r3, [r3, #0]
2400c50e:	681a      	ldr	r2, [r3, #0]
2400c510:	68fb      	ldr	r3, [r7, #12]
2400c512:	681b      	ldr	r3, [r3, #0]
2400c514:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c518:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
          will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400c51a:	68fb      	ldr	r3, [r7, #12]
2400c51c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c51e:	4a78      	ldr	r2, [pc, #480]	; (2400c700 <HAL_I2C_Slave_Seq_Transmit_DMA+0x27c>)
2400c520:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400c522:	68fb      	ldr	r3, [r7, #12]
2400c524:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c526:	4618      	mov	r0, r3
2400c528:	f7f8 f89a 	bl	24004660 <HAL_DMA_Abort_IT>
2400c52c:	4603      	mov	r3, r0
2400c52e:	2b00      	cmp	r3, #0
2400c530:	d034      	beq.n	2400c59c <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400c532:	68fb      	ldr	r3, [r7, #12]
2400c534:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c536:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c538:	68fa      	ldr	r2, [r7, #12]
2400c53a:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400c53c:	4610      	mov	r0, r2
2400c53e:	4798      	blx	r3
2400c540:	e02c      	b.n	2400c59c <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400c542:	68fb      	ldr	r3, [r7, #12]
2400c544:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c548:	b2db      	uxtb	r3, r3
2400c54a:	2b29      	cmp	r3, #41	; 0x29
2400c54c:	d126      	bne.n	2400c59c <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400c54e:	68fb      	ldr	r3, [r7, #12]
2400c550:	681b      	ldr	r3, [r3, #0]
2400c552:	681b      	ldr	r3, [r3, #0]
2400c554:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400c558:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400c55c:	d11e      	bne.n	2400c59c <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400c55e:	68fb      	ldr	r3, [r7, #12]
2400c560:	681b      	ldr	r3, [r3, #0]
2400c562:	681a      	ldr	r2, [r3, #0]
2400c564:	68fb      	ldr	r3, [r7, #12]
2400c566:	681b      	ldr	r3, [r3, #0]
2400c568:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400c56c:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400c56e:	68fb      	ldr	r3, [r7, #12]
2400c570:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c572:	2b00      	cmp	r3, #0
2400c574:	d012      	beq.n	2400c59c <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
        {
          /* Set the I2C DMA Abort callback :
          will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400c576:	68fb      	ldr	r3, [r7, #12]
2400c578:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c57a:	4a61      	ldr	r2, [pc, #388]	; (2400c700 <HAL_I2C_Slave_Seq_Transmit_DMA+0x27c>)
2400c57c:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400c57e:	68fb      	ldr	r3, [r7, #12]
2400c580:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c582:	4618      	mov	r0, r3
2400c584:	f7f8 f86c 	bl	24004660 <HAL_DMA_Abort_IT>
2400c588:	4603      	mov	r3, r0
2400c58a:	2b00      	cmp	r3, #0
2400c58c:	d006      	beq.n	2400c59c <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400c58e:	68fb      	ldr	r3, [r7, #12]
2400c590:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c592:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c594:	68fa      	ldr	r2, [r7, #12]
2400c596:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400c598:	4610      	mov	r0, r2
2400c59a:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400c59c:	68fb      	ldr	r3, [r7, #12]
2400c59e:	2229      	movs	r2, #41	; 0x29
2400c5a0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400c5a4:	68fb      	ldr	r3, [r7, #12]
2400c5a6:	2220      	movs	r2, #32
2400c5a8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c5ac:	68fb      	ldr	r3, [r7, #12]
2400c5ae:	2200      	movs	r2, #0
2400c5b0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400c5b2:	68fb      	ldr	r3, [r7, #12]
2400c5b4:	681b      	ldr	r3, [r3, #0]
2400c5b6:	685a      	ldr	r2, [r3, #4]
2400c5b8:	68fb      	ldr	r3, [r7, #12]
2400c5ba:	681b      	ldr	r3, [r3, #0]
2400c5bc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c5c0:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c5c2:	68fb      	ldr	r3, [r7, #12]
2400c5c4:	68ba      	ldr	r2, [r7, #8]
2400c5c6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c5c8:	68fb      	ldr	r3, [r7, #12]
2400c5ca:	88fa      	ldrh	r2, [r7, #6]
2400c5cc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400c5ce:	68fb      	ldr	r3, [r7, #12]
2400c5d0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c5d2:	b29a      	uxth	r2, r3
2400c5d4:	68fb      	ldr	r3, [r7, #12]
2400c5d6:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400c5d8:	68fb      	ldr	r3, [r7, #12]
2400c5da:	683a      	ldr	r2, [r7, #0]
2400c5dc:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400c5de:	68fb      	ldr	r3, [r7, #12]
2400c5e0:	4a48      	ldr	r2, [pc, #288]	; (2400c704 <HAL_I2C_Slave_Seq_Transmit_DMA+0x280>)
2400c5e2:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
2400c5e4:	68fb      	ldr	r3, [r7, #12]
2400c5e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c5e8:	2b00      	cmp	r3, #0
2400c5ea:	d020      	beq.n	2400c62e <HAL_I2C_Slave_Seq_Transmit_DMA+0x1aa>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2400c5ec:	68fb      	ldr	r3, [r7, #12]
2400c5ee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c5f0:	4a45      	ldr	r2, [pc, #276]	; (2400c708 <HAL_I2C_Slave_Seq_Transmit_DMA+0x284>)
2400c5f2:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400c5f4:	68fb      	ldr	r3, [r7, #12]
2400c5f6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c5f8:	4a44      	ldr	r2, [pc, #272]	; (2400c70c <HAL_I2C_Slave_Seq_Transmit_DMA+0x288>)
2400c5fa:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400c5fc:	68fb      	ldr	r3, [r7, #12]
2400c5fe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c600:	2200      	movs	r2, #0
2400c602:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400c604:	68fb      	ldr	r3, [r7, #12]
2400c606:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c608:	2200      	movs	r2, #0
2400c60a:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400c60c:	68fb      	ldr	r3, [r7, #12]
2400c60e:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400c610:	68b9      	ldr	r1, [r7, #8]
2400c612:	68fb      	ldr	r3, [r7, #12]
2400c614:	681b      	ldr	r3, [r3, #0]
2400c616:	3328      	adds	r3, #40	; 0x28
2400c618:	461a      	mov	r2, r3
                                       hi2c->XferSize);
2400c61a:	68fb      	ldr	r3, [r7, #12]
2400c61c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400c61e:	f7f7 fa97 	bl	24003b50 <HAL_DMA_Start_IT>
2400c622:	4603      	mov	r3, r0
2400c624:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400c626:	7dfb      	ldrb	r3, [r7, #23]
2400c628:	2b00      	cmp	r3, #0
2400c62a:	d136      	bne.n	2400c69a <HAL_I2C_Slave_Seq_Transmit_DMA+0x216>
2400c62c:	e013      	b.n	2400c656 <HAL_I2C_Slave_Seq_Transmit_DMA+0x1d2>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400c62e:	68fb      	ldr	r3, [r7, #12]
2400c630:	2228      	movs	r2, #40	; 0x28
2400c632:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c636:	68fb      	ldr	r3, [r7, #12]
2400c638:	2200      	movs	r2, #0
2400c63a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400c63e:	68fb      	ldr	r3, [r7, #12]
2400c640:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c642:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400c646:	68fb      	ldr	r3, [r7, #12]
2400c648:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400c64a:	68fb      	ldr	r3, [r7, #12]
2400c64c:	2200      	movs	r2, #0
2400c64e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400c652:	2301      	movs	r3, #1
2400c654:	e050      	b.n	2400c6f8 <HAL_I2C_Slave_Seq_Transmit_DMA+0x274>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400c656:	68fb      	ldr	r3, [r7, #12]
2400c658:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c65a:	b29a      	uxth	r2, r3
2400c65c:	68fb      	ldr	r3, [r7, #12]
2400c65e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c660:	1ad3      	subs	r3, r2, r3
2400c662:	b29a      	uxth	r2, r3
2400c664:	68fb      	ldr	r3, [r7, #12]
2400c666:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2400c668:	68fb      	ldr	r3, [r7, #12]
2400c66a:	2200      	movs	r2, #0
2400c66c:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    tmp = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
2400c66e:	68fb      	ldr	r3, [r7, #12]
2400c670:	681b      	ldr	r3, [r3, #0]
2400c672:	699b      	ldr	r3, [r3, #24]
2400c674:	f003 0308 	and.w	r3, r3, #8
2400c678:	2b08      	cmp	r3, #8
2400c67a:	bf0c      	ite	eq
2400c67c:	2301      	moveq	r3, #1
2400c67e:	2300      	movne	r3, #0
2400c680:	b2db      	uxtb	r3, r3
2400c682:	75bb      	strb	r3, [r7, #22]
    if ((I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE) && (tmp != RESET))
2400c684:	68fb      	ldr	r3, [r7, #12]
2400c686:	681b      	ldr	r3, [r3, #0]
2400c688:	699b      	ldr	r3, [r3, #24]
2400c68a:	0c1b      	lsrs	r3, r3, #16
2400c68c:	b2db      	uxtb	r3, r3
2400c68e:	f003 0301 	and.w	r3, r3, #1
2400c692:	b2db      	uxtb	r3, r3
2400c694:	2b01      	cmp	r3, #1
2400c696:	d11b      	bne.n	2400c6d0 <HAL_I2C_Slave_Seq_Transmit_DMA+0x24c>
2400c698:	e013      	b.n	2400c6c2 <HAL_I2C_Slave_Seq_Transmit_DMA+0x23e>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400c69a:	68fb      	ldr	r3, [r7, #12]
2400c69c:	2228      	movs	r2, #40	; 0x28
2400c69e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c6a2:	68fb      	ldr	r3, [r7, #12]
2400c6a4:	2200      	movs	r2, #0
2400c6a6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400c6aa:	68fb      	ldr	r3, [r7, #12]
2400c6ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c6ae:	f043 0210 	orr.w	r2, r3, #16
2400c6b2:	68fb      	ldr	r3, [r7, #12]
2400c6b4:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400c6b6:	68fb      	ldr	r3, [r7, #12]
2400c6b8:	2200      	movs	r2, #0
2400c6ba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400c6be:	2301      	movs	r3, #1
2400c6c0:	e01a      	b.n	2400c6f8 <HAL_I2C_Slave_Seq_Transmit_DMA+0x274>
    if ((I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE) && (tmp != RESET))
2400c6c2:	7dbb      	ldrb	r3, [r7, #22]
2400c6c4:	2b00      	cmp	r3, #0
2400c6c6:	d003      	beq.n	2400c6d0 <HAL_I2C_Slave_Seq_Transmit_DMA+0x24c>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400c6c8:	68fb      	ldr	r3, [r7, #12]
2400c6ca:	681b      	ldr	r3, [r3, #0]
2400c6cc:	2208      	movs	r2, #8
2400c6ce:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400c6d0:	68fb      	ldr	r3, [r7, #12]
2400c6d2:	2200      	movs	r2, #0
2400c6d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400c6d8:	68fb      	ldr	r3, [r7, #12]
2400c6da:	681b      	ldr	r3, [r3, #0]
2400c6dc:	681a      	ldr	r2, [r3, #0]
2400c6de:	68fb      	ldr	r3, [r7, #12]
2400c6e0:	681b      	ldr	r3, [r3, #0]
2400c6e2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c6e6:	601a      	str	r2, [r3, #0]

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* Enable ERR, STOP, NACK, ADDR interrupts */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400c6e8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400c6ec:	68f8      	ldr	r0, [r7, #12]
2400c6ee:	f002 fe4d 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400c6f2:	2300      	movs	r3, #0
2400c6f4:	e000      	b.n	2400c6f8 <HAL_I2C_Slave_Seq_Transmit_DMA+0x274>
  }
  else
  {
    return HAL_ERROR;
2400c6f6:	2301      	movs	r3, #1
  }
}
2400c6f8:	4618      	mov	r0, r3
2400c6fa:	3718      	adds	r7, #24
2400c6fc:	46bd      	mov	sp, r7
2400c6fe:	bd80      	pop	{r7, pc}
2400c700:	2400ee75 	.word	0x2400ee75
2400c704:	2400d935 	.word	0x2400d935
2400c708:	2400e9c5 	.word	0x2400e9c5
2400c70c:	2400ec01 	.word	0x2400ec01

2400c710 <HAL_I2C_Slave_Seq_Receive_IT>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                               uint32_t XferOptions)
{
2400c710:	b580      	push	{r7, lr}
2400c712:	b086      	sub	sp, #24
2400c714:	af00      	add	r7, sp, #0
2400c716:	60f8      	str	r0, [r7, #12]
2400c718:	60b9      	str	r1, [r7, #8]
2400c71a:	603b      	str	r3, [r7, #0]
2400c71c:	4613      	mov	r3, r2
2400c71e:	80fb      	strh	r3, [r7, #6]
  FlagStatus tmp;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400c720:	68fb      	ldr	r3, [r7, #12]
2400c722:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c726:	b2db      	uxtb	r3, r3
2400c728:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400c72c:	2b28      	cmp	r3, #40	; 0x28
2400c72e:	f040 8098 	bne.w	2400c862 <HAL_I2C_Slave_Seq_Receive_IT+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
2400c732:	68bb      	ldr	r3, [r7, #8]
2400c734:	2b00      	cmp	r3, #0
2400c736:	d002      	beq.n	2400c73e <HAL_I2C_Slave_Seq_Receive_IT+0x2e>
2400c738:	88fb      	ldrh	r3, [r7, #6]
2400c73a:	2b00      	cmp	r3, #0
2400c73c:	d105      	bne.n	2400c74a <HAL_I2C_Slave_Seq_Receive_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400c73e:	68fb      	ldr	r3, [r7, #12]
2400c740:	f44f 7200 	mov.w	r2, #512	; 0x200
2400c744:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400c746:	2301      	movs	r3, #1
2400c748:	e08c      	b.n	2400c864 <HAL_I2C_Slave_Seq_Receive_IT+0x154>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400c74a:	f248 0102 	movw	r1, #32770	; 0x8002
2400c74e:	68f8      	ldr	r0, [r7, #12]
2400c750:	f002 fe86 	bl	2400f460 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c754:	68fb      	ldr	r3, [r7, #12]
2400c756:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c75a:	2b01      	cmp	r3, #1
2400c75c:	d101      	bne.n	2400c762 <HAL_I2C_Slave_Seq_Receive_IT+0x52>
2400c75e:	2302      	movs	r3, #2
2400c760:	e080      	b.n	2400c864 <HAL_I2C_Slave_Seq_Receive_IT+0x154>
2400c762:	68fb      	ldr	r3, [r7, #12]
2400c764:	2201      	movs	r2, #1
2400c766:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400c76a:	68fb      	ldr	r3, [r7, #12]
2400c76c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c770:	b2db      	uxtb	r3, r3
2400c772:	2b29      	cmp	r3, #41	; 0x29
2400c774:	d12a      	bne.n	2400c7cc <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400c776:	2101      	movs	r1, #1
2400c778:	68f8      	ldr	r0, [r7, #12]
2400c77a:	f002 fe71 	bl	2400f460 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400c77e:	68fb      	ldr	r3, [r7, #12]
2400c780:	681b      	ldr	r3, [r3, #0]
2400c782:	681b      	ldr	r3, [r3, #0]
2400c784:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400c788:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400c78c:	d11e      	bne.n	2400c7cc <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400c78e:	68fb      	ldr	r3, [r7, #12]
2400c790:	681b      	ldr	r3, [r3, #0]
2400c792:	681a      	ldr	r2, [r3, #0]
2400c794:	68fb      	ldr	r3, [r7, #12]
2400c796:	681b      	ldr	r3, [r3, #0]
2400c798:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400c79c:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400c79e:	68fb      	ldr	r3, [r7, #12]
2400c7a0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c7a2:	2b00      	cmp	r3, #0
2400c7a4:	d012      	beq.n	2400c7cc <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400c7a6:	68fb      	ldr	r3, [r7, #12]
2400c7a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c7aa:	4a30      	ldr	r2, [pc, #192]	; (2400c86c <HAL_I2C_Slave_Seq_Receive_IT+0x15c>)
2400c7ac:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400c7ae:	68fb      	ldr	r3, [r7, #12]
2400c7b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c7b2:	4618      	mov	r0, r3
2400c7b4:	f7f7 ff54 	bl	24004660 <HAL_DMA_Abort_IT>
2400c7b8:	4603      	mov	r3, r0
2400c7ba:	2b00      	cmp	r3, #0
2400c7bc:	d006      	beq.n	2400c7cc <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400c7be:	68fb      	ldr	r3, [r7, #12]
2400c7c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c7c2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c7c4:	68fa      	ldr	r2, [r7, #12]
2400c7c6:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400c7c8:	4610      	mov	r0, r2
2400c7ca:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400c7cc:	68fb      	ldr	r3, [r7, #12]
2400c7ce:	222a      	movs	r2, #42	; 0x2a
2400c7d0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400c7d4:	68fb      	ldr	r3, [r7, #12]
2400c7d6:	2220      	movs	r2, #32
2400c7d8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c7dc:	68fb      	ldr	r3, [r7, #12]
2400c7de:	2200      	movs	r2, #0
2400c7e0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400c7e2:	68fb      	ldr	r3, [r7, #12]
2400c7e4:	681b      	ldr	r3, [r3, #0]
2400c7e6:	685a      	ldr	r2, [r3, #4]
2400c7e8:	68fb      	ldr	r3, [r7, #12]
2400c7ea:	681b      	ldr	r3, [r3, #0]
2400c7ec:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c7f0:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c7f2:	68fb      	ldr	r3, [r7, #12]
2400c7f4:	68ba      	ldr	r2, [r7, #8]
2400c7f6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c7f8:	68fb      	ldr	r3, [r7, #12]
2400c7fa:	88fa      	ldrh	r2, [r7, #6]
2400c7fc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400c7fe:	68fb      	ldr	r3, [r7, #12]
2400c800:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c802:	b29a      	uxth	r2, r3
2400c804:	68fb      	ldr	r3, [r7, #12]
2400c806:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400c808:	68fb      	ldr	r3, [r7, #12]
2400c80a:	683a      	ldr	r2, [r7, #0]
2400c80c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400c80e:	68fb      	ldr	r3, [r7, #12]
2400c810:	4a17      	ldr	r2, [pc, #92]	; (2400c870 <HAL_I2C_Slave_Seq_Receive_IT+0x160>)
2400c812:	635a      	str	r2, [r3, #52]	; 0x34

    tmp = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
2400c814:	68fb      	ldr	r3, [r7, #12]
2400c816:	681b      	ldr	r3, [r3, #0]
2400c818:	699b      	ldr	r3, [r3, #24]
2400c81a:	f003 0308 	and.w	r3, r3, #8
2400c81e:	2b08      	cmp	r3, #8
2400c820:	bf0c      	ite	eq
2400c822:	2301      	moveq	r3, #1
2400c824:	2300      	movne	r3, #0
2400c826:	b2db      	uxtb	r3, r3
2400c828:	75fb      	strb	r3, [r7, #23]
    if ((I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT) && (tmp != RESET))
2400c82a:	68fb      	ldr	r3, [r7, #12]
2400c82c:	681b      	ldr	r3, [r3, #0]
2400c82e:	699b      	ldr	r3, [r3, #24]
2400c830:	0c1b      	lsrs	r3, r3, #16
2400c832:	b2db      	uxtb	r3, r3
2400c834:	f003 0301 	and.w	r3, r3, #1
2400c838:	b2db      	uxtb	r3, r3
2400c83a:	2b00      	cmp	r3, #0
2400c83c:	d106      	bne.n	2400c84c <HAL_I2C_Slave_Seq_Receive_IT+0x13c>
2400c83e:	7dfb      	ldrb	r3, [r7, #23]
2400c840:	2b00      	cmp	r3, #0
2400c842:	d003      	beq.n	2400c84c <HAL_I2C_Slave_Seq_Receive_IT+0x13c>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400c844:	68fb      	ldr	r3, [r7, #12]
2400c846:	681b      	ldr	r3, [r3, #0]
2400c848:	2208      	movs	r2, #8
2400c84a:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400c84c:	68fb      	ldr	r3, [r7, #12]
2400c84e:	2200      	movs	r2, #0
2400c850:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400c854:	f248 0102 	movw	r1, #32770	; 0x8002
2400c858:	68f8      	ldr	r0, [r7, #12]
2400c85a:	f002 fd97 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400c85e:	2300      	movs	r3, #0
2400c860:	e000      	b.n	2400c864 <HAL_I2C_Slave_Seq_Receive_IT+0x154>
  }
  else
  {
    return HAL_ERROR;
2400c862:	2301      	movs	r3, #1
  }
}
2400c864:	4618      	mov	r0, r3
2400c866:	3718      	adds	r7, #24
2400c868:	46bd      	mov	sp, r7
2400c86a:	bd80      	pop	{r7, pc}
2400c86c:	2400ee75 	.word	0x2400ee75
2400c870:	2400d301 	.word	0x2400d301

2400c874 <HAL_I2C_Slave_Seq_Receive_DMA>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                                uint32_t XferOptions)
{
2400c874:	b580      	push	{r7, lr}
2400c876:	b086      	sub	sp, #24
2400c878:	af00      	add	r7, sp, #0
2400c87a:	60f8      	str	r0, [r7, #12]
2400c87c:	60b9      	str	r1, [r7, #8]
2400c87e:	603b      	str	r3, [r7, #0]
2400c880:	4613      	mov	r3, r2
2400c882:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400c884:	68fb      	ldr	r3, [r7, #12]
2400c886:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c88a:	b2db      	uxtb	r3, r3
2400c88c:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400c890:	2b28      	cmp	r3, #40	; 0x28
2400c892:	f040 8128 	bne.w	2400cae6 <HAL_I2C_Slave_Seq_Receive_DMA+0x272>
  {
    if ((pData == NULL) || (Size == 0U))
2400c896:	68bb      	ldr	r3, [r7, #8]
2400c898:	2b00      	cmp	r3, #0
2400c89a:	d002      	beq.n	2400c8a2 <HAL_I2C_Slave_Seq_Receive_DMA+0x2e>
2400c89c:	88fb      	ldrh	r3, [r7, #6]
2400c89e:	2b00      	cmp	r3, #0
2400c8a0:	d105      	bne.n	2400c8ae <HAL_I2C_Slave_Seq_Receive_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400c8a2:	68fb      	ldr	r3, [r7, #12]
2400c8a4:	f44f 7200 	mov.w	r2, #512	; 0x200
2400c8a8:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400c8aa:	2301      	movs	r3, #1
2400c8ac:	e11c      	b.n	2400cae8 <HAL_I2C_Slave_Seq_Receive_DMA+0x274>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400c8ae:	f248 0102 	movw	r1, #32770	; 0x8002
2400c8b2:	68f8      	ldr	r0, [r7, #12]
2400c8b4:	f002 fdd4 	bl	2400f460 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c8b8:	68fb      	ldr	r3, [r7, #12]
2400c8ba:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c8be:	2b01      	cmp	r3, #1
2400c8c0:	d101      	bne.n	2400c8c6 <HAL_I2C_Slave_Seq_Receive_DMA+0x52>
2400c8c2:	2302      	movs	r3, #2
2400c8c4:	e110      	b.n	2400cae8 <HAL_I2C_Slave_Seq_Receive_DMA+0x274>
2400c8c6:	68fb      	ldr	r3, [r7, #12]
2400c8c8:	2201      	movs	r2, #1
2400c8ca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400c8ce:	68fb      	ldr	r3, [r7, #12]
2400c8d0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c8d4:	b2db      	uxtb	r3, r3
2400c8d6:	2b29      	cmp	r3, #41	; 0x29
2400c8d8:	d12b      	bne.n	2400c932 <HAL_I2C_Slave_Seq_Receive_DMA+0xbe>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400c8da:	2101      	movs	r1, #1
2400c8dc:	68f8      	ldr	r0, [r7, #12]
2400c8de:	f002 fdbf 	bl	2400f460 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400c8e2:	68fb      	ldr	r3, [r7, #12]
2400c8e4:	681b      	ldr	r3, [r3, #0]
2400c8e6:	681b      	ldr	r3, [r3, #0]
2400c8e8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400c8ec:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400c8f0:	d14c      	bne.n	2400c98c <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400c8f2:	68fb      	ldr	r3, [r7, #12]
2400c8f4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c8f6:	2b00      	cmp	r3, #0
2400c8f8:	d048      	beq.n	2400c98c <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400c8fa:	68fb      	ldr	r3, [r7, #12]
2400c8fc:	681b      	ldr	r3, [r3, #0]
2400c8fe:	681a      	ldr	r2, [r3, #0]
2400c900:	68fb      	ldr	r3, [r7, #12]
2400c902:	681b      	ldr	r3, [r3, #0]
2400c904:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400c908:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400c90a:	68fb      	ldr	r3, [r7, #12]
2400c90c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c90e:	4a78      	ldr	r2, [pc, #480]	; (2400caf0 <HAL_I2C_Slave_Seq_Receive_DMA+0x27c>)
2400c910:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400c912:	68fb      	ldr	r3, [r7, #12]
2400c914:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c916:	4618      	mov	r0, r3
2400c918:	f7f7 fea2 	bl	24004660 <HAL_DMA_Abort_IT>
2400c91c:	4603      	mov	r3, r0
2400c91e:	2b00      	cmp	r3, #0
2400c920:	d034      	beq.n	2400c98c <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400c922:	68fb      	ldr	r3, [r7, #12]
2400c924:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c926:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c928:	68fa      	ldr	r2, [r7, #12]
2400c92a:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400c92c:	4610      	mov	r0, r2
2400c92e:	4798      	blx	r3
2400c930:	e02c      	b.n	2400c98c <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400c932:	68fb      	ldr	r3, [r7, #12]
2400c934:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c938:	b2db      	uxtb	r3, r3
2400c93a:	2b2a      	cmp	r3, #42	; 0x2a
2400c93c:	d126      	bne.n	2400c98c <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400c93e:	68fb      	ldr	r3, [r7, #12]
2400c940:	681b      	ldr	r3, [r3, #0]
2400c942:	681b      	ldr	r3, [r3, #0]
2400c944:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400c948:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400c94c:	d11e      	bne.n	2400c98c <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400c94e:	68fb      	ldr	r3, [r7, #12]
2400c950:	681b      	ldr	r3, [r3, #0]
2400c952:	681a      	ldr	r2, [r3, #0]
2400c954:	68fb      	ldr	r3, [r7, #12]
2400c956:	681b      	ldr	r3, [r3, #0]
2400c958:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c95c:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2400c95e:	68fb      	ldr	r3, [r7, #12]
2400c960:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c962:	2b00      	cmp	r3, #0
2400c964:	d012      	beq.n	2400c98c <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400c966:	68fb      	ldr	r3, [r7, #12]
2400c968:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c96a:	4a61      	ldr	r2, [pc, #388]	; (2400caf0 <HAL_I2C_Slave_Seq_Receive_DMA+0x27c>)
2400c96c:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400c96e:	68fb      	ldr	r3, [r7, #12]
2400c970:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c972:	4618      	mov	r0, r3
2400c974:	f7f7 fe74 	bl	24004660 <HAL_DMA_Abort_IT>
2400c978:	4603      	mov	r3, r0
2400c97a:	2b00      	cmp	r3, #0
2400c97c:	d006      	beq.n	2400c98c <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400c97e:	68fb      	ldr	r3, [r7, #12]
2400c980:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c982:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c984:	68fa      	ldr	r2, [r7, #12]
2400c986:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400c988:	4610      	mov	r0, r2
2400c98a:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400c98c:	68fb      	ldr	r3, [r7, #12]
2400c98e:	222a      	movs	r2, #42	; 0x2a
2400c990:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400c994:	68fb      	ldr	r3, [r7, #12]
2400c996:	2220      	movs	r2, #32
2400c998:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c99c:	68fb      	ldr	r3, [r7, #12]
2400c99e:	2200      	movs	r2, #0
2400c9a0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400c9a2:	68fb      	ldr	r3, [r7, #12]
2400c9a4:	681b      	ldr	r3, [r3, #0]
2400c9a6:	685a      	ldr	r2, [r3, #4]
2400c9a8:	68fb      	ldr	r3, [r7, #12]
2400c9aa:	681b      	ldr	r3, [r3, #0]
2400c9ac:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c9b0:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c9b2:	68fb      	ldr	r3, [r7, #12]
2400c9b4:	68ba      	ldr	r2, [r7, #8]
2400c9b6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c9b8:	68fb      	ldr	r3, [r7, #12]
2400c9ba:	88fa      	ldrh	r2, [r7, #6]
2400c9bc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400c9be:	68fb      	ldr	r3, [r7, #12]
2400c9c0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c9c2:	b29a      	uxth	r2, r3
2400c9c4:	68fb      	ldr	r3, [r7, #12]
2400c9c6:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400c9c8:	68fb      	ldr	r3, [r7, #12]
2400c9ca:	683a      	ldr	r2, [r7, #0]
2400c9cc:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400c9ce:	68fb      	ldr	r3, [r7, #12]
2400c9d0:	4a48      	ldr	r2, [pc, #288]	; (2400caf4 <HAL_I2C_Slave_Seq_Receive_DMA+0x280>)
2400c9d2:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2400c9d4:	68fb      	ldr	r3, [r7, #12]
2400c9d6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c9d8:	2b00      	cmp	r3, #0
2400c9da:	d020      	beq.n	2400ca1e <HAL_I2C_Slave_Seq_Receive_DMA+0x1aa>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400c9dc:	68fb      	ldr	r3, [r7, #12]
2400c9de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c9e0:	4a45      	ldr	r2, [pc, #276]	; (2400caf8 <HAL_I2C_Slave_Seq_Receive_DMA+0x284>)
2400c9e2:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400c9e4:	68fb      	ldr	r3, [r7, #12]
2400c9e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c9e8:	4a44      	ldr	r2, [pc, #272]	; (2400cafc <HAL_I2C_Slave_Seq_Receive_DMA+0x288>)
2400c9ea:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400c9ec:	68fb      	ldr	r3, [r7, #12]
2400c9ee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c9f0:	2200      	movs	r2, #0
2400c9f2:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400c9f4:	68fb      	ldr	r3, [r7, #12]
2400c9f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c9f8:	2200      	movs	r2, #0
2400c9fa:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR,
2400c9fc:	68fb      	ldr	r3, [r7, #12]
2400c9fe:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400ca00:	68fb      	ldr	r3, [r7, #12]
2400ca02:	681b      	ldr	r3, [r3, #0]
2400ca04:	3324      	adds	r3, #36	; 0x24
2400ca06:	4619      	mov	r1, r3
2400ca08:	68ba      	ldr	r2, [r7, #8]
                                       (uint32_t)pData, hi2c->XferSize);
2400ca0a:	68fb      	ldr	r3, [r7, #12]
2400ca0c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR,
2400ca0e:	f7f7 f89f 	bl	24003b50 <HAL_DMA_Start_IT>
2400ca12:	4603      	mov	r3, r0
2400ca14:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400ca16:	7dfb      	ldrb	r3, [r7, #23]
2400ca18:	2b00      	cmp	r3, #0
2400ca1a:	d136      	bne.n	2400ca8a <HAL_I2C_Slave_Seq_Receive_DMA+0x216>
2400ca1c:	e013      	b.n	2400ca46 <HAL_I2C_Slave_Seq_Receive_DMA+0x1d2>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400ca1e:	68fb      	ldr	r3, [r7, #12]
2400ca20:	2228      	movs	r2, #40	; 0x28
2400ca22:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ca26:	68fb      	ldr	r3, [r7, #12]
2400ca28:	2200      	movs	r2, #0
2400ca2a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400ca2e:	68fb      	ldr	r3, [r7, #12]
2400ca30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ca32:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400ca36:	68fb      	ldr	r3, [r7, #12]
2400ca38:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400ca3a:	68fb      	ldr	r3, [r7, #12]
2400ca3c:	2200      	movs	r2, #0
2400ca3e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400ca42:	2301      	movs	r3, #1
2400ca44:	e050      	b.n	2400cae8 <HAL_I2C_Slave_Seq_Receive_DMA+0x274>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400ca46:	68fb      	ldr	r3, [r7, #12]
2400ca48:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ca4a:	b29a      	uxth	r2, r3
2400ca4c:	68fb      	ldr	r3, [r7, #12]
2400ca4e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ca50:	1ad3      	subs	r3, r2, r3
2400ca52:	b29a      	uxth	r2, r3
2400ca54:	68fb      	ldr	r3, [r7, #12]
2400ca56:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2400ca58:	68fb      	ldr	r3, [r7, #12]
2400ca5a:	2200      	movs	r2, #0
2400ca5c:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    tmp = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
2400ca5e:	68fb      	ldr	r3, [r7, #12]
2400ca60:	681b      	ldr	r3, [r3, #0]
2400ca62:	699b      	ldr	r3, [r3, #24]
2400ca64:	f003 0308 	and.w	r3, r3, #8
2400ca68:	2b08      	cmp	r3, #8
2400ca6a:	bf0c      	ite	eq
2400ca6c:	2301      	moveq	r3, #1
2400ca6e:	2300      	movne	r3, #0
2400ca70:	b2db      	uxtb	r3, r3
2400ca72:	75bb      	strb	r3, [r7, #22]
    if ((I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT) && (tmp != RESET))
2400ca74:	68fb      	ldr	r3, [r7, #12]
2400ca76:	681b      	ldr	r3, [r3, #0]
2400ca78:	699b      	ldr	r3, [r3, #24]
2400ca7a:	0c1b      	lsrs	r3, r3, #16
2400ca7c:	b2db      	uxtb	r3, r3
2400ca7e:	f003 0301 	and.w	r3, r3, #1
2400ca82:	b2db      	uxtb	r3, r3
2400ca84:	2b00      	cmp	r3, #0
2400ca86:	d11b      	bne.n	2400cac0 <HAL_I2C_Slave_Seq_Receive_DMA+0x24c>
2400ca88:	e013      	b.n	2400cab2 <HAL_I2C_Slave_Seq_Receive_DMA+0x23e>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400ca8a:	68fb      	ldr	r3, [r7, #12]
2400ca8c:	2228      	movs	r2, #40	; 0x28
2400ca8e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ca92:	68fb      	ldr	r3, [r7, #12]
2400ca94:	2200      	movs	r2, #0
2400ca96:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400ca9a:	68fb      	ldr	r3, [r7, #12]
2400ca9c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ca9e:	f043 0210 	orr.w	r2, r3, #16
2400caa2:	68fb      	ldr	r3, [r7, #12]
2400caa4:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400caa6:	68fb      	ldr	r3, [r7, #12]
2400caa8:	2200      	movs	r2, #0
2400caaa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400caae:	2301      	movs	r3, #1
2400cab0:	e01a      	b.n	2400cae8 <HAL_I2C_Slave_Seq_Receive_DMA+0x274>
    if ((I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT) && (tmp != RESET))
2400cab2:	7dbb      	ldrb	r3, [r7, #22]
2400cab4:	2b00      	cmp	r3, #0
2400cab6:	d003      	beq.n	2400cac0 <HAL_I2C_Slave_Seq_Receive_DMA+0x24c>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400cab8:	68fb      	ldr	r3, [r7, #12]
2400caba:	681b      	ldr	r3, [r3, #0]
2400cabc:	2208      	movs	r2, #8
2400cabe:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400cac0:	68fb      	ldr	r3, [r7, #12]
2400cac2:	2200      	movs	r2, #0
2400cac4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400cac8:	68fb      	ldr	r3, [r7, #12]
2400caca:	681b      	ldr	r3, [r3, #0]
2400cacc:	681a      	ldr	r2, [r3, #0]
2400cace:	68fb      	ldr	r3, [r7, #12]
2400cad0:	681b      	ldr	r3, [r3, #0]
2400cad2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400cad6:	601a      	str	r2, [r3, #0]

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400cad8:	f248 0102 	movw	r1, #32770	; 0x8002
2400cadc:	68f8      	ldr	r0, [r7, #12]
2400cade:	f002 fc55 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400cae2:	2300      	movs	r3, #0
2400cae4:	e000      	b.n	2400cae8 <HAL_I2C_Slave_Seq_Receive_DMA+0x274>
  }
  else
  {
    return HAL_ERROR;
2400cae6:	2301      	movs	r3, #1
  }
}
2400cae8:	4618      	mov	r0, r3
2400caea:	3718      	adds	r7, #24
2400caec:	46bd      	mov	sp, r7
2400caee:	bd80      	pop	{r7, pc}
2400caf0:	2400ee75 	.word	0x2400ee75
2400caf4:	2400d935 	.word	0x2400d935
2400caf8:	2400ea9d 	.word	0x2400ea9d
2400cafc:	2400ec01 	.word	0x2400ec01

2400cb00 <HAL_I2C_EnableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
{
2400cb00:	b580      	push	{r7, lr}
2400cb02:	b082      	sub	sp, #8
2400cb04:	af00      	add	r7, sp, #0
2400cb06:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400cb08:	687b      	ldr	r3, [r7, #4]
2400cb0a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cb0e:	b2db      	uxtb	r3, r3
2400cb10:	2b20      	cmp	r3, #32
2400cb12:	d10d      	bne.n	2400cb30 <HAL_I2C_EnableListen_IT+0x30>
  {
    hi2c->State = HAL_I2C_STATE_LISTEN;
2400cb14:	687b      	ldr	r3, [r7, #4]
2400cb16:	2228      	movs	r2, #40	; 0x28
2400cb18:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR = I2C_Slave_ISR_IT;
2400cb1c:	687b      	ldr	r3, [r7, #4]
2400cb1e:	4a07      	ldr	r2, [pc, #28]	; (2400cb3c <HAL_I2C_EnableListen_IT+0x3c>)
2400cb20:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable the Address Match interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400cb22:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400cb26:	6878      	ldr	r0, [r7, #4]
2400cb28:	f002 fc30 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400cb2c:	2300      	movs	r3, #0
2400cb2e:	e000      	b.n	2400cb32 <HAL_I2C_EnableListen_IT+0x32>
  }
  else
  {
    return HAL_BUSY;
2400cb30:	2302      	movs	r3, #2
  }
}
2400cb32:	4618      	mov	r0, r3
2400cb34:	3708      	adds	r7, #8
2400cb36:	46bd      	mov	sp, r7
2400cb38:	bd80      	pop	{r7, pc}
2400cb3a:	bf00      	nop
2400cb3c:	2400d301 	.word	0x2400d301

2400cb40 <HAL_I2C_DisableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
{
2400cb40:	b580      	push	{r7, lr}
2400cb42:	b084      	sub	sp, #16
2400cb44:	af00      	add	r7, sp, #0
2400cb46:	6078      	str	r0, [r7, #4]
  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp;

  /* Disable Address listen mode only if a transfer is not ongoing */
  if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400cb48:	687b      	ldr	r3, [r7, #4]
2400cb4a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cb4e:	b2db      	uxtb	r3, r3
2400cb50:	2b28      	cmp	r3, #40	; 0x28
2400cb52:	d121      	bne.n	2400cb98 <HAL_I2C_DisableListen_IT+0x58>
  {
    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
2400cb54:	687b      	ldr	r3, [r7, #4]
2400cb56:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cb5a:	b2db      	uxtb	r3, r3
2400cb5c:	f003 0303 	and.w	r3, r3, #3
2400cb60:	60fb      	str	r3, [r7, #12]
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
2400cb62:	687b      	ldr	r3, [r7, #4]
2400cb64:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400cb68:	b2db      	uxtb	r3, r3
2400cb6a:	461a      	mov	r2, r3
2400cb6c:	68fb      	ldr	r3, [r7, #12]
2400cb6e:	431a      	orrs	r2, r3
2400cb70:	687b      	ldr	r3, [r7, #4]
2400cb72:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
2400cb74:	687b      	ldr	r3, [r7, #4]
2400cb76:	2220      	movs	r2, #32
2400cb78:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400cb7c:	687b      	ldr	r3, [r7, #4]
2400cb7e:	2200      	movs	r2, #0
2400cb80:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->XferISR = NULL;
2400cb84:	687b      	ldr	r3, [r7, #4]
2400cb86:	2200      	movs	r2, #0
2400cb88:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable the Address Match interrupt */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400cb8a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400cb8e:	6878      	ldr	r0, [r7, #4]
2400cb90:	f002 fc66 	bl	2400f460 <I2C_Disable_IRQ>

    return HAL_OK;
2400cb94:	2300      	movs	r3, #0
2400cb96:	e000      	b.n	2400cb9a <HAL_I2C_DisableListen_IT+0x5a>
  }
  else
  {
    return HAL_BUSY;
2400cb98:	2302      	movs	r3, #2
  }
}
2400cb9a:	4618      	mov	r0, r3
2400cb9c:	3710      	adds	r7, #16
2400cb9e:	46bd      	mov	sp, r7
2400cba0:	bd80      	pop	{r7, pc}
	...

2400cba4 <HAL_I2C_Master_Abort_IT>:
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
{
2400cba4:	b580      	push	{r7, lr}
2400cba6:	b084      	sub	sp, #16
2400cba8:	af02      	add	r7, sp, #8
2400cbaa:	6078      	str	r0, [r7, #4]
2400cbac:	460b      	mov	r3, r1
2400cbae:	807b      	strh	r3, [r7, #2]
  if (hi2c->Mode == HAL_I2C_MODE_MASTER)
2400cbb0:	687b      	ldr	r3, [r7, #4]
2400cbb2:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400cbb6:	b2db      	uxtb	r3, r3
2400cbb8:	2b10      	cmp	r3, #16
2400cbba:	d13c      	bne.n	2400cc36 <HAL_I2C_Master_Abort_IT+0x92>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400cbbc:	687b      	ldr	r3, [r7, #4]
2400cbbe:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400cbc2:	2b01      	cmp	r3, #1
2400cbc4:	d101      	bne.n	2400cbca <HAL_I2C_Master_Abort_IT+0x26>
2400cbc6:	2302      	movs	r3, #2
2400cbc8:	e036      	b.n	2400cc38 <HAL_I2C_Master_Abort_IT+0x94>
2400cbca:	687b      	ldr	r3, [r7, #4]
2400cbcc:	2201      	movs	r2, #1
2400cbce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts and Store Previous state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400cbd2:	687b      	ldr	r3, [r7, #4]
2400cbd4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cbd8:	b2db      	uxtb	r3, r3
2400cbda:	2b21      	cmp	r3, #33	; 0x21
2400cbdc:	d107      	bne.n	2400cbee <HAL_I2C_Master_Abort_IT+0x4a>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400cbde:	2101      	movs	r1, #1
2400cbe0:	6878      	ldr	r0, [r7, #4]
2400cbe2:	f002 fc3d 	bl	2400f460 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400cbe6:	687b      	ldr	r3, [r7, #4]
2400cbe8:	2211      	movs	r2, #17
2400cbea:	631a      	str	r2, [r3, #48]	; 0x30
2400cbec:	e00c      	b.n	2400cc08 <HAL_I2C_Master_Abort_IT+0x64>
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400cbee:	687b      	ldr	r3, [r7, #4]
2400cbf0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cbf4:	b2db      	uxtb	r3, r3
2400cbf6:	2b22      	cmp	r3, #34	; 0x22
2400cbf8:	d106      	bne.n	2400cc08 <HAL_I2C_Master_Abort_IT+0x64>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400cbfa:	2102      	movs	r1, #2
2400cbfc:	6878      	ldr	r0, [r7, #4]
2400cbfe:	f002 fc2f 	bl	2400f460 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400cc02:	687b      	ldr	r3, [r7, #4]
2400cc04:	2212      	movs	r2, #18
2400cc06:	631a      	str	r2, [r3, #48]	; 0x30
    {
      /* Do nothing */
    }

    /* Set State at HAL_I2C_STATE_ABORT */
    hi2c->State = HAL_I2C_STATE_ABORT;
2400cc08:	687b      	ldr	r3, [r7, #4]
2400cc0a:	2260      	movs	r2, #96	; 0x60
2400cc0c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
    /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
2400cc10:	8879      	ldrh	r1, [r7, #2]
2400cc12:	4b0b      	ldr	r3, [pc, #44]	; (2400cc40 <HAL_I2C_Master_Abort_IT+0x9c>)
2400cc14:	9300      	str	r3, [sp, #0]
2400cc16:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400cc1a:	2201      	movs	r2, #1
2400cc1c:	6878      	ldr	r0, [r7, #4]
2400cc1e:	f002 fb83 	bl	2400f328 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400cc22:	687b      	ldr	r3, [r7, #4]
2400cc24:	2200      	movs	r2, #0
2400cc26:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400cc2a:	2120      	movs	r1, #32
2400cc2c:	6878      	ldr	r0, [r7, #4]
2400cc2e:	f002 fbad 	bl	2400f38c <I2C_Enable_IRQ>

    return HAL_OK;
2400cc32:	2300      	movs	r3, #0
2400cc34:	e000      	b.n	2400cc38 <HAL_I2C_Master_Abort_IT+0x94>
  }
  else
  {
    /* Wrong usage of abort function */
    /* This function should be used only in case of abort monitored by master device */
    return HAL_ERROR;
2400cc36:	2301      	movs	r3, #1
  }
}
2400cc38:	4618      	mov	r0, r3
2400cc3a:	3708      	adds	r7, #8
2400cc3c:	46bd      	mov	sp, r7
2400cc3e:	bd80      	pop	{r7, pc}
2400cc40:	80004000 	.word	0x80004000

2400cc44 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2400cc44:	b580      	push	{r7, lr}
2400cc46:	b084      	sub	sp, #16
2400cc48:	af00      	add	r7, sp, #0
2400cc4a:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2400cc4c:	687b      	ldr	r3, [r7, #4]
2400cc4e:	681b      	ldr	r3, [r3, #0]
2400cc50:	699b      	ldr	r3, [r3, #24]
2400cc52:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2400cc54:	687b      	ldr	r3, [r7, #4]
2400cc56:	681b      	ldr	r3, [r3, #0]
2400cc58:	681b      	ldr	r3, [r3, #0]
2400cc5a:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
2400cc5c:	687b      	ldr	r3, [r7, #4]
2400cc5e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400cc60:	2b00      	cmp	r3, #0
2400cc62:	d005      	beq.n	2400cc70 <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
2400cc64:	687b      	ldr	r3, [r7, #4]
2400cc66:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400cc68:	68ba      	ldr	r2, [r7, #8]
2400cc6a:	68f9      	ldr	r1, [r7, #12]
2400cc6c:	6878      	ldr	r0, [r7, #4]
2400cc6e:	4798      	blx	r3
  }
}
2400cc70:	bf00      	nop
2400cc72:	3710      	adds	r7, #16
2400cc74:	46bd      	mov	sp, r7
2400cc76:	bd80      	pop	{r7, pc}

2400cc78 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2400cc78:	b580      	push	{r7, lr}
2400cc7a:	b086      	sub	sp, #24
2400cc7c:	af00      	add	r7, sp, #0
2400cc7e:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2400cc80:	687b      	ldr	r3, [r7, #4]
2400cc82:	681b      	ldr	r3, [r3, #0]
2400cc84:	699b      	ldr	r3, [r3, #24]
2400cc86:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2400cc88:	687b      	ldr	r3, [r7, #4]
2400cc8a:	681b      	ldr	r3, [r3, #0]
2400cc8c:	681b      	ldr	r3, [r3, #0]
2400cc8e:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
2400cc90:	697b      	ldr	r3, [r7, #20]
2400cc92:	0a1b      	lsrs	r3, r3, #8
2400cc94:	f003 0301 	and.w	r3, r3, #1
2400cc98:	2b00      	cmp	r3, #0
2400cc9a:	d010      	beq.n	2400ccbe <HAL_I2C_ER_IRQHandler+0x46>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400cc9c:	693b      	ldr	r3, [r7, #16]
2400cc9e:	09db      	lsrs	r3, r3, #7
2400cca0:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
2400cca4:	2b00      	cmp	r3, #0
2400cca6:	d00a      	beq.n	2400ccbe <HAL_I2C_ER_IRQHandler+0x46>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
2400cca8:	687b      	ldr	r3, [r7, #4]
2400ccaa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ccac:	f043 0201 	orr.w	r2, r3, #1
2400ccb0:	687b      	ldr	r3, [r7, #4]
2400ccb2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2400ccb4:	687b      	ldr	r3, [r7, #4]
2400ccb6:	681b      	ldr	r3, [r3, #0]
2400ccb8:	f44f 7280 	mov.w	r2, #256	; 0x100
2400ccbc:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
2400ccbe:	697b      	ldr	r3, [r7, #20]
2400ccc0:	0a9b      	lsrs	r3, r3, #10
2400ccc2:	f003 0301 	and.w	r3, r3, #1
2400ccc6:	2b00      	cmp	r3, #0
2400ccc8:	d010      	beq.n	2400ccec <HAL_I2C_ER_IRQHandler+0x74>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400ccca:	693b      	ldr	r3, [r7, #16]
2400cccc:	09db      	lsrs	r3, r3, #7
2400ccce:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
2400ccd2:	2b00      	cmp	r3, #0
2400ccd4:	d00a      	beq.n	2400ccec <HAL_I2C_ER_IRQHandler+0x74>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
2400ccd6:	687b      	ldr	r3, [r7, #4]
2400ccd8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ccda:	f043 0208 	orr.w	r2, r3, #8
2400ccde:	687b      	ldr	r3, [r7, #4]
2400cce0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
2400cce2:	687b      	ldr	r3, [r7, #4]
2400cce4:	681b      	ldr	r3, [r3, #0]
2400cce6:	f44f 6280 	mov.w	r2, #1024	; 0x400
2400ccea:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
2400ccec:	697b      	ldr	r3, [r7, #20]
2400ccee:	0a5b      	lsrs	r3, r3, #9
2400ccf0:	f003 0301 	and.w	r3, r3, #1
2400ccf4:	2b00      	cmp	r3, #0
2400ccf6:	d010      	beq.n	2400cd1a <HAL_I2C_ER_IRQHandler+0xa2>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400ccf8:	693b      	ldr	r3, [r7, #16]
2400ccfa:	09db      	lsrs	r3, r3, #7
2400ccfc:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
2400cd00:	2b00      	cmp	r3, #0
2400cd02:	d00a      	beq.n	2400cd1a <HAL_I2C_ER_IRQHandler+0xa2>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
2400cd04:	687b      	ldr	r3, [r7, #4]
2400cd06:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cd08:	f043 0202 	orr.w	r2, r3, #2
2400cd0c:	687b      	ldr	r3, [r7, #4]
2400cd0e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2400cd10:	687b      	ldr	r3, [r7, #4]
2400cd12:	681b      	ldr	r3, [r3, #0]
2400cd14:	f44f 7200 	mov.w	r2, #512	; 0x200
2400cd18:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2400cd1a:	687b      	ldr	r3, [r7, #4]
2400cd1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cd1e:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
2400cd20:	68fb      	ldr	r3, [r7, #12]
2400cd22:	f003 030b 	and.w	r3, r3, #11
2400cd26:	2b00      	cmp	r3, #0
2400cd28:	d003      	beq.n	2400cd32 <HAL_I2C_ER_IRQHandler+0xba>
  {
    I2C_ITError(hi2c, tmperror);
2400cd2a:	68f9      	ldr	r1, [r7, #12]
2400cd2c:	6878      	ldr	r0, [r7, #4]
2400cd2e:	f001 fcc3 	bl	2400e6b8 <I2C_ITError>
  }
}
2400cd32:	bf00      	nop
2400cd34:	3718      	adds	r7, #24
2400cd36:	46bd      	mov	sp, r7
2400cd38:	bd80      	pop	{r7, pc}

2400cd3a <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cd3a:	b480      	push	{r7}
2400cd3c:	b083      	sub	sp, #12
2400cd3e:	af00      	add	r7, sp, #0
2400cd40:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */
}
2400cd42:	bf00      	nop
2400cd44:	370c      	adds	r7, #12
2400cd46:	46bd      	mov	sp, r7
2400cd48:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cd4c:	4770      	bx	lr

2400cd4e <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cd4e:	b480      	push	{r7}
2400cd50:	b083      	sub	sp, #12
2400cd52:	af00      	add	r7, sp, #0
2400cd54:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */
}
2400cd56:	bf00      	nop
2400cd58:	370c      	adds	r7, #12
2400cd5a:	46bd      	mov	sp, r7
2400cd5c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cd60:	4770      	bx	lr

2400cd62 <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cd62:	b480      	push	{r7}
2400cd64:	b083      	sub	sp, #12
2400cd66:	af00      	add	r7, sp, #0
2400cd68:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
2400cd6a:	bf00      	nop
2400cd6c:	370c      	adds	r7, #12
2400cd6e:	46bd      	mov	sp, r7
2400cd70:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cd74:	4770      	bx	lr

2400cd76 <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cd76:	b480      	push	{r7}
2400cd78:	b083      	sub	sp, #12
2400cd7a:	af00      	add	r7, sp, #0
2400cd7c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
2400cd7e:	bf00      	nop
2400cd80:	370c      	adds	r7, #12
2400cd82:	46bd      	mov	sp, r7
2400cd84:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cd88:	4770      	bx	lr

2400cd8a <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
2400cd8a:	b480      	push	{r7}
2400cd8c:	b083      	sub	sp, #12
2400cd8e:	af00      	add	r7, sp, #0
2400cd90:	6078      	str	r0, [r7, #4]
2400cd92:	460b      	mov	r3, r1
2400cd94:	70fb      	strb	r3, [r7, #3]
2400cd96:	4613      	mov	r3, r2
2400cd98:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
2400cd9a:	bf00      	nop
2400cd9c:	370c      	adds	r7, #12
2400cd9e:	46bd      	mov	sp, r7
2400cda0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cda4:	4770      	bx	lr

2400cda6 <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cda6:	b480      	push	{r7}
2400cda8:	b083      	sub	sp, #12
2400cdaa:	af00      	add	r7, sp, #0
2400cdac:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
2400cdae:	bf00      	nop
2400cdb0:	370c      	adds	r7, #12
2400cdb2:	46bd      	mov	sp, r7
2400cdb4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cdb8:	4770      	bx	lr

2400cdba <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cdba:	b480      	push	{r7}
2400cdbc:	b083      	sub	sp, #12
2400cdbe:	af00      	add	r7, sp, #0
2400cdc0:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
}
2400cdc2:	bf00      	nop
2400cdc4:	370c      	adds	r7, #12
2400cdc6:	46bd      	mov	sp, r7
2400cdc8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cdcc:	4770      	bx	lr

2400cdce <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cdce:	b480      	push	{r7}
2400cdd0:	b083      	sub	sp, #12
2400cdd2:	af00      	add	r7, sp, #0
2400cdd4:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */
}
2400cdd6:	bf00      	nop
2400cdd8:	370c      	adds	r7, #12
2400cdda:	46bd      	mov	sp, r7
2400cddc:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cde0:	4770      	bx	lr

2400cde2 <HAL_I2C_ErrorCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
2400cde2:	b480      	push	{r7}
2400cde4:	b083      	sub	sp, #12
2400cde6:	af00      	add	r7, sp, #0
2400cde8:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */
}
2400cdea:	bf00      	nop
2400cdec:	370c      	adds	r7, #12
2400cdee:	46bd      	mov	sp, r7
2400cdf0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cdf4:	4770      	bx	lr

2400cdf6 <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cdf6:	b480      	push	{r7}
2400cdf8:	b083      	sub	sp, #12
2400cdfa:	af00      	add	r7, sp, #0
2400cdfc:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
2400cdfe:	bf00      	nop
2400ce00:	370c      	adds	r7, #12
2400ce02:	46bd      	mov	sp, r7
2400ce04:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ce08:	4770      	bx	lr

2400ce0a <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
2400ce0a:	b480      	push	{r7}
2400ce0c:	b083      	sub	sp, #12
2400ce0e:	af00      	add	r7, sp, #0
2400ce10:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
2400ce12:	687b      	ldr	r3, [r7, #4]
2400ce14:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ce18:	b2db      	uxtb	r3, r3
}
2400ce1a:	4618      	mov	r0, r3
2400ce1c:	370c      	adds	r7, #12
2400ce1e:	46bd      	mov	sp, r7
2400ce20:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ce24:	4770      	bx	lr

2400ce26 <HAL_I2C_GetMode>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL mode
  */
HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
{
2400ce26:	b480      	push	{r7}
2400ce28:	b083      	sub	sp, #12
2400ce2a:	af00      	add	r7, sp, #0
2400ce2c:	6078      	str	r0, [r7, #4]
  return hi2c->Mode;
2400ce2e:	687b      	ldr	r3, [r7, #4]
2400ce30:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400ce34:	b2db      	uxtb	r3, r3
}
2400ce36:	4618      	mov	r0, r3
2400ce38:	370c      	adds	r7, #12
2400ce3a:	46bd      	mov	sp, r7
2400ce3c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ce40:	4770      	bx	lr

2400ce42 <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
2400ce42:	b480      	push	{r7}
2400ce44:	b083      	sub	sp, #12
2400ce46:	af00      	add	r7, sp, #0
2400ce48:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
2400ce4a:	687b      	ldr	r3, [r7, #4]
2400ce4c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2400ce4e:	4618      	mov	r0, r3
2400ce50:	370c      	adds	r7, #12
2400ce52:	46bd      	mov	sp, r7
2400ce54:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ce58:	4770      	bx	lr

2400ce5a <I2C_Master_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                           uint32_t ITSources)
{
2400ce5a:	b580      	push	{r7, lr}
2400ce5c:	b088      	sub	sp, #32
2400ce5e:	af02      	add	r7, sp, #8
2400ce60:	60f8      	str	r0, [r7, #12]
2400ce62:	60b9      	str	r1, [r7, #8]
2400ce64:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t tmpITFlags = ITFlags;
2400ce66:	68bb      	ldr	r3, [r7, #8]
2400ce68:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400ce6a:	68fb      	ldr	r3, [r7, #12]
2400ce6c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400ce70:	2b01      	cmp	r3, #1
2400ce72:	d101      	bne.n	2400ce78 <I2C_Master_ISR_IT+0x1e>
2400ce74:	2302      	movs	r3, #2
2400ce76:	e114      	b.n	2400d0a2 <I2C_Master_ISR_IT+0x248>
2400ce78:	68fb      	ldr	r3, [r7, #12]
2400ce7a:	2201      	movs	r2, #1
2400ce7c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400ce80:	697b      	ldr	r3, [r7, #20]
2400ce82:	091b      	lsrs	r3, r3, #4
2400ce84:	f003 0301 	and.w	r3, r3, #1
2400ce88:	2b00      	cmp	r3, #0
2400ce8a:	d013      	beq.n	2400ceb4 <I2C_Master_ISR_IT+0x5a>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400ce8c:	687b      	ldr	r3, [r7, #4]
2400ce8e:	091b      	lsrs	r3, r3, #4
2400ce90:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400ce94:	2b00      	cmp	r3, #0
2400ce96:	d00d      	beq.n	2400ceb4 <I2C_Master_ISR_IT+0x5a>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400ce98:	68fb      	ldr	r3, [r7, #12]
2400ce9a:	681b      	ldr	r3, [r3, #0]
2400ce9c:	2210      	movs	r2, #16
2400ce9e:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400cea0:	68fb      	ldr	r3, [r7, #12]
2400cea2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cea4:	f043 0204 	orr.w	r2, r3, #4
2400cea8:	68fb      	ldr	r3, [r7, #12]
2400ceaa:	645a      	str	r2, [r3, #68]	; 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400ceac:	68f8      	ldr	r0, [r7, #12]
2400ceae:	f001 fd1a 	bl	2400e8e6 <I2C_Flush_TXDR>
2400ceb2:	e0e1      	b.n	2400d078 <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400ceb4:	697b      	ldr	r3, [r7, #20]
2400ceb6:	089b      	lsrs	r3, r3, #2
2400ceb8:	f003 0301 	and.w	r3, r3, #1
2400cebc:	2b00      	cmp	r3, #0
2400cebe:	d023      	beq.n	2400cf08 <I2C_Master_ISR_IT+0xae>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400cec0:	687b      	ldr	r3, [r7, #4]
2400cec2:	089b      	lsrs	r3, r3, #2
2400cec4:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400cec8:	2b00      	cmp	r3, #0
2400ceca:	d01d      	beq.n	2400cf08 <I2C_Master_ISR_IT+0xae>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400cecc:	697b      	ldr	r3, [r7, #20]
2400cece:	f023 0304 	bic.w	r3, r3, #4
2400ced2:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400ced4:	68fb      	ldr	r3, [r7, #12]
2400ced6:	681b      	ldr	r3, [r3, #0]
2400ced8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400ceda:	68fb      	ldr	r3, [r7, #12]
2400cedc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400cede:	b2d2      	uxtb	r2, r2
2400cee0:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400cee2:	68fb      	ldr	r3, [r7, #12]
2400cee4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400cee6:	1c5a      	adds	r2, r3, #1
2400cee8:	68fb      	ldr	r3, [r7, #12]
2400ceea:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400ceec:	68fb      	ldr	r3, [r7, #12]
2400ceee:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400cef0:	3b01      	subs	r3, #1
2400cef2:	b29a      	uxth	r2, r3
2400cef4:	68fb      	ldr	r3, [r7, #12]
2400cef6:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400cef8:	68fb      	ldr	r3, [r7, #12]
2400cefa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400cefc:	b29b      	uxth	r3, r3
2400cefe:	3b01      	subs	r3, #1
2400cf00:	b29a      	uxth	r2, r3
2400cf02:	68fb      	ldr	r3, [r7, #12]
2400cf04:	855a      	strh	r2, [r3, #42]	; 0x2a
2400cf06:	e0b7      	b.n	2400d078 <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400cf08:	697b      	ldr	r3, [r7, #20]
2400cf0a:	085b      	lsrs	r3, r3, #1
2400cf0c:	f003 0301 	and.w	r3, r3, #1
2400cf10:	2b00      	cmp	r3, #0
2400cf12:	d01e      	beq.n	2400cf52 <I2C_Master_ISR_IT+0xf8>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400cf14:	687b      	ldr	r3, [r7, #4]
2400cf16:	085b      	lsrs	r3, r3, #1
2400cf18:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400cf1c:	2b00      	cmp	r3, #0
2400cf1e:	d018      	beq.n	2400cf52 <I2C_Master_ISR_IT+0xf8>
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400cf20:	68fb      	ldr	r3, [r7, #12]
2400cf22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400cf24:	781a      	ldrb	r2, [r3, #0]
2400cf26:	68fb      	ldr	r3, [r7, #12]
2400cf28:	681b      	ldr	r3, [r3, #0]
2400cf2a:	629a      	str	r2, [r3, #40]	; 0x28

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400cf2c:	68fb      	ldr	r3, [r7, #12]
2400cf2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400cf30:	1c5a      	adds	r2, r3, #1
2400cf32:	68fb      	ldr	r3, [r7, #12]
2400cf34:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400cf36:	68fb      	ldr	r3, [r7, #12]
2400cf38:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400cf3a:	3b01      	subs	r3, #1
2400cf3c:	b29a      	uxth	r2, r3
2400cf3e:	68fb      	ldr	r3, [r7, #12]
2400cf40:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400cf42:	68fb      	ldr	r3, [r7, #12]
2400cf44:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400cf46:	b29b      	uxth	r3, r3
2400cf48:	3b01      	subs	r3, #1
2400cf4a:	b29a      	uxth	r2, r3
2400cf4c:	68fb      	ldr	r3, [r7, #12]
2400cf4e:	855a      	strh	r2, [r3, #42]	; 0x2a
2400cf50:	e092      	b.n	2400d078 <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
2400cf52:	697b      	ldr	r3, [r7, #20]
2400cf54:	09db      	lsrs	r3, r3, #7
2400cf56:	f003 0301 	and.w	r3, r3, #1
2400cf5a:	2b00      	cmp	r3, #0
2400cf5c:	d05d      	beq.n	2400d01a <I2C_Master_ISR_IT+0x1c0>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400cf5e:	687b      	ldr	r3, [r7, #4]
2400cf60:	099b      	lsrs	r3, r3, #6
2400cf62:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
2400cf66:	2b00      	cmp	r3, #0
2400cf68:	d057      	beq.n	2400d01a <I2C_Master_ISR_IT+0x1c0>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400cf6a:	68fb      	ldr	r3, [r7, #12]
2400cf6c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400cf6e:	b29b      	uxth	r3, r3
2400cf70:	2b00      	cmp	r3, #0
2400cf72:	d040      	beq.n	2400cff6 <I2C_Master_ISR_IT+0x19c>
2400cf74:	68fb      	ldr	r3, [r7, #12]
2400cf76:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400cf78:	2b00      	cmp	r3, #0
2400cf7a:	d13c      	bne.n	2400cff6 <I2C_Master_ISR_IT+0x19c>
    {
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2400cf7c:	68fb      	ldr	r3, [r7, #12]
2400cf7e:	681b      	ldr	r3, [r3, #0]
2400cf80:	685b      	ldr	r3, [r3, #4]
2400cf82:	b29b      	uxth	r3, r3
2400cf84:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400cf88:	827b      	strh	r3, [r7, #18]

      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400cf8a:	68fb      	ldr	r3, [r7, #12]
2400cf8c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400cf8e:	b29b      	uxth	r3, r3
2400cf90:	2bff      	cmp	r3, #255	; 0xff
2400cf92:	d90e      	bls.n	2400cfb2 <I2C_Master_ISR_IT+0x158>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400cf94:	68fb      	ldr	r3, [r7, #12]
2400cf96:	22ff      	movs	r2, #255	; 0xff
2400cf98:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400cf9a:	68fb      	ldr	r3, [r7, #12]
2400cf9c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400cf9e:	b2da      	uxtb	r2, r3
2400cfa0:	8a79      	ldrh	r1, [r7, #18]
2400cfa2:	2300      	movs	r3, #0
2400cfa4:	9300      	str	r3, [sp, #0]
2400cfa6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400cfaa:	68f8      	ldr	r0, [r7, #12]
2400cfac:	f002 f9bc 	bl	2400f328 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400cfb0:	e032      	b.n	2400d018 <I2C_Master_ISR_IT+0x1be>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400cfb2:	68fb      	ldr	r3, [r7, #12]
2400cfb4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400cfb6:	b29a      	uxth	r2, r3
2400cfb8:	68fb      	ldr	r3, [r7, #12]
2400cfba:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400cfbc:	68fb      	ldr	r3, [r7, #12]
2400cfbe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400cfc0:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400cfc4:	d00b      	beq.n	2400cfde <I2C_Master_ISR_IT+0x184>
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
2400cfc6:	68fb      	ldr	r3, [r7, #12]
2400cfc8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400cfca:	b2da      	uxtb	r2, r3
2400cfcc:	68fb      	ldr	r3, [r7, #12]
2400cfce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400cfd0:	8a79      	ldrh	r1, [r7, #18]
2400cfd2:	2000      	movs	r0, #0
2400cfd4:	9000      	str	r0, [sp, #0]
2400cfd6:	68f8      	ldr	r0, [r7, #12]
2400cfd8:	f002 f9a6 	bl	2400f328 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400cfdc:	e01c      	b.n	2400d018 <I2C_Master_ISR_IT+0x1be>
                             hi2c->XferOptions, I2C_NO_STARTSTOP);
        }
        else
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
2400cfde:	68fb      	ldr	r3, [r7, #12]
2400cfe0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400cfe2:	b2da      	uxtb	r2, r3
2400cfe4:	8a79      	ldrh	r1, [r7, #18]
2400cfe6:	2300      	movs	r3, #0
2400cfe8:	9300      	str	r3, [sp, #0]
2400cfea:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400cfee:	68f8      	ldr	r0, [r7, #12]
2400cff0:	f002 f99a 	bl	2400f328 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400cff4:	e010      	b.n	2400d018 <I2C_Master_ISR_IT+0x1be>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400cff6:	68fb      	ldr	r3, [r7, #12]
2400cff8:	681b      	ldr	r3, [r3, #0]
2400cffa:	685b      	ldr	r3, [r3, #4]
2400cffc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400d000:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d004:	d003      	beq.n	2400d00e <I2C_Master_ISR_IT+0x1b4>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2400d006:	68f8      	ldr	r0, [r7, #12]
2400d008:	f000 ffa2 	bl	2400df50 <I2C_ITMasterSeqCplt>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400d00c:	e034      	b.n	2400d078 <I2C_Master_ISR_IT+0x21e>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d00e:	2140      	movs	r1, #64	; 0x40
2400d010:	68f8      	ldr	r0, [r7, #12]
2400d012:	f001 fb51 	bl	2400e6b8 <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400d016:	e02f      	b.n	2400d078 <I2C_Master_ISR_IT+0x21e>
2400d018:	e02e      	b.n	2400d078 <I2C_Master_ISR_IT+0x21e>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
2400d01a:	697b      	ldr	r3, [r7, #20]
2400d01c:	099b      	lsrs	r3, r3, #6
2400d01e:	f003 0301 	and.w	r3, r3, #1
2400d022:	2b00      	cmp	r3, #0
2400d024:	d028      	beq.n	2400d078 <I2C_Master_ISR_IT+0x21e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d026:	687b      	ldr	r3, [r7, #4]
2400d028:	099b      	lsrs	r3, r3, #6
2400d02a:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
2400d02e:	2b00      	cmp	r3, #0
2400d030:	d022      	beq.n	2400d078 <I2C_Master_ISR_IT+0x21e>
  {
    if (hi2c->XferCount == 0U)
2400d032:	68fb      	ldr	r3, [r7, #12]
2400d034:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d036:	b29b      	uxth	r3, r3
2400d038:	2b00      	cmp	r3, #0
2400d03a:	d119      	bne.n	2400d070 <I2C_Master_ISR_IT+0x216>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400d03c:	68fb      	ldr	r3, [r7, #12]
2400d03e:	681b      	ldr	r3, [r3, #0]
2400d040:	685b      	ldr	r3, [r3, #4]
2400d042:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400d046:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d04a:	d015      	beq.n	2400d078 <I2C_Master_ISR_IT+0x21e>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2400d04c:	68fb      	ldr	r3, [r7, #12]
2400d04e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d050:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d054:	d108      	bne.n	2400d068 <I2C_Master_ISR_IT+0x20e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400d056:	68fb      	ldr	r3, [r7, #12]
2400d058:	681b      	ldr	r3, [r3, #0]
2400d05a:	685a      	ldr	r2, [r3, #4]
2400d05c:	68fb      	ldr	r3, [r7, #12]
2400d05e:	681b      	ldr	r3, [r3, #0]
2400d060:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400d064:	605a      	str	r2, [r3, #4]
2400d066:	e007      	b.n	2400d078 <I2C_Master_ISR_IT+0x21e>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
2400d068:	68f8      	ldr	r0, [r7, #12]
2400d06a:	f000 ff71 	bl	2400df50 <I2C_ITMasterSeqCplt>
2400d06e:	e003      	b.n	2400d078 <I2C_Master_ISR_IT+0x21e>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d070:	2140      	movs	r1, #64	; 0x40
2400d072:	68f8      	ldr	r0, [r7, #12]
2400d074:	f001 fb20 	bl	2400e6b8 <I2C_ITError>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d078:	697b      	ldr	r3, [r7, #20]
2400d07a:	095b      	lsrs	r3, r3, #5
2400d07c:	f003 0301 	and.w	r3, r3, #1
2400d080:	2b00      	cmp	r3, #0
2400d082:	d009      	beq.n	2400d098 <I2C_Master_ISR_IT+0x23e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d084:	687b      	ldr	r3, [r7, #4]
2400d086:	095b      	lsrs	r3, r3, #5
2400d088:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d08c:	2b00      	cmp	r3, #0
2400d08e:	d003      	beq.n	2400d098 <I2C_Master_ISR_IT+0x23e>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
2400d090:	6979      	ldr	r1, [r7, #20]
2400d092:	68f8      	ldr	r0, [r7, #12]
2400d094:	f000 fff8 	bl	2400e088 <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d098:	68fb      	ldr	r3, [r7, #12]
2400d09a:	2200      	movs	r2, #0
2400d09c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400d0a0:	2300      	movs	r3, #0
}
2400d0a2:	4618      	mov	r0, r3
2400d0a4:	3718      	adds	r7, #24
2400d0a6:	46bd      	mov	sp, r7
2400d0a8:	bd80      	pop	{r7, pc}
	...

2400d0ac <I2C_Mem_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Mem_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                        uint32_t ITSources)
{
2400d0ac:	b580      	push	{r7, lr}
2400d0ae:	b088      	sub	sp, #32
2400d0b0:	af02      	add	r7, sp, #8
2400d0b2:	60f8      	str	r0, [r7, #12]
2400d0b4:	60b9      	str	r1, [r7, #8]
2400d0b6:	607a      	str	r2, [r7, #4]
  uint32_t direction = I2C_GENERATE_START_WRITE;
2400d0b8:	4b8f      	ldr	r3, [pc, #572]	; (2400d2f8 <I2C_Mem_ISR_IT+0x24c>)
2400d0ba:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
2400d0bc:	68bb      	ldr	r3, [r7, #8]
2400d0be:	613b      	str	r3, [r7, #16]

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400d0c0:	68fb      	ldr	r3, [r7, #12]
2400d0c2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d0c6:	2b01      	cmp	r3, #1
2400d0c8:	d101      	bne.n	2400d0ce <I2C_Mem_ISR_IT+0x22>
2400d0ca:	2302      	movs	r3, #2
2400d0cc:	e110      	b.n	2400d2f0 <I2C_Mem_ISR_IT+0x244>
2400d0ce:	68fb      	ldr	r3, [r7, #12]
2400d0d0:	2201      	movs	r2, #1
2400d0d2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400d0d6:	693b      	ldr	r3, [r7, #16]
2400d0d8:	091b      	lsrs	r3, r3, #4
2400d0da:	f003 0301 	and.w	r3, r3, #1
2400d0de:	2b00      	cmp	r3, #0
2400d0e0:	d013      	beq.n	2400d10a <I2C_Mem_ISR_IT+0x5e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d0e2:	687b      	ldr	r3, [r7, #4]
2400d0e4:	091b      	lsrs	r3, r3, #4
2400d0e6:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400d0ea:	2b00      	cmp	r3, #0
2400d0ec:	d00d      	beq.n	2400d10a <I2C_Mem_ISR_IT+0x5e>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d0ee:	68fb      	ldr	r3, [r7, #12]
2400d0f0:	681b      	ldr	r3, [r3, #0]
2400d0f2:	2210      	movs	r2, #16
2400d0f4:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d0f6:	68fb      	ldr	r3, [r7, #12]
2400d0f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d0fa:	f043 0204 	orr.w	r2, r3, #4
2400d0fe:	68fb      	ldr	r3, [r7, #12]
2400d100:	645a      	str	r2, [r3, #68]	; 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400d102:	68f8      	ldr	r0, [r7, #12]
2400d104:	f001 fbef 	bl	2400e8e6 <I2C_Flush_TXDR>
2400d108:	e0dd      	b.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400d10a:	693b      	ldr	r3, [r7, #16]
2400d10c:	089b      	lsrs	r3, r3, #2
2400d10e:	f003 0301 	and.w	r3, r3, #1
2400d112:	2b00      	cmp	r3, #0
2400d114:	d023      	beq.n	2400d15e <I2C_Mem_ISR_IT+0xb2>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400d116:	687b      	ldr	r3, [r7, #4]
2400d118:	089b      	lsrs	r3, r3, #2
2400d11a:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400d11e:	2b00      	cmp	r3, #0
2400d120:	d01d      	beq.n	2400d15e <I2C_Mem_ISR_IT+0xb2>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400d122:	693b      	ldr	r3, [r7, #16]
2400d124:	f023 0304 	bic.w	r3, r3, #4
2400d128:	613b      	str	r3, [r7, #16]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400d12a:	68fb      	ldr	r3, [r7, #12]
2400d12c:	681b      	ldr	r3, [r3, #0]
2400d12e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400d130:	68fb      	ldr	r3, [r7, #12]
2400d132:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d134:	b2d2      	uxtb	r2, r2
2400d136:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400d138:	68fb      	ldr	r3, [r7, #12]
2400d13a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d13c:	1c5a      	adds	r2, r3, #1
2400d13e:	68fb      	ldr	r3, [r7, #12]
2400d140:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400d142:	68fb      	ldr	r3, [r7, #12]
2400d144:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d146:	3b01      	subs	r3, #1
2400d148:	b29a      	uxth	r2, r3
2400d14a:	68fb      	ldr	r3, [r7, #12]
2400d14c:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400d14e:	68fb      	ldr	r3, [r7, #12]
2400d150:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d152:	b29b      	uxth	r3, r3
2400d154:	3b01      	subs	r3, #1
2400d156:	b29a      	uxth	r2, r3
2400d158:	68fb      	ldr	r3, [r7, #12]
2400d15a:	855a      	strh	r2, [r3, #42]	; 0x2a
2400d15c:	e0b3      	b.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d15e:	693b      	ldr	r3, [r7, #16]
2400d160:	085b      	lsrs	r3, r3, #1
2400d162:	f003 0301 	and.w	r3, r3, #1
2400d166:	2b00      	cmp	r3, #0
2400d168:	d02d      	beq.n	2400d1c6 <I2C_Mem_ISR_IT+0x11a>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400d16a:	687b      	ldr	r3, [r7, #4]
2400d16c:	085b      	lsrs	r3, r3, #1
2400d16e:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d172:	2b00      	cmp	r3, #0
2400d174:	d027      	beq.n	2400d1c6 <I2C_Mem_ISR_IT+0x11a>
  {
    if (hi2c->Memaddress == 0xFFFFFFFFU)
2400d176:	68fb      	ldr	r3, [r7, #12]
2400d178:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400d17a:	f1b3 3fff 	cmp.w	r3, #4294967295
2400d17e:	d118      	bne.n	2400d1b2 <I2C_Mem_ISR_IT+0x106>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400d180:	68fb      	ldr	r3, [r7, #12]
2400d182:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d184:	781a      	ldrb	r2, [r3, #0]
2400d186:	68fb      	ldr	r3, [r7, #12]
2400d188:	681b      	ldr	r3, [r3, #0]
2400d18a:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400d18c:	68fb      	ldr	r3, [r7, #12]
2400d18e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d190:	1c5a      	adds	r2, r3, #1
2400d192:	68fb      	ldr	r3, [r7, #12]
2400d194:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400d196:	68fb      	ldr	r3, [r7, #12]
2400d198:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d19a:	3b01      	subs	r3, #1
2400d19c:	b29a      	uxth	r2, r3
2400d19e:	68fb      	ldr	r3, [r7, #12]
2400d1a0:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400d1a2:	68fb      	ldr	r3, [r7, #12]
2400d1a4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d1a6:	b29b      	uxth	r3, r3
2400d1a8:	3b01      	subs	r3, #1
2400d1aa:	b29a      	uxth	r2, r3
2400d1ac:	68fb      	ldr	r3, [r7, #12]
2400d1ae:	855a      	strh	r2, [r3, #42]	; 0x2a
    if (hi2c->Memaddress == 0xFFFFFFFFU)
2400d1b0:	e089      	b.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
    }
    else
    {
      /* Write LSB part of Memory Address */
      hi2c->Instance->TXDR = hi2c->Memaddress;
2400d1b2:	68fb      	ldr	r3, [r7, #12]
2400d1b4:	681b      	ldr	r3, [r3, #0]
2400d1b6:	68fa      	ldr	r2, [r7, #12]
2400d1b8:	6d12      	ldr	r2, [r2, #80]	; 0x50
2400d1ba:	629a      	str	r2, [r3, #40]	; 0x28

      /* Reset Memaddress content */
      hi2c->Memaddress = 0xFFFFFFFFU;
2400d1bc:	68fb      	ldr	r3, [r7, #12]
2400d1be:	f04f 32ff 	mov.w	r2, #4294967295
2400d1c2:	651a      	str	r2, [r3, #80]	; 0x50
    if (hi2c->Memaddress == 0xFFFFFFFFU)
2400d1c4:	e07f      	b.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
2400d1c6:	693b      	ldr	r3, [r7, #16]
2400d1c8:	09db      	lsrs	r3, r3, #7
2400d1ca:	f003 0301 	and.w	r3, r3, #1
2400d1ce:	2b00      	cmp	r3, #0
2400d1d0:	d03d      	beq.n	2400d24e <I2C_Mem_ISR_IT+0x1a2>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d1d2:	687b      	ldr	r3, [r7, #4]
2400d1d4:	099b      	lsrs	r3, r3, #6
2400d1d6:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
2400d1da:	2b00      	cmp	r3, #0
2400d1dc:	d037      	beq.n	2400d24e <I2C_Mem_ISR_IT+0x1a2>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400d1de:	68fb      	ldr	r3, [r7, #12]
2400d1e0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d1e2:	b29b      	uxth	r3, r3
2400d1e4:	2b00      	cmp	r3, #0
2400d1e6:	d02c      	beq.n	2400d242 <I2C_Mem_ISR_IT+0x196>
2400d1e8:	68fb      	ldr	r3, [r7, #12]
2400d1ea:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d1ec:	2b00      	cmp	r3, #0
2400d1ee:	d128      	bne.n	2400d242 <I2C_Mem_ISR_IT+0x196>
    {
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d1f0:	68fb      	ldr	r3, [r7, #12]
2400d1f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d1f4:	b29b      	uxth	r3, r3
2400d1f6:	2bff      	cmp	r3, #255	; 0xff
2400d1f8:	d910      	bls.n	2400d21c <I2C_Mem_ISR_IT+0x170>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400d1fa:	68fb      	ldr	r3, [r7, #12]
2400d1fc:	22ff      	movs	r2, #255	; 0xff
2400d1fe:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
2400d200:	68fb      	ldr	r3, [r7, #12]
2400d202:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400d204:	b299      	uxth	r1, r3
2400d206:	68fb      	ldr	r3, [r7, #12]
2400d208:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d20a:	b2da      	uxtb	r2, r3
2400d20c:	2300      	movs	r3, #0
2400d20e:	9300      	str	r3, [sp, #0]
2400d210:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400d214:	68f8      	ldr	r0, [r7, #12]
2400d216:	f002 f887 	bl	2400f328 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d21a:	e017      	b.n	2400d24c <I2C_Mem_ISR_IT+0x1a0>
                           I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400d21c:	68fb      	ldr	r3, [r7, #12]
2400d21e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d220:	b29a      	uxth	r2, r3
2400d222:	68fb      	ldr	r3, [r7, #12]
2400d224:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
2400d226:	68fb      	ldr	r3, [r7, #12]
2400d228:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400d22a:	b299      	uxth	r1, r3
2400d22c:	68fb      	ldr	r3, [r7, #12]
2400d22e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d230:	b2da      	uxtb	r2, r3
2400d232:	2300      	movs	r3, #0
2400d234:	9300      	str	r3, [sp, #0]
2400d236:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400d23a:	68f8      	ldr	r0, [r7, #12]
2400d23c:	f002 f874 	bl	2400f328 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d240:	e004      	b.n	2400d24c <I2C_Mem_ISR_IT+0x1a0>
    }
    else
    {
      /* Wrong size Status regarding TCR flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d242:	2140      	movs	r1, #64	; 0x40
2400d244:	68f8      	ldr	r0, [r7, #12]
2400d246:	f001 fa37 	bl	2400e6b8 <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400d24a:	e03c      	b.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
2400d24c:	e03b      	b.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
2400d24e:	693b      	ldr	r3, [r7, #16]
2400d250:	099b      	lsrs	r3, r3, #6
2400d252:	f003 0301 	and.w	r3, r3, #1
2400d256:	2b00      	cmp	r3, #0
2400d258:	d035      	beq.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d25a:	687b      	ldr	r3, [r7, #4]
2400d25c:	099b      	lsrs	r3, r3, #6
2400d25e:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
2400d262:	2b00      	cmp	r3, #0
2400d264:	d02f      	beq.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
  {
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d266:	68fb      	ldr	r3, [r7, #12]
2400d268:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d26c:	b2db      	uxtb	r3, r3
2400d26e:	2b22      	cmp	r3, #34	; 0x22
2400d270:	d101      	bne.n	2400d276 <I2C_Mem_ISR_IT+0x1ca>
    {
      direction = I2C_GENERATE_START_READ;
2400d272:	4b22      	ldr	r3, [pc, #136]	; (2400d2fc <I2C_Mem_ISR_IT+0x250>)
2400d274:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d276:	68fb      	ldr	r3, [r7, #12]
2400d278:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d27a:	b29b      	uxth	r3, r3
2400d27c:	2bff      	cmp	r3, #255	; 0xff
2400d27e:	d910      	bls.n	2400d2a2 <I2C_Mem_ISR_IT+0x1f6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400d280:	68fb      	ldr	r3, [r7, #12]
2400d282:	22ff      	movs	r2, #255	; 0xff
2400d284:	851a      	strh	r2, [r3, #40]	; 0x28

      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
2400d286:	68fb      	ldr	r3, [r7, #12]
2400d288:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400d28a:	b299      	uxth	r1, r3
2400d28c:	68fb      	ldr	r3, [r7, #12]
2400d28e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d290:	b2da      	uxtb	r2, r3
2400d292:	697b      	ldr	r3, [r7, #20]
2400d294:	9300      	str	r3, [sp, #0]
2400d296:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400d29a:	68f8      	ldr	r0, [r7, #12]
2400d29c:	f002 f844 	bl	2400f328 <I2C_TransferConfig>
2400d2a0:	e011      	b.n	2400d2c6 <I2C_Mem_ISR_IT+0x21a>
                         I2C_RELOAD_MODE, direction);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400d2a2:	68fb      	ldr	r3, [r7, #12]
2400d2a4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d2a6:	b29a      	uxth	r2, r3
2400d2a8:	68fb      	ldr	r3, [r7, #12]
2400d2aa:	851a      	strh	r2, [r3, #40]	; 0x28

      /* Set NBYTES to write and generate RESTART */
      I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
2400d2ac:	68fb      	ldr	r3, [r7, #12]
2400d2ae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400d2b0:	b299      	uxth	r1, r3
2400d2b2:	68fb      	ldr	r3, [r7, #12]
2400d2b4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d2b6:	b2da      	uxtb	r2, r3
2400d2b8:	697b      	ldr	r3, [r7, #20]
2400d2ba:	9300      	str	r3, [sp, #0]
2400d2bc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400d2c0:	68f8      	ldr	r0, [r7, #12]
2400d2c2:	f002 f831 	bl	2400f328 <I2C_TransferConfig>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d2c6:	693b      	ldr	r3, [r7, #16]
2400d2c8:	095b      	lsrs	r3, r3, #5
2400d2ca:	f003 0301 	and.w	r3, r3, #1
2400d2ce:	2b00      	cmp	r3, #0
2400d2d0:	d009      	beq.n	2400d2e6 <I2C_Mem_ISR_IT+0x23a>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d2d2:	687b      	ldr	r3, [r7, #4]
2400d2d4:	095b      	lsrs	r3, r3, #5
2400d2d6:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d2da:	2b00      	cmp	r3, #0
2400d2dc:	d003      	beq.n	2400d2e6 <I2C_Mem_ISR_IT+0x23a>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
2400d2de:	6939      	ldr	r1, [r7, #16]
2400d2e0:	68f8      	ldr	r0, [r7, #12]
2400d2e2:	f000 fed1 	bl	2400e088 <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d2e6:	68fb      	ldr	r3, [r7, #12]
2400d2e8:	2200      	movs	r2, #0
2400d2ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400d2ee:	2300      	movs	r3, #0
}
2400d2f0:	4618      	mov	r0, r3
2400d2f2:	3718      	adds	r7, #24
2400d2f4:	46bd      	mov	sp, r7
2400d2f6:	bd80      	pop	{r7, pc}
2400d2f8:	80002000 	.word	0x80002000
2400d2fc:	80002400 	.word	0x80002400

2400d300 <I2C_Slave_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                          uint32_t ITSources)
{
2400d300:	b580      	push	{r7, lr}
2400d302:	b086      	sub	sp, #24
2400d304:	af00      	add	r7, sp, #0
2400d306:	60f8      	str	r0, [r7, #12]
2400d308:	60b9      	str	r1, [r7, #8]
2400d30a:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2400d30c:	68fb      	ldr	r3, [r7, #12]
2400d30e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d310:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
2400d312:	68bb      	ldr	r3, [r7, #8]
2400d314:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
2400d316:	68fb      	ldr	r3, [r7, #12]
2400d318:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d31c:	2b01      	cmp	r3, #1
2400d31e:	d101      	bne.n	2400d324 <I2C_Slave_ISR_IT+0x24>
2400d320:	2302      	movs	r3, #2
2400d322:	e0ec      	b.n	2400d4fe <I2C_Slave_ISR_IT+0x1fe>
2400d324:	68fb      	ldr	r3, [r7, #12]
2400d326:	2201      	movs	r2, #1
2400d328:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d32c:	693b      	ldr	r3, [r7, #16]
2400d32e:	095b      	lsrs	r3, r3, #5
2400d330:	f003 0301 	and.w	r3, r3, #1
2400d334:	2b00      	cmp	r3, #0
2400d336:	d009      	beq.n	2400d34c <I2C_Slave_ISR_IT+0x4c>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d338:	687b      	ldr	r3, [r7, #4]
2400d33a:	095b      	lsrs	r3, r3, #5
2400d33c:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d340:	2b00      	cmp	r3, #0
2400d342:	d003      	beq.n	2400d34c <I2C_Slave_ISR_IT+0x4c>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
2400d344:	6939      	ldr	r1, [r7, #16]
2400d346:	68f8      	ldr	r0, [r7, #12]
2400d348:	f000 ff68 	bl	2400e21c <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400d34c:	693b      	ldr	r3, [r7, #16]
2400d34e:	091b      	lsrs	r3, r3, #4
2400d350:	f003 0301 	and.w	r3, r3, #1
2400d354:	2b00      	cmp	r3, #0
2400d356:	d04d      	beq.n	2400d3f4 <I2C_Slave_ISR_IT+0xf4>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d358:	687b      	ldr	r3, [r7, #4]
2400d35a:	091b      	lsrs	r3, r3, #4
2400d35c:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400d360:	2b00      	cmp	r3, #0
2400d362:	d047      	beq.n	2400d3f4 <I2C_Slave_ISR_IT+0xf4>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
2400d364:	68fb      	ldr	r3, [r7, #12]
2400d366:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d368:	b29b      	uxth	r3, r3
2400d36a:	2b00      	cmp	r3, #0
2400d36c:	d128      	bne.n	2400d3c0 <I2C_Slave_ISR_IT+0xc0>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
2400d36e:	68fb      	ldr	r3, [r7, #12]
2400d370:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d374:	b2db      	uxtb	r3, r3
2400d376:	2b28      	cmp	r3, #40	; 0x28
2400d378:	d108      	bne.n	2400d38c <I2C_Slave_ISR_IT+0x8c>
2400d37a:	697b      	ldr	r3, [r7, #20]
2400d37c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d380:	d104      	bne.n	2400d38c <I2C_Slave_ISR_IT+0x8c>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
2400d382:	6939      	ldr	r1, [r7, #16]
2400d384:	68f8      	ldr	r0, [r7, #12]
2400d386:	f001 f941 	bl	2400e60c <I2C_ITListenCplt>
2400d38a:	e032      	b.n	2400d3f2 <I2C_Slave_ISR_IT+0xf2>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
2400d38c:	68fb      	ldr	r3, [r7, #12]
2400d38e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d392:	b2db      	uxtb	r3, r3
2400d394:	2b29      	cmp	r3, #41	; 0x29
2400d396:	d10e      	bne.n	2400d3b6 <I2C_Slave_ISR_IT+0xb6>
2400d398:	697b      	ldr	r3, [r7, #20]
2400d39a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d39e:	d00a      	beq.n	2400d3b6 <I2C_Slave_ISR_IT+0xb6>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d3a0:	68fb      	ldr	r3, [r7, #12]
2400d3a2:	681b      	ldr	r3, [r3, #0]
2400d3a4:	2210      	movs	r2, #16
2400d3a6:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
2400d3a8:	68f8      	ldr	r0, [r7, #12]
2400d3aa:	f001 fa9c 	bl	2400e8e6 <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2400d3ae:	68f8      	ldr	r0, [r7, #12]
2400d3b0:	f000 fe0b 	bl	2400dfca <I2C_ITSlaveSeqCplt>
2400d3b4:	e01d      	b.n	2400d3f2 <I2C_Slave_ISR_IT+0xf2>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d3b6:	68fb      	ldr	r3, [r7, #12]
2400d3b8:	681b      	ldr	r3, [r3, #0]
2400d3ba:	2210      	movs	r2, #16
2400d3bc:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
2400d3be:	e096      	b.n	2400d4ee <I2C_Slave_ISR_IT+0x1ee>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d3c0:	68fb      	ldr	r3, [r7, #12]
2400d3c2:	681b      	ldr	r3, [r3, #0]
2400d3c4:	2210      	movs	r2, #16
2400d3c6:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d3c8:	68fb      	ldr	r3, [r7, #12]
2400d3ca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d3cc:	f043 0204 	orr.w	r2, r3, #4
2400d3d0:	68fb      	ldr	r3, [r7, #12]
2400d3d2:	645a      	str	r2, [r3, #68]	; 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2400d3d4:	697b      	ldr	r3, [r7, #20]
2400d3d6:	2b00      	cmp	r3, #0
2400d3d8:	d004      	beq.n	2400d3e4 <I2C_Slave_ISR_IT+0xe4>
2400d3da:	697b      	ldr	r3, [r7, #20]
2400d3dc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400d3e0:	f040 8085 	bne.w	2400d4ee <I2C_Slave_ISR_IT+0x1ee>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
2400d3e4:	68fb      	ldr	r3, [r7, #12]
2400d3e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d3e8:	4619      	mov	r1, r3
2400d3ea:	68f8      	ldr	r0, [r7, #12]
2400d3ec:	f001 f964 	bl	2400e6b8 <I2C_ITError>
    if (hi2c->XferCount == 0U)
2400d3f0:	e07d      	b.n	2400d4ee <I2C_Slave_ISR_IT+0x1ee>
2400d3f2:	e07c      	b.n	2400d4ee <I2C_Slave_ISR_IT+0x1ee>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400d3f4:	693b      	ldr	r3, [r7, #16]
2400d3f6:	089b      	lsrs	r3, r3, #2
2400d3f8:	f003 0301 	and.w	r3, r3, #1
2400d3fc:	2b00      	cmp	r3, #0
2400d3fe:	d030      	beq.n	2400d462 <I2C_Slave_ISR_IT+0x162>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400d400:	687b      	ldr	r3, [r7, #4]
2400d402:	089b      	lsrs	r3, r3, #2
2400d404:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400d408:	2b00      	cmp	r3, #0
2400d40a:	d02a      	beq.n	2400d462 <I2C_Slave_ISR_IT+0x162>
  {
    if (hi2c->XferCount > 0U)
2400d40c:	68fb      	ldr	r3, [r7, #12]
2400d40e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d410:	b29b      	uxth	r3, r3
2400d412:	2b00      	cmp	r3, #0
2400d414:	d018      	beq.n	2400d448 <I2C_Slave_ISR_IT+0x148>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400d416:	68fb      	ldr	r3, [r7, #12]
2400d418:	681b      	ldr	r3, [r3, #0]
2400d41a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400d41c:	68fb      	ldr	r3, [r7, #12]
2400d41e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d420:	b2d2      	uxtb	r2, r2
2400d422:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400d424:	68fb      	ldr	r3, [r7, #12]
2400d426:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d428:	1c5a      	adds	r2, r3, #1
2400d42a:	68fb      	ldr	r3, [r7, #12]
2400d42c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400d42e:	68fb      	ldr	r3, [r7, #12]
2400d430:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d432:	3b01      	subs	r3, #1
2400d434:	b29a      	uxth	r2, r3
2400d436:	68fb      	ldr	r3, [r7, #12]
2400d438:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400d43a:	68fb      	ldr	r3, [r7, #12]
2400d43c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d43e:	b29b      	uxth	r3, r3
2400d440:	3b01      	subs	r3, #1
2400d442:	b29a      	uxth	r2, r3
2400d444:	68fb      	ldr	r3, [r7, #12]
2400d446:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
2400d448:	68fb      	ldr	r3, [r7, #12]
2400d44a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d44c:	b29b      	uxth	r3, r3
2400d44e:	2b00      	cmp	r3, #0
2400d450:	d14f      	bne.n	2400d4f2 <I2C_Slave_ISR_IT+0x1f2>
2400d452:	697b      	ldr	r3, [r7, #20]
2400d454:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d458:	d04b      	beq.n	2400d4f2 <I2C_Slave_ISR_IT+0x1f2>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
2400d45a:	68f8      	ldr	r0, [r7, #12]
2400d45c:	f000 fdb5 	bl	2400dfca <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
2400d460:	e047      	b.n	2400d4f2 <I2C_Slave_ISR_IT+0x1f2>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
2400d462:	693b      	ldr	r3, [r7, #16]
2400d464:	08db      	lsrs	r3, r3, #3
2400d466:	f003 0301 	and.w	r3, r3, #1
2400d46a:	2b00      	cmp	r3, #0
2400d46c:	d00a      	beq.n	2400d484 <I2C_Slave_ISR_IT+0x184>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
2400d46e:	687b      	ldr	r3, [r7, #4]
2400d470:	08db      	lsrs	r3, r3, #3
2400d472:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
2400d476:	2b00      	cmp	r3, #0
2400d478:	d004      	beq.n	2400d484 <I2C_Slave_ISR_IT+0x184>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
2400d47a:	6939      	ldr	r1, [r7, #16]
2400d47c:	68f8      	ldr	r0, [r7, #12]
2400d47e:	f000 fce3 	bl	2400de48 <I2C_ITAddrCplt>
2400d482:	e037      	b.n	2400d4f4 <I2C_Slave_ISR_IT+0x1f4>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d484:	693b      	ldr	r3, [r7, #16]
2400d486:	085b      	lsrs	r3, r3, #1
2400d488:	f003 0301 	and.w	r3, r3, #1
2400d48c:	2b00      	cmp	r3, #0
2400d48e:	d031      	beq.n	2400d4f4 <I2C_Slave_ISR_IT+0x1f4>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400d490:	687b      	ldr	r3, [r7, #4]
2400d492:	085b      	lsrs	r3, r3, #1
2400d494:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d498:	2b00      	cmp	r3, #0
2400d49a:	d02b      	beq.n	2400d4f4 <I2C_Slave_ISR_IT+0x1f4>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Data have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
2400d49c:	68fb      	ldr	r3, [r7, #12]
2400d49e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d4a0:	b29b      	uxth	r3, r3
2400d4a2:	2b00      	cmp	r3, #0
2400d4a4:	d018      	beq.n	2400d4d8 <I2C_Slave_ISR_IT+0x1d8>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400d4a6:	68fb      	ldr	r3, [r7, #12]
2400d4a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d4aa:	781a      	ldrb	r2, [r3, #0]
2400d4ac:	68fb      	ldr	r3, [r7, #12]
2400d4ae:	681b      	ldr	r3, [r3, #0]
2400d4b0:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400d4b2:	68fb      	ldr	r3, [r7, #12]
2400d4b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d4b6:	1c5a      	adds	r2, r3, #1
2400d4b8:	68fb      	ldr	r3, [r7, #12]
2400d4ba:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400d4bc:	68fb      	ldr	r3, [r7, #12]
2400d4be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d4c0:	b29b      	uxth	r3, r3
2400d4c2:	3b01      	subs	r3, #1
2400d4c4:	b29a      	uxth	r2, r3
2400d4c6:	68fb      	ldr	r3, [r7, #12]
2400d4c8:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400d4ca:	68fb      	ldr	r3, [r7, #12]
2400d4cc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d4ce:	3b01      	subs	r3, #1
2400d4d0:	b29a      	uxth	r2, r3
2400d4d2:	68fb      	ldr	r3, [r7, #12]
2400d4d4:	851a      	strh	r2, [r3, #40]	; 0x28
2400d4d6:	e00d      	b.n	2400d4f4 <I2C_Slave_ISR_IT+0x1f4>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400d4d8:	697b      	ldr	r3, [r7, #20]
2400d4da:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400d4de:	d002      	beq.n	2400d4e6 <I2C_Slave_ISR_IT+0x1e6>
2400d4e0:	697b      	ldr	r3, [r7, #20]
2400d4e2:	2b00      	cmp	r3, #0
2400d4e4:	d106      	bne.n	2400d4f4 <I2C_Slave_ISR_IT+0x1f4>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2400d4e6:	68f8      	ldr	r0, [r7, #12]
2400d4e8:	f000 fd6f 	bl	2400dfca <I2C_ITSlaveSeqCplt>
2400d4ec:	e002      	b.n	2400d4f4 <I2C_Slave_ISR_IT+0x1f4>
    if (hi2c->XferCount == 0U)
2400d4ee:	bf00      	nop
2400d4f0:	e000      	b.n	2400d4f4 <I2C_Slave_ISR_IT+0x1f4>
    if ((hi2c->XferCount == 0U) && \
2400d4f2:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d4f4:	68fb      	ldr	r3, [r7, #12]
2400d4f6:	2200      	movs	r2, #0
2400d4f8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400d4fc:	2300      	movs	r3, #0
}
2400d4fe:	4618      	mov	r0, r3
2400d500:	3718      	adds	r7, #24
2400d502:	46bd      	mov	sp, r7
2400d504:	bd80      	pop	{r7, pc}

2400d506 <I2C_Master_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                            uint32_t ITSources)
{
2400d506:	b580      	push	{r7, lr}
2400d508:	b088      	sub	sp, #32
2400d50a:	af02      	add	r7, sp, #8
2400d50c:	60f8      	str	r0, [r7, #12]
2400d50e:	60b9      	str	r1, [r7, #8]
2400d510:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t xfermode;

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400d512:	68fb      	ldr	r3, [r7, #12]
2400d514:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d518:	2b01      	cmp	r3, #1
2400d51a:	d101      	bne.n	2400d520 <I2C_Master_ISR_DMA+0x1a>
2400d51c:	2302      	movs	r3, #2
2400d51e:	e0e1      	b.n	2400d6e4 <I2C_Master_ISR_DMA+0x1de>
2400d520:	68fb      	ldr	r3, [r7, #12]
2400d522:	2201      	movs	r2, #1
2400d524:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d528:	68bb      	ldr	r3, [r7, #8]
2400d52a:	091b      	lsrs	r3, r3, #4
2400d52c:	f003 0301 	and.w	r3, r3, #1
2400d530:	2b00      	cmp	r3, #0
2400d532:	d017      	beq.n	2400d564 <I2C_Master_ISR_DMA+0x5e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d534:	687b      	ldr	r3, [r7, #4]
2400d536:	091b      	lsrs	r3, r3, #4
2400d538:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d53c:	2b00      	cmp	r3, #0
2400d53e:	d011      	beq.n	2400d564 <I2C_Master_ISR_DMA+0x5e>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d540:	68fb      	ldr	r3, [r7, #12]
2400d542:	681b      	ldr	r3, [r3, #0]
2400d544:	2210      	movs	r2, #16
2400d546:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d548:	68fb      	ldr	r3, [r7, #12]
2400d54a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d54c:	f043 0204 	orr.w	r2, r3, #4
2400d550:	68fb      	ldr	r3, [r7, #12]
2400d552:	645a      	str	r2, [r3, #68]	; 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400d554:	2120      	movs	r1, #32
2400d556:	68f8      	ldr	r0, [r7, #12]
2400d558:	f001 ff18 	bl	2400f38c <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400d55c:	68f8      	ldr	r0, [r7, #12]
2400d55e:	f001 f9c2 	bl	2400e8e6 <I2C_Flush_TXDR>
2400d562:	e0ba      	b.n	2400d6da <I2C_Master_ISR_DMA+0x1d4>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
2400d564:	68bb      	ldr	r3, [r7, #8]
2400d566:	09db      	lsrs	r3, r3, #7
2400d568:	f003 0301 	and.w	r3, r3, #1
2400d56c:	2b00      	cmp	r3, #0
2400d56e:	d072      	beq.n	2400d656 <I2C_Master_ISR_DMA+0x150>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d570:	687b      	ldr	r3, [r7, #4]
2400d572:	099b      	lsrs	r3, r3, #6
2400d574:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
2400d578:	2b00      	cmp	r3, #0
2400d57a:	d06c      	beq.n	2400d656 <I2C_Master_ISR_DMA+0x150>
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
2400d57c:	68fb      	ldr	r3, [r7, #12]
2400d57e:	681b      	ldr	r3, [r3, #0]
2400d580:	681a      	ldr	r2, [r3, #0]
2400d582:	68fb      	ldr	r3, [r7, #12]
2400d584:	681b      	ldr	r3, [r3, #0]
2400d586:	f022 0240 	bic.w	r2, r2, #64	; 0x40
2400d58a:	601a      	str	r2, [r3, #0]

    if (hi2c->XferCount != 0U)
2400d58c:	68fb      	ldr	r3, [r7, #12]
2400d58e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d590:	b29b      	uxth	r3, r3
2400d592:	2b00      	cmp	r3, #0
2400d594:	d04e      	beq.n	2400d634 <I2C_Master_ISR_DMA+0x12e>
    {
      /* Recover Slave address */
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2400d596:	68fb      	ldr	r3, [r7, #12]
2400d598:	681b      	ldr	r3, [r3, #0]
2400d59a:	685b      	ldr	r3, [r3, #4]
2400d59c:	b29b      	uxth	r3, r3
2400d59e:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400d5a2:	827b      	strh	r3, [r7, #18]

      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d5a4:	68fb      	ldr	r3, [r7, #12]
2400d5a6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d5a8:	b29b      	uxth	r3, r3
2400d5aa:	2bff      	cmp	r3, #255	; 0xff
2400d5ac:	d906      	bls.n	2400d5bc <I2C_Master_ISR_DMA+0xb6>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400d5ae:	68fb      	ldr	r3, [r7, #12]
2400d5b0:	22ff      	movs	r2, #255	; 0xff
2400d5b2:	851a      	strh	r2, [r3, #40]	; 0x28
        xfermode = I2C_RELOAD_MODE;
2400d5b4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400d5b8:	617b      	str	r3, [r7, #20]
2400d5ba:	e010      	b.n	2400d5de <I2C_Master_ISR_DMA+0xd8>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400d5bc:	68fb      	ldr	r3, [r7, #12]
2400d5be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d5c0:	b29a      	uxth	r2, r3
2400d5c2:	68fb      	ldr	r3, [r7, #12]
2400d5c4:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400d5c6:	68fb      	ldr	r3, [r7, #12]
2400d5c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d5ca:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d5ce:	d003      	beq.n	2400d5d8 <I2C_Master_ISR_DMA+0xd2>
        {
          xfermode = hi2c->XferOptions;
2400d5d0:	68fb      	ldr	r3, [r7, #12]
2400d5d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d5d4:	617b      	str	r3, [r7, #20]
2400d5d6:	e002      	b.n	2400d5de <I2C_Master_ISR_DMA+0xd8>
        }
        else
        {
          xfermode = I2C_AUTOEND_MODE;
2400d5d8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400d5dc:	617b      	str	r3, [r7, #20]
        }
      }

      /* Set the new XferSize in Nbytes register */
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400d5de:	68fb      	ldr	r3, [r7, #12]
2400d5e0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d5e2:	b2da      	uxtb	r2, r3
2400d5e4:	8a79      	ldrh	r1, [r7, #18]
2400d5e6:	2300      	movs	r3, #0
2400d5e8:	9300      	str	r3, [sp, #0]
2400d5ea:	697b      	ldr	r3, [r7, #20]
2400d5ec:	68f8      	ldr	r0, [r7, #12]
2400d5ee:	f001 fe9b 	bl	2400f328 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400d5f2:	68fb      	ldr	r3, [r7, #12]
2400d5f4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d5f6:	b29a      	uxth	r2, r3
2400d5f8:	68fb      	ldr	r3, [r7, #12]
2400d5fa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d5fc:	1ad3      	subs	r3, r2, r3
2400d5fe:	b29a      	uxth	r2, r3
2400d600:	68fb      	ldr	r3, [r7, #12]
2400d602:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d604:	68fb      	ldr	r3, [r7, #12]
2400d606:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d60a:	b2db      	uxtb	r3, r3
2400d60c:	2b22      	cmp	r3, #34	; 0x22
2400d60e:	d108      	bne.n	2400d622 <I2C_Master_ISR_DMA+0x11c>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400d610:	68fb      	ldr	r3, [r7, #12]
2400d612:	681b      	ldr	r3, [r3, #0]
2400d614:	681a      	ldr	r2, [r3, #0]
2400d616:	68fb      	ldr	r3, [r7, #12]
2400d618:	681b      	ldr	r3, [r3, #0]
2400d61a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400d61e:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400d620:	e05b      	b.n	2400d6da <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400d622:	68fb      	ldr	r3, [r7, #12]
2400d624:	681b      	ldr	r3, [r3, #0]
2400d626:	681a      	ldr	r2, [r3, #0]
2400d628:	68fb      	ldr	r3, [r7, #12]
2400d62a:	681b      	ldr	r3, [r3, #0]
2400d62c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400d630:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400d632:	e052      	b.n	2400d6da <I2C_Master_ISR_DMA+0x1d4>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400d634:	68fb      	ldr	r3, [r7, #12]
2400d636:	681b      	ldr	r3, [r3, #0]
2400d638:	685b      	ldr	r3, [r3, #4]
2400d63a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400d63e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d642:	d003      	beq.n	2400d64c <I2C_Master_ISR_DMA+0x146>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2400d644:	68f8      	ldr	r0, [r7, #12]
2400d646:	f000 fc83 	bl	2400df50 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount != 0U)
2400d64a:	e046      	b.n	2400d6da <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d64c:	2140      	movs	r1, #64	; 0x40
2400d64e:	68f8      	ldr	r0, [r7, #12]
2400d650:	f001 f832 	bl	2400e6b8 <I2C_ITError>
    if (hi2c->XferCount != 0U)
2400d654:	e041      	b.n	2400d6da <I2C_Master_ISR_DMA+0x1d4>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
2400d656:	68bb      	ldr	r3, [r7, #8]
2400d658:	099b      	lsrs	r3, r3, #6
2400d65a:	f003 0301 	and.w	r3, r3, #1
2400d65e:	2b00      	cmp	r3, #0
2400d660:	d029      	beq.n	2400d6b6 <I2C_Master_ISR_DMA+0x1b0>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d662:	687b      	ldr	r3, [r7, #4]
2400d664:	099b      	lsrs	r3, r3, #6
2400d666:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
2400d66a:	2b00      	cmp	r3, #0
2400d66c:	d023      	beq.n	2400d6b6 <I2C_Master_ISR_DMA+0x1b0>
  {
    if (hi2c->XferCount == 0U)
2400d66e:	68fb      	ldr	r3, [r7, #12]
2400d670:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d672:	b29b      	uxth	r3, r3
2400d674:	2b00      	cmp	r3, #0
2400d676:	d119      	bne.n	2400d6ac <I2C_Master_ISR_DMA+0x1a6>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400d678:	68fb      	ldr	r3, [r7, #12]
2400d67a:	681b      	ldr	r3, [r3, #0]
2400d67c:	685b      	ldr	r3, [r3, #4]
2400d67e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400d682:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d686:	d027      	beq.n	2400d6d8 <I2C_Master_ISR_DMA+0x1d2>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2400d688:	68fb      	ldr	r3, [r7, #12]
2400d68a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d68c:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d690:	d108      	bne.n	2400d6a4 <I2C_Master_ISR_DMA+0x19e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400d692:	68fb      	ldr	r3, [r7, #12]
2400d694:	681b      	ldr	r3, [r3, #0]
2400d696:	685a      	ldr	r2, [r3, #4]
2400d698:	68fb      	ldr	r3, [r7, #12]
2400d69a:	681b      	ldr	r3, [r3, #0]
2400d69c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400d6a0:	605a      	str	r2, [r3, #4]
    if (hi2c->XferCount == 0U)
2400d6a2:	e019      	b.n	2400d6d8 <I2C_Master_ISR_DMA+0x1d2>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
2400d6a4:	68f8      	ldr	r0, [r7, #12]
2400d6a6:	f000 fc53 	bl	2400df50 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount == 0U)
2400d6aa:	e015      	b.n	2400d6d8 <I2C_Master_ISR_DMA+0x1d2>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d6ac:	2140      	movs	r1, #64	; 0x40
2400d6ae:	68f8      	ldr	r0, [r7, #12]
2400d6b0:	f001 f802 	bl	2400e6b8 <I2C_ITError>
    if (hi2c->XferCount == 0U)
2400d6b4:	e010      	b.n	2400d6d8 <I2C_Master_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d6b6:	68bb      	ldr	r3, [r7, #8]
2400d6b8:	095b      	lsrs	r3, r3, #5
2400d6ba:	f003 0301 	and.w	r3, r3, #1
2400d6be:	2b00      	cmp	r3, #0
2400d6c0:	d00b      	beq.n	2400d6da <I2C_Master_ISR_DMA+0x1d4>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d6c2:	687b      	ldr	r3, [r7, #4]
2400d6c4:	095b      	lsrs	r3, r3, #5
2400d6c6:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d6ca:	2b00      	cmp	r3, #0
2400d6cc:	d005      	beq.n	2400d6da <I2C_Master_ISR_DMA+0x1d4>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
2400d6ce:	68b9      	ldr	r1, [r7, #8]
2400d6d0:	68f8      	ldr	r0, [r7, #12]
2400d6d2:	f000 fcd9 	bl	2400e088 <I2C_ITMasterCplt>
2400d6d6:	e000      	b.n	2400d6da <I2C_Master_ISR_DMA+0x1d4>
    if (hi2c->XferCount == 0U)
2400d6d8:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d6da:	68fb      	ldr	r3, [r7, #12]
2400d6dc:	2200      	movs	r2, #0
2400d6de:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400d6e2:	2300      	movs	r3, #0
}
2400d6e4:	4618      	mov	r0, r3
2400d6e6:	3718      	adds	r7, #24
2400d6e8:	46bd      	mov	sp, r7
2400d6ea:	bd80      	pop	{r7, pc}

2400d6ec <I2C_Mem_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Mem_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                         uint32_t ITSources)
{
2400d6ec:	b580      	push	{r7, lr}
2400d6ee:	b088      	sub	sp, #32
2400d6f0:	af02      	add	r7, sp, #8
2400d6f2:	60f8      	str	r0, [r7, #12]
2400d6f4:	60b9      	str	r1, [r7, #8]
2400d6f6:	607a      	str	r2, [r7, #4]
  uint32_t direction = I2C_GENERATE_START_WRITE;
2400d6f8:	4b8c      	ldr	r3, [pc, #560]	; (2400d92c <I2C_Mem_ISR_DMA+0x240>)
2400d6fa:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400d6fc:	68fb      	ldr	r3, [r7, #12]
2400d6fe:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d702:	2b01      	cmp	r3, #1
2400d704:	d101      	bne.n	2400d70a <I2C_Mem_ISR_DMA+0x1e>
2400d706:	2302      	movs	r3, #2
2400d708:	e10c      	b.n	2400d924 <I2C_Mem_ISR_DMA+0x238>
2400d70a:	68fb      	ldr	r3, [r7, #12]
2400d70c:	2201      	movs	r2, #1
2400d70e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d712:	68bb      	ldr	r3, [r7, #8]
2400d714:	091b      	lsrs	r3, r3, #4
2400d716:	f003 0301 	and.w	r3, r3, #1
2400d71a:	2b00      	cmp	r3, #0
2400d71c:	d017      	beq.n	2400d74e <I2C_Mem_ISR_DMA+0x62>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d71e:	687b      	ldr	r3, [r7, #4]
2400d720:	091b      	lsrs	r3, r3, #4
2400d722:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d726:	2b00      	cmp	r3, #0
2400d728:	d011      	beq.n	2400d74e <I2C_Mem_ISR_DMA+0x62>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d72a:	68fb      	ldr	r3, [r7, #12]
2400d72c:	681b      	ldr	r3, [r3, #0]
2400d72e:	2210      	movs	r2, #16
2400d730:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d732:	68fb      	ldr	r3, [r7, #12]
2400d734:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d736:	f043 0204 	orr.w	r2, r3, #4
2400d73a:	68fb      	ldr	r3, [r7, #12]
2400d73c:	645a      	str	r2, [r3, #68]	; 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400d73e:	2120      	movs	r1, #32
2400d740:	68f8      	ldr	r0, [r7, #12]
2400d742:	f001 fe23 	bl	2400f38c <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400d746:	68f8      	ldr	r0, [r7, #12]
2400d748:	f001 f8cd 	bl	2400e8e6 <I2C_Flush_TXDR>
2400d74c:	e0e5      	b.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d74e:	68bb      	ldr	r3, [r7, #8]
2400d750:	085b      	lsrs	r3, r3, #1
2400d752:	f003 0301 	and.w	r3, r3, #1
2400d756:	2b00      	cmp	r3, #0
2400d758:	d00f      	beq.n	2400d77a <I2C_Mem_ISR_DMA+0x8e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400d75a:	687b      	ldr	r3, [r7, #4]
2400d75c:	085b      	lsrs	r3, r3, #1
2400d75e:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d762:	2b00      	cmp	r3, #0
2400d764:	d009      	beq.n	2400d77a <I2C_Mem_ISR_DMA+0x8e>
  {
    /* Write LSB part of Memory Address */
    hi2c->Instance->TXDR = hi2c->Memaddress;
2400d766:	68fb      	ldr	r3, [r7, #12]
2400d768:	681b      	ldr	r3, [r3, #0]
2400d76a:	68fa      	ldr	r2, [r7, #12]
2400d76c:	6d12      	ldr	r2, [r2, #80]	; 0x50
2400d76e:	629a      	str	r2, [r3, #40]	; 0x28

    /* Reset Memaddress content */
    hi2c->Memaddress = 0xFFFFFFFFU;
2400d770:	68fb      	ldr	r3, [r7, #12]
2400d772:	f04f 32ff 	mov.w	r2, #4294967295
2400d776:	651a      	str	r2, [r3, #80]	; 0x50
2400d778:	e0cf      	b.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
2400d77a:	68bb      	ldr	r3, [r7, #8]
2400d77c:	09db      	lsrs	r3, r3, #7
2400d77e:	f003 0301 	and.w	r3, r3, #1
2400d782:	2b00      	cmp	r3, #0
2400d784:	d05c      	beq.n	2400d840 <I2C_Mem_ISR_DMA+0x154>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d786:	687b      	ldr	r3, [r7, #4]
2400d788:	099b      	lsrs	r3, r3, #6
2400d78a:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
2400d78e:	2b00      	cmp	r3, #0
2400d790:	d056      	beq.n	2400d840 <I2C_Mem_ISR_DMA+0x154>
  {
    /* Enable only Error interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400d792:	2110      	movs	r1, #16
2400d794:	68f8      	ldr	r0, [r7, #12]
2400d796:	f001 fdf9 	bl	2400f38c <I2C_Enable_IRQ>

    if (hi2c->XferCount != 0U)
2400d79a:	68fb      	ldr	r3, [r7, #12]
2400d79c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d79e:	b29b      	uxth	r3, r3
2400d7a0:	2b00      	cmp	r3, #0
2400d7a2:	d048      	beq.n	2400d836 <I2C_Mem_ISR_DMA+0x14a>
    {
      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d7a4:	68fb      	ldr	r3, [r7, #12]
2400d7a6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d7a8:	b29b      	uxth	r3, r3
2400d7aa:	2bff      	cmp	r3, #255	; 0xff
2400d7ac:	d910      	bls.n	2400d7d0 <I2C_Mem_ISR_DMA+0xe4>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400d7ae:	68fb      	ldr	r3, [r7, #12]
2400d7b0:	22ff      	movs	r2, #255	; 0xff
2400d7b2:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
2400d7b4:	68fb      	ldr	r3, [r7, #12]
2400d7b6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400d7b8:	b299      	uxth	r1, r3
2400d7ba:	68fb      	ldr	r3, [r7, #12]
2400d7bc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d7be:	b2da      	uxtb	r2, r3
2400d7c0:	2300      	movs	r3, #0
2400d7c2:	9300      	str	r3, [sp, #0]
2400d7c4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400d7c8:	68f8      	ldr	r0, [r7, #12]
2400d7ca:	f001 fdad 	bl	2400f328 <I2C_TransferConfig>
2400d7ce:	e011      	b.n	2400d7f4 <I2C_Mem_ISR_DMA+0x108>
                           I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400d7d0:	68fb      	ldr	r3, [r7, #12]
2400d7d2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d7d4:	b29a      	uxth	r2, r3
2400d7d6:	68fb      	ldr	r3, [r7, #12]
2400d7d8:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
2400d7da:	68fb      	ldr	r3, [r7, #12]
2400d7dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400d7de:	b299      	uxth	r1, r3
2400d7e0:	68fb      	ldr	r3, [r7, #12]
2400d7e2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d7e4:	b2da      	uxtb	r2, r3
2400d7e6:	2300      	movs	r3, #0
2400d7e8:	9300      	str	r3, [sp, #0]
2400d7ea:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400d7ee:	68f8      	ldr	r0, [r7, #12]
2400d7f0:	f001 fd9a 	bl	2400f328 <I2C_TransferConfig>
                           I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
      }

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400d7f4:	68fb      	ldr	r3, [r7, #12]
2400d7f6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d7f8:	b29a      	uxth	r2, r3
2400d7fa:	68fb      	ldr	r3, [r7, #12]
2400d7fc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d7fe:	1ad3      	subs	r3, r2, r3
2400d800:	b29a      	uxth	r2, r3
2400d802:	68fb      	ldr	r3, [r7, #12]
2400d804:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d806:	68fb      	ldr	r3, [r7, #12]
2400d808:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d80c:	b2db      	uxtb	r3, r3
2400d80e:	2b22      	cmp	r3, #34	; 0x22
2400d810:	d108      	bne.n	2400d824 <I2C_Mem_ISR_DMA+0x138>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400d812:	68fb      	ldr	r3, [r7, #12]
2400d814:	681b      	ldr	r3, [r3, #0]
2400d816:	681a      	ldr	r2, [r3, #0]
2400d818:	68fb      	ldr	r3, [r7, #12]
2400d81a:	681b      	ldr	r3, [r3, #0]
2400d81c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400d820:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400d822:	e07a      	b.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400d824:	68fb      	ldr	r3, [r7, #12]
2400d826:	681b      	ldr	r3, [r3, #0]
2400d828:	681a      	ldr	r2, [r3, #0]
2400d82a:	68fb      	ldr	r3, [r7, #12]
2400d82c:	681b      	ldr	r3, [r3, #0]
2400d82e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400d832:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400d834:	e071      	b.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
    }
    else
    {
      /* Wrong size Status regarding TCR flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d836:	2140      	movs	r1, #64	; 0x40
2400d838:	68f8      	ldr	r0, [r7, #12]
2400d83a:	f000 ff3d 	bl	2400e6b8 <I2C_ITError>
    if (hi2c->XferCount != 0U)
2400d83e:	e06c      	b.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
2400d840:	68bb      	ldr	r3, [r7, #8]
2400d842:	099b      	lsrs	r3, r3, #6
2400d844:	f003 0301 	and.w	r3, r3, #1
2400d848:	2b00      	cmp	r3, #0
2400d84a:	d056      	beq.n	2400d8fa <I2C_Mem_ISR_DMA+0x20e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d84c:	687b      	ldr	r3, [r7, #4]
2400d84e:	099b      	lsrs	r3, r3, #6
2400d850:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
2400d854:	2b00      	cmp	r3, #0
2400d856:	d050      	beq.n	2400d8fa <I2C_Mem_ISR_DMA+0x20e>
  {
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d858:	68fb      	ldr	r3, [r7, #12]
2400d85a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d85e:	b2db      	uxtb	r3, r3
2400d860:	2b22      	cmp	r3, #34	; 0x22
2400d862:	d101      	bne.n	2400d868 <I2C_Mem_ISR_DMA+0x17c>
    {
      direction = I2C_GENERATE_START_READ;
2400d864:	4b32      	ldr	r3, [pc, #200]	; (2400d930 <I2C_Mem_ISR_DMA+0x244>)
2400d866:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d868:	68fb      	ldr	r3, [r7, #12]
2400d86a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d86c:	b29b      	uxth	r3, r3
2400d86e:	2bff      	cmp	r3, #255	; 0xff
2400d870:	d910      	bls.n	2400d894 <I2C_Mem_ISR_DMA+0x1a8>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400d872:	68fb      	ldr	r3, [r7, #12]
2400d874:	22ff      	movs	r2, #255	; 0xff
2400d876:	851a      	strh	r2, [r3, #40]	; 0x28

      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
2400d878:	68fb      	ldr	r3, [r7, #12]
2400d87a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400d87c:	b299      	uxth	r1, r3
2400d87e:	68fb      	ldr	r3, [r7, #12]
2400d880:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d882:	b2da      	uxtb	r2, r3
2400d884:	697b      	ldr	r3, [r7, #20]
2400d886:	9300      	str	r3, [sp, #0]
2400d888:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400d88c:	68f8      	ldr	r0, [r7, #12]
2400d88e:	f001 fd4b 	bl	2400f328 <I2C_TransferConfig>
2400d892:	e011      	b.n	2400d8b8 <I2C_Mem_ISR_DMA+0x1cc>
                         I2C_RELOAD_MODE, direction);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400d894:	68fb      	ldr	r3, [r7, #12]
2400d896:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d898:	b29a      	uxth	r2, r3
2400d89a:	68fb      	ldr	r3, [r7, #12]
2400d89c:	851a      	strh	r2, [r3, #40]	; 0x28

      /* Set NBYTES to write and generate RESTART */
      I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
2400d89e:	68fb      	ldr	r3, [r7, #12]
2400d8a0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400d8a2:	b299      	uxth	r1, r3
2400d8a4:	68fb      	ldr	r3, [r7, #12]
2400d8a6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d8a8:	b2da      	uxtb	r2, r3
2400d8aa:	697b      	ldr	r3, [r7, #20]
2400d8ac:	9300      	str	r3, [sp, #0]
2400d8ae:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400d8b2:	68f8      	ldr	r0, [r7, #12]
2400d8b4:	f001 fd38 	bl	2400f328 <I2C_TransferConfig>
                         I2C_AUTOEND_MODE, direction);
    }

    /* Update XferCount value */
    hi2c->XferCount -= hi2c->XferSize;
2400d8b8:	68fb      	ldr	r3, [r7, #12]
2400d8ba:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d8bc:	b29a      	uxth	r2, r3
2400d8be:	68fb      	ldr	r3, [r7, #12]
2400d8c0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d8c2:	1ad3      	subs	r3, r2, r3
2400d8c4:	b29a      	uxth	r2, r3
2400d8c6:	68fb      	ldr	r3, [r7, #12]
2400d8c8:	855a      	strh	r2, [r3, #42]	; 0x2a

    /* Enable DMA Request */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d8ca:	68fb      	ldr	r3, [r7, #12]
2400d8cc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d8d0:	b2db      	uxtb	r3, r3
2400d8d2:	2b22      	cmp	r3, #34	; 0x22
2400d8d4:	d108      	bne.n	2400d8e8 <I2C_Mem_ISR_DMA+0x1fc>
    {
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400d8d6:	68fb      	ldr	r3, [r7, #12]
2400d8d8:	681b      	ldr	r3, [r3, #0]
2400d8da:	681a      	ldr	r2, [r3, #0]
2400d8dc:	68fb      	ldr	r3, [r7, #12]
2400d8de:	681b      	ldr	r3, [r3, #0]
2400d8e0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400d8e4:	601a      	str	r2, [r3, #0]
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d8e6:	e018      	b.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
    }
    else
    {
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400d8e8:	68fb      	ldr	r3, [r7, #12]
2400d8ea:	681b      	ldr	r3, [r3, #0]
2400d8ec:	681a      	ldr	r2, [r3, #0]
2400d8ee:	68fb      	ldr	r3, [r7, #12]
2400d8f0:	681b      	ldr	r3, [r3, #0]
2400d8f2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400d8f6:	601a      	str	r2, [r3, #0]
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d8f8:	e00f      	b.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d8fa:	68bb      	ldr	r3, [r7, #8]
2400d8fc:	095b      	lsrs	r3, r3, #5
2400d8fe:	f003 0301 	and.w	r3, r3, #1
2400d902:	2b00      	cmp	r3, #0
2400d904:	d009      	beq.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d906:	687b      	ldr	r3, [r7, #4]
2400d908:	095b      	lsrs	r3, r3, #5
2400d90a:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d90e:	2b00      	cmp	r3, #0
2400d910:	d003      	beq.n	2400d91a <I2C_Mem_ISR_DMA+0x22e>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
2400d912:	68b9      	ldr	r1, [r7, #8]
2400d914:	68f8      	ldr	r0, [r7, #12]
2400d916:	f000 fbb7 	bl	2400e088 <I2C_ITMasterCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d91a:	68fb      	ldr	r3, [r7, #12]
2400d91c:	2200      	movs	r2, #0
2400d91e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400d922:	2300      	movs	r3, #0
}
2400d924:	4618      	mov	r0, r3
2400d926:	3718      	adds	r7, #24
2400d928:	46bd      	mov	sp, r7
2400d92a:	bd80      	pop	{r7, pc}
2400d92c:	80002000 	.word	0x80002000
2400d930:	80002400 	.word	0x80002400

2400d934 <I2C_Slave_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                           uint32_t ITSources)
{
2400d934:	b580      	push	{r7, lr}
2400d936:	b088      	sub	sp, #32
2400d938:	af00      	add	r7, sp, #0
2400d93a:	60f8      	str	r0, [r7, #12]
2400d93c:	60b9      	str	r1, [r7, #8]
2400d93e:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2400d940:	68fb      	ldr	r3, [r7, #12]
2400d942:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d944:	61bb      	str	r3, [r7, #24]
  uint32_t treatdmanack = 0U;
2400d946:	2300      	movs	r3, #0
2400d948:	61fb      	str	r3, [r7, #28]
  HAL_I2C_StateTypeDef tmpstate;

  /* Process locked */
  __HAL_LOCK(hi2c);
2400d94a:	68fb      	ldr	r3, [r7, #12]
2400d94c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d950:	2b01      	cmp	r3, #1
2400d952:	d101      	bne.n	2400d958 <I2C_Slave_ISR_DMA+0x24>
2400d954:	2302      	movs	r3, #2
2400d956:	e1ca      	b.n	2400dcee <I2C_Slave_ISR_DMA+0x3ba>
2400d958:	68fb      	ldr	r3, [r7, #12]
2400d95a:	2201      	movs	r2, #1
2400d95c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d960:	68bb      	ldr	r3, [r7, #8]
2400d962:	095b      	lsrs	r3, r3, #5
2400d964:	f003 0301 	and.w	r3, r3, #1
2400d968:	2b00      	cmp	r3, #0
2400d96a:	d009      	beq.n	2400d980 <I2C_Slave_ISR_DMA+0x4c>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d96c:	687b      	ldr	r3, [r7, #4]
2400d96e:	095b      	lsrs	r3, r3, #5
2400d970:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d974:	2b00      	cmp	r3, #0
2400d976:	d003      	beq.n	2400d980 <I2C_Slave_ISR_DMA+0x4c>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
2400d978:	68b9      	ldr	r1, [r7, #8]
2400d97a:	68f8      	ldr	r0, [r7, #12]
2400d97c:	f000 fc4e 	bl	2400e21c <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d980:	68bb      	ldr	r3, [r7, #8]
2400d982:	091b      	lsrs	r3, r3, #4
2400d984:	f003 0301 	and.w	r3, r3, #1
2400d988:	2b00      	cmp	r3, #0
2400d98a:	f000 819b 	beq.w	2400dcc4 <I2C_Slave_ISR_DMA+0x390>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d98e:	687b      	ldr	r3, [r7, #4]
2400d990:	091b      	lsrs	r3, r3, #4
2400d992:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d996:	2b00      	cmp	r3, #0
2400d998:	f000 8194 	beq.w	2400dcc4 <I2C_Slave_ISR_DMA+0x390>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0 */
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400d99c:	687b      	ldr	r3, [r7, #4]
2400d99e:	0b9b      	lsrs	r3, r3, #14
2400d9a0:	f003 0301 	and.w	r3, r3, #1
2400d9a4:	2b00      	cmp	r3, #0
2400d9a6:	d106      	bne.n	2400d9b6 <I2C_Slave_ISR_DMA+0x82>
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
2400d9a8:	687b      	ldr	r3, [r7, #4]
2400d9aa:	0bdb      	lsrs	r3, r3, #15
2400d9ac:	f003 0301 	and.w	r3, r3, #1
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400d9b0:	2b00      	cmp	r3, #0
2400d9b2:	f000 8180 	beq.w	2400dcb6 <I2C_Slave_ISR_DMA+0x382>
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
2400d9b6:	68fb      	ldr	r3, [r7, #12]
2400d9b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d9ba:	2b00      	cmp	r3, #0
2400d9bc:	d07c      	beq.n	2400dab8 <I2C_Slave_ISR_DMA+0x184>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
2400d9be:	687b      	ldr	r3, [r7, #4]
2400d9c0:	0bdb      	lsrs	r3, r3, #15
2400d9c2:	f003 0301 	and.w	r3, r3, #1
2400d9c6:	2b00      	cmp	r3, #0
2400d9c8:	d076      	beq.n	2400dab8 <I2C_Slave_ISR_DMA+0x184>
        {
          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)
2400d9ca:	68fb      	ldr	r3, [r7, #12]
2400d9cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d9ce:	681b      	ldr	r3, [r3, #0]
2400d9d0:	4a74      	ldr	r2, [pc, #464]	; (2400dba4 <I2C_Slave_ISR_DMA+0x270>)
2400d9d2:	4293      	cmp	r3, r2
2400d9d4:	d059      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400d9d6:	68fb      	ldr	r3, [r7, #12]
2400d9d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d9da:	681b      	ldr	r3, [r3, #0]
2400d9dc:	4a72      	ldr	r2, [pc, #456]	; (2400dba8 <I2C_Slave_ISR_DMA+0x274>)
2400d9de:	4293      	cmp	r3, r2
2400d9e0:	d053      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400d9e2:	68fb      	ldr	r3, [r7, #12]
2400d9e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d9e6:	681b      	ldr	r3, [r3, #0]
2400d9e8:	4a70      	ldr	r2, [pc, #448]	; (2400dbac <I2C_Slave_ISR_DMA+0x278>)
2400d9ea:	4293      	cmp	r3, r2
2400d9ec:	d04d      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400d9ee:	68fb      	ldr	r3, [r7, #12]
2400d9f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d9f2:	681b      	ldr	r3, [r3, #0]
2400d9f4:	4a6e      	ldr	r2, [pc, #440]	; (2400dbb0 <I2C_Slave_ISR_DMA+0x27c>)
2400d9f6:	4293      	cmp	r3, r2
2400d9f8:	d047      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400d9fa:	68fb      	ldr	r3, [r7, #12]
2400d9fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d9fe:	681b      	ldr	r3, [r3, #0]
2400da00:	4a6c      	ldr	r2, [pc, #432]	; (2400dbb4 <I2C_Slave_ISR_DMA+0x280>)
2400da02:	4293      	cmp	r3, r2
2400da04:	d041      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da06:	68fb      	ldr	r3, [r7, #12]
2400da08:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da0a:	681b      	ldr	r3, [r3, #0]
2400da0c:	4a6a      	ldr	r2, [pc, #424]	; (2400dbb8 <I2C_Slave_ISR_DMA+0x284>)
2400da0e:	4293      	cmp	r3, r2
2400da10:	d03b      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da12:	68fb      	ldr	r3, [r7, #12]
2400da14:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da16:	681b      	ldr	r3, [r3, #0]
2400da18:	4a68      	ldr	r2, [pc, #416]	; (2400dbbc <I2C_Slave_ISR_DMA+0x288>)
2400da1a:	4293      	cmp	r3, r2
2400da1c:	d035      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da1e:	68fb      	ldr	r3, [r7, #12]
2400da20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da22:	681b      	ldr	r3, [r3, #0]
2400da24:	4a66      	ldr	r2, [pc, #408]	; (2400dbc0 <I2C_Slave_ISR_DMA+0x28c>)
2400da26:	4293      	cmp	r3, r2
2400da28:	d02f      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da2a:	68fb      	ldr	r3, [r7, #12]
2400da2c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da2e:	681b      	ldr	r3, [r3, #0]
2400da30:	4a64      	ldr	r2, [pc, #400]	; (2400dbc4 <I2C_Slave_ISR_DMA+0x290>)
2400da32:	4293      	cmp	r3, r2
2400da34:	d029      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da36:	68fb      	ldr	r3, [r7, #12]
2400da38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da3a:	681b      	ldr	r3, [r3, #0]
2400da3c:	4a62      	ldr	r2, [pc, #392]	; (2400dbc8 <I2C_Slave_ISR_DMA+0x294>)
2400da3e:	4293      	cmp	r3, r2
2400da40:	d023      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da42:	68fb      	ldr	r3, [r7, #12]
2400da44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da46:	681b      	ldr	r3, [r3, #0]
2400da48:	4a60      	ldr	r2, [pc, #384]	; (2400dbcc <I2C_Slave_ISR_DMA+0x298>)
2400da4a:	4293      	cmp	r3, r2
2400da4c:	d01d      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da4e:	68fb      	ldr	r3, [r7, #12]
2400da50:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da52:	681b      	ldr	r3, [r3, #0]
2400da54:	4a5e      	ldr	r2, [pc, #376]	; (2400dbd0 <I2C_Slave_ISR_DMA+0x29c>)
2400da56:	4293      	cmp	r3, r2
2400da58:	d017      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da5a:	68fb      	ldr	r3, [r7, #12]
2400da5c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da5e:	681b      	ldr	r3, [r3, #0]
2400da60:	4a5c      	ldr	r2, [pc, #368]	; (2400dbd4 <I2C_Slave_ISR_DMA+0x2a0>)
2400da62:	4293      	cmp	r3, r2
2400da64:	d011      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da66:	68fb      	ldr	r3, [r7, #12]
2400da68:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da6a:	681b      	ldr	r3, [r3, #0]
2400da6c:	4a5a      	ldr	r2, [pc, #360]	; (2400dbd8 <I2C_Slave_ISR_DMA+0x2a4>)
2400da6e:	4293      	cmp	r3, r2
2400da70:	d00b      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da72:	68fb      	ldr	r3, [r7, #12]
2400da74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da76:	681b      	ldr	r3, [r3, #0]
2400da78:	4a58      	ldr	r2, [pc, #352]	; (2400dbdc <I2C_Slave_ISR_DMA+0x2a8>)
2400da7a:	4293      	cmp	r3, r2
2400da7c:	d005      	beq.n	2400da8a <I2C_Slave_ISR_DMA+0x156>
2400da7e:	68fb      	ldr	r3, [r7, #12]
2400da80:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da82:	681b      	ldr	r3, [r3, #0]
2400da84:	4a56      	ldr	r2, [pc, #344]	; (2400dbe0 <I2C_Slave_ISR_DMA+0x2ac>)
2400da86:	4293      	cmp	r3, r2
2400da88:	d109      	bne.n	2400da9e <I2C_Slave_ISR_DMA+0x16a>
2400da8a:	68fb      	ldr	r3, [r7, #12]
2400da8c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da8e:	681b      	ldr	r3, [r3, #0]
2400da90:	685b      	ldr	r3, [r3, #4]
2400da92:	2b00      	cmp	r3, #0
2400da94:	bf0c      	ite	eq
2400da96:	2301      	moveq	r3, #1
2400da98:	2300      	movne	r3, #0
2400da9a:	b2db      	uxtb	r3, r3
2400da9c:	e008      	b.n	2400dab0 <I2C_Slave_ISR_DMA+0x17c>
2400da9e:	68fb      	ldr	r3, [r7, #12]
2400daa0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400daa2:	681b      	ldr	r3, [r3, #0]
2400daa4:	685b      	ldr	r3, [r3, #4]
2400daa6:	2b00      	cmp	r3, #0
2400daa8:	bf0c      	ite	eq
2400daaa:	2301      	moveq	r3, #1
2400daac:	2300      	movne	r3, #0
2400daae:	b2db      	uxtb	r3, r3
2400dab0:	2b00      	cmp	r3, #0
2400dab2:	d001      	beq.n	2400dab8 <I2C_Slave_ISR_DMA+0x184>
          {
            treatdmanack = 1U;
2400dab4:	2301      	movs	r3, #1
2400dab6:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      /* Split check of hdmatx, for MISRA compliance  */
      if (hi2c->hdmatx != NULL)
2400dab8:	68fb      	ldr	r3, [r7, #12]
2400daba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400dabc:	2b00      	cmp	r3, #0
2400dabe:	f000 809e 	beq.w	2400dbfe <I2C_Slave_ISR_DMA+0x2ca>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
2400dac2:	687b      	ldr	r3, [r7, #4]
2400dac4:	0b9b      	lsrs	r3, r3, #14
2400dac6:	f003 0301 	and.w	r3, r3, #1
2400daca:	2b00      	cmp	r3, #0
2400dacc:	f000 8097 	beq.w	2400dbfe <I2C_Slave_ISR_DMA+0x2ca>
        {
          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)
2400dad0:	68fb      	ldr	r3, [r7, #12]
2400dad2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400dad4:	681b      	ldr	r3, [r3, #0]
2400dad6:	4a33      	ldr	r2, [pc, #204]	; (2400dba4 <I2C_Slave_ISR_DMA+0x270>)
2400dad8:	4293      	cmp	r3, r2
2400dada:	d059      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400dadc:	68fb      	ldr	r3, [r7, #12]
2400dade:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400dae0:	681b      	ldr	r3, [r3, #0]
2400dae2:	4a31      	ldr	r2, [pc, #196]	; (2400dba8 <I2C_Slave_ISR_DMA+0x274>)
2400dae4:	4293      	cmp	r3, r2
2400dae6:	d053      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400dae8:	68fb      	ldr	r3, [r7, #12]
2400daea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400daec:	681b      	ldr	r3, [r3, #0]
2400daee:	4a2f      	ldr	r2, [pc, #188]	; (2400dbac <I2C_Slave_ISR_DMA+0x278>)
2400daf0:	4293      	cmp	r3, r2
2400daf2:	d04d      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400daf4:	68fb      	ldr	r3, [r7, #12]
2400daf6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400daf8:	681b      	ldr	r3, [r3, #0]
2400dafa:	4a2d      	ldr	r2, [pc, #180]	; (2400dbb0 <I2C_Slave_ISR_DMA+0x27c>)
2400dafc:	4293      	cmp	r3, r2
2400dafe:	d047      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db00:	68fb      	ldr	r3, [r7, #12]
2400db02:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db04:	681b      	ldr	r3, [r3, #0]
2400db06:	4a2b      	ldr	r2, [pc, #172]	; (2400dbb4 <I2C_Slave_ISR_DMA+0x280>)
2400db08:	4293      	cmp	r3, r2
2400db0a:	d041      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db0c:	68fb      	ldr	r3, [r7, #12]
2400db0e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db10:	681b      	ldr	r3, [r3, #0]
2400db12:	4a29      	ldr	r2, [pc, #164]	; (2400dbb8 <I2C_Slave_ISR_DMA+0x284>)
2400db14:	4293      	cmp	r3, r2
2400db16:	d03b      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db18:	68fb      	ldr	r3, [r7, #12]
2400db1a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db1c:	681b      	ldr	r3, [r3, #0]
2400db1e:	4a27      	ldr	r2, [pc, #156]	; (2400dbbc <I2C_Slave_ISR_DMA+0x288>)
2400db20:	4293      	cmp	r3, r2
2400db22:	d035      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db24:	68fb      	ldr	r3, [r7, #12]
2400db26:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db28:	681b      	ldr	r3, [r3, #0]
2400db2a:	4a25      	ldr	r2, [pc, #148]	; (2400dbc0 <I2C_Slave_ISR_DMA+0x28c>)
2400db2c:	4293      	cmp	r3, r2
2400db2e:	d02f      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db30:	68fb      	ldr	r3, [r7, #12]
2400db32:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db34:	681b      	ldr	r3, [r3, #0]
2400db36:	4a23      	ldr	r2, [pc, #140]	; (2400dbc4 <I2C_Slave_ISR_DMA+0x290>)
2400db38:	4293      	cmp	r3, r2
2400db3a:	d029      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db3c:	68fb      	ldr	r3, [r7, #12]
2400db3e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db40:	681b      	ldr	r3, [r3, #0]
2400db42:	4a21      	ldr	r2, [pc, #132]	; (2400dbc8 <I2C_Slave_ISR_DMA+0x294>)
2400db44:	4293      	cmp	r3, r2
2400db46:	d023      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db48:	68fb      	ldr	r3, [r7, #12]
2400db4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db4c:	681b      	ldr	r3, [r3, #0]
2400db4e:	4a1f      	ldr	r2, [pc, #124]	; (2400dbcc <I2C_Slave_ISR_DMA+0x298>)
2400db50:	4293      	cmp	r3, r2
2400db52:	d01d      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db54:	68fb      	ldr	r3, [r7, #12]
2400db56:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db58:	681b      	ldr	r3, [r3, #0]
2400db5a:	4a1d      	ldr	r2, [pc, #116]	; (2400dbd0 <I2C_Slave_ISR_DMA+0x29c>)
2400db5c:	4293      	cmp	r3, r2
2400db5e:	d017      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db60:	68fb      	ldr	r3, [r7, #12]
2400db62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db64:	681b      	ldr	r3, [r3, #0]
2400db66:	4a1b      	ldr	r2, [pc, #108]	; (2400dbd4 <I2C_Slave_ISR_DMA+0x2a0>)
2400db68:	4293      	cmp	r3, r2
2400db6a:	d011      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db6c:	68fb      	ldr	r3, [r7, #12]
2400db6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db70:	681b      	ldr	r3, [r3, #0]
2400db72:	4a19      	ldr	r2, [pc, #100]	; (2400dbd8 <I2C_Slave_ISR_DMA+0x2a4>)
2400db74:	4293      	cmp	r3, r2
2400db76:	d00b      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db78:	68fb      	ldr	r3, [r7, #12]
2400db7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db7c:	681b      	ldr	r3, [r3, #0]
2400db7e:	4a17      	ldr	r2, [pc, #92]	; (2400dbdc <I2C_Slave_ISR_DMA+0x2a8>)
2400db80:	4293      	cmp	r3, r2
2400db82:	d005      	beq.n	2400db90 <I2C_Slave_ISR_DMA+0x25c>
2400db84:	68fb      	ldr	r3, [r7, #12]
2400db86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db88:	681b      	ldr	r3, [r3, #0]
2400db8a:	4a15      	ldr	r2, [pc, #84]	; (2400dbe0 <I2C_Slave_ISR_DMA+0x2ac>)
2400db8c:	4293      	cmp	r3, r2
2400db8e:	d129      	bne.n	2400dbe4 <I2C_Slave_ISR_DMA+0x2b0>
2400db90:	68fb      	ldr	r3, [r7, #12]
2400db92:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400db94:	681b      	ldr	r3, [r3, #0]
2400db96:	685b      	ldr	r3, [r3, #4]
2400db98:	2b00      	cmp	r3, #0
2400db9a:	bf0c      	ite	eq
2400db9c:	2301      	moveq	r3, #1
2400db9e:	2300      	movne	r3, #0
2400dba0:	b2db      	uxtb	r3, r3
2400dba2:	e028      	b.n	2400dbf6 <I2C_Slave_ISR_DMA+0x2c2>
2400dba4:	40020010 	.word	0x40020010
2400dba8:	40020028 	.word	0x40020028
2400dbac:	40020040 	.word	0x40020040
2400dbb0:	40020058 	.word	0x40020058
2400dbb4:	40020070 	.word	0x40020070
2400dbb8:	40020088 	.word	0x40020088
2400dbbc:	400200a0 	.word	0x400200a0
2400dbc0:	400200b8 	.word	0x400200b8
2400dbc4:	40020410 	.word	0x40020410
2400dbc8:	40020428 	.word	0x40020428
2400dbcc:	40020440 	.word	0x40020440
2400dbd0:	40020458 	.word	0x40020458
2400dbd4:	40020470 	.word	0x40020470
2400dbd8:	40020488 	.word	0x40020488
2400dbdc:	400204a0 	.word	0x400204a0
2400dbe0:	400204b8 	.word	0x400204b8
2400dbe4:	68fb      	ldr	r3, [r7, #12]
2400dbe6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400dbe8:	681b      	ldr	r3, [r3, #0]
2400dbea:	685b      	ldr	r3, [r3, #4]
2400dbec:	2b00      	cmp	r3, #0
2400dbee:	bf0c      	ite	eq
2400dbf0:	2301      	moveq	r3, #1
2400dbf2:	2300      	movne	r3, #0
2400dbf4:	b2db      	uxtb	r3, r3
2400dbf6:	2b00      	cmp	r3, #0
2400dbf8:	d001      	beq.n	2400dbfe <I2C_Slave_ISR_DMA+0x2ca>
          {
            treatdmanack = 1U;
2400dbfa:	2301      	movs	r3, #1
2400dbfc:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      if (treatdmanack == 1U)
2400dbfe:	69fb      	ldr	r3, [r7, #28]
2400dc00:	2b01      	cmp	r3, #1
2400dc02:	d128      	bne.n	2400dc56 <I2C_Slave_ISR_DMA+0x322>
      {
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
2400dc04:	68fb      	ldr	r3, [r7, #12]
2400dc06:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dc0a:	b2db      	uxtb	r3, r3
2400dc0c:	2b28      	cmp	r3, #40	; 0x28
2400dc0e:	d108      	bne.n	2400dc22 <I2C_Slave_ISR_DMA+0x2ee>
2400dc10:	69bb      	ldr	r3, [r7, #24]
2400dc12:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400dc16:	d104      	bne.n	2400dc22 <I2C_Slave_ISR_DMA+0x2ee>
          /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
             Warning[Pa134]: left and right operands are identical */
        {
          /* Call I2C Listen complete process */
          I2C_ITListenCplt(hi2c, ITFlags);
2400dc18:	68b9      	ldr	r1, [r7, #8]
2400dc1a:	68f8      	ldr	r0, [r7, #12]
2400dc1c:	f000 fcf6 	bl	2400e60c <I2C_ITListenCplt>
2400dc20:	e048      	b.n	2400dcb4 <I2C_Slave_ISR_DMA+0x380>
        }
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
2400dc22:	68fb      	ldr	r3, [r7, #12]
2400dc24:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dc28:	b2db      	uxtb	r3, r3
2400dc2a:	2b29      	cmp	r3, #41	; 0x29
2400dc2c:	d10e      	bne.n	2400dc4c <I2C_Slave_ISR_DMA+0x318>
2400dc2e:	69bb      	ldr	r3, [r7, #24]
2400dc30:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400dc34:	d00a      	beq.n	2400dc4c <I2C_Slave_ISR_DMA+0x318>
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400dc36:	68fb      	ldr	r3, [r7, #12]
2400dc38:	681b      	ldr	r3, [r3, #0]
2400dc3a:	2210      	movs	r2, #16
2400dc3c:	61da      	str	r2, [r3, #28]

          /* Flush TX register */
          I2C_Flush_TXDR(hi2c);
2400dc3e:	68f8      	ldr	r0, [r7, #12]
2400dc40:	f000 fe51 	bl	2400e8e6 <I2C_Flush_TXDR>

          /* Last Byte is Transmitted */
          /* Call I2C Slave Sequential complete process */
          I2C_ITSlaveSeqCplt(hi2c);
2400dc44:	68f8      	ldr	r0, [r7, #12]
2400dc46:	f000 f9c0 	bl	2400dfca <I2C_ITSlaveSeqCplt>
2400dc4a:	e033      	b.n	2400dcb4 <I2C_Slave_ISR_DMA+0x380>
        }
        else
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400dc4c:	68fb      	ldr	r3, [r7, #12]
2400dc4e:	681b      	ldr	r3, [r3, #0]
2400dc50:	2210      	movs	r2, #16
2400dc52:	61da      	str	r2, [r3, #28]
      if (treatdmanack == 1U)
2400dc54:	e034      	b.n	2400dcc0 <I2C_Slave_ISR_DMA+0x38c>
      }
      else
      {
        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400dc56:	68fb      	ldr	r3, [r7, #12]
2400dc58:	681b      	ldr	r3, [r3, #0]
2400dc5a:	2210      	movs	r2, #16
2400dc5c:	61da      	str	r2, [r3, #28]

        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400dc5e:	68fb      	ldr	r3, [r7, #12]
2400dc60:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dc62:	f043 0204 	orr.w	r2, r3, #4
2400dc66:	68fb      	ldr	r3, [r7, #12]
2400dc68:	645a      	str	r2, [r3, #68]	; 0x44

        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */
        tmpstate = hi2c->State;
2400dc6a:	68fb      	ldr	r3, [r7, #12]
2400dc6c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dc70:	75fb      	strb	r3, [r7, #23]

        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2400dc72:	69bb      	ldr	r3, [r7, #24]
2400dc74:	2b00      	cmp	r3, #0
2400dc76:	d003      	beq.n	2400dc80 <I2C_Slave_ISR_DMA+0x34c>
2400dc78:	69bb      	ldr	r3, [r7, #24]
2400dc7a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400dc7e:	d11f      	bne.n	2400dcc0 <I2C_Slave_ISR_DMA+0x38c>
        {
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
2400dc80:	7dfb      	ldrb	r3, [r7, #23]
2400dc82:	2b21      	cmp	r3, #33	; 0x21
2400dc84:	d002      	beq.n	2400dc8c <I2C_Slave_ISR_DMA+0x358>
2400dc86:	7dfb      	ldrb	r3, [r7, #23]
2400dc88:	2b29      	cmp	r3, #41	; 0x29
2400dc8a:	d103      	bne.n	2400dc94 <I2C_Slave_ISR_DMA+0x360>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400dc8c:	68fb      	ldr	r3, [r7, #12]
2400dc8e:	2221      	movs	r2, #33	; 0x21
2400dc90:	631a      	str	r2, [r3, #48]	; 0x30
2400dc92:	e008      	b.n	2400dca6 <I2C_Slave_ISR_DMA+0x372>
          }
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2400dc94:	7dfb      	ldrb	r3, [r7, #23]
2400dc96:	2b22      	cmp	r3, #34	; 0x22
2400dc98:	d002      	beq.n	2400dca0 <I2C_Slave_ISR_DMA+0x36c>
2400dc9a:	7dfb      	ldrb	r3, [r7, #23]
2400dc9c:	2b2a      	cmp	r3, #42	; 0x2a
2400dc9e:	d102      	bne.n	2400dca6 <I2C_Slave_ISR_DMA+0x372>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400dca0:	68fb      	ldr	r3, [r7, #12]
2400dca2:	2222      	movs	r2, #34	; 0x22
2400dca4:	631a      	str	r2, [r3, #48]	; 0x30
          {
            /* Do nothing */
          }

          /* Call the corresponding callback to inform upper layer of End of Transfer */
          I2C_ITError(hi2c, hi2c->ErrorCode);
2400dca6:	68fb      	ldr	r3, [r7, #12]
2400dca8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dcaa:	4619      	mov	r1, r3
2400dcac:	68f8      	ldr	r0, [r7, #12]
2400dcae:	f000 fd03 	bl	2400e6b8 <I2C_ITError>
      if (treatdmanack == 1U)
2400dcb2:	e005      	b.n	2400dcc0 <I2C_Slave_ISR_DMA+0x38c>
2400dcb4:	e004      	b.n	2400dcc0 <I2C_Slave_ISR_DMA+0x38c>
      }
    }
    else
    {
      /* Only Clear NACK Flag, no DMA treatment is pending */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400dcb6:	68fb      	ldr	r3, [r7, #12]
2400dcb8:	681b      	ldr	r3, [r3, #0]
2400dcba:	2210      	movs	r2, #16
2400dcbc:	61da      	str	r2, [r3, #28]
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400dcbe:	e011      	b.n	2400dce4 <I2C_Slave_ISR_DMA+0x3b0>
      if (treatdmanack == 1U)
2400dcc0:	bf00      	nop
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400dcc2:	e00f      	b.n	2400dce4 <I2C_Slave_ISR_DMA+0x3b0>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \
2400dcc4:	68bb      	ldr	r3, [r7, #8]
2400dcc6:	08db      	lsrs	r3, r3, #3
2400dcc8:	f003 0301 	and.w	r3, r3, #1
2400dccc:	2b00      	cmp	r3, #0
2400dcce:	d009      	beq.n	2400dce4 <I2C_Slave_ISR_DMA+0x3b0>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
2400dcd0:	687b      	ldr	r3, [r7, #4]
2400dcd2:	08db      	lsrs	r3, r3, #3
2400dcd4:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \
2400dcd8:	2b00      	cmp	r3, #0
2400dcda:	d003      	beq.n	2400dce4 <I2C_Slave_ISR_DMA+0x3b0>
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
2400dcdc:	68b9      	ldr	r1, [r7, #8]
2400dcde:	68f8      	ldr	r0, [r7, #12]
2400dce0:	f000 f8b2 	bl	2400de48 <I2C_ITAddrCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400dce4:	68fb      	ldr	r3, [r7, #12]
2400dce6:	2200      	movs	r2, #0
2400dce8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400dcec:	2300      	movs	r3, #0
}
2400dcee:	4618      	mov	r0, r3
2400dcf0:	3720      	adds	r7, #32
2400dcf2:	46bd      	mov	sp, r7
2400dcf4:	bd80      	pop	{r7, pc}
2400dcf6:	bf00      	nop

2400dcf8 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
2400dcf8:	b580      	push	{r7, lr}
2400dcfa:	b086      	sub	sp, #24
2400dcfc:	af02      	add	r7, sp, #8
2400dcfe:	60f8      	str	r0, [r7, #12]
2400dd00:	4608      	mov	r0, r1
2400dd02:	4611      	mov	r1, r2
2400dd04:	461a      	mov	r2, r3
2400dd06:	4603      	mov	r3, r0
2400dd08:	817b      	strh	r3, [r7, #10]
2400dd0a:	460b      	mov	r3, r1
2400dd0c:	813b      	strh	r3, [r7, #8]
2400dd0e:	4613      	mov	r3, r2
2400dd10:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2400dd12:	88fb      	ldrh	r3, [r7, #6]
2400dd14:	b2da      	uxtb	r2, r3
2400dd16:	8979      	ldrh	r1, [r7, #10]
2400dd18:	4b20      	ldr	r3, [pc, #128]	; (2400dd9c <I2C_RequestMemoryWrite+0xa4>)
2400dd1a:	9300      	str	r3, [sp, #0]
2400dd1c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400dd20:	68f8      	ldr	r0, [r7, #12]
2400dd22:	f001 fb01 	bl	2400f328 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400dd26:	69fa      	ldr	r2, [r7, #28]
2400dd28:	69b9      	ldr	r1, [r7, #24]
2400dd2a:	68f8      	ldr	r0, [r7, #12]
2400dd2c:	f001 f90f 	bl	2400ef4e <I2C_WaitOnTXISFlagUntilTimeout>
2400dd30:	4603      	mov	r3, r0
2400dd32:	2b00      	cmp	r3, #0
2400dd34:	d001      	beq.n	2400dd3a <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
2400dd36:	2301      	movs	r3, #1
2400dd38:	e02c      	b.n	2400dd94 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400dd3a:	88fb      	ldrh	r3, [r7, #6]
2400dd3c:	2b01      	cmp	r3, #1
2400dd3e:	d105      	bne.n	2400dd4c <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400dd40:	893b      	ldrh	r3, [r7, #8]
2400dd42:	b2da      	uxtb	r2, r3
2400dd44:	68fb      	ldr	r3, [r7, #12]
2400dd46:	681b      	ldr	r3, [r3, #0]
2400dd48:	629a      	str	r2, [r3, #40]	; 0x28
2400dd4a:	e015      	b.n	2400dd78 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400dd4c:	893b      	ldrh	r3, [r7, #8]
2400dd4e:	0a1b      	lsrs	r3, r3, #8
2400dd50:	b29b      	uxth	r3, r3
2400dd52:	b2da      	uxtb	r2, r3
2400dd54:	68fb      	ldr	r3, [r7, #12]
2400dd56:	681b      	ldr	r3, [r3, #0]
2400dd58:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400dd5a:	69fa      	ldr	r2, [r7, #28]
2400dd5c:	69b9      	ldr	r1, [r7, #24]
2400dd5e:	68f8      	ldr	r0, [r7, #12]
2400dd60:	f001 f8f5 	bl	2400ef4e <I2C_WaitOnTXISFlagUntilTimeout>
2400dd64:	4603      	mov	r3, r0
2400dd66:	2b00      	cmp	r3, #0
2400dd68:	d001      	beq.n	2400dd6e <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
2400dd6a:	2301      	movs	r3, #1
2400dd6c:	e012      	b.n	2400dd94 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400dd6e:	893b      	ldrh	r3, [r7, #8]
2400dd70:	b2da      	uxtb	r2, r3
2400dd72:	68fb      	ldr	r3, [r7, #12]
2400dd74:	681b      	ldr	r3, [r3, #0]
2400dd76:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
2400dd78:	69fb      	ldr	r3, [r7, #28]
2400dd7a:	9300      	str	r3, [sp, #0]
2400dd7c:	69bb      	ldr	r3, [r7, #24]
2400dd7e:	2200      	movs	r2, #0
2400dd80:	2180      	movs	r1, #128	; 0x80
2400dd82:	68f8      	ldr	r0, [r7, #12]
2400dd84:	f001 f894 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400dd88:	4603      	mov	r3, r0
2400dd8a:	2b00      	cmp	r3, #0
2400dd8c:	d001      	beq.n	2400dd92 <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
2400dd8e:	2301      	movs	r3, #1
2400dd90:	e000      	b.n	2400dd94 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
2400dd92:	2300      	movs	r3, #0
}
2400dd94:	4618      	mov	r0, r3
2400dd96:	3710      	adds	r7, #16
2400dd98:	46bd      	mov	sp, r7
2400dd9a:	bd80      	pop	{r7, pc}
2400dd9c:	80002000 	.word	0x80002000

2400dda0 <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
2400dda0:	b580      	push	{r7, lr}
2400dda2:	b086      	sub	sp, #24
2400dda4:	af02      	add	r7, sp, #8
2400dda6:	60f8      	str	r0, [r7, #12]
2400dda8:	4608      	mov	r0, r1
2400ddaa:	4611      	mov	r1, r2
2400ddac:	461a      	mov	r2, r3
2400ddae:	4603      	mov	r3, r0
2400ddb0:	817b      	strh	r3, [r7, #10]
2400ddb2:	460b      	mov	r3, r1
2400ddb4:	813b      	strh	r3, [r7, #8]
2400ddb6:	4613      	mov	r3, r2
2400ddb8:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
2400ddba:	88fb      	ldrh	r3, [r7, #6]
2400ddbc:	b2da      	uxtb	r2, r3
2400ddbe:	8979      	ldrh	r1, [r7, #10]
2400ddc0:	4b20      	ldr	r3, [pc, #128]	; (2400de44 <I2C_RequestMemoryRead+0xa4>)
2400ddc2:	9300      	str	r3, [sp, #0]
2400ddc4:	2300      	movs	r3, #0
2400ddc6:	68f8      	ldr	r0, [r7, #12]
2400ddc8:	f001 faae 	bl	2400f328 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400ddcc:	69fa      	ldr	r2, [r7, #28]
2400ddce:	69b9      	ldr	r1, [r7, #24]
2400ddd0:	68f8      	ldr	r0, [r7, #12]
2400ddd2:	f001 f8bc 	bl	2400ef4e <I2C_WaitOnTXISFlagUntilTimeout>
2400ddd6:	4603      	mov	r3, r0
2400ddd8:	2b00      	cmp	r3, #0
2400ddda:	d001      	beq.n	2400dde0 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
2400dddc:	2301      	movs	r3, #1
2400ddde:	e02c      	b.n	2400de3a <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400dde0:	88fb      	ldrh	r3, [r7, #6]
2400dde2:	2b01      	cmp	r3, #1
2400dde4:	d105      	bne.n	2400ddf2 <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400dde6:	893b      	ldrh	r3, [r7, #8]
2400dde8:	b2da      	uxtb	r2, r3
2400ddea:	68fb      	ldr	r3, [r7, #12]
2400ddec:	681b      	ldr	r3, [r3, #0]
2400ddee:	629a      	str	r2, [r3, #40]	; 0x28
2400ddf0:	e015      	b.n	2400de1e <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400ddf2:	893b      	ldrh	r3, [r7, #8]
2400ddf4:	0a1b      	lsrs	r3, r3, #8
2400ddf6:	b29b      	uxth	r3, r3
2400ddf8:	b2da      	uxtb	r2, r3
2400ddfa:	68fb      	ldr	r3, [r7, #12]
2400ddfc:	681b      	ldr	r3, [r3, #0]
2400ddfe:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400de00:	69fa      	ldr	r2, [r7, #28]
2400de02:	69b9      	ldr	r1, [r7, #24]
2400de04:	68f8      	ldr	r0, [r7, #12]
2400de06:	f001 f8a2 	bl	2400ef4e <I2C_WaitOnTXISFlagUntilTimeout>
2400de0a:	4603      	mov	r3, r0
2400de0c:	2b00      	cmp	r3, #0
2400de0e:	d001      	beq.n	2400de14 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
2400de10:	2301      	movs	r3, #1
2400de12:	e012      	b.n	2400de3a <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400de14:	893b      	ldrh	r3, [r7, #8]
2400de16:	b2da      	uxtb	r2, r3
2400de18:	68fb      	ldr	r3, [r7, #12]
2400de1a:	681b      	ldr	r3, [r3, #0]
2400de1c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
2400de1e:	69fb      	ldr	r3, [r7, #28]
2400de20:	9300      	str	r3, [sp, #0]
2400de22:	69bb      	ldr	r3, [r7, #24]
2400de24:	2200      	movs	r2, #0
2400de26:	2140      	movs	r1, #64	; 0x40
2400de28:	68f8      	ldr	r0, [r7, #12]
2400de2a:	f001 f841 	bl	2400eeb0 <I2C_WaitOnFlagUntilTimeout>
2400de2e:	4603      	mov	r3, r0
2400de30:	2b00      	cmp	r3, #0
2400de32:	d001      	beq.n	2400de38 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
2400de34:	2301      	movs	r3, #1
2400de36:	e000      	b.n	2400de3a <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
2400de38:	2300      	movs	r3, #0
}
2400de3a:	4618      	mov	r0, r3
2400de3c:	3710      	adds	r7, #16
2400de3e:	46bd      	mov	sp, r7
2400de40:	bd80      	pop	{r7, pc}
2400de42:	bf00      	nop
2400de44:	80002000 	.word	0x80002000

2400de48 <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400de48:	b580      	push	{r7, lr}
2400de4a:	b084      	sub	sp, #16
2400de4c:	af00      	add	r7, sp, #0
2400de4e:	6078      	str	r0, [r7, #4]
2400de50:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400de52:	687b      	ldr	r3, [r7, #4]
2400de54:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400de58:	b2db      	uxtb	r3, r3
2400de5a:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400de5e:	2b28      	cmp	r3, #40	; 0x28
2400de60:	d16a      	bne.n	2400df38 <I2C_ITAddrCplt+0xf0>
  {
    transferdirection = I2C_GET_DIR(hi2c);
2400de62:	687b      	ldr	r3, [r7, #4]
2400de64:	681b      	ldr	r3, [r3, #0]
2400de66:	699b      	ldr	r3, [r3, #24]
2400de68:	0c1b      	lsrs	r3, r3, #16
2400de6a:	b2db      	uxtb	r3, r3
2400de6c:	f003 0301 	and.w	r3, r3, #1
2400de70:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
2400de72:	687b      	ldr	r3, [r7, #4]
2400de74:	681b      	ldr	r3, [r3, #0]
2400de76:	699b      	ldr	r3, [r3, #24]
2400de78:	0c1b      	lsrs	r3, r3, #16
2400de7a:	b29b      	uxth	r3, r3
2400de7c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
2400de80:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
2400de82:	687b      	ldr	r3, [r7, #4]
2400de84:	681b      	ldr	r3, [r3, #0]
2400de86:	689b      	ldr	r3, [r3, #8]
2400de88:	b29b      	uxth	r3, r3
2400de8a:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400de8e:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
2400de90:	687b      	ldr	r3, [r7, #4]
2400de92:	681b      	ldr	r3, [r3, #0]
2400de94:	68db      	ldr	r3, [r3, #12]
2400de96:	b29b      	uxth	r3, r3
2400de98:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
2400de9c:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400de9e:	687b      	ldr	r3, [r7, #4]
2400dea0:	68db      	ldr	r3, [r3, #12]
2400dea2:	2b02      	cmp	r3, #2
2400dea4:	d138      	bne.n	2400df18 <I2C_ITAddrCplt+0xd0>
    {
      if ((slaveaddrcode & SLAVE_ADDR_MSK) == ((ownadd1code >> SLAVE_ADDR_SHIFT) & SLAVE_ADDR_MSK))
2400dea6:	897b      	ldrh	r3, [r7, #10]
2400dea8:	09db      	lsrs	r3, r3, #7
2400deaa:	b29a      	uxth	r2, r3
2400deac:	89bb      	ldrh	r3, [r7, #12]
2400deae:	4053      	eors	r3, r2
2400deb0:	b29b      	uxth	r3, r3
2400deb2:	f003 0306 	and.w	r3, r3, #6
2400deb6:	2b00      	cmp	r3, #0
2400deb8:	d11c      	bne.n	2400def4 <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
2400deba:	897b      	ldrh	r3, [r7, #10]
2400debc:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
2400debe:	687b      	ldr	r3, [r7, #4]
2400dec0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400dec2:	1c5a      	adds	r2, r3, #1
2400dec4:	687b      	ldr	r3, [r7, #4]
2400dec6:	649a      	str	r2, [r3, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
2400dec8:	687b      	ldr	r3, [r7, #4]
2400deca:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400decc:	2b02      	cmp	r3, #2
2400dece:	d13b      	bne.n	2400df48 <I2C_ITAddrCplt+0x100>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
2400ded0:	687b      	ldr	r3, [r7, #4]
2400ded2:	2200      	movs	r2, #0
2400ded4:	649a      	str	r2, [r3, #72]	; 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400ded6:	687b      	ldr	r3, [r7, #4]
2400ded8:	681b      	ldr	r3, [r3, #0]
2400deda:	2208      	movs	r2, #8
2400dedc:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2400dede:	687b      	ldr	r3, [r7, #4]
2400dee0:	2200      	movs	r2, #0
2400dee2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400dee6:	89ba      	ldrh	r2, [r7, #12]
2400dee8:	7bfb      	ldrb	r3, [r7, #15]
2400deea:	4619      	mov	r1, r3
2400deec:	6878      	ldr	r0, [r7, #4]
2400deee:	f7fe ff4c 	bl	2400cd8a <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
2400def2:	e029      	b.n	2400df48 <I2C_ITAddrCplt+0x100>
        slaveaddrcode = ownadd2code;
2400def4:	893b      	ldrh	r3, [r7, #8]
2400def6:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400def8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400defc:	6878      	ldr	r0, [r7, #4]
2400defe:	f001 faaf 	bl	2400f460 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
2400df02:	687b      	ldr	r3, [r7, #4]
2400df04:	2200      	movs	r2, #0
2400df06:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400df0a:	89ba      	ldrh	r2, [r7, #12]
2400df0c:	7bfb      	ldrb	r3, [r7, #15]
2400df0e:	4619      	mov	r1, r3
2400df10:	6878      	ldr	r0, [r7, #4]
2400df12:	f7fe ff3a 	bl	2400cd8a <HAL_I2C_AddrCallback>
}
2400df16:	e017      	b.n	2400df48 <I2C_ITAddrCplt+0x100>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400df18:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400df1c:	6878      	ldr	r0, [r7, #4]
2400df1e:	f001 fa9f 	bl	2400f460 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
2400df22:	687b      	ldr	r3, [r7, #4]
2400df24:	2200      	movs	r2, #0
2400df26:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400df2a:	89ba      	ldrh	r2, [r7, #12]
2400df2c:	7bfb      	ldrb	r3, [r7, #15]
2400df2e:	4619      	mov	r1, r3
2400df30:	6878      	ldr	r0, [r7, #4]
2400df32:	f7fe ff2a 	bl	2400cd8a <HAL_I2C_AddrCallback>
}
2400df36:	e007      	b.n	2400df48 <I2C_ITAddrCplt+0x100>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400df38:	687b      	ldr	r3, [r7, #4]
2400df3a:	681b      	ldr	r3, [r3, #0]
2400df3c:	2208      	movs	r2, #8
2400df3e:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
2400df40:	687b      	ldr	r3, [r7, #4]
2400df42:	2200      	movs	r2, #0
2400df44:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
2400df48:	bf00      	nop
2400df4a:	3710      	adds	r7, #16
2400df4c:	46bd      	mov	sp, r7
2400df4e:	bd80      	pop	{r7, pc}

2400df50 <I2C_ITMasterSeqCplt>:
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
{
2400df50:	b580      	push	{r7, lr}
2400df52:	b082      	sub	sp, #8
2400df54:	af00      	add	r7, sp, #0
2400df56:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400df58:	687b      	ldr	r3, [r7, #4]
2400df5a:	2200      	movs	r2, #0
2400df5c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* No Generate Stop, to permit restart mode */
  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400df60:	687b      	ldr	r3, [r7, #4]
2400df62:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400df66:	b2db      	uxtb	r3, r3
2400df68:	2b21      	cmp	r3, #33	; 0x21
2400df6a:	d115      	bne.n	2400df98 <I2C_ITMasterSeqCplt+0x48>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
2400df6c:	687b      	ldr	r3, [r7, #4]
2400df6e:	2220      	movs	r2, #32
2400df70:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400df74:	687b      	ldr	r3, [r7, #4]
2400df76:	2211      	movs	r2, #17
2400df78:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2400df7a:	687b      	ldr	r3, [r7, #4]
2400df7c:	2200      	movs	r2, #0
2400df7e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400df80:	2101      	movs	r1, #1
2400df82:	6878      	ldr	r0, [r7, #4]
2400df84:	f001 fa6c 	bl	2400f460 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400df88:	687b      	ldr	r3, [r7, #4]
2400df8a:	2200      	movs	r2, #0
2400df8c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->MasterTxCpltCallback(hi2c);
#else
    HAL_I2C_MasterTxCpltCallback(hi2c);
2400df90:	6878      	ldr	r0, [r7, #4]
2400df92:	f7fe fed2 	bl	2400cd3a <HAL_I2C_MasterTxCpltCallback>
    hi2c->MasterRxCpltCallback(hi2c);
#else
    HAL_I2C_MasterRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400df96:	e014      	b.n	2400dfc2 <I2C_ITMasterSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_READY;
2400df98:	687b      	ldr	r3, [r7, #4]
2400df9a:	2220      	movs	r2, #32
2400df9c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400dfa0:	687b      	ldr	r3, [r7, #4]
2400dfa2:	2212      	movs	r2, #18
2400dfa4:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2400dfa6:	687b      	ldr	r3, [r7, #4]
2400dfa8:	2200      	movs	r2, #0
2400dfaa:	635a      	str	r2, [r3, #52]	; 0x34
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400dfac:	2102      	movs	r1, #2
2400dfae:	6878      	ldr	r0, [r7, #4]
2400dfb0:	f001 fa56 	bl	2400f460 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2400dfb4:	687b      	ldr	r3, [r7, #4]
2400dfb6:	2200      	movs	r2, #0
2400dfb8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
2400dfbc:	6878      	ldr	r0, [r7, #4]
2400dfbe:	f7fe fec6 	bl	2400cd4e <HAL_I2C_MasterRxCpltCallback>
}
2400dfc2:	bf00      	nop
2400dfc4:	3708      	adds	r7, #8
2400dfc6:	46bd      	mov	sp, r7
2400dfc8:	bd80      	pop	{r7, pc}

2400dfca <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
2400dfca:	b580      	push	{r7, lr}
2400dfcc:	b084      	sub	sp, #16
2400dfce:	af00      	add	r7, sp, #0
2400dfd0:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400dfd2:	687b      	ldr	r3, [r7, #4]
2400dfd4:	681b      	ldr	r3, [r3, #0]
2400dfd6:	681b      	ldr	r3, [r3, #0]
2400dfd8:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400dfda:	687b      	ldr	r3, [r7, #4]
2400dfdc:	2200      	movs	r2, #0
2400dfde:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
2400dfe2:	68fb      	ldr	r3, [r7, #12]
2400dfe4:	0b9b      	lsrs	r3, r3, #14
2400dfe6:	f003 0301 	and.w	r3, r3, #1
2400dfea:	2b00      	cmp	r3, #0
2400dfec:	d008      	beq.n	2400e000 <I2C_ITSlaveSeqCplt+0x36>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400dfee:	687b      	ldr	r3, [r7, #4]
2400dff0:	681b      	ldr	r3, [r3, #0]
2400dff2:	681a      	ldr	r2, [r3, #0]
2400dff4:	687b      	ldr	r3, [r7, #4]
2400dff6:	681b      	ldr	r3, [r3, #0]
2400dff8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400dffc:	601a      	str	r2, [r3, #0]
2400dffe:	e00d      	b.n	2400e01c <I2C_ITSlaveSeqCplt+0x52>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
2400e000:	68fb      	ldr	r3, [r7, #12]
2400e002:	0bdb      	lsrs	r3, r3, #15
2400e004:	f003 0301 	and.w	r3, r3, #1
2400e008:	2b00      	cmp	r3, #0
2400e00a:	d007      	beq.n	2400e01c <I2C_ITSlaveSeqCplt+0x52>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400e00c:	687b      	ldr	r3, [r7, #4]
2400e00e:	681b      	ldr	r3, [r3, #0]
2400e010:	681a      	ldr	r2, [r3, #0]
2400e012:	687b      	ldr	r3, [r7, #4]
2400e014:	681b      	ldr	r3, [r3, #0]
2400e016:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400e01a:	601a      	str	r2, [r3, #0]
  else
  {
    /* Do nothing */
  }

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400e01c:	687b      	ldr	r3, [r7, #4]
2400e01e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e022:	b2db      	uxtb	r3, r3
2400e024:	2b29      	cmp	r3, #41	; 0x29
2400e026:	d112      	bne.n	2400e04e <I2C_ITSlaveSeqCplt+0x84>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400e028:	687b      	ldr	r3, [r7, #4]
2400e02a:	2228      	movs	r2, #40	; 0x28
2400e02c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400e030:	687b      	ldr	r3, [r7, #4]
2400e032:	2221      	movs	r2, #33	; 0x21
2400e034:	631a      	str	r2, [r3, #48]	; 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400e036:	2101      	movs	r1, #1
2400e038:	6878      	ldr	r0, [r7, #4]
2400e03a:	f001 fa11 	bl	2400f460 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e03e:	687b      	ldr	r3, [r7, #4]
2400e040:	2200      	movs	r2, #0
2400e042:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400e046:	6878      	ldr	r0, [r7, #4]
2400e048:	f7fe fe8b 	bl	2400cd62 <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
2400e04c:	e017      	b.n	2400e07e <I2C_ITSlaveSeqCplt+0xb4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400e04e:	687b      	ldr	r3, [r7, #4]
2400e050:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e054:	b2db      	uxtb	r3, r3
2400e056:	2b2a      	cmp	r3, #42	; 0x2a
2400e058:	d111      	bne.n	2400e07e <I2C_ITSlaveSeqCplt+0xb4>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400e05a:	687b      	ldr	r3, [r7, #4]
2400e05c:	2228      	movs	r2, #40	; 0x28
2400e05e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400e062:	687b      	ldr	r3, [r7, #4]
2400e064:	2222      	movs	r2, #34	; 0x22
2400e066:	631a      	str	r2, [r3, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400e068:	2102      	movs	r1, #2
2400e06a:	6878      	ldr	r0, [r7, #4]
2400e06c:	f001 f9f8 	bl	2400f460 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2400e070:	687b      	ldr	r3, [r7, #4]
2400e072:	2200      	movs	r2, #0
2400e074:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400e078:	6878      	ldr	r0, [r7, #4]
2400e07a:	f7fe fe7c 	bl	2400cd76 <HAL_I2C_SlaveRxCpltCallback>
}
2400e07e:	bf00      	nop
2400e080:	3710      	adds	r7, #16
2400e082:	46bd      	mov	sp, r7
2400e084:	bd80      	pop	{r7, pc}
	...

2400e088 <I2C_ITMasterCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400e088:	b580      	push	{r7, lr}
2400e08a:	b086      	sub	sp, #24
2400e08c:	af00      	add	r7, sp, #0
2400e08e:	6078      	str	r0, [r7, #4]
2400e090:	6039      	str	r1, [r7, #0]
  uint32_t tmperror;
  uint32_t tmpITFlags = ITFlags;
2400e092:	683b      	ldr	r3, [r7, #0]
2400e094:	617b      	str	r3, [r7, #20]
  __IO uint32_t tmpreg;

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400e096:	687b      	ldr	r3, [r7, #4]
2400e098:	681b      	ldr	r3, [r3, #0]
2400e09a:	2220      	movs	r2, #32
2400e09c:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400e09e:	687b      	ldr	r3, [r7, #4]
2400e0a0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e0a4:	b2db      	uxtb	r3, r3
2400e0a6:	2b21      	cmp	r3, #33	; 0x21
2400e0a8:	d107      	bne.n	2400e0ba <I2C_ITMasterCplt+0x32>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400e0aa:	2101      	movs	r1, #1
2400e0ac:	6878      	ldr	r0, [r7, #4]
2400e0ae:	f001 f9d7 	bl	2400f460 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400e0b2:	687b      	ldr	r3, [r7, #4]
2400e0b4:	2211      	movs	r2, #17
2400e0b6:	631a      	str	r2, [r3, #48]	; 0x30
2400e0b8:	e00c      	b.n	2400e0d4 <I2C_ITMasterCplt+0x4c>
  }
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400e0ba:	687b      	ldr	r3, [r7, #4]
2400e0bc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e0c0:	b2db      	uxtb	r3, r3
2400e0c2:	2b22      	cmp	r3, #34	; 0x22
2400e0c4:	d106      	bne.n	2400e0d4 <I2C_ITMasterCplt+0x4c>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400e0c6:	2102      	movs	r1, #2
2400e0c8:	6878      	ldr	r0, [r7, #4]
2400e0ca:	f001 f9c9 	bl	2400f460 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400e0ce:	687b      	ldr	r3, [r7, #4]
2400e0d0:	2212      	movs	r2, #18
2400e0d2:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
2400e0d4:	687b      	ldr	r3, [r7, #4]
2400e0d6:	681b      	ldr	r3, [r3, #0]
2400e0d8:	6859      	ldr	r1, [r3, #4]
2400e0da:	687b      	ldr	r3, [r7, #4]
2400e0dc:	681a      	ldr	r2, [r3, #0]
2400e0de:	4b4d      	ldr	r3, [pc, #308]	; (2400e214 <I2C_ITMasterCplt+0x18c>)
2400e0e0:	400b      	ands	r3, r1
2400e0e2:	6053      	str	r3, [r2, #4]

  /* Reset handle parameters */
  hi2c->XferISR       = NULL;
2400e0e4:	687b      	ldr	r3, [r7, #4]
2400e0e6:	2200      	movs	r2, #0
2400e0e8:	635a      	str	r2, [r3, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400e0ea:	687b      	ldr	r3, [r7, #4]
2400e0ec:	4a4a      	ldr	r2, [pc, #296]	; (2400e218 <I2C_ITMasterCplt+0x190>)
2400e0ee:	62da      	str	r2, [r3, #44]	; 0x2c

  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
2400e0f0:	697b      	ldr	r3, [r7, #20]
2400e0f2:	091b      	lsrs	r3, r3, #4
2400e0f4:	f003 0301 	and.w	r3, r3, #1
2400e0f8:	2b00      	cmp	r3, #0
2400e0fa:	d009      	beq.n	2400e110 <I2C_ITMasterCplt+0x88>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400e0fc:	687b      	ldr	r3, [r7, #4]
2400e0fe:	681b      	ldr	r3, [r3, #0]
2400e100:	2210      	movs	r2, #16
2400e102:	61da      	str	r2, [r3, #28]

    /* Set acknowledge error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400e104:	687b      	ldr	r3, [r7, #4]
2400e106:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e108:	f043 0204 	orr.w	r2, r3, #4
2400e10c:	687b      	ldr	r3, [r7, #4]
2400e10e:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Fetch Last receive data if any */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
2400e110:	687b      	ldr	r3, [r7, #4]
2400e112:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e116:	b2db      	uxtb	r3, r3
2400e118:	2b60      	cmp	r3, #96	; 0x60
2400e11a:	d10b      	bne.n	2400e134 <I2C_ITMasterCplt+0xac>
2400e11c:	697b      	ldr	r3, [r7, #20]
2400e11e:	089b      	lsrs	r3, r3, #2
2400e120:	f003 0301 	and.w	r3, r3, #1
2400e124:	2b00      	cmp	r3, #0
2400e126:	d005      	beq.n	2400e134 <I2C_ITMasterCplt+0xac>
  {
    /* Read data from RXDR */
    tmpreg = (uint8_t)hi2c->Instance->RXDR;
2400e128:	687b      	ldr	r3, [r7, #4]
2400e12a:	681b      	ldr	r3, [r3, #0]
2400e12c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e12e:	b2db      	uxtb	r3, r3
2400e130:	60fb      	str	r3, [r7, #12]
    UNUSED(tmpreg);
2400e132:	68fb      	ldr	r3, [r7, #12]
  }

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
2400e134:	6878      	ldr	r0, [r7, #4]
2400e136:	f000 fbd6 	bl	2400e8e6 <I2C_Flush_TXDR>

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2400e13a:	687b      	ldr	r3, [r7, #4]
2400e13c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e13e:	613b      	str	r3, [r7, #16]

  /* Call the corresponding callback to inform upper layer of End of Transfer */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
2400e140:	687b      	ldr	r3, [r7, #4]
2400e142:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e146:	b2db      	uxtb	r3, r3
2400e148:	2b60      	cmp	r3, #96	; 0x60
2400e14a:	d002      	beq.n	2400e152 <I2C_ITMasterCplt+0xca>
2400e14c:	693b      	ldr	r3, [r7, #16]
2400e14e:	2b00      	cmp	r3, #0
2400e150:	d006      	beq.n	2400e160 <I2C_ITMasterCplt+0xd8>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400e152:	687b      	ldr	r3, [r7, #4]
2400e154:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e156:	4619      	mov	r1, r3
2400e158:	6878      	ldr	r0, [r7, #4]
2400e15a:	f000 faad 	bl	2400e6b8 <I2C_ITError>
  }
  else
  {
    /* Nothing to do */
  }
}
2400e15e:	e054      	b.n	2400e20a <I2C_ITMasterCplt+0x182>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400e160:	687b      	ldr	r3, [r7, #4]
2400e162:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e166:	b2db      	uxtb	r3, r3
2400e168:	2b21      	cmp	r3, #33	; 0x21
2400e16a:	d124      	bne.n	2400e1b6 <I2C_ITMasterCplt+0x12e>
    hi2c->State = HAL_I2C_STATE_READY;
2400e16c:	687b      	ldr	r3, [r7, #4]
2400e16e:	2220      	movs	r2, #32
2400e170:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e174:	687b      	ldr	r3, [r7, #4]
2400e176:	2200      	movs	r2, #0
2400e178:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
2400e17a:	687b      	ldr	r3, [r7, #4]
2400e17c:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400e180:	b2db      	uxtb	r3, r3
2400e182:	2b40      	cmp	r3, #64	; 0x40
2400e184:	d10b      	bne.n	2400e19e <I2C_ITMasterCplt+0x116>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400e186:	687b      	ldr	r3, [r7, #4]
2400e188:	2200      	movs	r2, #0
2400e18a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400e18e:	687b      	ldr	r3, [r7, #4]
2400e190:	2200      	movs	r2, #0
2400e192:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemTxCpltCallback(hi2c);
2400e196:	6878      	ldr	r0, [r7, #4]
2400e198:	f7fe fe0f 	bl	2400cdba <HAL_I2C_MemTxCpltCallback>
}
2400e19c:	e035      	b.n	2400e20a <I2C_ITMasterCplt+0x182>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400e19e:	687b      	ldr	r3, [r7, #4]
2400e1a0:	2200      	movs	r2, #0
2400e1a2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400e1a6:	687b      	ldr	r3, [r7, #4]
2400e1a8:	2200      	movs	r2, #0
2400e1aa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterTxCpltCallback(hi2c);
2400e1ae:	6878      	ldr	r0, [r7, #4]
2400e1b0:	f7fe fdc3 	bl	2400cd3a <HAL_I2C_MasterTxCpltCallback>
}
2400e1b4:	e029      	b.n	2400e20a <I2C_ITMasterCplt+0x182>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400e1b6:	687b      	ldr	r3, [r7, #4]
2400e1b8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e1bc:	b2db      	uxtb	r3, r3
2400e1be:	2b22      	cmp	r3, #34	; 0x22
2400e1c0:	d123      	bne.n	2400e20a <I2C_ITMasterCplt+0x182>
    hi2c->State = HAL_I2C_STATE_READY;
2400e1c2:	687b      	ldr	r3, [r7, #4]
2400e1c4:	2220      	movs	r2, #32
2400e1c6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e1ca:	687b      	ldr	r3, [r7, #4]
2400e1cc:	2200      	movs	r2, #0
2400e1ce:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
2400e1d0:	687b      	ldr	r3, [r7, #4]
2400e1d2:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400e1d6:	b2db      	uxtb	r3, r3
2400e1d8:	2b40      	cmp	r3, #64	; 0x40
2400e1da:	d10b      	bne.n	2400e1f4 <I2C_ITMasterCplt+0x16c>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400e1dc:	687b      	ldr	r3, [r7, #4]
2400e1de:	2200      	movs	r2, #0
2400e1e0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400e1e4:	687b      	ldr	r3, [r7, #4]
2400e1e6:	2200      	movs	r2, #0
2400e1e8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemRxCpltCallback(hi2c);
2400e1ec:	6878      	ldr	r0, [r7, #4]
2400e1ee:	f7fe fdee 	bl	2400cdce <HAL_I2C_MemRxCpltCallback>
}
2400e1f2:	e00a      	b.n	2400e20a <I2C_ITMasterCplt+0x182>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400e1f4:	687b      	ldr	r3, [r7, #4]
2400e1f6:	2200      	movs	r2, #0
2400e1f8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400e1fc:	687b      	ldr	r3, [r7, #4]
2400e1fe:	2200      	movs	r2, #0
2400e200:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterRxCpltCallback(hi2c);
2400e204:	6878      	ldr	r0, [r7, #4]
2400e206:	f7fe fda2 	bl	2400cd4e <HAL_I2C_MasterRxCpltCallback>
}
2400e20a:	bf00      	nop
2400e20c:	3718      	adds	r7, #24
2400e20e:	46bd      	mov	sp, r7
2400e210:	bd80      	pop	{r7, pc}
2400e212:	bf00      	nop
2400e214:	fe00e800 	.word	0xfe00e800
2400e218:	ffff0000 	.word	0xffff0000

2400e21c <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400e21c:	b580      	push	{r7, lr}
2400e21e:	b086      	sub	sp, #24
2400e220:	af00      	add	r7, sp, #0
2400e222:	6078      	str	r0, [r7, #4]
2400e224:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400e226:	687b      	ldr	r3, [r7, #4]
2400e228:	681b      	ldr	r3, [r3, #0]
2400e22a:	681b      	ldr	r3, [r3, #0]
2400e22c:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
2400e22e:	683b      	ldr	r3, [r7, #0]
2400e230:	617b      	str	r3, [r7, #20]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400e232:	687b      	ldr	r3, [r7, #4]
2400e234:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e238:	73fb      	strb	r3, [r7, #15]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400e23a:	687b      	ldr	r3, [r7, #4]
2400e23c:	681b      	ldr	r3, [r3, #0]
2400e23e:	2220      	movs	r2, #32
2400e240:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
2400e242:	7bfb      	ldrb	r3, [r7, #15]
2400e244:	2b21      	cmp	r3, #33	; 0x21
2400e246:	d002      	beq.n	2400e24e <I2C_ITSlaveCplt+0x32>
2400e248:	7bfb      	ldrb	r3, [r7, #15]
2400e24a:	2b29      	cmp	r3, #41	; 0x29
2400e24c:	d108      	bne.n	2400e260 <I2C_ITSlaveCplt+0x44>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400e24e:	f248 0101 	movw	r1, #32769	; 0x8001
2400e252:	6878      	ldr	r0, [r7, #4]
2400e254:	f001 f904 	bl	2400f460 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400e258:	687b      	ldr	r3, [r7, #4]
2400e25a:	2221      	movs	r2, #33	; 0x21
2400e25c:	631a      	str	r2, [r3, #48]	; 0x30
2400e25e:	e00d      	b.n	2400e27c <I2C_ITSlaveCplt+0x60>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2400e260:	7bfb      	ldrb	r3, [r7, #15]
2400e262:	2b22      	cmp	r3, #34	; 0x22
2400e264:	d002      	beq.n	2400e26c <I2C_ITSlaveCplt+0x50>
2400e266:	7bfb      	ldrb	r3, [r7, #15]
2400e268:	2b2a      	cmp	r3, #42	; 0x2a
2400e26a:	d107      	bne.n	2400e27c <I2C_ITSlaveCplt+0x60>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400e26c:	f248 0102 	movw	r1, #32770	; 0x8002
2400e270:	6878      	ldr	r0, [r7, #4]
2400e272:	f001 f8f5 	bl	2400f460 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400e276:	687b      	ldr	r3, [r7, #4]
2400e278:	2222      	movs	r2, #34	; 0x22
2400e27a:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400e27c:	687b      	ldr	r3, [r7, #4]
2400e27e:	681b      	ldr	r3, [r3, #0]
2400e280:	685a      	ldr	r2, [r3, #4]
2400e282:	687b      	ldr	r3, [r7, #4]
2400e284:	681b      	ldr	r3, [r3, #0]
2400e286:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400e28a:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
2400e28c:	687b      	ldr	r3, [r7, #4]
2400e28e:	681b      	ldr	r3, [r3, #0]
2400e290:	6859      	ldr	r1, [r3, #4]
2400e292:	687b      	ldr	r3, [r7, #4]
2400e294:	681a      	ldr	r2, [r3, #0]
2400e296:	4b80      	ldr	r3, [pc, #512]	; (2400e498 <I2C_ITSlaveCplt+0x27c>)
2400e298:	400b      	ands	r3, r1
2400e29a:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
2400e29c:	6878      	ldr	r0, [r7, #4]
2400e29e:	f000 fb22 	bl	2400e8e6 <I2C_Flush_TXDR>

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
2400e2a2:	693b      	ldr	r3, [r7, #16]
2400e2a4:	0b9b      	lsrs	r3, r3, #14
2400e2a6:	f003 0301 	and.w	r3, r3, #1
2400e2aa:	2b00      	cmp	r3, #0
2400e2ac:	d07a      	beq.n	2400e3a4 <I2C_ITSlaveCplt+0x188>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400e2ae:	687b      	ldr	r3, [r7, #4]
2400e2b0:	681b      	ldr	r3, [r3, #0]
2400e2b2:	681a      	ldr	r2, [r3, #0]
2400e2b4:	687b      	ldr	r3, [r7, #4]
2400e2b6:	681b      	ldr	r3, [r3, #0]
2400e2b8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400e2bc:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
2400e2be:	687b      	ldr	r3, [r7, #4]
2400e2c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e2c2:	2b00      	cmp	r3, #0
2400e2c4:	f000 8111 	beq.w	2400e4ea <I2C_ITSlaveCplt+0x2ce>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx);
2400e2c8:	687b      	ldr	r3, [r7, #4]
2400e2ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e2cc:	681b      	ldr	r3, [r3, #0]
2400e2ce:	4a73      	ldr	r2, [pc, #460]	; (2400e49c <I2C_ITSlaveCplt+0x280>)
2400e2d0:	4293      	cmp	r3, r2
2400e2d2:	d059      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e2d4:	687b      	ldr	r3, [r7, #4]
2400e2d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e2d8:	681b      	ldr	r3, [r3, #0]
2400e2da:	4a71      	ldr	r2, [pc, #452]	; (2400e4a0 <I2C_ITSlaveCplt+0x284>)
2400e2dc:	4293      	cmp	r3, r2
2400e2de:	d053      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e2e0:	687b      	ldr	r3, [r7, #4]
2400e2e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e2e4:	681b      	ldr	r3, [r3, #0]
2400e2e6:	4a6f      	ldr	r2, [pc, #444]	; (2400e4a4 <I2C_ITSlaveCplt+0x288>)
2400e2e8:	4293      	cmp	r3, r2
2400e2ea:	d04d      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e2ec:	687b      	ldr	r3, [r7, #4]
2400e2ee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e2f0:	681b      	ldr	r3, [r3, #0]
2400e2f2:	4a6d      	ldr	r2, [pc, #436]	; (2400e4a8 <I2C_ITSlaveCplt+0x28c>)
2400e2f4:	4293      	cmp	r3, r2
2400e2f6:	d047      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e2f8:	687b      	ldr	r3, [r7, #4]
2400e2fa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e2fc:	681b      	ldr	r3, [r3, #0]
2400e2fe:	4a6b      	ldr	r2, [pc, #428]	; (2400e4ac <I2C_ITSlaveCplt+0x290>)
2400e300:	4293      	cmp	r3, r2
2400e302:	d041      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e304:	687b      	ldr	r3, [r7, #4]
2400e306:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e308:	681b      	ldr	r3, [r3, #0]
2400e30a:	4a69      	ldr	r2, [pc, #420]	; (2400e4b0 <I2C_ITSlaveCplt+0x294>)
2400e30c:	4293      	cmp	r3, r2
2400e30e:	d03b      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e310:	687b      	ldr	r3, [r7, #4]
2400e312:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e314:	681b      	ldr	r3, [r3, #0]
2400e316:	4a67      	ldr	r2, [pc, #412]	; (2400e4b4 <I2C_ITSlaveCplt+0x298>)
2400e318:	4293      	cmp	r3, r2
2400e31a:	d035      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e31c:	687b      	ldr	r3, [r7, #4]
2400e31e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e320:	681b      	ldr	r3, [r3, #0]
2400e322:	4a65      	ldr	r2, [pc, #404]	; (2400e4b8 <I2C_ITSlaveCplt+0x29c>)
2400e324:	4293      	cmp	r3, r2
2400e326:	d02f      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e328:	687b      	ldr	r3, [r7, #4]
2400e32a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e32c:	681b      	ldr	r3, [r3, #0]
2400e32e:	4a63      	ldr	r2, [pc, #396]	; (2400e4bc <I2C_ITSlaveCplt+0x2a0>)
2400e330:	4293      	cmp	r3, r2
2400e332:	d029      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e334:	687b      	ldr	r3, [r7, #4]
2400e336:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e338:	681b      	ldr	r3, [r3, #0]
2400e33a:	4a61      	ldr	r2, [pc, #388]	; (2400e4c0 <I2C_ITSlaveCplt+0x2a4>)
2400e33c:	4293      	cmp	r3, r2
2400e33e:	d023      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e340:	687b      	ldr	r3, [r7, #4]
2400e342:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e344:	681b      	ldr	r3, [r3, #0]
2400e346:	4a5f      	ldr	r2, [pc, #380]	; (2400e4c4 <I2C_ITSlaveCplt+0x2a8>)
2400e348:	4293      	cmp	r3, r2
2400e34a:	d01d      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e34c:	687b      	ldr	r3, [r7, #4]
2400e34e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e350:	681b      	ldr	r3, [r3, #0]
2400e352:	4a5d      	ldr	r2, [pc, #372]	; (2400e4c8 <I2C_ITSlaveCplt+0x2ac>)
2400e354:	4293      	cmp	r3, r2
2400e356:	d017      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e358:	687b      	ldr	r3, [r7, #4]
2400e35a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e35c:	681b      	ldr	r3, [r3, #0]
2400e35e:	4a5b      	ldr	r2, [pc, #364]	; (2400e4cc <I2C_ITSlaveCplt+0x2b0>)
2400e360:	4293      	cmp	r3, r2
2400e362:	d011      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e364:	687b      	ldr	r3, [r7, #4]
2400e366:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e368:	681b      	ldr	r3, [r3, #0]
2400e36a:	4a59      	ldr	r2, [pc, #356]	; (2400e4d0 <I2C_ITSlaveCplt+0x2b4>)
2400e36c:	4293      	cmp	r3, r2
2400e36e:	d00b      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e370:	687b      	ldr	r3, [r7, #4]
2400e372:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e374:	681b      	ldr	r3, [r3, #0]
2400e376:	4a57      	ldr	r2, [pc, #348]	; (2400e4d4 <I2C_ITSlaveCplt+0x2b8>)
2400e378:	4293      	cmp	r3, r2
2400e37a:	d005      	beq.n	2400e388 <I2C_ITSlaveCplt+0x16c>
2400e37c:	687b      	ldr	r3, [r7, #4]
2400e37e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e380:	681b      	ldr	r3, [r3, #0]
2400e382:	4a55      	ldr	r2, [pc, #340]	; (2400e4d8 <I2C_ITSlaveCplt+0x2bc>)
2400e384:	4293      	cmp	r3, r2
2400e386:	d105      	bne.n	2400e394 <I2C_ITSlaveCplt+0x178>
2400e388:	687b      	ldr	r3, [r7, #4]
2400e38a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e38c:	681b      	ldr	r3, [r3, #0]
2400e38e:	685b      	ldr	r3, [r3, #4]
2400e390:	b29b      	uxth	r3, r3
2400e392:	e004      	b.n	2400e39e <I2C_ITSlaveCplt+0x182>
2400e394:	687b      	ldr	r3, [r7, #4]
2400e396:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e398:	681b      	ldr	r3, [r3, #0]
2400e39a:	685b      	ldr	r3, [r3, #4]
2400e39c:	b29b      	uxth	r3, r3
2400e39e:	687a      	ldr	r2, [r7, #4]
2400e3a0:	8553      	strh	r3, [r2, #42]	; 0x2a
2400e3a2:	e0a2      	b.n	2400e4ea <I2C_ITSlaveCplt+0x2ce>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
2400e3a4:	693b      	ldr	r3, [r7, #16]
2400e3a6:	0bdb      	lsrs	r3, r3, #15
2400e3a8:	f003 0301 	and.w	r3, r3, #1
2400e3ac:	2b00      	cmp	r3, #0
2400e3ae:	f000 809c 	beq.w	2400e4ea <I2C_ITSlaveCplt+0x2ce>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400e3b2:	687b      	ldr	r3, [r7, #4]
2400e3b4:	681b      	ldr	r3, [r3, #0]
2400e3b6:	681a      	ldr	r2, [r3, #0]
2400e3b8:	687b      	ldr	r3, [r7, #4]
2400e3ba:	681b      	ldr	r3, [r3, #0]
2400e3bc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400e3c0:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
2400e3c2:	687b      	ldr	r3, [r7, #4]
2400e3c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e3c6:	2b00      	cmp	r3, #0
2400e3c8:	f000 808f 	beq.w	2400e4ea <I2C_ITSlaveCplt+0x2ce>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx);
2400e3cc:	687b      	ldr	r3, [r7, #4]
2400e3ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e3d0:	681b      	ldr	r3, [r3, #0]
2400e3d2:	4a32      	ldr	r2, [pc, #200]	; (2400e49c <I2C_ITSlaveCplt+0x280>)
2400e3d4:	4293      	cmp	r3, r2
2400e3d6:	d059      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e3d8:	687b      	ldr	r3, [r7, #4]
2400e3da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e3dc:	681b      	ldr	r3, [r3, #0]
2400e3de:	4a30      	ldr	r2, [pc, #192]	; (2400e4a0 <I2C_ITSlaveCplt+0x284>)
2400e3e0:	4293      	cmp	r3, r2
2400e3e2:	d053      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e3e4:	687b      	ldr	r3, [r7, #4]
2400e3e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e3e8:	681b      	ldr	r3, [r3, #0]
2400e3ea:	4a2e      	ldr	r2, [pc, #184]	; (2400e4a4 <I2C_ITSlaveCplt+0x288>)
2400e3ec:	4293      	cmp	r3, r2
2400e3ee:	d04d      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e3f0:	687b      	ldr	r3, [r7, #4]
2400e3f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e3f4:	681b      	ldr	r3, [r3, #0]
2400e3f6:	4a2c      	ldr	r2, [pc, #176]	; (2400e4a8 <I2C_ITSlaveCplt+0x28c>)
2400e3f8:	4293      	cmp	r3, r2
2400e3fa:	d047      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e3fc:	687b      	ldr	r3, [r7, #4]
2400e3fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e400:	681b      	ldr	r3, [r3, #0]
2400e402:	4a2a      	ldr	r2, [pc, #168]	; (2400e4ac <I2C_ITSlaveCplt+0x290>)
2400e404:	4293      	cmp	r3, r2
2400e406:	d041      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e408:	687b      	ldr	r3, [r7, #4]
2400e40a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e40c:	681b      	ldr	r3, [r3, #0]
2400e40e:	4a28      	ldr	r2, [pc, #160]	; (2400e4b0 <I2C_ITSlaveCplt+0x294>)
2400e410:	4293      	cmp	r3, r2
2400e412:	d03b      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e414:	687b      	ldr	r3, [r7, #4]
2400e416:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e418:	681b      	ldr	r3, [r3, #0]
2400e41a:	4a26      	ldr	r2, [pc, #152]	; (2400e4b4 <I2C_ITSlaveCplt+0x298>)
2400e41c:	4293      	cmp	r3, r2
2400e41e:	d035      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e420:	687b      	ldr	r3, [r7, #4]
2400e422:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e424:	681b      	ldr	r3, [r3, #0]
2400e426:	4a24      	ldr	r2, [pc, #144]	; (2400e4b8 <I2C_ITSlaveCplt+0x29c>)
2400e428:	4293      	cmp	r3, r2
2400e42a:	d02f      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e42c:	687b      	ldr	r3, [r7, #4]
2400e42e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e430:	681b      	ldr	r3, [r3, #0]
2400e432:	4a22      	ldr	r2, [pc, #136]	; (2400e4bc <I2C_ITSlaveCplt+0x2a0>)
2400e434:	4293      	cmp	r3, r2
2400e436:	d029      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e438:	687b      	ldr	r3, [r7, #4]
2400e43a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e43c:	681b      	ldr	r3, [r3, #0]
2400e43e:	4a20      	ldr	r2, [pc, #128]	; (2400e4c0 <I2C_ITSlaveCplt+0x2a4>)
2400e440:	4293      	cmp	r3, r2
2400e442:	d023      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e444:	687b      	ldr	r3, [r7, #4]
2400e446:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e448:	681b      	ldr	r3, [r3, #0]
2400e44a:	4a1e      	ldr	r2, [pc, #120]	; (2400e4c4 <I2C_ITSlaveCplt+0x2a8>)
2400e44c:	4293      	cmp	r3, r2
2400e44e:	d01d      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e450:	687b      	ldr	r3, [r7, #4]
2400e452:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e454:	681b      	ldr	r3, [r3, #0]
2400e456:	4a1c      	ldr	r2, [pc, #112]	; (2400e4c8 <I2C_ITSlaveCplt+0x2ac>)
2400e458:	4293      	cmp	r3, r2
2400e45a:	d017      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e45c:	687b      	ldr	r3, [r7, #4]
2400e45e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e460:	681b      	ldr	r3, [r3, #0]
2400e462:	4a1a      	ldr	r2, [pc, #104]	; (2400e4cc <I2C_ITSlaveCplt+0x2b0>)
2400e464:	4293      	cmp	r3, r2
2400e466:	d011      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e468:	687b      	ldr	r3, [r7, #4]
2400e46a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e46c:	681b      	ldr	r3, [r3, #0]
2400e46e:	4a18      	ldr	r2, [pc, #96]	; (2400e4d0 <I2C_ITSlaveCplt+0x2b4>)
2400e470:	4293      	cmp	r3, r2
2400e472:	d00b      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e474:	687b      	ldr	r3, [r7, #4]
2400e476:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e478:	681b      	ldr	r3, [r3, #0]
2400e47a:	4a16      	ldr	r2, [pc, #88]	; (2400e4d4 <I2C_ITSlaveCplt+0x2b8>)
2400e47c:	4293      	cmp	r3, r2
2400e47e:	d005      	beq.n	2400e48c <I2C_ITSlaveCplt+0x270>
2400e480:	687b      	ldr	r3, [r7, #4]
2400e482:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e484:	681b      	ldr	r3, [r3, #0]
2400e486:	4a14      	ldr	r2, [pc, #80]	; (2400e4d8 <I2C_ITSlaveCplt+0x2bc>)
2400e488:	4293      	cmp	r3, r2
2400e48a:	d127      	bne.n	2400e4dc <I2C_ITSlaveCplt+0x2c0>
2400e48c:	687b      	ldr	r3, [r7, #4]
2400e48e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e490:	681b      	ldr	r3, [r3, #0]
2400e492:	685b      	ldr	r3, [r3, #4]
2400e494:	b29b      	uxth	r3, r3
2400e496:	e026      	b.n	2400e4e6 <I2C_ITSlaveCplt+0x2ca>
2400e498:	fe00e800 	.word	0xfe00e800
2400e49c:	40020010 	.word	0x40020010
2400e4a0:	40020028 	.word	0x40020028
2400e4a4:	40020040 	.word	0x40020040
2400e4a8:	40020058 	.word	0x40020058
2400e4ac:	40020070 	.word	0x40020070
2400e4b0:	40020088 	.word	0x40020088
2400e4b4:	400200a0 	.word	0x400200a0
2400e4b8:	400200b8 	.word	0x400200b8
2400e4bc:	40020410 	.word	0x40020410
2400e4c0:	40020428 	.word	0x40020428
2400e4c4:	40020440 	.word	0x40020440
2400e4c8:	40020458 	.word	0x40020458
2400e4cc:	40020470 	.word	0x40020470
2400e4d0:	40020488 	.word	0x40020488
2400e4d4:	400204a0 	.word	0x400204a0
2400e4d8:	400204b8 	.word	0x400204b8
2400e4dc:	687b      	ldr	r3, [r7, #4]
2400e4de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e4e0:	681b      	ldr	r3, [r3, #0]
2400e4e2:	685b      	ldr	r3, [r3, #4]
2400e4e4:	b29b      	uxth	r3, r3
2400e4e6:	687a      	ldr	r2, [r7, #4]
2400e4e8:	8553      	strh	r3, [r2, #42]	; 0x2a
  {
    /* Do nothing */
  }

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
2400e4ea:	697b      	ldr	r3, [r7, #20]
2400e4ec:	089b      	lsrs	r3, r3, #2
2400e4ee:	f003 0301 	and.w	r3, r3, #1
2400e4f2:	2b00      	cmp	r3, #0
2400e4f4:	d020      	beq.n	2400e538 <I2C_ITSlaveCplt+0x31c>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400e4f6:	697b      	ldr	r3, [r7, #20]
2400e4f8:	f023 0304 	bic.w	r3, r3, #4
2400e4fc:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400e4fe:	687b      	ldr	r3, [r7, #4]
2400e500:	681b      	ldr	r3, [r3, #0]
2400e502:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400e504:	687b      	ldr	r3, [r7, #4]
2400e506:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e508:	b2d2      	uxtb	r2, r2
2400e50a:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400e50c:	687b      	ldr	r3, [r7, #4]
2400e50e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e510:	1c5a      	adds	r2, r3, #1
2400e512:	687b      	ldr	r3, [r7, #4]
2400e514:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2400e516:	687b      	ldr	r3, [r7, #4]
2400e518:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400e51a:	2b00      	cmp	r3, #0
2400e51c:	d00c      	beq.n	2400e538 <I2C_ITSlaveCplt+0x31c>
    {
      hi2c->XferSize--;
2400e51e:	687b      	ldr	r3, [r7, #4]
2400e520:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400e522:	3b01      	subs	r3, #1
2400e524:	b29a      	uxth	r2, r3
2400e526:	687b      	ldr	r3, [r7, #4]
2400e528:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400e52a:	687b      	ldr	r3, [r7, #4]
2400e52c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e52e:	b29b      	uxth	r3, r3
2400e530:	3b01      	subs	r3, #1
2400e532:	b29a      	uxth	r2, r3
2400e534:	687b      	ldr	r3, [r7, #4]
2400e536:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
2400e538:	687b      	ldr	r3, [r7, #4]
2400e53a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e53c:	b29b      	uxth	r3, r3
2400e53e:	2b00      	cmp	r3, #0
2400e540:	d005      	beq.n	2400e54e <I2C_ITSlaveCplt+0x332>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400e542:	687b      	ldr	r3, [r7, #4]
2400e544:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e546:	f043 0204 	orr.w	r2, r3, #4
2400e54a:	687b      	ldr	r3, [r7, #4]
2400e54c:	645a      	str	r2, [r3, #68]	; 0x44
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
2400e54e:	687b      	ldr	r3, [r7, #4]
2400e550:	2200      	movs	r2, #0
2400e552:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2400e556:	687b      	ldr	r3, [r7, #4]
2400e558:	2200      	movs	r2, #0
2400e55a:	635a      	str	r2, [r3, #52]	; 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
2400e55c:	687b      	ldr	r3, [r7, #4]
2400e55e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e560:	2b00      	cmp	r3, #0
2400e562:	d010      	beq.n	2400e586 <I2C_ITSlaveCplt+0x36a>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400e564:	687b      	ldr	r3, [r7, #4]
2400e566:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e568:	4619      	mov	r1, r3
2400e56a:	6878      	ldr	r0, [r7, #4]
2400e56c:	f000 f8a4 	bl	2400e6b8 <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400e570:	687b      	ldr	r3, [r7, #4]
2400e572:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e576:	b2db      	uxtb	r3, r3
2400e578:	2b28      	cmp	r3, #40	; 0x28
2400e57a:	d141      	bne.n	2400e600 <I2C_ITSlaveCplt+0x3e4>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
2400e57c:	6979      	ldr	r1, [r7, #20]
2400e57e:	6878      	ldr	r0, [r7, #4]
2400e580:	f000 f844 	bl	2400e60c <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400e584:	e03c      	b.n	2400e600 <I2C_ITSlaveCplt+0x3e4>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400e586:	687b      	ldr	r3, [r7, #4]
2400e588:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400e58a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400e58e:	d014      	beq.n	2400e5ba <I2C_ITSlaveCplt+0x39e>
    I2C_ITSlaveSeqCplt(hi2c);
2400e590:	6878      	ldr	r0, [r7, #4]
2400e592:	f7ff fd1a 	bl	2400dfca <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400e596:	687b      	ldr	r3, [r7, #4]
2400e598:	4a1b      	ldr	r2, [pc, #108]	; (2400e608 <I2C_ITSlaveCplt+0x3ec>)
2400e59a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
2400e59c:	687b      	ldr	r3, [r7, #4]
2400e59e:	2220      	movs	r2, #32
2400e5a0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e5a4:	687b      	ldr	r3, [r7, #4]
2400e5a6:	2200      	movs	r2, #0
2400e5a8:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400e5aa:	687b      	ldr	r3, [r7, #4]
2400e5ac:	2200      	movs	r2, #0
2400e5ae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
2400e5b2:	6878      	ldr	r0, [r7, #4]
2400e5b4:	f7fe fbf7 	bl	2400cda6 <HAL_I2C_ListenCpltCallback>
}
2400e5b8:	e022      	b.n	2400e600 <I2C_ITSlaveCplt+0x3e4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400e5ba:	687b      	ldr	r3, [r7, #4]
2400e5bc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e5c0:	b2db      	uxtb	r3, r3
2400e5c2:	2b22      	cmp	r3, #34	; 0x22
2400e5c4:	d10e      	bne.n	2400e5e4 <I2C_ITSlaveCplt+0x3c8>
    hi2c->State = HAL_I2C_STATE_READY;
2400e5c6:	687b      	ldr	r3, [r7, #4]
2400e5c8:	2220      	movs	r2, #32
2400e5ca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e5ce:	687b      	ldr	r3, [r7, #4]
2400e5d0:	2200      	movs	r2, #0
2400e5d2:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400e5d4:	687b      	ldr	r3, [r7, #4]
2400e5d6:	2200      	movs	r2, #0
2400e5d8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400e5dc:	6878      	ldr	r0, [r7, #4]
2400e5de:	f7fe fbca 	bl	2400cd76 <HAL_I2C_SlaveRxCpltCallback>
}
2400e5e2:	e00d      	b.n	2400e600 <I2C_ITSlaveCplt+0x3e4>
    hi2c->State = HAL_I2C_STATE_READY;
2400e5e4:	687b      	ldr	r3, [r7, #4]
2400e5e6:	2220      	movs	r2, #32
2400e5e8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e5ec:	687b      	ldr	r3, [r7, #4]
2400e5ee:	2200      	movs	r2, #0
2400e5f0:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400e5f2:	687b      	ldr	r3, [r7, #4]
2400e5f4:	2200      	movs	r2, #0
2400e5f6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400e5fa:	6878      	ldr	r0, [r7, #4]
2400e5fc:	f7fe fbb1 	bl	2400cd62 <HAL_I2C_SlaveTxCpltCallback>
}
2400e600:	bf00      	nop
2400e602:	3718      	adds	r7, #24
2400e604:	46bd      	mov	sp, r7
2400e606:	bd80      	pop	{r7, pc}
2400e608:	ffff0000 	.word	0xffff0000

2400e60c <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400e60c:	b580      	push	{r7, lr}
2400e60e:	b082      	sub	sp, #8
2400e610:	af00      	add	r7, sp, #0
2400e612:	6078      	str	r0, [r7, #4]
2400e614:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400e616:	687b      	ldr	r3, [r7, #4]
2400e618:	4a26      	ldr	r2, [pc, #152]	; (2400e6b4 <I2C_ITListenCplt+0xa8>)
2400e61a:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
2400e61c:	687b      	ldr	r3, [r7, #4]
2400e61e:	2200      	movs	r2, #0
2400e620:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
2400e622:	687b      	ldr	r3, [r7, #4]
2400e624:	2220      	movs	r2, #32
2400e626:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400e62a:	687b      	ldr	r3, [r7, #4]
2400e62c:	2200      	movs	r2, #0
2400e62e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2400e632:	687b      	ldr	r3, [r7, #4]
2400e634:	2200      	movs	r2, #0
2400e636:	635a      	str	r2, [r3, #52]	; 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
2400e638:	683b      	ldr	r3, [r7, #0]
2400e63a:	089b      	lsrs	r3, r3, #2
2400e63c:	f003 0301 	and.w	r3, r3, #1
2400e640:	2b00      	cmp	r3, #0
2400e642:	d022      	beq.n	2400e68a <I2C_ITListenCplt+0x7e>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400e644:	687b      	ldr	r3, [r7, #4]
2400e646:	681b      	ldr	r3, [r3, #0]
2400e648:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400e64a:	687b      	ldr	r3, [r7, #4]
2400e64c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e64e:	b2d2      	uxtb	r2, r2
2400e650:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400e652:	687b      	ldr	r3, [r7, #4]
2400e654:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e656:	1c5a      	adds	r2, r3, #1
2400e658:	687b      	ldr	r3, [r7, #4]
2400e65a:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2400e65c:	687b      	ldr	r3, [r7, #4]
2400e65e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400e660:	2b00      	cmp	r3, #0
2400e662:	d012      	beq.n	2400e68a <I2C_ITListenCplt+0x7e>
    {
      hi2c->XferSize--;
2400e664:	687b      	ldr	r3, [r7, #4]
2400e666:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400e668:	3b01      	subs	r3, #1
2400e66a:	b29a      	uxth	r2, r3
2400e66c:	687b      	ldr	r3, [r7, #4]
2400e66e:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400e670:	687b      	ldr	r3, [r7, #4]
2400e672:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e674:	b29b      	uxth	r3, r3
2400e676:	3b01      	subs	r3, #1
2400e678:	b29a      	uxth	r2, r3
2400e67a:	687b      	ldr	r3, [r7, #4]
2400e67c:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400e67e:	687b      	ldr	r3, [r7, #4]
2400e680:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e682:	f043 0204 	orr.w	r2, r3, #4
2400e686:	687b      	ldr	r3, [r7, #4]
2400e688:	645a      	str	r2, [r3, #68]	; 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400e68a:	f248 0103 	movw	r1, #32771	; 0x8003
2400e68e:	6878      	ldr	r0, [r7, #4]
2400e690:	f000 fee6 	bl	2400f460 <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400e694:	687b      	ldr	r3, [r7, #4]
2400e696:	681b      	ldr	r3, [r3, #0]
2400e698:	2210      	movs	r2, #16
2400e69a:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400e69c:	687b      	ldr	r3, [r7, #4]
2400e69e:	2200      	movs	r2, #0
2400e6a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
2400e6a4:	6878      	ldr	r0, [r7, #4]
2400e6a6:	f7fe fb7e 	bl	2400cda6 <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
2400e6aa:	bf00      	nop
2400e6ac:	3708      	adds	r7, #8
2400e6ae:	46bd      	mov	sp, r7
2400e6b0:	bd80      	pop	{r7, pc}
2400e6b2:	bf00      	nop
2400e6b4:	ffff0000 	.word	0xffff0000

2400e6b8 <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
2400e6b8:	b580      	push	{r7, lr}
2400e6ba:	b084      	sub	sp, #16
2400e6bc:	af00      	add	r7, sp, #0
2400e6be:	6078      	str	r0, [r7, #4]
2400e6c0:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400e6c2:	687b      	ldr	r3, [r7, #4]
2400e6c4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e6c8:	73fb      	strb	r3, [r7, #15]
  uint32_t tmppreviousstate;

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
2400e6ca:	687b      	ldr	r3, [r7, #4]
2400e6cc:	2200      	movs	r2, #0
2400e6ce:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400e6d2:	687b      	ldr	r3, [r7, #4]
2400e6d4:	4a6d      	ldr	r2, [pc, #436]	; (2400e88c <I2C_ITError+0x1d4>)
2400e6d6:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->XferCount     = 0U;
2400e6d8:	687b      	ldr	r3, [r7, #4]
2400e6da:	2200      	movs	r2, #0
2400e6dc:	855a      	strh	r2, [r3, #42]	; 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
2400e6de:	687b      	ldr	r3, [r7, #4]
2400e6e0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2400e6e2:	683b      	ldr	r3, [r7, #0]
2400e6e4:	431a      	orrs	r2, r3
2400e6e6:	687b      	ldr	r3, [r7, #4]
2400e6e8:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
2400e6ea:	7bfb      	ldrb	r3, [r7, #15]
2400e6ec:	2b28      	cmp	r3, #40	; 0x28
2400e6ee:	d005      	beq.n	2400e6fc <I2C_ITError+0x44>
2400e6f0:	7bfb      	ldrb	r3, [r7, #15]
2400e6f2:	2b29      	cmp	r3, #41	; 0x29
2400e6f4:	d002      	beq.n	2400e6fc <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
2400e6f6:	7bfb      	ldrb	r3, [r7, #15]
2400e6f8:	2b2a      	cmp	r3, #42	; 0x2a
2400e6fa:	d10b      	bne.n	2400e714 <I2C_ITError+0x5c>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400e6fc:	2103      	movs	r1, #3
2400e6fe:	6878      	ldr	r0, [r7, #4]
2400e700:	f000 feae 	bl	2400f460 <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400e704:	687b      	ldr	r3, [r7, #4]
2400e706:	2228      	movs	r2, #40	; 0x28
2400e708:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
2400e70c:	687b      	ldr	r3, [r7, #4]
2400e70e:	4a60      	ldr	r2, [pc, #384]	; (2400e890 <I2C_ITError+0x1d8>)
2400e710:	635a      	str	r2, [r3, #52]	; 0x34
2400e712:	e030      	b.n	2400e776 <I2C_ITError+0xbe>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400e714:	f248 0103 	movw	r1, #32771	; 0x8003
2400e718:	6878      	ldr	r0, [r7, #4]
2400e71a:	f000 fea1 	bl	2400f460 <I2C_Disable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400e71e:	6878      	ldr	r0, [r7, #4]
2400e720:	f000 f8e1 	bl	2400e8e6 <I2C_Flush_TXDR>

    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
2400e724:	687b      	ldr	r3, [r7, #4]
2400e726:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e72a:	b2db      	uxtb	r3, r3
2400e72c:	2b60      	cmp	r3, #96	; 0x60
2400e72e:	d01f      	beq.n	2400e770 <I2C_ITError+0xb8>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
2400e730:	687b      	ldr	r3, [r7, #4]
2400e732:	2220      	movs	r2, #32
2400e734:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Check if a STOPF is detected */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
2400e738:	687b      	ldr	r3, [r7, #4]
2400e73a:	681b      	ldr	r3, [r3, #0]
2400e73c:	699b      	ldr	r3, [r3, #24]
2400e73e:	f003 0320 	and.w	r3, r3, #32
2400e742:	2b20      	cmp	r3, #32
2400e744:	d114      	bne.n	2400e770 <I2C_ITError+0xb8>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
2400e746:	687b      	ldr	r3, [r7, #4]
2400e748:	681b      	ldr	r3, [r3, #0]
2400e74a:	699b      	ldr	r3, [r3, #24]
2400e74c:	f003 0310 	and.w	r3, r3, #16
2400e750:	2b10      	cmp	r3, #16
2400e752:	d109      	bne.n	2400e768 <I2C_ITError+0xb0>
        {
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400e754:	687b      	ldr	r3, [r7, #4]
2400e756:	681b      	ldr	r3, [r3, #0]
2400e758:	2210      	movs	r2, #16
2400e75a:	61da      	str	r2, [r3, #28]
          hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400e75c:	687b      	ldr	r3, [r7, #4]
2400e75e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e760:	f043 0204 	orr.w	r2, r3, #4
2400e764:	687b      	ldr	r3, [r7, #4]
2400e766:	645a      	str	r2, [r3, #68]	; 0x44
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400e768:	687b      	ldr	r3, [r7, #4]
2400e76a:	681b      	ldr	r3, [r3, #0]
2400e76c:	2220      	movs	r2, #32
2400e76e:	61da      	str	r2, [r3, #28]
      }

    }
    hi2c->XferISR       = NULL;
2400e770:	687b      	ldr	r3, [r7, #4]
2400e772:	2200      	movs	r2, #0
2400e774:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
2400e776:	687b      	ldr	r3, [r7, #4]
2400e778:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400e77a:	60bb      	str	r3, [r7, #8]
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
2400e77c:	687b      	ldr	r3, [r7, #4]
2400e77e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e780:	2b00      	cmp	r3, #0
2400e782:	d039      	beq.n	2400e7f8 <I2C_ITError+0x140>
2400e784:	68bb      	ldr	r3, [r7, #8]
2400e786:	2b11      	cmp	r3, #17
2400e788:	d002      	beq.n	2400e790 <I2C_ITError+0xd8>
2400e78a:	68bb      	ldr	r3, [r7, #8]
2400e78c:	2b21      	cmp	r3, #33	; 0x21
2400e78e:	d133      	bne.n	2400e7f8 <I2C_ITError+0x140>
                                 (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400e790:	687b      	ldr	r3, [r7, #4]
2400e792:	681b      	ldr	r3, [r3, #0]
2400e794:	681b      	ldr	r3, [r3, #0]
2400e796:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400e79a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400e79e:	d107      	bne.n	2400e7b0 <I2C_ITError+0xf8>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400e7a0:	687b      	ldr	r3, [r7, #4]
2400e7a2:	681b      	ldr	r3, [r3, #0]
2400e7a4:	681a      	ldr	r2, [r3, #0]
2400e7a6:	687b      	ldr	r3, [r7, #4]
2400e7a8:	681b      	ldr	r3, [r3, #0]
2400e7aa:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400e7ae:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400e7b0:	687b      	ldr	r3, [r7, #4]
2400e7b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e7b4:	4618      	mov	r0, r3
2400e7b6:	f7f7 fd35 	bl	24006224 <HAL_DMA_GetState>
2400e7ba:	4603      	mov	r3, r0
2400e7bc:	2b01      	cmp	r3, #1
2400e7be:	d017      	beq.n	2400e7f0 <I2C_ITError+0x138>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400e7c0:	687b      	ldr	r3, [r7, #4]
2400e7c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e7c4:	4a33      	ldr	r2, [pc, #204]	; (2400e894 <I2C_ITError+0x1dc>)
2400e7c6:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400e7c8:	687b      	ldr	r3, [r7, #4]
2400e7ca:	2200      	movs	r2, #0
2400e7cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400e7d0:	687b      	ldr	r3, [r7, #4]
2400e7d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e7d4:	4618      	mov	r0, r3
2400e7d6:	f7f5 ff43 	bl	24004660 <HAL_DMA_Abort_IT>
2400e7da:	4603      	mov	r3, r0
2400e7dc:	2b00      	cmp	r3, #0
2400e7de:	d04d      	beq.n	2400e87c <I2C_ITError+0x1c4>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400e7e0:	687b      	ldr	r3, [r7, #4]
2400e7e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e7e4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400e7e6:	687a      	ldr	r2, [r7, #4]
2400e7e8:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400e7ea:	4610      	mov	r0, r2
2400e7ec:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400e7ee:	e045      	b.n	2400e87c <I2C_ITError+0x1c4>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
2400e7f0:	6878      	ldr	r0, [r7, #4]
2400e7f2:	f000 f851 	bl	2400e898 <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400e7f6:	e041      	b.n	2400e87c <I2C_ITError+0x1c4>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \
2400e7f8:	687b      	ldr	r3, [r7, #4]
2400e7fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e7fc:	2b00      	cmp	r3, #0
2400e7fe:	d039      	beq.n	2400e874 <I2C_ITError+0x1bc>
2400e800:	68bb      	ldr	r3, [r7, #8]
2400e802:	2b12      	cmp	r3, #18
2400e804:	d002      	beq.n	2400e80c <I2C_ITError+0x154>
2400e806:	68bb      	ldr	r3, [r7, #8]
2400e808:	2b22      	cmp	r3, #34	; 0x22
2400e80a:	d133      	bne.n	2400e874 <I2C_ITError+0x1bc>
                                      (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400e80c:	687b      	ldr	r3, [r7, #4]
2400e80e:	681b      	ldr	r3, [r3, #0]
2400e810:	681b      	ldr	r3, [r3, #0]
2400e812:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400e816:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400e81a:	d107      	bne.n	2400e82c <I2C_ITError+0x174>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400e81c:	687b      	ldr	r3, [r7, #4]
2400e81e:	681b      	ldr	r3, [r3, #0]
2400e820:	681a      	ldr	r2, [r3, #0]
2400e822:	687b      	ldr	r3, [r7, #4]
2400e824:	681b      	ldr	r3, [r3, #0]
2400e826:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400e82a:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400e82c:	687b      	ldr	r3, [r7, #4]
2400e82e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e830:	4618      	mov	r0, r3
2400e832:	f7f7 fcf7 	bl	24006224 <HAL_DMA_GetState>
2400e836:	4603      	mov	r3, r0
2400e838:	2b01      	cmp	r3, #1
2400e83a:	d017      	beq.n	2400e86c <I2C_ITError+0x1b4>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400e83c:	687b      	ldr	r3, [r7, #4]
2400e83e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e840:	4a14      	ldr	r2, [pc, #80]	; (2400e894 <I2C_ITError+0x1dc>)
2400e842:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400e844:	687b      	ldr	r3, [r7, #4]
2400e846:	2200      	movs	r2, #0
2400e848:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400e84c:	687b      	ldr	r3, [r7, #4]
2400e84e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e850:	4618      	mov	r0, r3
2400e852:	f7f5 ff05 	bl	24004660 <HAL_DMA_Abort_IT>
2400e856:	4603      	mov	r3, r0
2400e858:	2b00      	cmp	r3, #0
2400e85a:	d011      	beq.n	2400e880 <I2C_ITError+0x1c8>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400e85c:	687b      	ldr	r3, [r7, #4]
2400e85e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e860:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400e862:	687a      	ldr	r2, [r7, #4]
2400e864:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400e866:	4610      	mov	r0, r2
2400e868:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400e86a:	e009      	b.n	2400e880 <I2C_ITError+0x1c8>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
2400e86c:	6878      	ldr	r0, [r7, #4]
2400e86e:	f000 f813 	bl	2400e898 <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400e872:	e005      	b.n	2400e880 <I2C_ITError+0x1c8>
    }
  }
  else
  {
    I2C_TreatErrorCallback(hi2c);
2400e874:	6878      	ldr	r0, [r7, #4]
2400e876:	f000 f80f 	bl	2400e898 <I2C_TreatErrorCallback>
  }
}
2400e87a:	e002      	b.n	2400e882 <I2C_ITError+0x1ca>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400e87c:	bf00      	nop
2400e87e:	e000      	b.n	2400e882 <I2C_ITError+0x1ca>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400e880:	bf00      	nop
}
2400e882:	bf00      	nop
2400e884:	3710      	adds	r7, #16
2400e886:	46bd      	mov	sp, r7
2400e888:	bd80      	pop	{r7, pc}
2400e88a:	bf00      	nop
2400e88c:	ffff0000 	.word	0xffff0000
2400e890:	2400d301 	.word	0x2400d301
2400e894:	2400ee75 	.word	0x2400ee75

2400e898 <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
2400e898:	b580      	push	{r7, lr}
2400e89a:	b082      	sub	sp, #8
2400e89c:	af00      	add	r7, sp, #0
2400e89e:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
2400e8a0:	687b      	ldr	r3, [r7, #4]
2400e8a2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e8a6:	b2db      	uxtb	r3, r3
2400e8a8:	2b60      	cmp	r3, #96	; 0x60
2400e8aa:	d10e      	bne.n	2400e8ca <I2C_TreatErrorCallback+0x32>
  {
    hi2c->State = HAL_I2C_STATE_READY;
2400e8ac:	687b      	ldr	r3, [r7, #4]
2400e8ae:	2220      	movs	r2, #32
2400e8b0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e8b4:	687b      	ldr	r3, [r7, #4]
2400e8b6:	2200      	movs	r2, #0
2400e8b8:	631a      	str	r2, [r3, #48]	; 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e8ba:	687b      	ldr	r3, [r7, #4]
2400e8bc:	2200      	movs	r2, #0
2400e8be:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
2400e8c2:	6878      	ldr	r0, [r7, #4]
2400e8c4:	f7fe fa97 	bl	2400cdf6 <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400e8c8:	e009      	b.n	2400e8de <I2C_TreatErrorCallback+0x46>
    hi2c->PreviousState = I2C_STATE_NONE;
2400e8ca:	687b      	ldr	r3, [r7, #4]
2400e8cc:	2200      	movs	r2, #0
2400e8ce:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400e8d0:	687b      	ldr	r3, [r7, #4]
2400e8d2:	2200      	movs	r2, #0
2400e8d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
2400e8d8:	6878      	ldr	r0, [r7, #4]
2400e8da:	f7fe fa82 	bl	2400cde2 <HAL_I2C_ErrorCallback>
}
2400e8de:	bf00      	nop
2400e8e0:	3708      	adds	r7, #8
2400e8e2:	46bd      	mov	sp, r7
2400e8e4:	bd80      	pop	{r7, pc}

2400e8e6 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
2400e8e6:	b480      	push	{r7}
2400e8e8:	b083      	sub	sp, #12
2400e8ea:	af00      	add	r7, sp, #0
2400e8ec:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
2400e8ee:	687b      	ldr	r3, [r7, #4]
2400e8f0:	681b      	ldr	r3, [r3, #0]
2400e8f2:	699b      	ldr	r3, [r3, #24]
2400e8f4:	f003 0302 	and.w	r3, r3, #2
2400e8f8:	2b02      	cmp	r3, #2
2400e8fa:	d103      	bne.n	2400e904 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
2400e8fc:	687b      	ldr	r3, [r7, #4]
2400e8fe:	681b      	ldr	r3, [r3, #0]
2400e900:	2200      	movs	r2, #0
2400e902:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
2400e904:	687b      	ldr	r3, [r7, #4]
2400e906:	681b      	ldr	r3, [r3, #0]
2400e908:	699b      	ldr	r3, [r3, #24]
2400e90a:	f003 0301 	and.w	r3, r3, #1
2400e90e:	2b01      	cmp	r3, #1
2400e910:	d007      	beq.n	2400e922 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
2400e912:	687b      	ldr	r3, [r7, #4]
2400e914:	681b      	ldr	r3, [r3, #0]
2400e916:	699a      	ldr	r2, [r3, #24]
2400e918:	687b      	ldr	r3, [r7, #4]
2400e91a:	681b      	ldr	r3, [r3, #0]
2400e91c:	f042 0201 	orr.w	r2, r2, #1
2400e920:	619a      	str	r2, [r3, #24]
  }
}
2400e922:	bf00      	nop
2400e924:	370c      	adds	r7, #12
2400e926:	46bd      	mov	sp, r7
2400e928:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e92c:	4770      	bx	lr

2400e92e <I2C_DMAMasterTransmitCplt>:
  * @brief  DMA I2C master transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
{
2400e92e:	b580      	push	{r7, lr}
2400e930:	b084      	sub	sp, #16
2400e932:	af00      	add	r7, sp, #0
2400e934:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400e936:	687b      	ldr	r3, [r7, #4]
2400e938:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e93a:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400e93c:	68fb      	ldr	r3, [r7, #12]
2400e93e:	681b      	ldr	r3, [r3, #0]
2400e940:	681a      	ldr	r2, [r3, #0]
2400e942:	68fb      	ldr	r3, [r7, #12]
2400e944:	681b      	ldr	r3, [r3, #0]
2400e946:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400e94a:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
2400e94c:	68fb      	ldr	r3, [r7, #12]
2400e94e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e950:	b29b      	uxth	r3, r3
2400e952:	2b00      	cmp	r3, #0
2400e954:	d104      	bne.n	2400e960 <I2C_DMAMasterTransmitCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400e956:	2120      	movs	r1, #32
2400e958:	68f8      	ldr	r0, [r7, #12]
2400e95a:	f000 fd17 	bl	2400f38c <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
2400e95e:	e02d      	b.n	2400e9bc <I2C_DMAMasterTransmitCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
2400e960:	68fb      	ldr	r3, [r7, #12]
2400e962:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e964:	68fa      	ldr	r2, [r7, #12]
2400e966:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2400e968:	441a      	add	r2, r3
2400e96a:	68fb      	ldr	r3, [r7, #12]
2400e96c:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400e96e:	68fb      	ldr	r3, [r7, #12]
2400e970:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e972:	b29b      	uxth	r3, r3
2400e974:	2bff      	cmp	r3, #255	; 0xff
2400e976:	d903      	bls.n	2400e980 <I2C_DMAMasterTransmitCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400e978:	68fb      	ldr	r3, [r7, #12]
2400e97a:	22ff      	movs	r2, #255	; 0xff
2400e97c:	851a      	strh	r2, [r3, #40]	; 0x28
2400e97e:	e004      	b.n	2400e98a <I2C_DMAMasterTransmitCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2400e980:	68fb      	ldr	r3, [r7, #12]
2400e982:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e984:	b29a      	uxth	r2, r3
2400e986:	68fb      	ldr	r3, [r7, #12]
2400e988:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR,
2400e98a:	68fb      	ldr	r3, [r7, #12]
2400e98c:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400e98e:	68fb      	ldr	r3, [r7, #12]
2400e990:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e992:	4619      	mov	r1, r3
2400e994:	68fb      	ldr	r3, [r7, #12]
2400e996:	681b      	ldr	r3, [r3, #0]
2400e998:	3328      	adds	r3, #40	; 0x28
2400e99a:	461a      	mov	r2, r3
                         hi2c->XferSize) != HAL_OK)
2400e99c:	68fb      	ldr	r3, [r7, #12]
2400e99e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR,
2400e9a0:	f7f5 f8d6 	bl	24003b50 <HAL_DMA_Start_IT>
2400e9a4:	4603      	mov	r3, r0
2400e9a6:	2b00      	cmp	r3, #0
2400e9a8:	d004      	beq.n	2400e9b4 <I2C_DMAMasterTransmitCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400e9aa:	2110      	movs	r1, #16
2400e9ac:	68f8      	ldr	r0, [r7, #12]
2400e9ae:	f7ff fe83 	bl	2400e6b8 <I2C_ITError>
}
2400e9b2:	e003      	b.n	2400e9bc <I2C_DMAMasterTransmitCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2400e9b4:	2140      	movs	r1, #64	; 0x40
2400e9b6:	68f8      	ldr	r0, [r7, #12]
2400e9b8:	f000 fce8 	bl	2400f38c <I2C_Enable_IRQ>
}
2400e9bc:	bf00      	nop
2400e9be:	3710      	adds	r7, #16
2400e9c0:	46bd      	mov	sp, r7
2400e9c2:	bd80      	pop	{r7, pc}

2400e9c4 <I2C_DMASlaveTransmitCplt>:
  * @brief  DMA I2C slave transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
{
2400e9c4:	b580      	push	{r7, lr}
2400e9c6:	b084      	sub	sp, #16
2400e9c8:	af00      	add	r7, sp, #0
2400e9ca:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400e9cc:	687b      	ldr	r3, [r7, #4]
2400e9ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e9d0:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2400e9d2:	68fb      	ldr	r3, [r7, #12]
2400e9d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400e9d6:	60bb      	str	r3, [r7, #8]

  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400e9d8:	68bb      	ldr	r3, [r7, #8]
2400e9da:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400e9de:	d002      	beq.n	2400e9e6 <I2C_DMASlaveTransmitCplt+0x22>
2400e9e0:	68bb      	ldr	r3, [r7, #8]
2400e9e2:	2b00      	cmp	r3, #0
2400e9e4:	d10a      	bne.n	2400e9fc <I2C_DMASlaveTransmitCplt+0x38>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400e9e6:	68fb      	ldr	r3, [r7, #12]
2400e9e8:	681b      	ldr	r3, [r3, #0]
2400e9ea:	681a      	ldr	r2, [r3, #0]
2400e9ec:	68fb      	ldr	r3, [r7, #12]
2400e9ee:	681b      	ldr	r3, [r3, #0]
2400e9f0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400e9f4:	601a      	str	r2, [r3, #0]

    /* Last Byte is Transmitted */
    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2400e9f6:	68f8      	ldr	r0, [r7, #12]
2400e9f8:	f7ff fae7 	bl	2400dfca <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2400e9fc:	bf00      	nop
2400e9fe:	3710      	adds	r7, #16
2400ea00:	46bd      	mov	sp, r7
2400ea02:	bd80      	pop	{r7, pc}

2400ea04 <I2C_DMAMasterReceiveCplt>:
  * @brief DMA I2C master receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
{
2400ea04:	b580      	push	{r7, lr}
2400ea06:	b084      	sub	sp, #16
2400ea08:	af00      	add	r7, sp, #0
2400ea0a:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400ea0c:	687b      	ldr	r3, [r7, #4]
2400ea0e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ea10:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400ea12:	68fb      	ldr	r3, [r7, #12]
2400ea14:	681b      	ldr	r3, [r3, #0]
2400ea16:	681a      	ldr	r2, [r3, #0]
2400ea18:	68fb      	ldr	r3, [r7, #12]
2400ea1a:	681b      	ldr	r3, [r3, #0]
2400ea1c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400ea20:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
2400ea22:	68fb      	ldr	r3, [r7, #12]
2400ea24:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ea26:	b29b      	uxth	r3, r3
2400ea28:	2b00      	cmp	r3, #0
2400ea2a:	d104      	bne.n	2400ea36 <I2C_DMAMasterReceiveCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400ea2c:	2120      	movs	r1, #32
2400ea2e:	68f8      	ldr	r0, [r7, #12]
2400ea30:	f000 fcac 	bl	2400f38c <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
2400ea34:	e02d      	b.n	2400ea92 <I2C_DMAMasterReceiveCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
2400ea36:	68fb      	ldr	r3, [r7, #12]
2400ea38:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400ea3a:	68fa      	ldr	r2, [r7, #12]
2400ea3c:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2400ea3e:	441a      	add	r2, r3
2400ea40:	68fb      	ldr	r3, [r7, #12]
2400ea42:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400ea44:	68fb      	ldr	r3, [r7, #12]
2400ea46:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ea48:	b29b      	uxth	r3, r3
2400ea4a:	2bff      	cmp	r3, #255	; 0xff
2400ea4c:	d903      	bls.n	2400ea56 <I2C_DMAMasterReceiveCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400ea4e:	68fb      	ldr	r3, [r7, #12]
2400ea50:	22ff      	movs	r2, #255	; 0xff
2400ea52:	851a      	strh	r2, [r3, #40]	; 0x28
2400ea54:	e004      	b.n	2400ea60 <I2C_DMAMasterReceiveCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2400ea56:	68fb      	ldr	r3, [r7, #12]
2400ea58:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ea5a:	b29a      	uxth	r2, r3
2400ea5c:	68fb      	ldr	r3, [r7, #12]
2400ea5e:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr,
2400ea60:	68fb      	ldr	r3, [r7, #12]
2400ea62:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400ea64:	68fb      	ldr	r3, [r7, #12]
2400ea66:	681b      	ldr	r3, [r3, #0]
2400ea68:	3324      	adds	r3, #36	; 0x24
2400ea6a:	4619      	mov	r1, r3
2400ea6c:	68fb      	ldr	r3, [r7, #12]
2400ea6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400ea70:	461a      	mov	r2, r3
                         hi2c->XferSize) != HAL_OK)
2400ea72:	68fb      	ldr	r3, [r7, #12]
2400ea74:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr,
2400ea76:	f7f5 f86b 	bl	24003b50 <HAL_DMA_Start_IT>
2400ea7a:	4603      	mov	r3, r0
2400ea7c:	2b00      	cmp	r3, #0
2400ea7e:	d004      	beq.n	2400ea8a <I2C_DMAMasterReceiveCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400ea80:	2110      	movs	r1, #16
2400ea82:	68f8      	ldr	r0, [r7, #12]
2400ea84:	f7ff fe18 	bl	2400e6b8 <I2C_ITError>
}
2400ea88:	e003      	b.n	2400ea92 <I2C_DMAMasterReceiveCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2400ea8a:	2140      	movs	r1, #64	; 0x40
2400ea8c:	68f8      	ldr	r0, [r7, #12]
2400ea8e:	f000 fc7d 	bl	2400f38c <I2C_Enable_IRQ>
}
2400ea92:	bf00      	nop
2400ea94:	3710      	adds	r7, #16
2400ea96:	46bd      	mov	sp, r7
2400ea98:	bd80      	pop	{r7, pc}
	...

2400ea9c <I2C_DMASlaveReceiveCplt>:
  * @brief  DMA I2C slave receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
{
2400ea9c:	b580      	push	{r7, lr}
2400ea9e:	b084      	sub	sp, #16
2400eaa0:	af00      	add	r7, sp, #0
2400eaa2:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400eaa4:	687b      	ldr	r3, [r7, #4]
2400eaa6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400eaa8:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2400eaaa:	68fb      	ldr	r3, [r7, #12]
2400eaac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400eaae:	60bb      	str	r3, [r7, #8]

  if ((I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U) && \
2400eab0:	68fb      	ldr	r3, [r7, #12]
2400eab2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eab4:	681b      	ldr	r3, [r3, #0]
2400eab6:	4a42      	ldr	r2, [pc, #264]	; (2400ebc0 <I2C_DMASlaveReceiveCplt+0x124>)
2400eab8:	4293      	cmp	r3, r2
2400eaba:	d059      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eabc:	68fb      	ldr	r3, [r7, #12]
2400eabe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eac0:	681b      	ldr	r3, [r3, #0]
2400eac2:	4a40      	ldr	r2, [pc, #256]	; (2400ebc4 <I2C_DMASlaveReceiveCplt+0x128>)
2400eac4:	4293      	cmp	r3, r2
2400eac6:	d053      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eac8:	68fb      	ldr	r3, [r7, #12]
2400eaca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eacc:	681b      	ldr	r3, [r3, #0]
2400eace:	4a3e      	ldr	r2, [pc, #248]	; (2400ebc8 <I2C_DMASlaveReceiveCplt+0x12c>)
2400ead0:	4293      	cmp	r3, r2
2400ead2:	d04d      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400ead4:	68fb      	ldr	r3, [r7, #12]
2400ead6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ead8:	681b      	ldr	r3, [r3, #0]
2400eada:	4a3c      	ldr	r2, [pc, #240]	; (2400ebcc <I2C_DMASlaveReceiveCplt+0x130>)
2400eadc:	4293      	cmp	r3, r2
2400eade:	d047      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eae0:	68fb      	ldr	r3, [r7, #12]
2400eae2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eae4:	681b      	ldr	r3, [r3, #0]
2400eae6:	4a3a      	ldr	r2, [pc, #232]	; (2400ebd0 <I2C_DMASlaveReceiveCplt+0x134>)
2400eae8:	4293      	cmp	r3, r2
2400eaea:	d041      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eaec:	68fb      	ldr	r3, [r7, #12]
2400eaee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eaf0:	681b      	ldr	r3, [r3, #0]
2400eaf2:	4a38      	ldr	r2, [pc, #224]	; (2400ebd4 <I2C_DMASlaveReceiveCplt+0x138>)
2400eaf4:	4293      	cmp	r3, r2
2400eaf6:	d03b      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eaf8:	68fb      	ldr	r3, [r7, #12]
2400eafa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eafc:	681b      	ldr	r3, [r3, #0]
2400eafe:	4a36      	ldr	r2, [pc, #216]	; (2400ebd8 <I2C_DMASlaveReceiveCplt+0x13c>)
2400eb00:	4293      	cmp	r3, r2
2400eb02:	d035      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb04:	68fb      	ldr	r3, [r7, #12]
2400eb06:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb08:	681b      	ldr	r3, [r3, #0]
2400eb0a:	4a34      	ldr	r2, [pc, #208]	; (2400ebdc <I2C_DMASlaveReceiveCplt+0x140>)
2400eb0c:	4293      	cmp	r3, r2
2400eb0e:	d02f      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb10:	68fb      	ldr	r3, [r7, #12]
2400eb12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb14:	681b      	ldr	r3, [r3, #0]
2400eb16:	4a32      	ldr	r2, [pc, #200]	; (2400ebe0 <I2C_DMASlaveReceiveCplt+0x144>)
2400eb18:	4293      	cmp	r3, r2
2400eb1a:	d029      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb1c:	68fb      	ldr	r3, [r7, #12]
2400eb1e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb20:	681b      	ldr	r3, [r3, #0]
2400eb22:	4a30      	ldr	r2, [pc, #192]	; (2400ebe4 <I2C_DMASlaveReceiveCplt+0x148>)
2400eb24:	4293      	cmp	r3, r2
2400eb26:	d023      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb28:	68fb      	ldr	r3, [r7, #12]
2400eb2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb2c:	681b      	ldr	r3, [r3, #0]
2400eb2e:	4a2e      	ldr	r2, [pc, #184]	; (2400ebe8 <I2C_DMASlaveReceiveCplt+0x14c>)
2400eb30:	4293      	cmp	r3, r2
2400eb32:	d01d      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb34:	68fb      	ldr	r3, [r7, #12]
2400eb36:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb38:	681b      	ldr	r3, [r3, #0]
2400eb3a:	4a2c      	ldr	r2, [pc, #176]	; (2400ebec <I2C_DMASlaveReceiveCplt+0x150>)
2400eb3c:	4293      	cmp	r3, r2
2400eb3e:	d017      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb40:	68fb      	ldr	r3, [r7, #12]
2400eb42:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb44:	681b      	ldr	r3, [r3, #0]
2400eb46:	4a2a      	ldr	r2, [pc, #168]	; (2400ebf0 <I2C_DMASlaveReceiveCplt+0x154>)
2400eb48:	4293      	cmp	r3, r2
2400eb4a:	d011      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb4c:	68fb      	ldr	r3, [r7, #12]
2400eb4e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb50:	681b      	ldr	r3, [r3, #0]
2400eb52:	4a28      	ldr	r2, [pc, #160]	; (2400ebf4 <I2C_DMASlaveReceiveCplt+0x158>)
2400eb54:	4293      	cmp	r3, r2
2400eb56:	d00b      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb58:	68fb      	ldr	r3, [r7, #12]
2400eb5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb5c:	681b      	ldr	r3, [r3, #0]
2400eb5e:	4a26      	ldr	r2, [pc, #152]	; (2400ebf8 <I2C_DMASlaveReceiveCplt+0x15c>)
2400eb60:	4293      	cmp	r3, r2
2400eb62:	d005      	beq.n	2400eb70 <I2C_DMASlaveReceiveCplt+0xd4>
2400eb64:	68fb      	ldr	r3, [r7, #12]
2400eb66:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb68:	681b      	ldr	r3, [r3, #0]
2400eb6a:	4a24      	ldr	r2, [pc, #144]	; (2400ebfc <I2C_DMASlaveReceiveCplt+0x160>)
2400eb6c:	4293      	cmp	r3, r2
2400eb6e:	d109      	bne.n	2400eb84 <I2C_DMASlaveReceiveCplt+0xe8>
2400eb70:	68fb      	ldr	r3, [r7, #12]
2400eb72:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb74:	681b      	ldr	r3, [r3, #0]
2400eb76:	685b      	ldr	r3, [r3, #4]
2400eb78:	2b00      	cmp	r3, #0
2400eb7a:	bf0c      	ite	eq
2400eb7c:	2301      	moveq	r3, #1
2400eb7e:	2300      	movne	r3, #0
2400eb80:	b2db      	uxtb	r3, r3
2400eb82:	e008      	b.n	2400eb96 <I2C_DMASlaveReceiveCplt+0xfa>
2400eb84:	68fb      	ldr	r3, [r7, #12]
2400eb86:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb88:	681b      	ldr	r3, [r3, #0]
2400eb8a:	685b      	ldr	r3, [r3, #4]
2400eb8c:	2b00      	cmp	r3, #0
2400eb8e:	bf0c      	ite	eq
2400eb90:	2301      	moveq	r3, #1
2400eb92:	2300      	movne	r3, #0
2400eb94:	b2db      	uxtb	r3, r3
2400eb96:	2b00      	cmp	r3, #0
2400eb98:	d00e      	beq.n	2400ebb8 <I2C_DMASlaveReceiveCplt+0x11c>
2400eb9a:	68bb      	ldr	r3, [r7, #8]
2400eb9c:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400eba0:	d00a      	beq.n	2400ebb8 <I2C_DMASlaveReceiveCplt+0x11c>
      (tmpoptions != I2C_NO_OPTION_FRAME))
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400eba2:	68fb      	ldr	r3, [r7, #12]
2400eba4:	681b      	ldr	r3, [r3, #0]
2400eba6:	681a      	ldr	r2, [r3, #0]
2400eba8:	68fb      	ldr	r3, [r7, #12]
2400ebaa:	681b      	ldr	r3, [r3, #0]
2400ebac:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400ebb0:	601a      	str	r2, [r3, #0]

    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2400ebb2:	68f8      	ldr	r0, [r7, #12]
2400ebb4:	f7ff fa09 	bl	2400dfca <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2400ebb8:	bf00      	nop
2400ebba:	3710      	adds	r7, #16
2400ebbc:	46bd      	mov	sp, r7
2400ebbe:	bd80      	pop	{r7, pc}
2400ebc0:	40020010 	.word	0x40020010
2400ebc4:	40020028 	.word	0x40020028
2400ebc8:	40020040 	.word	0x40020040
2400ebcc:	40020058 	.word	0x40020058
2400ebd0:	40020070 	.word	0x40020070
2400ebd4:	40020088 	.word	0x40020088
2400ebd8:	400200a0 	.word	0x400200a0
2400ebdc:	400200b8 	.word	0x400200b8
2400ebe0:	40020410 	.word	0x40020410
2400ebe4:	40020428 	.word	0x40020428
2400ebe8:	40020440 	.word	0x40020440
2400ebec:	40020458 	.word	0x40020458
2400ebf0:	40020470 	.word	0x40020470
2400ebf4:	40020488 	.word	0x40020488
2400ebf8:	400204a0 	.word	0x400204a0
2400ebfc:	400204b8 	.word	0x400204b8

2400ec00 <I2C_DMAError>:
  * @brief  DMA I2C communication error callback.
  * @param hdma DMA handle
  * @retval None
  */
static void I2C_DMAError(DMA_HandleTypeDef *hdma)
{
2400ec00:	b580      	push	{r7, lr}
2400ec02:	b084      	sub	sp, #16
2400ec04:	af00      	add	r7, sp, #0
2400ec06:	6078      	str	r0, [r7, #4]
  uint32_t treatdmaerror = 0U;
2400ec08:	2300      	movs	r3, #0
2400ec0a:	60fb      	str	r3, [r7, #12]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400ec0c:	687b      	ldr	r3, [r7, #4]
2400ec0e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec10:	60bb      	str	r3, [r7, #8]

  if (hi2c->hdmatx != NULL)
2400ec12:	68bb      	ldr	r3, [r7, #8]
2400ec14:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec16:	2b00      	cmp	r3, #0
2400ec18:	d076      	beq.n	2400ed08 <I2C_DMAError+0x108>
  {
    if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)
2400ec1a:	68bb      	ldr	r3, [r7, #8]
2400ec1c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec1e:	681b      	ldr	r3, [r3, #0]
2400ec20:	4a71      	ldr	r2, [pc, #452]	; (2400ede8 <I2C_DMAError+0x1e8>)
2400ec22:	4293      	cmp	r3, r2
2400ec24:	d059      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec26:	68bb      	ldr	r3, [r7, #8]
2400ec28:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec2a:	681b      	ldr	r3, [r3, #0]
2400ec2c:	4a6f      	ldr	r2, [pc, #444]	; (2400edec <I2C_DMAError+0x1ec>)
2400ec2e:	4293      	cmp	r3, r2
2400ec30:	d053      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec32:	68bb      	ldr	r3, [r7, #8]
2400ec34:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec36:	681b      	ldr	r3, [r3, #0]
2400ec38:	4a6d      	ldr	r2, [pc, #436]	; (2400edf0 <I2C_DMAError+0x1f0>)
2400ec3a:	4293      	cmp	r3, r2
2400ec3c:	d04d      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec3e:	68bb      	ldr	r3, [r7, #8]
2400ec40:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec42:	681b      	ldr	r3, [r3, #0]
2400ec44:	4a6b      	ldr	r2, [pc, #428]	; (2400edf4 <I2C_DMAError+0x1f4>)
2400ec46:	4293      	cmp	r3, r2
2400ec48:	d047      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec4a:	68bb      	ldr	r3, [r7, #8]
2400ec4c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec4e:	681b      	ldr	r3, [r3, #0]
2400ec50:	4a69      	ldr	r2, [pc, #420]	; (2400edf8 <I2C_DMAError+0x1f8>)
2400ec52:	4293      	cmp	r3, r2
2400ec54:	d041      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec56:	68bb      	ldr	r3, [r7, #8]
2400ec58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec5a:	681b      	ldr	r3, [r3, #0]
2400ec5c:	4a67      	ldr	r2, [pc, #412]	; (2400edfc <I2C_DMAError+0x1fc>)
2400ec5e:	4293      	cmp	r3, r2
2400ec60:	d03b      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec62:	68bb      	ldr	r3, [r7, #8]
2400ec64:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec66:	681b      	ldr	r3, [r3, #0]
2400ec68:	4a65      	ldr	r2, [pc, #404]	; (2400ee00 <I2C_DMAError+0x200>)
2400ec6a:	4293      	cmp	r3, r2
2400ec6c:	d035      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec6e:	68bb      	ldr	r3, [r7, #8]
2400ec70:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec72:	681b      	ldr	r3, [r3, #0]
2400ec74:	4a63      	ldr	r2, [pc, #396]	; (2400ee04 <I2C_DMAError+0x204>)
2400ec76:	4293      	cmp	r3, r2
2400ec78:	d02f      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec7a:	68bb      	ldr	r3, [r7, #8]
2400ec7c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec7e:	681b      	ldr	r3, [r3, #0]
2400ec80:	4a61      	ldr	r2, [pc, #388]	; (2400ee08 <I2C_DMAError+0x208>)
2400ec82:	4293      	cmp	r3, r2
2400ec84:	d029      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec86:	68bb      	ldr	r3, [r7, #8]
2400ec88:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec8a:	681b      	ldr	r3, [r3, #0]
2400ec8c:	4a5f      	ldr	r2, [pc, #380]	; (2400ee0c <I2C_DMAError+0x20c>)
2400ec8e:	4293      	cmp	r3, r2
2400ec90:	d023      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec92:	68bb      	ldr	r3, [r7, #8]
2400ec94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ec96:	681b      	ldr	r3, [r3, #0]
2400ec98:	4a5d      	ldr	r2, [pc, #372]	; (2400ee10 <I2C_DMAError+0x210>)
2400ec9a:	4293      	cmp	r3, r2
2400ec9c:	d01d      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ec9e:	68bb      	ldr	r3, [r7, #8]
2400eca0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400eca2:	681b      	ldr	r3, [r3, #0]
2400eca4:	4a5b      	ldr	r2, [pc, #364]	; (2400ee14 <I2C_DMAError+0x214>)
2400eca6:	4293      	cmp	r3, r2
2400eca8:	d017      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ecaa:	68bb      	ldr	r3, [r7, #8]
2400ecac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ecae:	681b      	ldr	r3, [r3, #0]
2400ecb0:	4a59      	ldr	r2, [pc, #356]	; (2400ee18 <I2C_DMAError+0x218>)
2400ecb2:	4293      	cmp	r3, r2
2400ecb4:	d011      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ecb6:	68bb      	ldr	r3, [r7, #8]
2400ecb8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ecba:	681b      	ldr	r3, [r3, #0]
2400ecbc:	4a57      	ldr	r2, [pc, #348]	; (2400ee1c <I2C_DMAError+0x21c>)
2400ecbe:	4293      	cmp	r3, r2
2400ecc0:	d00b      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ecc2:	68bb      	ldr	r3, [r7, #8]
2400ecc4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ecc6:	681b      	ldr	r3, [r3, #0]
2400ecc8:	4a55      	ldr	r2, [pc, #340]	; (2400ee20 <I2C_DMAError+0x220>)
2400ecca:	4293      	cmp	r3, r2
2400eccc:	d005      	beq.n	2400ecda <I2C_DMAError+0xda>
2400ecce:	68bb      	ldr	r3, [r7, #8]
2400ecd0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ecd2:	681b      	ldr	r3, [r3, #0]
2400ecd4:	4a53      	ldr	r2, [pc, #332]	; (2400ee24 <I2C_DMAError+0x224>)
2400ecd6:	4293      	cmp	r3, r2
2400ecd8:	d109      	bne.n	2400ecee <I2C_DMAError+0xee>
2400ecda:	68bb      	ldr	r3, [r7, #8]
2400ecdc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ecde:	681b      	ldr	r3, [r3, #0]
2400ece0:	685b      	ldr	r3, [r3, #4]
2400ece2:	2b00      	cmp	r3, #0
2400ece4:	bf0c      	ite	eq
2400ece6:	2301      	moveq	r3, #1
2400ece8:	2300      	movne	r3, #0
2400ecea:	b2db      	uxtb	r3, r3
2400ecec:	e008      	b.n	2400ed00 <I2C_DMAError+0x100>
2400ecee:	68bb      	ldr	r3, [r7, #8]
2400ecf0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ecf2:	681b      	ldr	r3, [r3, #0]
2400ecf4:	685b      	ldr	r3, [r3, #4]
2400ecf6:	2b00      	cmp	r3, #0
2400ecf8:	bf0c      	ite	eq
2400ecfa:	2301      	moveq	r3, #1
2400ecfc:	2300      	movne	r3, #0
2400ecfe:	b2db      	uxtb	r3, r3
2400ed00:	2b00      	cmp	r3, #0
2400ed02:	d001      	beq.n	2400ed08 <I2C_DMAError+0x108>
    {
      treatdmaerror = 1U;
2400ed04:	2301      	movs	r3, #1
2400ed06:	60fb      	str	r3, [r7, #12]
    }
  }

  if (hi2c->hdmarx != NULL)
2400ed08:	68bb      	ldr	r3, [r7, #8]
2400ed0a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed0c:	2b00      	cmp	r3, #0
2400ed0e:	f000 8098 	beq.w	2400ee42 <I2C_DMAError+0x242>
  {
    if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)
2400ed12:	68bb      	ldr	r3, [r7, #8]
2400ed14:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed16:	681b      	ldr	r3, [r3, #0]
2400ed18:	4a33      	ldr	r2, [pc, #204]	; (2400ede8 <I2C_DMAError+0x1e8>)
2400ed1a:	4293      	cmp	r3, r2
2400ed1c:	d059      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed1e:	68bb      	ldr	r3, [r7, #8]
2400ed20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed22:	681b      	ldr	r3, [r3, #0]
2400ed24:	4a31      	ldr	r2, [pc, #196]	; (2400edec <I2C_DMAError+0x1ec>)
2400ed26:	4293      	cmp	r3, r2
2400ed28:	d053      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed2a:	68bb      	ldr	r3, [r7, #8]
2400ed2c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed2e:	681b      	ldr	r3, [r3, #0]
2400ed30:	4a2f      	ldr	r2, [pc, #188]	; (2400edf0 <I2C_DMAError+0x1f0>)
2400ed32:	4293      	cmp	r3, r2
2400ed34:	d04d      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed36:	68bb      	ldr	r3, [r7, #8]
2400ed38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed3a:	681b      	ldr	r3, [r3, #0]
2400ed3c:	4a2d      	ldr	r2, [pc, #180]	; (2400edf4 <I2C_DMAError+0x1f4>)
2400ed3e:	4293      	cmp	r3, r2
2400ed40:	d047      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed42:	68bb      	ldr	r3, [r7, #8]
2400ed44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed46:	681b      	ldr	r3, [r3, #0]
2400ed48:	4a2b      	ldr	r2, [pc, #172]	; (2400edf8 <I2C_DMAError+0x1f8>)
2400ed4a:	4293      	cmp	r3, r2
2400ed4c:	d041      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed4e:	68bb      	ldr	r3, [r7, #8]
2400ed50:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed52:	681b      	ldr	r3, [r3, #0]
2400ed54:	4a29      	ldr	r2, [pc, #164]	; (2400edfc <I2C_DMAError+0x1fc>)
2400ed56:	4293      	cmp	r3, r2
2400ed58:	d03b      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed5a:	68bb      	ldr	r3, [r7, #8]
2400ed5c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed5e:	681b      	ldr	r3, [r3, #0]
2400ed60:	4a27      	ldr	r2, [pc, #156]	; (2400ee00 <I2C_DMAError+0x200>)
2400ed62:	4293      	cmp	r3, r2
2400ed64:	d035      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed66:	68bb      	ldr	r3, [r7, #8]
2400ed68:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed6a:	681b      	ldr	r3, [r3, #0]
2400ed6c:	4a25      	ldr	r2, [pc, #148]	; (2400ee04 <I2C_DMAError+0x204>)
2400ed6e:	4293      	cmp	r3, r2
2400ed70:	d02f      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed72:	68bb      	ldr	r3, [r7, #8]
2400ed74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed76:	681b      	ldr	r3, [r3, #0]
2400ed78:	4a23      	ldr	r2, [pc, #140]	; (2400ee08 <I2C_DMAError+0x208>)
2400ed7a:	4293      	cmp	r3, r2
2400ed7c:	d029      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed7e:	68bb      	ldr	r3, [r7, #8]
2400ed80:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed82:	681b      	ldr	r3, [r3, #0]
2400ed84:	4a21      	ldr	r2, [pc, #132]	; (2400ee0c <I2C_DMAError+0x20c>)
2400ed86:	4293      	cmp	r3, r2
2400ed88:	d023      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed8a:	68bb      	ldr	r3, [r7, #8]
2400ed8c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed8e:	681b      	ldr	r3, [r3, #0]
2400ed90:	4a1f      	ldr	r2, [pc, #124]	; (2400ee10 <I2C_DMAError+0x210>)
2400ed92:	4293      	cmp	r3, r2
2400ed94:	d01d      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400ed96:	68bb      	ldr	r3, [r7, #8]
2400ed98:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ed9a:	681b      	ldr	r3, [r3, #0]
2400ed9c:	4a1d      	ldr	r2, [pc, #116]	; (2400ee14 <I2C_DMAError+0x214>)
2400ed9e:	4293      	cmp	r3, r2
2400eda0:	d017      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400eda2:	68bb      	ldr	r3, [r7, #8]
2400eda4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eda6:	681b      	ldr	r3, [r3, #0]
2400eda8:	4a1b      	ldr	r2, [pc, #108]	; (2400ee18 <I2C_DMAError+0x218>)
2400edaa:	4293      	cmp	r3, r2
2400edac:	d011      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400edae:	68bb      	ldr	r3, [r7, #8]
2400edb0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400edb2:	681b      	ldr	r3, [r3, #0]
2400edb4:	4a19      	ldr	r2, [pc, #100]	; (2400ee1c <I2C_DMAError+0x21c>)
2400edb6:	4293      	cmp	r3, r2
2400edb8:	d00b      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400edba:	68bb      	ldr	r3, [r7, #8]
2400edbc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400edbe:	681b      	ldr	r3, [r3, #0]
2400edc0:	4a17      	ldr	r2, [pc, #92]	; (2400ee20 <I2C_DMAError+0x220>)
2400edc2:	4293      	cmp	r3, r2
2400edc4:	d005      	beq.n	2400edd2 <I2C_DMAError+0x1d2>
2400edc6:	68bb      	ldr	r3, [r7, #8]
2400edc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400edca:	681b      	ldr	r3, [r3, #0]
2400edcc:	4a15      	ldr	r2, [pc, #84]	; (2400ee24 <I2C_DMAError+0x224>)
2400edce:	4293      	cmp	r3, r2
2400edd0:	d12a      	bne.n	2400ee28 <I2C_DMAError+0x228>
2400edd2:	68bb      	ldr	r3, [r7, #8]
2400edd4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400edd6:	681b      	ldr	r3, [r3, #0]
2400edd8:	685b      	ldr	r3, [r3, #4]
2400edda:	2b00      	cmp	r3, #0
2400eddc:	bf0c      	ite	eq
2400edde:	2301      	moveq	r3, #1
2400ede0:	2300      	movne	r3, #0
2400ede2:	b2db      	uxtb	r3, r3
2400ede4:	e029      	b.n	2400ee3a <I2C_DMAError+0x23a>
2400ede6:	bf00      	nop
2400ede8:	40020010 	.word	0x40020010
2400edec:	40020028 	.word	0x40020028
2400edf0:	40020040 	.word	0x40020040
2400edf4:	40020058 	.word	0x40020058
2400edf8:	40020070 	.word	0x40020070
2400edfc:	40020088 	.word	0x40020088
2400ee00:	400200a0 	.word	0x400200a0
2400ee04:	400200b8 	.word	0x400200b8
2400ee08:	40020410 	.word	0x40020410
2400ee0c:	40020428 	.word	0x40020428
2400ee10:	40020440 	.word	0x40020440
2400ee14:	40020458 	.word	0x40020458
2400ee18:	40020470 	.word	0x40020470
2400ee1c:	40020488 	.word	0x40020488
2400ee20:	400204a0 	.word	0x400204a0
2400ee24:	400204b8 	.word	0x400204b8
2400ee28:	68bb      	ldr	r3, [r7, #8]
2400ee2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ee2c:	681b      	ldr	r3, [r3, #0]
2400ee2e:	685b      	ldr	r3, [r3, #4]
2400ee30:	2b00      	cmp	r3, #0
2400ee32:	bf0c      	ite	eq
2400ee34:	2301      	moveq	r3, #1
2400ee36:	2300      	movne	r3, #0
2400ee38:	b2db      	uxtb	r3, r3
2400ee3a:	2b00      	cmp	r3, #0
2400ee3c:	d001      	beq.n	2400ee42 <I2C_DMAError+0x242>
    {
      treatdmaerror = 1U;
2400ee3e:	2301      	movs	r3, #1
2400ee40:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
2400ee42:	6878      	ldr	r0, [r7, #4]
2400ee44:	f7f7 f9fc 	bl	24006240 <HAL_DMA_GetError>
2400ee48:	4603      	mov	r3, r0
2400ee4a:	2b02      	cmp	r3, #2
2400ee4c:	d00e      	beq.n	2400ee6c <I2C_DMAError+0x26c>
2400ee4e:	68fb      	ldr	r3, [r7, #12]
2400ee50:	2b00      	cmp	r3, #0
2400ee52:	d00b      	beq.n	2400ee6c <I2C_DMAError+0x26c>
  {
    /* Disable Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400ee54:	68bb      	ldr	r3, [r7, #8]
2400ee56:	681b      	ldr	r3, [r3, #0]
2400ee58:	685a      	ldr	r2, [r3, #4]
2400ee5a:	68bb      	ldr	r3, [r7, #8]
2400ee5c:	681b      	ldr	r3, [r3, #0]
2400ee5e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400ee62:	605a      	str	r2, [r3, #4]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400ee64:	2110      	movs	r1, #16
2400ee66:	68b8      	ldr	r0, [r7, #8]
2400ee68:	f7ff fc26 	bl	2400e6b8 <I2C_ITError>
  }
}
2400ee6c:	bf00      	nop
2400ee6e:	3710      	adds	r7, #16
2400ee70:	46bd      	mov	sp, r7
2400ee72:	bd80      	pop	{r7, pc}

2400ee74 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
2400ee74:	b580      	push	{r7, lr}
2400ee76:	b084      	sub	sp, #16
2400ee78:	af00      	add	r7, sp, #0
2400ee7a:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400ee7c:	687b      	ldr	r3, [r7, #4]
2400ee7e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ee80:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
2400ee82:	68fb      	ldr	r3, [r7, #12]
2400ee84:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ee86:	2b00      	cmp	r3, #0
2400ee88:	d003      	beq.n	2400ee92 <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
2400ee8a:	68fb      	ldr	r3, [r7, #12]
2400ee8c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ee8e:	2200      	movs	r2, #0
2400ee90:	651a      	str	r2, [r3, #80]	; 0x50
  }
  if (hi2c->hdmarx != NULL)
2400ee92:	68fb      	ldr	r3, [r7, #12]
2400ee94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ee96:	2b00      	cmp	r3, #0
2400ee98:	d003      	beq.n	2400eea2 <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
2400ee9a:	68fb      	ldr	r3, [r7, #12]
2400ee9c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ee9e:	2200      	movs	r2, #0
2400eea0:	651a      	str	r2, [r3, #80]	; 0x50
  }

  I2C_TreatErrorCallback(hi2c);
2400eea2:	68f8      	ldr	r0, [r7, #12]
2400eea4:	f7ff fcf8 	bl	2400e898 <I2C_TreatErrorCallback>
}
2400eea8:	bf00      	nop
2400eeaa:	3710      	adds	r7, #16
2400eeac:	46bd      	mov	sp, r7
2400eeae:	bd80      	pop	{r7, pc}

2400eeb0 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
2400eeb0:	b580      	push	{r7, lr}
2400eeb2:	b084      	sub	sp, #16
2400eeb4:	af00      	add	r7, sp, #0
2400eeb6:	60f8      	str	r0, [r7, #12]
2400eeb8:	60b9      	str	r1, [r7, #8]
2400eeba:	603b      	str	r3, [r7, #0]
2400eebc:	4613      	mov	r3, r2
2400eebe:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400eec0:	e031      	b.n	2400ef26 <I2C_WaitOnFlagUntilTimeout+0x76>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2400eec2:	683b      	ldr	r3, [r7, #0]
2400eec4:	f1b3 3fff 	cmp.w	r3, #4294967295
2400eec8:	d02d      	beq.n	2400ef26 <I2C_WaitOnFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400eeca:	f7f3 f8a7 	bl	2400201c <HAL_GetTick>
2400eece:	4602      	mov	r2, r0
2400eed0:	69bb      	ldr	r3, [r7, #24]
2400eed2:	1ad3      	subs	r3, r2, r3
2400eed4:	683a      	ldr	r2, [r7, #0]
2400eed6:	429a      	cmp	r2, r3
2400eed8:	d302      	bcc.n	2400eee0 <I2C_WaitOnFlagUntilTimeout+0x30>
2400eeda:	683b      	ldr	r3, [r7, #0]
2400eedc:	2b00      	cmp	r3, #0
2400eede:	d122      	bne.n	2400ef26 <I2C_WaitOnFlagUntilTimeout+0x76>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
2400eee0:	68fb      	ldr	r3, [r7, #12]
2400eee2:	681b      	ldr	r3, [r3, #0]
2400eee4:	699a      	ldr	r2, [r3, #24]
2400eee6:	68bb      	ldr	r3, [r7, #8]
2400eee8:	4013      	ands	r3, r2
2400eeea:	68ba      	ldr	r2, [r7, #8]
2400eeec:	429a      	cmp	r2, r3
2400eeee:	bf0c      	ite	eq
2400eef0:	2301      	moveq	r3, #1
2400eef2:	2300      	movne	r3, #0
2400eef4:	b2db      	uxtb	r3, r3
2400eef6:	461a      	mov	r2, r3
2400eef8:	79fb      	ldrb	r3, [r7, #7]
2400eefa:	429a      	cmp	r2, r3
2400eefc:	d113      	bne.n	2400ef26 <I2C_WaitOnFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400eefe:	68fb      	ldr	r3, [r7, #12]
2400ef00:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ef02:	f043 0220 	orr.w	r2, r3, #32
2400ef06:	68fb      	ldr	r3, [r7, #12]
2400ef08:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
2400ef0a:	68fb      	ldr	r3, [r7, #12]
2400ef0c:	2220      	movs	r2, #32
2400ef0e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
2400ef12:	68fb      	ldr	r3, [r7, #12]
2400ef14:	2200      	movs	r2, #0
2400ef16:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2400ef1a:	68fb      	ldr	r3, [r7, #12]
2400ef1c:	2200      	movs	r2, #0
2400ef1e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
          return HAL_ERROR;
2400ef22:	2301      	movs	r3, #1
2400ef24:	e00f      	b.n	2400ef46 <I2C_WaitOnFlagUntilTimeout+0x96>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400ef26:	68fb      	ldr	r3, [r7, #12]
2400ef28:	681b      	ldr	r3, [r3, #0]
2400ef2a:	699a      	ldr	r2, [r3, #24]
2400ef2c:	68bb      	ldr	r3, [r7, #8]
2400ef2e:	4013      	ands	r3, r2
2400ef30:	68ba      	ldr	r2, [r7, #8]
2400ef32:	429a      	cmp	r2, r3
2400ef34:	bf0c      	ite	eq
2400ef36:	2301      	moveq	r3, #1
2400ef38:	2300      	movne	r3, #0
2400ef3a:	b2db      	uxtb	r3, r3
2400ef3c:	461a      	mov	r2, r3
2400ef3e:	79fb      	ldrb	r3, [r7, #7]
2400ef40:	429a      	cmp	r2, r3
2400ef42:	d0be      	beq.n	2400eec2 <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
2400ef44:	2300      	movs	r3, #0
}
2400ef46:	4618      	mov	r0, r3
2400ef48:	3710      	adds	r7, #16
2400ef4a:	46bd      	mov	sp, r7
2400ef4c:	bd80      	pop	{r7, pc}

2400ef4e <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
2400ef4e:	b580      	push	{r7, lr}
2400ef50:	b084      	sub	sp, #16
2400ef52:	af00      	add	r7, sp, #0
2400ef54:	60f8      	str	r0, [r7, #12]
2400ef56:	60b9      	str	r1, [r7, #8]
2400ef58:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400ef5a:	e033      	b.n	2400efc4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2400ef5c:	687a      	ldr	r2, [r7, #4]
2400ef5e:	68b9      	ldr	r1, [r7, #8]
2400ef60:	68f8      	ldr	r0, [r7, #12]
2400ef62:	f000 f901 	bl	2400f168 <I2C_IsErrorOccurred>
2400ef66:	4603      	mov	r3, r0
2400ef68:	2b00      	cmp	r3, #0
2400ef6a:	d001      	beq.n	2400ef70 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400ef6c:	2301      	movs	r3, #1
2400ef6e:	e031      	b.n	2400efd4 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2400ef70:	68bb      	ldr	r3, [r7, #8]
2400ef72:	f1b3 3fff 	cmp.w	r3, #4294967295
2400ef76:	d025      	beq.n	2400efc4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400ef78:	f7f3 f850 	bl	2400201c <HAL_GetTick>
2400ef7c:	4602      	mov	r2, r0
2400ef7e:	687b      	ldr	r3, [r7, #4]
2400ef80:	1ad3      	subs	r3, r2, r3
2400ef82:	68ba      	ldr	r2, [r7, #8]
2400ef84:	429a      	cmp	r2, r3
2400ef86:	d302      	bcc.n	2400ef8e <I2C_WaitOnTXISFlagUntilTimeout+0x40>
2400ef88:	68bb      	ldr	r3, [r7, #8]
2400ef8a:	2b00      	cmp	r3, #0
2400ef8c:	d11a      	bne.n	2400efc4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET))
2400ef8e:	68fb      	ldr	r3, [r7, #12]
2400ef90:	681b      	ldr	r3, [r3, #0]
2400ef92:	699b      	ldr	r3, [r3, #24]
2400ef94:	f003 0302 	and.w	r3, r3, #2
2400ef98:	2b02      	cmp	r3, #2
2400ef9a:	d013      	beq.n	2400efc4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400ef9c:	68fb      	ldr	r3, [r7, #12]
2400ef9e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400efa0:	f043 0220 	orr.w	r2, r3, #32
2400efa4:	68fb      	ldr	r3, [r7, #12]
2400efa6:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
2400efa8:	68fb      	ldr	r3, [r7, #12]
2400efaa:	2220      	movs	r2, #32
2400efac:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
2400efb0:	68fb      	ldr	r3, [r7, #12]
2400efb2:	2200      	movs	r2, #0
2400efb4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2400efb8:	68fb      	ldr	r3, [r7, #12]
2400efba:	2200      	movs	r2, #0
2400efbc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          return HAL_ERROR;
2400efc0:	2301      	movs	r3, #1
2400efc2:	e007      	b.n	2400efd4 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400efc4:	68fb      	ldr	r3, [r7, #12]
2400efc6:	681b      	ldr	r3, [r3, #0]
2400efc8:	699b      	ldr	r3, [r3, #24]
2400efca:	f003 0302 	and.w	r3, r3, #2
2400efce:	2b02      	cmp	r3, #2
2400efd0:	d1c4      	bne.n	2400ef5c <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
2400efd2:	2300      	movs	r3, #0
}
2400efd4:	4618      	mov	r0, r3
2400efd6:	3710      	adds	r7, #16
2400efd8:	46bd      	mov	sp, r7
2400efda:	bd80      	pop	{r7, pc}

2400efdc <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
2400efdc:	b580      	push	{r7, lr}
2400efde:	b084      	sub	sp, #16
2400efe0:	af00      	add	r7, sp, #0
2400efe2:	60f8      	str	r0, [r7, #12]
2400efe4:	60b9      	str	r1, [r7, #8]
2400efe6:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400efe8:	e02f      	b.n	2400f04a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2400efea:	687a      	ldr	r2, [r7, #4]
2400efec:	68b9      	ldr	r1, [r7, #8]
2400efee:	68f8      	ldr	r0, [r7, #12]
2400eff0:	f000 f8ba 	bl	2400f168 <I2C_IsErrorOccurred>
2400eff4:	4603      	mov	r3, r0
2400eff6:	2b00      	cmp	r3, #0
2400eff8:	d001      	beq.n	2400effe <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400effa:	2301      	movs	r3, #1
2400effc:	e02d      	b.n	2400f05a <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400effe:	f7f3 f80d 	bl	2400201c <HAL_GetTick>
2400f002:	4602      	mov	r2, r0
2400f004:	687b      	ldr	r3, [r7, #4]
2400f006:	1ad3      	subs	r3, r2, r3
2400f008:	68ba      	ldr	r2, [r7, #8]
2400f00a:	429a      	cmp	r2, r3
2400f00c:	d302      	bcc.n	2400f014 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
2400f00e:	68bb      	ldr	r3, [r7, #8]
2400f010:	2b00      	cmp	r3, #0
2400f012:	d11a      	bne.n	2400f04a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET))
2400f014:	68fb      	ldr	r3, [r7, #12]
2400f016:	681b      	ldr	r3, [r3, #0]
2400f018:	699b      	ldr	r3, [r3, #24]
2400f01a:	f003 0320 	and.w	r3, r3, #32
2400f01e:	2b20      	cmp	r3, #32
2400f020:	d013      	beq.n	2400f04a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400f022:	68fb      	ldr	r3, [r7, #12]
2400f024:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400f026:	f043 0220 	orr.w	r2, r3, #32
2400f02a:	68fb      	ldr	r3, [r7, #12]
2400f02c:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400f02e:	68fb      	ldr	r3, [r7, #12]
2400f030:	2220      	movs	r2, #32
2400f032:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400f036:	68fb      	ldr	r3, [r7, #12]
2400f038:	2200      	movs	r2, #0
2400f03a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400f03e:	68fb      	ldr	r3, [r7, #12]
2400f040:	2200      	movs	r2, #0
2400f042:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400f046:	2301      	movs	r3, #1
2400f048:	e007      	b.n	2400f05a <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400f04a:	68fb      	ldr	r3, [r7, #12]
2400f04c:	681b      	ldr	r3, [r3, #0]
2400f04e:	699b      	ldr	r3, [r3, #24]
2400f050:	f003 0320 	and.w	r3, r3, #32
2400f054:	2b20      	cmp	r3, #32
2400f056:	d1c8      	bne.n	2400efea <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
2400f058:	2300      	movs	r3, #0
}
2400f05a:	4618      	mov	r0, r3
2400f05c:	3710      	adds	r7, #16
2400f05e:	46bd      	mov	sp, r7
2400f060:	bd80      	pop	{r7, pc}
	...

2400f064 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
2400f064:	b580      	push	{r7, lr}
2400f066:	b084      	sub	sp, #16
2400f068:	af00      	add	r7, sp, #0
2400f06a:	60f8      	str	r0, [r7, #12]
2400f06c:	60b9      	str	r1, [r7, #8]
2400f06e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2400f070:	e06b      	b.n	2400f14a <I2C_WaitOnRXNEFlagUntilTimeout+0xe6>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2400f072:	687a      	ldr	r2, [r7, #4]
2400f074:	68b9      	ldr	r1, [r7, #8]
2400f076:	68f8      	ldr	r0, [r7, #12]
2400f078:	f000 f876 	bl	2400f168 <I2C_IsErrorOccurred>
2400f07c:	4603      	mov	r3, r0
2400f07e:	2b00      	cmp	r3, #0
2400f080:	d001      	beq.n	2400f086 <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400f082:	2301      	movs	r3, #1
2400f084:	e069      	b.n	2400f15a <I2C_WaitOnRXNEFlagUntilTimeout+0xf6>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
2400f086:	68fb      	ldr	r3, [r7, #12]
2400f088:	681b      	ldr	r3, [r3, #0]
2400f08a:	699b      	ldr	r3, [r3, #24]
2400f08c:	f003 0320 	and.w	r3, r3, #32
2400f090:	2b20      	cmp	r3, #32
2400f092:	d138      	bne.n	2400f106 <I2C_WaitOnRXNEFlagUntilTimeout+0xa2>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
2400f094:	68fb      	ldr	r3, [r7, #12]
2400f096:	681b      	ldr	r3, [r3, #0]
2400f098:	699b      	ldr	r3, [r3, #24]
2400f09a:	f003 0304 	and.w	r3, r3, #4
2400f09e:	2b04      	cmp	r3, #4
2400f0a0:	d105      	bne.n	2400f0ae <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
2400f0a2:	68fb      	ldr	r3, [r7, #12]
2400f0a4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400f0a6:	2b00      	cmp	r3, #0
2400f0a8:	d001      	beq.n	2400f0ae <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
2400f0aa:	2300      	movs	r3, #0
2400f0ac:	e055      	b.n	2400f15a <I2C_WaitOnRXNEFlagUntilTimeout+0xf6>
      }
      else
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
2400f0ae:	68fb      	ldr	r3, [r7, #12]
2400f0b0:	681b      	ldr	r3, [r3, #0]
2400f0b2:	699b      	ldr	r3, [r3, #24]
2400f0b4:	f003 0310 	and.w	r3, r3, #16
2400f0b8:	2b10      	cmp	r3, #16
2400f0ba:	d107      	bne.n	2400f0cc <I2C_WaitOnRXNEFlagUntilTimeout+0x68>
        {
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400f0bc:	68fb      	ldr	r3, [r7, #12]
2400f0be:	681b      	ldr	r3, [r3, #0]
2400f0c0:	2210      	movs	r2, #16
2400f0c2:	61da      	str	r2, [r3, #28]
          hi2c->ErrorCode = HAL_I2C_ERROR_AF;
2400f0c4:	68fb      	ldr	r3, [r7, #12]
2400f0c6:	2204      	movs	r2, #4
2400f0c8:	645a      	str	r2, [r3, #68]	; 0x44
2400f0ca:	e002      	b.n	2400f0d2 <I2C_WaitOnRXNEFlagUntilTimeout+0x6e>
        }
        else
        {
          hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400f0cc:	68fb      	ldr	r3, [r7, #12]
2400f0ce:	2200      	movs	r2, #0
2400f0d0:	645a      	str	r2, [r3, #68]	; 0x44
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400f0d2:	68fb      	ldr	r3, [r7, #12]
2400f0d4:	681b      	ldr	r3, [r3, #0]
2400f0d6:	2220      	movs	r2, #32
2400f0d8:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
2400f0da:	68fb      	ldr	r3, [r7, #12]
2400f0dc:	681b      	ldr	r3, [r3, #0]
2400f0de:	6859      	ldr	r1, [r3, #4]
2400f0e0:	68fb      	ldr	r3, [r7, #12]
2400f0e2:	681a      	ldr	r2, [r3, #0]
2400f0e4:	4b1f      	ldr	r3, [pc, #124]	; (2400f164 <I2C_WaitOnRXNEFlagUntilTimeout+0x100>)
2400f0e6:	400b      	ands	r3, r1
2400f0e8:	6053      	str	r3, [r2, #4]

        hi2c->State = HAL_I2C_STATE_READY;
2400f0ea:	68fb      	ldr	r3, [r7, #12]
2400f0ec:	2220      	movs	r2, #32
2400f0ee:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400f0f2:	68fb      	ldr	r3, [r7, #12]
2400f0f4:	2200      	movs	r2, #0
2400f0f6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400f0fa:	68fb      	ldr	r3, [r7, #12]
2400f0fc:	2200      	movs	r2, #0
2400f0fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400f102:	2301      	movs	r3, #1
2400f104:	e029      	b.n	2400f15a <I2C_WaitOnRXNEFlagUntilTimeout+0xf6>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400f106:	f7f2 ff89 	bl	2400201c <HAL_GetTick>
2400f10a:	4602      	mov	r2, r0
2400f10c:	687b      	ldr	r3, [r7, #4]
2400f10e:	1ad3      	subs	r3, r2, r3
2400f110:	68ba      	ldr	r2, [r7, #8]
2400f112:	429a      	cmp	r2, r3
2400f114:	d302      	bcc.n	2400f11c <I2C_WaitOnRXNEFlagUntilTimeout+0xb8>
2400f116:	68bb      	ldr	r3, [r7, #8]
2400f118:	2b00      	cmp	r3, #0
2400f11a:	d116      	bne.n	2400f14a <I2C_WaitOnRXNEFlagUntilTimeout+0xe6>
    {
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET))
2400f11c:	68fb      	ldr	r3, [r7, #12]
2400f11e:	681b      	ldr	r3, [r3, #0]
2400f120:	699b      	ldr	r3, [r3, #24]
2400f122:	f003 0304 	and.w	r3, r3, #4
2400f126:	2b04      	cmp	r3, #4
2400f128:	d00f      	beq.n	2400f14a <I2C_WaitOnRXNEFlagUntilTimeout+0xe6>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400f12a:	68fb      	ldr	r3, [r7, #12]
2400f12c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400f12e:	f043 0220 	orr.w	r2, r3, #32
2400f132:	68fb      	ldr	r3, [r7, #12]
2400f134:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400f136:	68fb      	ldr	r3, [r7, #12]
2400f138:	2220      	movs	r2, #32
2400f13a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400f13e:	68fb      	ldr	r3, [r7, #12]
2400f140:	2200      	movs	r2, #0
2400f142:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400f146:	2301      	movs	r3, #1
2400f148:	e007      	b.n	2400f15a <I2C_WaitOnRXNEFlagUntilTimeout+0xf6>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2400f14a:	68fb      	ldr	r3, [r7, #12]
2400f14c:	681b      	ldr	r3, [r3, #0]
2400f14e:	699b      	ldr	r3, [r3, #24]
2400f150:	f003 0304 	and.w	r3, r3, #4
2400f154:	2b04      	cmp	r3, #4
2400f156:	d18c      	bne.n	2400f072 <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
2400f158:	2300      	movs	r3, #0
}
2400f15a:	4618      	mov	r0, r3
2400f15c:	3710      	adds	r7, #16
2400f15e:	46bd      	mov	sp, r7
2400f160:	bd80      	pop	{r7, pc}
2400f162:	bf00      	nop
2400f164:	fe00e800 	.word	0xfe00e800

2400f168 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400f168:	b580      	push	{r7, lr}
2400f16a:	b08a      	sub	sp, #40	; 0x28
2400f16c:	af00      	add	r7, sp, #0
2400f16e:	60f8      	str	r0, [r7, #12]
2400f170:	60b9      	str	r1, [r7, #8]
2400f172:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2400f174:	2300      	movs	r3, #0
2400f176:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
2400f17a:	68fb      	ldr	r3, [r7, #12]
2400f17c:	681b      	ldr	r3, [r3, #0]
2400f17e:	699b      	ldr	r3, [r3, #24]
2400f180:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
2400f182:	2300      	movs	r3, #0
2400f184:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
2400f186:	687b      	ldr	r3, [r7, #4]
2400f188:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
2400f18a:	69bb      	ldr	r3, [r7, #24]
2400f18c:	f003 0310 	and.w	r3, r3, #16
2400f190:	2b00      	cmp	r3, #0
2400f192:	d068      	beq.n	2400f266 <I2C_IsErrorOccurred+0xfe>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400f194:	68fb      	ldr	r3, [r7, #12]
2400f196:	681b      	ldr	r3, [r3, #0]
2400f198:	2210      	movs	r2, #16
2400f19a:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
2400f19c:	e049      	b.n	2400f232 <I2C_IsErrorOccurred+0xca>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
2400f19e:	68bb      	ldr	r3, [r7, #8]
2400f1a0:	f1b3 3fff 	cmp.w	r3, #4294967295
2400f1a4:	d045      	beq.n	2400f232 <I2C_IsErrorOccurred+0xca>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400f1a6:	f7f2 ff39 	bl	2400201c <HAL_GetTick>
2400f1aa:	4602      	mov	r2, r0
2400f1ac:	69fb      	ldr	r3, [r7, #28]
2400f1ae:	1ad3      	subs	r3, r2, r3
2400f1b0:	68ba      	ldr	r2, [r7, #8]
2400f1b2:	429a      	cmp	r2, r3
2400f1b4:	d302      	bcc.n	2400f1bc <I2C_IsErrorOccurred+0x54>
2400f1b6:	68bb      	ldr	r3, [r7, #8]
2400f1b8:	2b00      	cmp	r3, #0
2400f1ba:	d13a      	bne.n	2400f232 <I2C_IsErrorOccurred+0xca>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
2400f1bc:	68fb      	ldr	r3, [r7, #12]
2400f1be:	681b      	ldr	r3, [r3, #0]
2400f1c0:	685b      	ldr	r3, [r3, #4]
2400f1c2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400f1c6:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
2400f1c8:	68fb      	ldr	r3, [r7, #12]
2400f1ca:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400f1ce:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
2400f1d0:	68fb      	ldr	r3, [r7, #12]
2400f1d2:	681b      	ldr	r3, [r3, #0]
2400f1d4:	699b      	ldr	r3, [r3, #24]
2400f1d6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400f1da:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400f1de:	d121      	bne.n	2400f224 <I2C_IsErrorOccurred+0xbc>
2400f1e0:	697b      	ldr	r3, [r7, #20]
2400f1e2:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400f1e6:	d01d      	beq.n	2400f224 <I2C_IsErrorOccurred+0xbc>
              (tmp1 != I2C_CR2_STOP) && \
2400f1e8:	7cfb      	ldrb	r3, [r7, #19]
2400f1ea:	2b20      	cmp	r3, #32
2400f1ec:	d01a      	beq.n	2400f224 <I2C_IsErrorOccurred+0xbc>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400f1ee:	68fb      	ldr	r3, [r7, #12]
2400f1f0:	681b      	ldr	r3, [r3, #0]
2400f1f2:	685a      	ldr	r2, [r3, #4]
2400f1f4:	68fb      	ldr	r3, [r7, #12]
2400f1f6:	681b      	ldr	r3, [r3, #0]
2400f1f8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400f1fc:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
2400f1fe:	f7f2 ff0d 	bl	2400201c <HAL_GetTick>
2400f202:	61f8      	str	r0, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400f204:	e00e      	b.n	2400f224 <I2C_IsErrorOccurred+0xbc>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
2400f206:	f7f2 ff09 	bl	2400201c <HAL_GetTick>
2400f20a:	4602      	mov	r2, r0
2400f20c:	69fb      	ldr	r3, [r7, #28]
2400f20e:	1ad3      	subs	r3, r2, r3
2400f210:	2b19      	cmp	r3, #25
2400f212:	d907      	bls.n	2400f224 <I2C_IsErrorOccurred+0xbc>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
2400f214:	6a3b      	ldr	r3, [r7, #32]
2400f216:	f043 0320 	orr.w	r3, r3, #32
2400f21a:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
2400f21c:	2301      	movs	r3, #1
2400f21e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

              break;
2400f222:	e006      	b.n	2400f232 <I2C_IsErrorOccurred+0xca>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400f224:	68fb      	ldr	r3, [r7, #12]
2400f226:	681b      	ldr	r3, [r3, #0]
2400f228:	699b      	ldr	r3, [r3, #24]
2400f22a:	f003 0320 	and.w	r3, r3, #32
2400f22e:	2b20      	cmp	r3, #32
2400f230:	d1e9      	bne.n	2400f206 <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
2400f232:	68fb      	ldr	r3, [r7, #12]
2400f234:	681b      	ldr	r3, [r3, #0]
2400f236:	699b      	ldr	r3, [r3, #24]
2400f238:	f003 0320 	and.w	r3, r3, #32
2400f23c:	2b20      	cmp	r3, #32
2400f23e:	d003      	beq.n	2400f248 <I2C_IsErrorOccurred+0xe0>
2400f240:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
2400f244:	2b00      	cmp	r3, #0
2400f246:	d0aa      	beq.n	2400f19e <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
2400f248:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
2400f24c:	2b00      	cmp	r3, #0
2400f24e:	d103      	bne.n	2400f258 <I2C_IsErrorOccurred+0xf0>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400f250:	68fb      	ldr	r3, [r7, #12]
2400f252:	681b      	ldr	r3, [r3, #0]
2400f254:	2220      	movs	r2, #32
2400f256:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
2400f258:	6a3b      	ldr	r3, [r7, #32]
2400f25a:	f043 0304 	orr.w	r3, r3, #4
2400f25e:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
2400f260:	2301      	movs	r3, #1
2400f262:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
2400f266:	68fb      	ldr	r3, [r7, #12]
2400f268:	681b      	ldr	r3, [r3, #0]
2400f26a:	699b      	ldr	r3, [r3, #24]
2400f26c:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
2400f26e:	69bb      	ldr	r3, [r7, #24]
2400f270:	f403 7380 	and.w	r3, r3, #256	; 0x100
2400f274:	2b00      	cmp	r3, #0
2400f276:	d00b      	beq.n	2400f290 <I2C_IsErrorOccurred+0x128>
  {
    error_code |= HAL_I2C_ERROR_BERR;
2400f278:	6a3b      	ldr	r3, [r7, #32]
2400f27a:	f043 0301 	orr.w	r3, r3, #1
2400f27e:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2400f280:	68fb      	ldr	r3, [r7, #12]
2400f282:	681b      	ldr	r3, [r3, #0]
2400f284:	f44f 7280 	mov.w	r2, #256	; 0x100
2400f288:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
2400f28a:	2301      	movs	r3, #1
2400f28c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
2400f290:	69bb      	ldr	r3, [r7, #24]
2400f292:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2400f296:	2b00      	cmp	r3, #0
2400f298:	d00b      	beq.n	2400f2b2 <I2C_IsErrorOccurred+0x14a>
  {
    error_code |= HAL_I2C_ERROR_OVR;
2400f29a:	6a3b      	ldr	r3, [r7, #32]
2400f29c:	f043 0308 	orr.w	r3, r3, #8
2400f2a0:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
2400f2a2:	68fb      	ldr	r3, [r7, #12]
2400f2a4:	681b      	ldr	r3, [r3, #0]
2400f2a6:	f44f 6280 	mov.w	r2, #1024	; 0x400
2400f2aa:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
2400f2ac:	2301      	movs	r3, #1
2400f2ae:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
2400f2b2:	69bb      	ldr	r3, [r7, #24]
2400f2b4:	f403 7300 	and.w	r3, r3, #512	; 0x200
2400f2b8:	2b00      	cmp	r3, #0
2400f2ba:	d00b      	beq.n	2400f2d4 <I2C_IsErrorOccurred+0x16c>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
2400f2bc:	6a3b      	ldr	r3, [r7, #32]
2400f2be:	f043 0302 	orr.w	r3, r3, #2
2400f2c2:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2400f2c4:	68fb      	ldr	r3, [r7, #12]
2400f2c6:	681b      	ldr	r3, [r3, #0]
2400f2c8:	f44f 7200 	mov.w	r2, #512	; 0x200
2400f2cc:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
2400f2ce:	2301      	movs	r3, #1
2400f2d0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  if (status != HAL_OK)
2400f2d4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
2400f2d8:	2b00      	cmp	r3, #0
2400f2da:	d01c      	beq.n	2400f316 <I2C_IsErrorOccurred+0x1ae>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400f2dc:	68f8      	ldr	r0, [r7, #12]
2400f2de:	f7ff fb02 	bl	2400e8e6 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400f2e2:	68fb      	ldr	r3, [r7, #12]
2400f2e4:	681b      	ldr	r3, [r3, #0]
2400f2e6:	6859      	ldr	r1, [r3, #4]
2400f2e8:	68fb      	ldr	r3, [r7, #12]
2400f2ea:	681a      	ldr	r2, [r3, #0]
2400f2ec:	4b0d      	ldr	r3, [pc, #52]	; (2400f324 <I2C_IsErrorOccurred+0x1bc>)
2400f2ee:	400b      	ands	r3, r1
2400f2f0:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
2400f2f2:	68fb      	ldr	r3, [r7, #12]
2400f2f4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2400f2f6:	6a3b      	ldr	r3, [r7, #32]
2400f2f8:	431a      	orrs	r2, r3
2400f2fa:	68fb      	ldr	r3, [r7, #12]
2400f2fc:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
2400f2fe:	68fb      	ldr	r3, [r7, #12]
2400f300:	2220      	movs	r2, #32
2400f302:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400f306:	68fb      	ldr	r3, [r7, #12]
2400f308:	2200      	movs	r2, #0
2400f30a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f30e:	68fb      	ldr	r3, [r7, #12]
2400f310:	2200      	movs	r2, #0
2400f312:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
2400f316:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
2400f31a:	4618      	mov	r0, r3
2400f31c:	3728      	adds	r7, #40	; 0x28
2400f31e:	46bd      	mov	sp, r7
2400f320:	bd80      	pop	{r7, pc}
2400f322:	bf00      	nop
2400f324:	fe00e800 	.word	0xfe00e800

2400f328 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
2400f328:	b480      	push	{r7}
2400f32a:	b087      	sub	sp, #28
2400f32c:	af00      	add	r7, sp, #0
2400f32e:	60f8      	str	r0, [r7, #12]
2400f330:	607b      	str	r3, [r7, #4]
2400f332:	460b      	mov	r3, r1
2400f334:	817b      	strh	r3, [r7, #10]
2400f336:	4613      	mov	r3, r2
2400f338:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2400f33a:	897b      	ldrh	r3, [r7, #10]
2400f33c:	f3c3 0209 	ubfx	r2, r3, #0, #10
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2400f340:	7a7b      	ldrb	r3, [r7, #9]
2400f342:	041b      	lsls	r3, r3, #16
2400f344:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2400f348:	431a      	orrs	r2, r3
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2400f34a:	687b      	ldr	r3, [r7, #4]
2400f34c:	431a      	orrs	r2, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2400f34e:	6a3b      	ldr	r3, [r7, #32]
2400f350:	4313      	orrs	r3, r2
2400f352:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2400f356:	617b      	str	r3, [r7, #20]
                             (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
2400f358:	68fb      	ldr	r3, [r7, #12]
2400f35a:	681b      	ldr	r3, [r3, #0]
2400f35c:	685a      	ldr	r2, [r3, #4]
2400f35e:	6a3b      	ldr	r3, [r7, #32]
2400f360:	0d5b      	lsrs	r3, r3, #21
2400f362:	f403 6180 	and.w	r1, r3, #1024	; 0x400
2400f366:	4b08      	ldr	r3, [pc, #32]	; (2400f388 <I2C_TransferConfig+0x60>)
2400f368:	430b      	orrs	r3, r1
2400f36a:	43db      	mvns	r3, r3
2400f36c:	ea02 0103 	and.w	r1, r2, r3
2400f370:	68fb      	ldr	r3, [r7, #12]
2400f372:	681b      	ldr	r3, [r3, #0]
2400f374:	697a      	ldr	r2, [r7, #20]
2400f376:	430a      	orrs	r2, r1
2400f378:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
2400f37a:	bf00      	nop
2400f37c:	371c      	adds	r7, #28
2400f37e:	46bd      	mov	sp, r7
2400f380:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f384:	4770      	bx	lr
2400f386:	bf00      	nop
2400f388:	03ff63ff 	.word	0x03ff63ff

2400f38c <I2C_Enable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2400f38c:	b480      	push	{r7}
2400f38e:	b085      	sub	sp, #20
2400f390:	af00      	add	r7, sp, #0
2400f392:	6078      	str	r0, [r7, #4]
2400f394:	460b      	mov	r3, r1
2400f396:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2400f398:	2300      	movs	r3, #0
2400f39a:	60fb      	str	r3, [r7, #12]

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400f39c:	687b      	ldr	r3, [r7, #4]
2400f39e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f3a0:	4a2d      	ldr	r2, [pc, #180]	; (2400f458 <I2C_Enable_IRQ+0xcc>)
2400f3a2:	4293      	cmp	r3, r2
2400f3a4:	d004      	beq.n	2400f3b0 <I2C_Enable_IRQ+0x24>
      (hi2c->XferISR == I2C_Slave_ISR_DMA))
2400f3a6:	687b      	ldr	r3, [r7, #4]
2400f3a8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400f3aa:	4a2c      	ldr	r2, [pc, #176]	; (2400f45c <I2C_Enable_IRQ+0xd0>)
2400f3ac:	4293      	cmp	r3, r2
2400f3ae:	d11d      	bne.n	2400f3ec <I2C_Enable_IRQ+0x60>
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400f3b0:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400f3b4:	2b00      	cmp	r3, #0
2400f3b6:	da03      	bge.n	2400f3c0 <I2C_Enable_IRQ+0x34>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f3b8:	68fb      	ldr	r3, [r7, #12]
2400f3ba:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400f3be:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
2400f3c0:	887b      	ldrh	r3, [r7, #2]
2400f3c2:	2b10      	cmp	r3, #16
2400f3c4:	d103      	bne.n	2400f3ce <I2C_Enable_IRQ+0x42>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400f3c6:	68fb      	ldr	r3, [r7, #12]
2400f3c8:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400f3cc:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400f3ce:	887b      	ldrh	r3, [r7, #2]
2400f3d0:	2b20      	cmp	r3, #32
2400f3d2:	d103      	bne.n	2400f3dc <I2C_Enable_IRQ+0x50>
    {
      /* Enable STOP interrupts */
      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
2400f3d4:	68fb      	ldr	r3, [r7, #12]
2400f3d6:	f043 0360 	orr.w	r3, r3, #96	; 0x60
2400f3da:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400f3dc:	887b      	ldrh	r3, [r7, #2]
2400f3de:	2b40      	cmp	r3, #64	; 0x40
2400f3e0:	d12c      	bne.n	2400f43c <I2C_Enable_IRQ+0xb0>
    {
      /* Enable TC interrupts */
      tmpisr |= I2C_IT_TCI;
2400f3e2:	68fb      	ldr	r3, [r7, #12]
2400f3e4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400f3e8:	60fb      	str	r3, [r7, #12]
    if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400f3ea:	e027      	b.n	2400f43c <I2C_Enable_IRQ+0xb0>
    }
  }
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400f3ec:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400f3f0:	2b00      	cmp	r3, #0
2400f3f2:	da03      	bge.n	2400f3fc <I2C_Enable_IRQ+0x70>
    {
      /* Enable ERR, STOP, NACK, and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f3f4:	68fb      	ldr	r3, [r7, #12]
2400f3f6:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400f3fa:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2400f3fc:	887b      	ldrh	r3, [r7, #2]
2400f3fe:	f003 0301 	and.w	r3, r3, #1
2400f402:	2b00      	cmp	r3, #0
2400f404:	d003      	beq.n	2400f40e <I2C_Enable_IRQ+0x82>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
2400f406:	68fb      	ldr	r3, [r7, #12]
2400f408:	f043 03f2 	orr.w	r3, r3, #242	; 0xf2
2400f40c:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400f40e:	887b      	ldrh	r3, [r7, #2]
2400f410:	f003 0302 	and.w	r3, r3, #2
2400f414:	2b00      	cmp	r3, #0
2400f416:	d003      	beq.n	2400f420 <I2C_Enable_IRQ+0x94>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
2400f418:	68fb      	ldr	r3, [r7, #12]
2400f41a:	f043 03f4 	orr.w	r3, r3, #244	; 0xf4
2400f41e:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
2400f420:	887b      	ldrh	r3, [r7, #2]
2400f422:	2b10      	cmp	r3, #16
2400f424:	d103      	bne.n	2400f42e <I2C_Enable_IRQ+0xa2>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400f426:	68fb      	ldr	r3, [r7, #12]
2400f428:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400f42c:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400f42e:	887b      	ldrh	r3, [r7, #2]
2400f430:	2b20      	cmp	r3, #32
2400f432:	d103      	bne.n	2400f43c <I2C_Enable_IRQ+0xb0>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
2400f434:	68fb      	ldr	r3, [r7, #12]
2400f436:	f043 0320 	orr.w	r3, r3, #32
2400f43a:	60fb      	str	r3, [r7, #12]
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
2400f43c:	687b      	ldr	r3, [r7, #4]
2400f43e:	681b      	ldr	r3, [r3, #0]
2400f440:	6819      	ldr	r1, [r3, #0]
2400f442:	687b      	ldr	r3, [r7, #4]
2400f444:	681b      	ldr	r3, [r3, #0]
2400f446:	68fa      	ldr	r2, [r7, #12]
2400f448:	430a      	orrs	r2, r1
2400f44a:	601a      	str	r2, [r3, #0]
}
2400f44c:	bf00      	nop
2400f44e:	3714      	adds	r7, #20
2400f450:	46bd      	mov	sp, r7
2400f452:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f456:	4770      	bx	lr
2400f458:	2400d507 	.word	0x2400d507
2400f45c:	2400d935 	.word	0x2400d935

2400f460 <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2400f460:	b480      	push	{r7}
2400f462:	b085      	sub	sp, #20
2400f464:	af00      	add	r7, sp, #0
2400f466:	6078      	str	r0, [r7, #4]
2400f468:	460b      	mov	r3, r1
2400f46a:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2400f46c:	2300      	movs	r3, #0
2400f46e:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2400f470:	887b      	ldrh	r3, [r7, #2]
2400f472:	f003 0301 	and.w	r3, r3, #1
2400f476:	2b00      	cmp	r3, #0
2400f478:	d00f      	beq.n	2400f49a <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
2400f47a:	68fb      	ldr	r3, [r7, #12]
2400f47c:	f043 0342 	orr.w	r3, r3, #66	; 0x42
2400f480:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400f482:	687b      	ldr	r3, [r7, #4]
2400f484:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f488:	b2db      	uxtb	r3, r3
2400f48a:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400f48e:	2b28      	cmp	r3, #40	; 0x28
2400f490:	d003      	beq.n	2400f49a <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f492:	68fb      	ldr	r3, [r7, #12]
2400f494:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2400f498:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400f49a:	887b      	ldrh	r3, [r7, #2]
2400f49c:	f003 0302 	and.w	r3, r3, #2
2400f4a0:	2b00      	cmp	r3, #0
2400f4a2:	d00f      	beq.n	2400f4c4 <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
2400f4a4:	68fb      	ldr	r3, [r7, #12]
2400f4a6:	f043 0344 	orr.w	r3, r3, #68	; 0x44
2400f4aa:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400f4ac:	687b      	ldr	r3, [r7, #4]
2400f4ae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f4b2:	b2db      	uxtb	r3, r3
2400f4b4:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400f4b8:	2b28      	cmp	r3, #40	; 0x28
2400f4ba:	d003      	beq.n	2400f4c4 <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f4bc:	68fb      	ldr	r3, [r7, #12]
2400f4be:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2400f4c2:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400f4c4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400f4c8:	2b00      	cmp	r3, #0
2400f4ca:	da03      	bge.n	2400f4d4 <I2C_Disable_IRQ+0x74>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f4cc:	68fb      	ldr	r3, [r7, #12]
2400f4ce:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400f4d2:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
2400f4d4:	887b      	ldrh	r3, [r7, #2]
2400f4d6:	2b10      	cmp	r3, #16
2400f4d8:	d103      	bne.n	2400f4e2 <I2C_Disable_IRQ+0x82>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400f4da:	68fb      	ldr	r3, [r7, #12]
2400f4dc:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400f4e0:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
2400f4e2:	887b      	ldrh	r3, [r7, #2]
2400f4e4:	2b20      	cmp	r3, #32
2400f4e6:	d103      	bne.n	2400f4f0 <I2C_Disable_IRQ+0x90>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
2400f4e8:	68fb      	ldr	r3, [r7, #12]
2400f4ea:	f043 0320 	orr.w	r3, r3, #32
2400f4ee:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400f4f0:	887b      	ldrh	r3, [r7, #2]
2400f4f2:	2b40      	cmp	r3, #64	; 0x40
2400f4f4:	d103      	bne.n	2400f4fe <I2C_Disable_IRQ+0x9e>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
2400f4f6:	68fb      	ldr	r3, [r7, #12]
2400f4f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400f4fc:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
2400f4fe:	687b      	ldr	r3, [r7, #4]
2400f500:	681b      	ldr	r3, [r3, #0]
2400f502:	6819      	ldr	r1, [r3, #0]
2400f504:	68fb      	ldr	r3, [r7, #12]
2400f506:	43da      	mvns	r2, r3
2400f508:	687b      	ldr	r3, [r7, #4]
2400f50a:	681b      	ldr	r3, [r3, #0]
2400f50c:	400a      	ands	r2, r1
2400f50e:	601a      	str	r2, [r3, #0]
}
2400f510:	bf00      	nop
2400f512:	3714      	adds	r7, #20
2400f514:	46bd      	mov	sp, r7
2400f516:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f51a:	4770      	bx	lr

2400f51c <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functional XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
2400f51c:	b480      	push	{r7}
2400f51e:	b083      	sub	sp, #12
2400f520:	af00      	add	r7, sp, #0
2400f522:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
2400f524:	687b      	ldr	r3, [r7, #4]
2400f526:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f528:	2baa      	cmp	r3, #170	; 0xaa
2400f52a:	d103      	bne.n	2400f534 <I2C_ConvertOtherXferOptions+0x18>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
2400f52c:	687b      	ldr	r3, [r7, #4]
2400f52e:	2200      	movs	r2, #0
2400f530:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
2400f532:	e008      	b.n	2400f546 <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
2400f534:	687b      	ldr	r3, [r7, #4]
2400f536:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f538:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400f53c:	d103      	bne.n	2400f546 <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
2400f53e:	687b      	ldr	r3, [r7, #4]
2400f540:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
2400f544:	62da      	str	r2, [r3, #44]	; 0x2c
}
2400f546:	bf00      	nop
2400f548:	370c      	adds	r7, #12
2400f54a:	46bd      	mov	sp, r7
2400f54c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f550:	4770      	bx	lr

2400f552 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
2400f552:	b480      	push	{r7}
2400f554:	b083      	sub	sp, #12
2400f556:	af00      	add	r7, sp, #0
2400f558:	6078      	str	r0, [r7, #4]
2400f55a:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400f55c:	687b      	ldr	r3, [r7, #4]
2400f55e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f562:	b2db      	uxtb	r3, r3
2400f564:	2b20      	cmp	r3, #32
2400f566:	d138      	bne.n	2400f5da <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400f568:	687b      	ldr	r3, [r7, #4]
2400f56a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400f56e:	2b01      	cmp	r3, #1
2400f570:	d101      	bne.n	2400f576 <HAL_I2CEx_ConfigAnalogFilter+0x24>
2400f572:	2302      	movs	r3, #2
2400f574:	e032      	b.n	2400f5dc <HAL_I2CEx_ConfigAnalogFilter+0x8a>
2400f576:	687b      	ldr	r3, [r7, #4]
2400f578:	2201      	movs	r2, #1
2400f57a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400f57e:	687b      	ldr	r3, [r7, #4]
2400f580:	2224      	movs	r2, #36	; 0x24
2400f582:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400f586:	687b      	ldr	r3, [r7, #4]
2400f588:	681b      	ldr	r3, [r3, #0]
2400f58a:	681a      	ldr	r2, [r3, #0]
2400f58c:	687b      	ldr	r3, [r7, #4]
2400f58e:	681b      	ldr	r3, [r3, #0]
2400f590:	f022 0201 	bic.w	r2, r2, #1
2400f594:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
2400f596:	687b      	ldr	r3, [r7, #4]
2400f598:	681b      	ldr	r3, [r3, #0]
2400f59a:	681a      	ldr	r2, [r3, #0]
2400f59c:	687b      	ldr	r3, [r7, #4]
2400f59e:	681b      	ldr	r3, [r3, #0]
2400f5a0:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2400f5a4:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
2400f5a6:	687b      	ldr	r3, [r7, #4]
2400f5a8:	681b      	ldr	r3, [r3, #0]
2400f5aa:	6819      	ldr	r1, [r3, #0]
2400f5ac:	687b      	ldr	r3, [r7, #4]
2400f5ae:	681b      	ldr	r3, [r3, #0]
2400f5b0:	683a      	ldr	r2, [r7, #0]
2400f5b2:	430a      	orrs	r2, r1
2400f5b4:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400f5b6:	687b      	ldr	r3, [r7, #4]
2400f5b8:	681b      	ldr	r3, [r3, #0]
2400f5ba:	681a      	ldr	r2, [r3, #0]
2400f5bc:	687b      	ldr	r3, [r7, #4]
2400f5be:	681b      	ldr	r3, [r3, #0]
2400f5c0:	f042 0201 	orr.w	r2, r2, #1
2400f5c4:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400f5c6:	687b      	ldr	r3, [r7, #4]
2400f5c8:	2220      	movs	r2, #32
2400f5ca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f5ce:	687b      	ldr	r3, [r7, #4]
2400f5d0:	2200      	movs	r2, #0
2400f5d2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400f5d6:	2300      	movs	r3, #0
2400f5d8:	e000      	b.n	2400f5dc <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
2400f5da:	2302      	movs	r3, #2
  }
}
2400f5dc:	4618      	mov	r0, r3
2400f5de:	370c      	adds	r7, #12
2400f5e0:	46bd      	mov	sp, r7
2400f5e2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f5e6:	4770      	bx	lr

2400f5e8 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
2400f5e8:	b480      	push	{r7}
2400f5ea:	b085      	sub	sp, #20
2400f5ec:	af00      	add	r7, sp, #0
2400f5ee:	6078      	str	r0, [r7, #4]
2400f5f0:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400f5f2:	687b      	ldr	r3, [r7, #4]
2400f5f4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f5f8:	b2db      	uxtb	r3, r3
2400f5fa:	2b20      	cmp	r3, #32
2400f5fc:	d139      	bne.n	2400f672 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400f5fe:	687b      	ldr	r3, [r7, #4]
2400f600:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400f604:	2b01      	cmp	r3, #1
2400f606:	d101      	bne.n	2400f60c <HAL_I2CEx_ConfigDigitalFilter+0x24>
2400f608:	2302      	movs	r3, #2
2400f60a:	e033      	b.n	2400f674 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
2400f60c:	687b      	ldr	r3, [r7, #4]
2400f60e:	2201      	movs	r2, #1
2400f610:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400f614:	687b      	ldr	r3, [r7, #4]
2400f616:	2224      	movs	r2, #36	; 0x24
2400f618:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400f61c:	687b      	ldr	r3, [r7, #4]
2400f61e:	681b      	ldr	r3, [r3, #0]
2400f620:	681a      	ldr	r2, [r3, #0]
2400f622:	687b      	ldr	r3, [r7, #4]
2400f624:	681b      	ldr	r3, [r3, #0]
2400f626:	f022 0201 	bic.w	r2, r2, #1
2400f62a:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
2400f62c:	687b      	ldr	r3, [r7, #4]
2400f62e:	681b      	ldr	r3, [r3, #0]
2400f630:	681b      	ldr	r3, [r3, #0]
2400f632:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
2400f634:	68fb      	ldr	r3, [r7, #12]
2400f636:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
2400f63a:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
2400f63c:	683b      	ldr	r3, [r7, #0]
2400f63e:	021b      	lsls	r3, r3, #8
2400f640:	68fa      	ldr	r2, [r7, #12]
2400f642:	4313      	orrs	r3, r2
2400f644:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
2400f646:	687b      	ldr	r3, [r7, #4]
2400f648:	681b      	ldr	r3, [r3, #0]
2400f64a:	68fa      	ldr	r2, [r7, #12]
2400f64c:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400f64e:	687b      	ldr	r3, [r7, #4]
2400f650:	681b      	ldr	r3, [r3, #0]
2400f652:	681a      	ldr	r2, [r3, #0]
2400f654:	687b      	ldr	r3, [r7, #4]
2400f656:	681b      	ldr	r3, [r3, #0]
2400f658:	f042 0201 	orr.w	r2, r2, #1
2400f65c:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400f65e:	687b      	ldr	r3, [r7, #4]
2400f660:	2220      	movs	r2, #32
2400f662:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f666:	687b      	ldr	r3, [r7, #4]
2400f668:	2200      	movs	r2, #0
2400f66a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400f66e:	2300      	movs	r3, #0
2400f670:	e000      	b.n	2400f674 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
2400f672:	2302      	movs	r3, #2
  }
}
2400f674:	4618      	mov	r0, r3
2400f676:	3714      	adds	r7, #20
2400f678:	46bd      	mov	sp, r7
2400f67a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f67e:	4770      	bx	lr

2400f680 <HAL_I2CEx_EnableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_EnableWakeUp(I2C_HandleTypeDef *hi2c)
{
2400f680:	b480      	push	{r7}
2400f682:	b083      	sub	sp, #12
2400f684:	af00      	add	r7, sp, #0
2400f686:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400f688:	687b      	ldr	r3, [r7, #4]
2400f68a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f68e:	b2db      	uxtb	r3, r3
2400f690:	2b20      	cmp	r3, #32
2400f692:	d130      	bne.n	2400f6f6 <HAL_I2CEx_EnableWakeUp+0x76>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400f694:	687b      	ldr	r3, [r7, #4]
2400f696:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400f69a:	2b01      	cmp	r3, #1
2400f69c:	d101      	bne.n	2400f6a2 <HAL_I2CEx_EnableWakeUp+0x22>
2400f69e:	2302      	movs	r3, #2
2400f6a0:	e02a      	b.n	2400f6f8 <HAL_I2CEx_EnableWakeUp+0x78>
2400f6a2:	687b      	ldr	r3, [r7, #4]
2400f6a4:	2201      	movs	r2, #1
2400f6a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400f6aa:	687b      	ldr	r3, [r7, #4]
2400f6ac:	2224      	movs	r2, #36	; 0x24
2400f6ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400f6b2:	687b      	ldr	r3, [r7, #4]
2400f6b4:	681b      	ldr	r3, [r3, #0]
2400f6b6:	681a      	ldr	r2, [r3, #0]
2400f6b8:	687b      	ldr	r3, [r7, #4]
2400f6ba:	681b      	ldr	r3, [r3, #0]
2400f6bc:	f022 0201 	bic.w	r2, r2, #1
2400f6c0:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 |= I2C_CR1_WUPEN;
2400f6c2:	687b      	ldr	r3, [r7, #4]
2400f6c4:	681b      	ldr	r3, [r3, #0]
2400f6c6:	681a      	ldr	r2, [r3, #0]
2400f6c8:	687b      	ldr	r3, [r7, #4]
2400f6ca:	681b      	ldr	r3, [r3, #0]
2400f6cc:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2400f6d0:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400f6d2:	687b      	ldr	r3, [r7, #4]
2400f6d4:	681b      	ldr	r3, [r3, #0]
2400f6d6:	681a      	ldr	r2, [r3, #0]
2400f6d8:	687b      	ldr	r3, [r7, #4]
2400f6da:	681b      	ldr	r3, [r3, #0]
2400f6dc:	f042 0201 	orr.w	r2, r2, #1
2400f6e0:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400f6e2:	687b      	ldr	r3, [r7, #4]
2400f6e4:	2220      	movs	r2, #32
2400f6e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f6ea:	687b      	ldr	r3, [r7, #4]
2400f6ec:	2200      	movs	r2, #0
2400f6ee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400f6f2:	2300      	movs	r3, #0
2400f6f4:	e000      	b.n	2400f6f8 <HAL_I2CEx_EnableWakeUp+0x78>
  }
  else
  {
    return HAL_BUSY;
2400f6f6:	2302      	movs	r3, #2
  }
}
2400f6f8:	4618      	mov	r0, r3
2400f6fa:	370c      	adds	r7, #12
2400f6fc:	46bd      	mov	sp, r7
2400f6fe:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f702:	4770      	bx	lr

2400f704 <HAL_I2CEx_DisableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_DisableWakeUp(I2C_HandleTypeDef *hi2c)
{
2400f704:	b480      	push	{r7}
2400f706:	b083      	sub	sp, #12
2400f708:	af00      	add	r7, sp, #0
2400f70a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400f70c:	687b      	ldr	r3, [r7, #4]
2400f70e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f712:	b2db      	uxtb	r3, r3
2400f714:	2b20      	cmp	r3, #32
2400f716:	d130      	bne.n	2400f77a <HAL_I2CEx_DisableWakeUp+0x76>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400f718:	687b      	ldr	r3, [r7, #4]
2400f71a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400f71e:	2b01      	cmp	r3, #1
2400f720:	d101      	bne.n	2400f726 <HAL_I2CEx_DisableWakeUp+0x22>
2400f722:	2302      	movs	r3, #2
2400f724:	e02a      	b.n	2400f77c <HAL_I2CEx_DisableWakeUp+0x78>
2400f726:	687b      	ldr	r3, [r7, #4]
2400f728:	2201      	movs	r2, #1
2400f72a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400f72e:	687b      	ldr	r3, [r7, #4]
2400f730:	2224      	movs	r2, #36	; 0x24
2400f732:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400f736:	687b      	ldr	r3, [r7, #4]
2400f738:	681b      	ldr	r3, [r3, #0]
2400f73a:	681a      	ldr	r2, [r3, #0]
2400f73c:	687b      	ldr	r3, [r7, #4]
2400f73e:	681b      	ldr	r3, [r3, #0]
2400f740:	f022 0201 	bic.w	r2, r2, #1
2400f744:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);
2400f746:	687b      	ldr	r3, [r7, #4]
2400f748:	681b      	ldr	r3, [r3, #0]
2400f74a:	681a      	ldr	r2, [r3, #0]
2400f74c:	687b      	ldr	r3, [r7, #4]
2400f74e:	681b      	ldr	r3, [r3, #0]
2400f750:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2400f754:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400f756:	687b      	ldr	r3, [r7, #4]
2400f758:	681b      	ldr	r3, [r3, #0]
2400f75a:	681a      	ldr	r2, [r3, #0]
2400f75c:	687b      	ldr	r3, [r7, #4]
2400f75e:	681b      	ldr	r3, [r3, #0]
2400f760:	f042 0201 	orr.w	r2, r2, #1
2400f764:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400f766:	687b      	ldr	r3, [r7, #4]
2400f768:	2220      	movs	r2, #32
2400f76a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f76e:	687b      	ldr	r3, [r7, #4]
2400f770:	2200      	movs	r2, #0
2400f772:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400f776:	2300      	movs	r3, #0
2400f778:	e000      	b.n	2400f77c <HAL_I2CEx_DisableWakeUp+0x78>
  }
  else
  {
    return HAL_BUSY;
2400f77a:	2302      	movs	r3, #2
  }
}
2400f77c:	4618      	mov	r0, r3
2400f77e:	370c      	adds	r7, #12
2400f780:	46bd      	mov	sp, r7
2400f782:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f786:	4770      	bx	lr

2400f788 <HAL_I2CEx_EnableFastModePlus>:
  * @note  For all I2C5 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C5 parameter.
  * @retval None
  */
void HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)
{
2400f788:	b480      	push	{r7}
2400f78a:	b085      	sub	sp, #20
2400f78c:	af00      	add	r7, sp, #0
2400f78e:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2400f790:	4b0d      	ldr	r3, [pc, #52]	; (2400f7c8 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400f792:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400f796:	4a0c      	ldr	r2, [pc, #48]	; (2400f7c8 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400f798:	f043 0302 	orr.w	r3, r3, #2
2400f79c:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2400f7a0:	4b09      	ldr	r3, [pc, #36]	; (2400f7c8 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400f7a2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400f7a6:	f003 0302 	and.w	r3, r3, #2
2400f7aa:	60fb      	str	r3, [r7, #12]
2400f7ac:	68fb      	ldr	r3, [r7, #12]

  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
2400f7ae:	4b07      	ldr	r3, [pc, #28]	; (2400f7cc <HAL_I2CEx_EnableFastModePlus+0x44>)
2400f7b0:	685a      	ldr	r2, [r3, #4]
2400f7b2:	4906      	ldr	r1, [pc, #24]	; (2400f7cc <HAL_I2CEx_EnableFastModePlus+0x44>)
2400f7b4:	687b      	ldr	r3, [r7, #4]
2400f7b6:	4313      	orrs	r3, r2
2400f7b8:	604b      	str	r3, [r1, #4]
}
2400f7ba:	bf00      	nop
2400f7bc:	3714      	adds	r7, #20
2400f7be:	46bd      	mov	sp, r7
2400f7c0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f7c4:	4770      	bx	lr
2400f7c6:	bf00      	nop
2400f7c8:	58024400 	.word	0x58024400
2400f7cc:	58000400 	.word	0x58000400

2400f7d0 <HAL_I2CEx_DisableFastModePlus>:
  * @note  For all I2C5 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C5 parameter.
  * @retval None
  */
void HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)
{
2400f7d0:	b480      	push	{r7}
2400f7d2:	b085      	sub	sp, #20
2400f7d4:	af00      	add	r7, sp, #0
2400f7d6:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2400f7d8:	4b0d      	ldr	r3, [pc, #52]	; (2400f810 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400f7da:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400f7de:	4a0c      	ldr	r2, [pc, #48]	; (2400f810 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400f7e0:	f043 0302 	orr.w	r3, r3, #2
2400f7e4:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2400f7e8:	4b09      	ldr	r3, [pc, #36]	; (2400f810 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400f7ea:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400f7ee:	f003 0302 	and.w	r3, r3, #2
2400f7f2:	60fb      	str	r3, [r7, #12]
2400f7f4:	68fb      	ldr	r3, [r7, #12]

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
2400f7f6:	4b07      	ldr	r3, [pc, #28]	; (2400f814 <HAL_I2CEx_DisableFastModePlus+0x44>)
2400f7f8:	685a      	ldr	r2, [r3, #4]
2400f7fa:	687b      	ldr	r3, [r7, #4]
2400f7fc:	43db      	mvns	r3, r3
2400f7fe:	4905      	ldr	r1, [pc, #20]	; (2400f814 <HAL_I2CEx_DisableFastModePlus+0x44>)
2400f800:	4013      	ands	r3, r2
2400f802:	604b      	str	r3, [r1, #4]
}
2400f804:	bf00      	nop
2400f806:	3714      	adds	r7, #20
2400f808:	46bd      	mov	sp, r7
2400f80a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f80e:	4770      	bx	lr
2400f810:	58024400 	.word	0x58024400
2400f814:	58000400 	.word	0x58000400

2400f818 <HAL_MDMA_Init>:
  * @param  hmdma: Pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
2400f818:	b580      	push	{r7, lr}
2400f81a:	b084      	sub	sp, #16
2400f81c:	af00      	add	r7, sp, #0
2400f81e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
2400f820:	f7f2 fbfc 	bl	2400201c <HAL_GetTick>
2400f824:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400f826:	687b      	ldr	r3, [r7, #4]
2400f828:	2b00      	cmp	r3, #0
2400f82a:	d101      	bne.n	2400f830 <HAL_MDMA_Init+0x18>
  {
    return HAL_ERROR;
2400f82c:	2301      	movs	r3, #1
2400f82e:	e03b      	b.n	2400f8a8 <HAL_MDMA_Init+0x90>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.SourceBlockAddressOffset));
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.DestBlockAddressOffset));


  /* Allocate lock resource */
  __HAL_UNLOCK(hmdma);
2400f830:	687b      	ldr	r3, [r7, #4]
2400f832:	2200      	movs	r2, #0
2400f834:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change MDMA peripheral state */
  hmdma->State = HAL_MDMA_STATE_BUSY;
2400f838:	687b      	ldr	r3, [r7, #4]
2400f83a:	2202      	movs	r2, #2
2400f83c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
2400f840:	687b      	ldr	r3, [r7, #4]
2400f842:	681b      	ldr	r3, [r3, #0]
2400f844:	68da      	ldr	r2, [r3, #12]
2400f846:	687b      	ldr	r3, [r7, #4]
2400f848:	681b      	ldr	r3, [r3, #0]
2400f84a:	f022 0201 	bic.w	r2, r2, #1
2400f84e:	60da      	str	r2, [r3, #12]

  /* Check if the MDMA channel is effectively disabled */
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400f850:	e00f      	b.n	2400f872 <HAL_MDMA_Init+0x5a>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
2400f852:	f7f2 fbe3 	bl	2400201c <HAL_GetTick>
2400f856:	4602      	mov	r2, r0
2400f858:	68fb      	ldr	r3, [r7, #12]
2400f85a:	1ad3      	subs	r3, r2, r3
2400f85c:	2b05      	cmp	r3, #5
2400f85e:	d908      	bls.n	2400f872 <HAL_MDMA_Init+0x5a>
    {
      /* Update error code */
      hmdma->ErrorCode = HAL_MDMA_ERROR_TIMEOUT;
2400f860:	687b      	ldr	r3, [r7, #4]
2400f862:	2240      	movs	r2, #64	; 0x40
2400f864:	669a      	str	r2, [r3, #104]	; 0x68

      /* Change the MDMA state */
      hmdma->State = HAL_MDMA_STATE_ERROR;
2400f866:	687b      	ldr	r3, [r7, #4]
2400f868:	2203      	movs	r2, #3
2400f86a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      return HAL_ERROR;
2400f86e:	2301      	movs	r3, #1
2400f870:	e01a      	b.n	2400f8a8 <HAL_MDMA_Init+0x90>
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400f872:	687b      	ldr	r3, [r7, #4]
2400f874:	681b      	ldr	r3, [r3, #0]
2400f876:	68db      	ldr	r3, [r3, #12]
2400f878:	f003 0301 	and.w	r3, r3, #1
2400f87c:	2b00      	cmp	r3, #0
2400f87e:	d1e8      	bne.n	2400f852 <HAL_MDMA_Init+0x3a>
    }
  }

  /* Initialize the MDMA channel registers */
  MDMA_Init(hmdma);
2400f880:	6878      	ldr	r0, [r7, #4]
2400f882:	f001 f899 	bl	240109b8 <MDMA_Init>

  /* Reset the MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
2400f886:	687b      	ldr	r3, [r7, #4]
2400f888:	2200      	movs	r2, #0
2400f88a:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2400f88c:	687b      	ldr	r3, [r7, #4]
2400f88e:	2200      	movs	r2, #0
2400f890:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
2400f892:	687b      	ldr	r3, [r7, #4]
2400f894:	2200      	movs	r2, #0
2400f896:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400f898:	687b      	ldr	r3, [r7, #4]
2400f89a:	2200      	movs	r2, #0
2400f89c:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_READY;
2400f89e:	687b      	ldr	r3, [r7, #4]
2400f8a0:	2201      	movs	r2, #1
2400f8a2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
2400f8a6:	2300      	movs	r3, #0
}
2400f8a8:	4618      	mov	r0, r3
2400f8aa:	3710      	adds	r7, #16
2400f8ac:	46bd      	mov	sp, r7
2400f8ae:	bd80      	pop	{r7, pc}

2400f8b0 <HAL_MDMA_DeInit>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_DeInit(MDMA_HandleTypeDef *hmdma)
{
2400f8b0:	b480      	push	{r7}
2400f8b2:	b083      	sub	sp, #12
2400f8b4:	af00      	add	r7, sp, #0
2400f8b6:	6078      	str	r0, [r7, #4]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400f8b8:	687b      	ldr	r3, [r7, #4]
2400f8ba:	2b00      	cmp	r3, #0
2400f8bc:	d101      	bne.n	2400f8c2 <HAL_MDMA_DeInit+0x12>
  {
    return HAL_ERROR;
2400f8be:	2301      	movs	r3, #1
2400f8c0:	e048      	b.n	2400f954 <HAL_MDMA_DeInit+0xa4>
  }

  /* Disable the selected MDMA Channelx */
  __HAL_MDMA_DISABLE(hmdma);
2400f8c2:	687b      	ldr	r3, [r7, #4]
2400f8c4:	681b      	ldr	r3, [r3, #0]
2400f8c6:	68da      	ldr	r2, [r3, #12]
2400f8c8:	687b      	ldr	r3, [r7, #4]
2400f8ca:	681b      	ldr	r3, [r3, #0]
2400f8cc:	f022 0201 	bic.w	r2, r2, #1
2400f8d0:	60da      	str	r2, [r3, #12]

  /* Reset MDMA Channel control register */
  hmdma->Instance->CCR  = 0;
2400f8d2:	687b      	ldr	r3, [r7, #4]
2400f8d4:	681b      	ldr	r3, [r3, #0]
2400f8d6:	2200      	movs	r2, #0
2400f8d8:	60da      	str	r2, [r3, #12]
  hmdma->Instance->CTCR = 0;
2400f8da:	687b      	ldr	r3, [r7, #4]
2400f8dc:	681b      	ldr	r3, [r3, #0]
2400f8de:	2200      	movs	r2, #0
2400f8e0:	611a      	str	r2, [r3, #16]
  hmdma->Instance->CBNDTR = 0;
2400f8e2:	687b      	ldr	r3, [r7, #4]
2400f8e4:	681b      	ldr	r3, [r3, #0]
2400f8e6:	2200      	movs	r2, #0
2400f8e8:	615a      	str	r2, [r3, #20]
  hmdma->Instance->CSAR = 0;
2400f8ea:	687b      	ldr	r3, [r7, #4]
2400f8ec:	681b      	ldr	r3, [r3, #0]
2400f8ee:	2200      	movs	r2, #0
2400f8f0:	619a      	str	r2, [r3, #24]
  hmdma->Instance->CDAR = 0;
2400f8f2:	687b      	ldr	r3, [r7, #4]
2400f8f4:	681b      	ldr	r3, [r3, #0]
2400f8f6:	2200      	movs	r2, #0
2400f8f8:	61da      	str	r2, [r3, #28]
  hmdma->Instance->CBRUR = 0;
2400f8fa:	687b      	ldr	r3, [r7, #4]
2400f8fc:	681b      	ldr	r3, [r3, #0]
2400f8fe:	2200      	movs	r2, #0
2400f900:	621a      	str	r2, [r3, #32]
  hmdma->Instance->CLAR = 0;
2400f902:	687b      	ldr	r3, [r7, #4]
2400f904:	681b      	ldr	r3, [r3, #0]
2400f906:	2200      	movs	r2, #0
2400f908:	625a      	str	r2, [r3, #36]	; 0x24
  hmdma->Instance->CTBR = 0;
2400f90a:	687b      	ldr	r3, [r7, #4]
2400f90c:	681b      	ldr	r3, [r3, #0]
2400f90e:	2200      	movs	r2, #0
2400f910:	629a      	str	r2, [r3, #40]	; 0x28
  hmdma->Instance->CMAR = 0;
2400f912:	687b      	ldr	r3, [r7, #4]
2400f914:	681b      	ldr	r3, [r3, #0]
2400f916:	2200      	movs	r2, #0
2400f918:	631a      	str	r2, [r3, #48]	; 0x30
  hmdma->Instance->CMDR = 0;
2400f91a:	687b      	ldr	r3, [r7, #4]
2400f91c:	681b      	ldr	r3, [r3, #0]
2400f91e:	2200      	movs	r2, #0
2400f920:	635a      	str	r2, [r3, #52]	; 0x34

  /* Clear all flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));
2400f922:	687b      	ldr	r3, [r7, #4]
2400f924:	681b      	ldr	r3, [r3, #0]
2400f926:	221f      	movs	r2, #31
2400f928:	605a      	str	r2, [r3, #4]

  /* Reset the  MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
2400f92a:	687b      	ldr	r3, [r7, #4]
2400f92c:	2200      	movs	r2, #0
2400f92e:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2400f930:	687b      	ldr	r3, [r7, #4]
2400f932:	2200      	movs	r2, #0
2400f934:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
2400f936:	687b      	ldr	r3, [r7, #4]
2400f938:	2200      	movs	r2, #0
2400f93a:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400f93c:	687b      	ldr	r3, [r7, #4]
2400f93e:	2200      	movs	r2, #0
2400f940:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_RESET;
2400f942:	687b      	ldr	r3, [r7, #4]
2400f944:	2200      	movs	r2, #0
2400f946:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400f94a:	687b      	ldr	r3, [r7, #4]
2400f94c:	2200      	movs	r2, #0
2400f94e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2400f952:	2300      	movs	r3, #0
}
2400f954:	4618      	mov	r0, r3
2400f956:	370c      	adds	r7, #12
2400f958:	46bd      	mov	sp, r7
2400f95a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f95e:	4770      	bx	lr

2400f960 <HAL_MDMA_ConfigPostRequestMask>:
  * @param  MaskData:    specifies the value to be written to MaskAddress after a request is served.
  *                      MaskAddress and MaskData could be used to automatically clear a peripheral flag when the request is served.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_ConfigPostRequestMask(MDMA_HandleTypeDef *hmdma, uint32_t MaskAddress, uint32_t MaskData)
{
2400f960:	b480      	push	{r7}
2400f962:	b087      	sub	sp, #28
2400f964:	af00      	add	r7, sp, #0
2400f966:	60f8      	str	r0, [r7, #12]
2400f968:	60b9      	str	r1, [r7, #8]
2400f96a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
2400f96c:	2300      	movs	r3, #0
2400f96e:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400f970:	68fb      	ldr	r3, [r7, #12]
2400f972:	2b00      	cmp	r3, #0
2400f974:	d101      	bne.n	2400f97a <HAL_MDMA_ConfigPostRequestMask+0x1a>
  {
    return HAL_ERROR;
2400f976:	2301      	movs	r3, #1
2400f978:	e03e      	b.n	2400f9f8 <HAL_MDMA_ConfigPostRequestMask+0x98>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400f97a:	68fb      	ldr	r3, [r7, #12]
2400f97c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400f980:	2b01      	cmp	r3, #1
2400f982:	d101      	bne.n	2400f988 <HAL_MDMA_ConfigPostRequestMask+0x28>
2400f984:	2302      	movs	r3, #2
2400f986:	e037      	b.n	2400f9f8 <HAL_MDMA_ConfigPostRequestMask+0x98>
2400f988:	68fb      	ldr	r3, [r7, #12]
2400f98a:	2201      	movs	r2, #1
2400f98c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400f990:	68fb      	ldr	r3, [r7, #12]
2400f992:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400f996:	b2db      	uxtb	r3, r3
2400f998:	2b01      	cmp	r3, #1
2400f99a:	d126      	bne.n	2400f9ea <HAL_MDMA_ConfigPostRequestMask+0x8a>
  {
    /* if HW request set Post Request MaskAddress and MaskData,  */
    if((hmdma->Instance->CTCR & MDMA_CTCR_SWRM) == 0U)
2400f99c:	68fb      	ldr	r3, [r7, #12]
2400f99e:	681b      	ldr	r3, [r3, #0]
2400f9a0:	691b      	ldr	r3, [r3, #16]
2400f9a2:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2400f9a6:	2b00      	cmp	r3, #0
2400f9a8:	d11c      	bne.n	2400f9e4 <HAL_MDMA_ConfigPostRequestMask+0x84>
    {
      /* Set the HW request clear Mask and Data */
      hmdma->Instance->CMAR = MaskAddress;
2400f9aa:	68fb      	ldr	r3, [r7, #12]
2400f9ac:	681b      	ldr	r3, [r3, #0]
2400f9ae:	68ba      	ldr	r2, [r7, #8]
2400f9b0:	631a      	str	r2, [r3, #48]	; 0x30
      hmdma->Instance->CMDR = MaskData;
2400f9b2:	68fb      	ldr	r3, [r7, #12]
2400f9b4:	681b      	ldr	r3, [r3, #0]
2400f9b6:	687a      	ldr	r2, [r7, #4]
2400f9b8:	635a      	str	r2, [r3, #52]	; 0x34
      -If the request is done by SW : BWM could be set to 1 or 0.
      -If the request is done by a peripheral :
         If mask address not set (0) => BWM must be set to 0
         If mask address set (different than 0) => BWM could be set to 1 or 0
      */
      if(MaskAddress == 0U)
2400f9ba:	68bb      	ldr	r3, [r7, #8]
2400f9bc:	2b00      	cmp	r3, #0
2400f9be:	d108      	bne.n	2400f9d2 <HAL_MDMA_ConfigPostRequestMask+0x72>
      {
        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;
2400f9c0:	68fb      	ldr	r3, [r7, #12]
2400f9c2:	681b      	ldr	r3, [r3, #0]
2400f9c4:	691a      	ldr	r2, [r3, #16]
2400f9c6:	68fb      	ldr	r3, [r7, #12]
2400f9c8:	681b      	ldr	r3, [r3, #0]
2400f9ca:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
2400f9ce:	611a      	str	r2, [r3, #16]
2400f9d0:	e00d      	b.n	2400f9ee <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
      else
      {
        hmdma->Instance->CTCR |=  MDMA_CTCR_BWM;
2400f9d2:	68fb      	ldr	r3, [r7, #12]
2400f9d4:	681b      	ldr	r3, [r3, #0]
2400f9d6:	691a      	ldr	r2, [r3, #16]
2400f9d8:	68fb      	ldr	r3, [r7, #12]
2400f9da:	681b      	ldr	r3, [r3, #0]
2400f9dc:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
2400f9e0:	611a      	str	r2, [r3, #16]
2400f9e2:	e004      	b.n	2400f9ee <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
    }
    else
    {
      /* Return error status */
      status =  HAL_ERROR;
2400f9e4:	2301      	movs	r3, #1
2400f9e6:	75fb      	strb	r3, [r7, #23]
2400f9e8:	e001      	b.n	2400f9ee <HAL_MDMA_ConfigPostRequestMask+0x8e>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400f9ea:	2301      	movs	r3, #1
2400f9ec:	75fb      	strb	r3, [r7, #23]
  }
  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400f9ee:	68fb      	ldr	r3, [r7, #12]
2400f9f0:	2200      	movs	r2, #0
2400f9f2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400f9f6:	7dfb      	ldrb	r3, [r7, #23]
}
2400f9f8:	4618      	mov	r0, r3
2400f9fa:	371c      	adds	r7, #28
2400f9fc:	46bd      	mov	sp, r7
2400f9fe:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fa02:	4770      	bx	lr

2400fa04 <HAL_MDMA_RegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  * @param  pCallback:            pointer to callbacsk function.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_RegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID, void (* pCallback)(MDMA_HandleTypeDef *_hmdma))
{
2400fa04:	b480      	push	{r7}
2400fa06:	b087      	sub	sp, #28
2400fa08:	af00      	add	r7, sp, #0
2400fa0a:	60f8      	str	r0, [r7, #12]
2400fa0c:	460b      	mov	r3, r1
2400fa0e:	607a      	str	r2, [r7, #4]
2400fa10:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
2400fa12:	2300      	movs	r3, #0
2400fa14:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400fa16:	68fb      	ldr	r3, [r7, #12]
2400fa18:	2b00      	cmp	r3, #0
2400fa1a:	d101      	bne.n	2400fa20 <HAL_MDMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
2400fa1c:	2301      	movs	r3, #1
2400fa1e:	e044      	b.n	2400faaa <HAL_MDMA_RegisterCallback+0xa6>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fa20:	68fb      	ldr	r3, [r7, #12]
2400fa22:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fa26:	2b01      	cmp	r3, #1
2400fa28:	d101      	bne.n	2400fa2e <HAL_MDMA_RegisterCallback+0x2a>
2400fa2a:	2302      	movs	r3, #2
2400fa2c:	e03d      	b.n	2400faaa <HAL_MDMA_RegisterCallback+0xa6>
2400fa2e:	68fb      	ldr	r3, [r7, #12]
2400fa30:	2201      	movs	r2, #1
2400fa32:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fa36:	68fb      	ldr	r3, [r7, #12]
2400fa38:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400fa3c:	b2db      	uxtb	r3, r3
2400fa3e:	2b01      	cmp	r3, #1
2400fa40:	d12a      	bne.n	2400fa98 <HAL_MDMA_RegisterCallback+0x94>
  {
    switch (CallbackID)
2400fa42:	7afb      	ldrb	r3, [r7, #11]
2400fa44:	2b05      	cmp	r3, #5
2400fa46:	d82a      	bhi.n	2400fa9e <HAL_MDMA_RegisterCallback+0x9a>
2400fa48:	a201      	add	r2, pc, #4	; (adr r2, 2400fa50 <HAL_MDMA_RegisterCallback+0x4c>)
2400fa4a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400fa4e:	bf00      	nop
2400fa50:	2400fa69 	.word	0x2400fa69
2400fa54:	2400fa71 	.word	0x2400fa71
2400fa58:	2400fa79 	.word	0x2400fa79
2400fa5c:	2400fa81 	.word	0x2400fa81
2400fa60:	2400fa89 	.word	0x2400fa89
2400fa64:	2400fa91 	.word	0x2400fa91
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = pCallback;
2400fa68:	68fb      	ldr	r3, [r7, #12]
2400fa6a:	687a      	ldr	r2, [r7, #4]
2400fa6c:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400fa6e:	e017      	b.n	2400faa0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = pCallback;
2400fa70:	68fb      	ldr	r3, [r7, #12]
2400fa72:	687a      	ldr	r2, [r7, #4]
2400fa74:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400fa76:	e013      	b.n	2400faa0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = pCallback;
2400fa78:	68fb      	ldr	r3, [r7, #12]
2400fa7a:	687a      	ldr	r2, [r7, #4]
2400fa7c:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400fa7e:	e00f      	b.n	2400faa0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = pCallback;
2400fa80:	68fb      	ldr	r3, [r7, #12]
2400fa82:	687a      	ldr	r2, [r7, #4]
2400fa84:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400fa86:	e00b      	b.n	2400faa0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = pCallback;
2400fa88:	68fb      	ldr	r3, [r7, #12]
2400fa8a:	687a      	ldr	r2, [r7, #4]
2400fa8c:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2400fa8e:	e007      	b.n	2400faa0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = pCallback;
2400fa90:	68fb      	ldr	r3, [r7, #12]
2400fa92:	687a      	ldr	r2, [r7, #4]
2400fa94:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400fa96:	e003      	b.n	2400faa0 <HAL_MDMA_RegisterCallback+0x9c>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400fa98:	2301      	movs	r3, #1
2400fa9a:	75fb      	strb	r3, [r7, #23]
2400fa9c:	e000      	b.n	2400faa0 <HAL_MDMA_RegisterCallback+0x9c>
      break;
2400fa9e:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400faa0:	68fb      	ldr	r3, [r7, #12]
2400faa2:	2200      	movs	r2, #0
2400faa4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400faa8:	7dfb      	ldrb	r3, [r7, #23]
}
2400faaa:	4618      	mov	r0, r3
2400faac:	371c      	adds	r7, #28
2400faae:	46bd      	mov	sp, r7
2400fab0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fab4:	4770      	bx	lr
2400fab6:	bf00      	nop

2400fab8 <HAL_MDMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_MDMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_UnRegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID)
{
2400fab8:	b480      	push	{r7}
2400faba:	b085      	sub	sp, #20
2400fabc:	af00      	add	r7, sp, #0
2400fabe:	6078      	str	r0, [r7, #4]
2400fac0:	460b      	mov	r3, r1
2400fac2:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
2400fac4:	2300      	movs	r3, #0
2400fac6:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400fac8:	687b      	ldr	r3, [r7, #4]
2400faca:	2b00      	cmp	r3, #0
2400facc:	d101      	bne.n	2400fad2 <HAL_MDMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
2400face:	2301      	movs	r3, #1
2400fad0:	e059      	b.n	2400fb86 <HAL_MDMA_UnRegisterCallback+0xce>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fad2:	687b      	ldr	r3, [r7, #4]
2400fad4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fad8:	2b01      	cmp	r3, #1
2400fada:	d101      	bne.n	2400fae0 <HAL_MDMA_UnRegisterCallback+0x28>
2400fadc:	2302      	movs	r3, #2
2400fade:	e052      	b.n	2400fb86 <HAL_MDMA_UnRegisterCallback+0xce>
2400fae0:	687b      	ldr	r3, [r7, #4]
2400fae2:	2201      	movs	r2, #1
2400fae4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fae8:	687b      	ldr	r3, [r7, #4]
2400faea:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400faee:	b2db      	uxtb	r3, r3
2400faf0:	2b01      	cmp	r3, #1
2400faf2:	d141      	bne.n	2400fb78 <HAL_MDMA_UnRegisterCallback+0xc0>
  {
    switch (CallbackID)
2400faf4:	78fb      	ldrb	r3, [r7, #3]
2400faf6:	2b06      	cmp	r3, #6
2400faf8:	d83b      	bhi.n	2400fb72 <HAL_MDMA_UnRegisterCallback+0xba>
2400fafa:	a201      	add	r2, pc, #4	; (adr r2, 2400fb00 <HAL_MDMA_UnRegisterCallback+0x48>)
2400fafc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400fb00:	2400fb1d 	.word	0x2400fb1d
2400fb04:	2400fb25 	.word	0x2400fb25
2400fb08:	2400fb2d 	.word	0x2400fb2d
2400fb0c:	2400fb35 	.word	0x2400fb35
2400fb10:	2400fb3d 	.word	0x2400fb3d
2400fb14:	2400fb45 	.word	0x2400fb45
2400fb18:	2400fb4d 	.word	0x2400fb4d
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = NULL;
2400fb1c:	687b      	ldr	r3, [r7, #4]
2400fb1e:	2200      	movs	r2, #0
2400fb20:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400fb22:	e02b      	b.n	2400fb7c <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = NULL;
2400fb24:	687b      	ldr	r3, [r7, #4]
2400fb26:	2200      	movs	r2, #0
2400fb28:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400fb2a:	e027      	b.n	2400fb7c <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = NULL;
2400fb2c:	687b      	ldr	r3, [r7, #4]
2400fb2e:	2200      	movs	r2, #0
2400fb30:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400fb32:	e023      	b.n	2400fb7c <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400fb34:	687b      	ldr	r3, [r7, #4]
2400fb36:	2200      	movs	r2, #0
2400fb38:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400fb3a:	e01f      	b.n	2400fb7c <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = NULL;
2400fb3c:	687b      	ldr	r3, [r7, #4]
2400fb3e:	2200      	movs	r2, #0
2400fb40:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2400fb42:	e01b      	b.n	2400fb7c <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = NULL;
2400fb44:	687b      	ldr	r3, [r7, #4]
2400fb46:	2200      	movs	r2, #0
2400fb48:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400fb4a:	e017      	b.n	2400fb7c <HAL_MDMA_UnRegisterCallback+0xc4>

    case   HAL_MDMA_XFER_ALL_CB_ID:
      hmdma->XferCpltCallback = NULL;
2400fb4c:	687b      	ldr	r3, [r7, #4]
2400fb4e:	2200      	movs	r2, #0
2400fb50:	645a      	str	r2, [r3, #68]	; 0x44
      hmdma->XferBufferCpltCallback = NULL;
2400fb52:	687b      	ldr	r3, [r7, #4]
2400fb54:	2200      	movs	r2, #0
2400fb56:	649a      	str	r2, [r3, #72]	; 0x48
      hmdma->XferBlockCpltCallback = NULL;
2400fb58:	687b      	ldr	r3, [r7, #4]
2400fb5a:	2200      	movs	r2, #0
2400fb5c:	64da      	str	r2, [r3, #76]	; 0x4c
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400fb5e:	687b      	ldr	r3, [r7, #4]
2400fb60:	2200      	movs	r2, #0
2400fb62:	651a      	str	r2, [r3, #80]	; 0x50
      hmdma->XferErrorCallback = NULL;
2400fb64:	687b      	ldr	r3, [r7, #4]
2400fb66:	2200      	movs	r2, #0
2400fb68:	655a      	str	r2, [r3, #84]	; 0x54
      hmdma->XferAbortCallback = NULL;
2400fb6a:	687b      	ldr	r3, [r7, #4]
2400fb6c:	2200      	movs	r2, #0
2400fb6e:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400fb70:	e004      	b.n	2400fb7c <HAL_MDMA_UnRegisterCallback+0xc4>

    default:
      status = HAL_ERROR;
2400fb72:	2301      	movs	r3, #1
2400fb74:	73fb      	strb	r3, [r7, #15]
      break;
2400fb76:	e001      	b.n	2400fb7c <HAL_MDMA_UnRegisterCallback+0xc4>
    }
  }
  else
  {
    status = HAL_ERROR;
2400fb78:	2301      	movs	r3, #1
2400fb7a:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400fb7c:	687b      	ldr	r3, [r7, #4]
2400fb7e:	2200      	movs	r2, #0
2400fb80:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400fb84:	7bfb      	ldrb	r3, [r7, #15]
}
2400fb86:	4618      	mov	r0, r3
2400fb88:	3714      	adds	r7, #20
2400fb8a:	46bd      	mov	sp, r7
2400fb8c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fb90:	4770      	bx	lr
2400fb92:	bf00      	nop

2400fb94 <HAL_MDMA_LinkedList_CreateNode>:
  * @param  pNodeConfig: Pointer to a MDMA_LinkNodeConfTypeDef structure that contains
  *               the configuration information for the specified MDMA Linked List Node.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_CreateNode(MDMA_LinkNodeTypeDef *pNode, MDMA_LinkNodeConfTypeDef *pNodeConfig)
{
2400fb94:	b480      	push	{r7}
2400fb96:	b085      	sub	sp, #20
2400fb98:	af00      	add	r7, sp, #0
2400fb9a:	6078      	str	r0, [r7, #4]
2400fb9c:	6039      	str	r1, [r7, #0]
  uint32_t addressMask;
  uint32_t blockoffset;

  /* Check the MDMA peripheral state */
  if((pNode == NULL) || (pNodeConfig == NULL))
2400fb9e:	687b      	ldr	r3, [r7, #4]
2400fba0:	2b00      	cmp	r3, #0
2400fba2:	d002      	beq.n	2400fbaa <HAL_MDMA_LinkedList_CreateNode+0x16>
2400fba4:	683b      	ldr	r3, [r7, #0]
2400fba6:	2b00      	cmp	r3, #0
2400fba8:	d101      	bne.n	2400fbae <HAL_MDMA_LinkedList_CreateNode+0x1a>
  {
    return HAL_ERROR;
2400fbaa:	2301      	movs	r3, #1
2400fbac:	e0c8      	b.n	2400fd40 <HAL_MDMA_LinkedList_CreateNode+0x1ac>
  assert_param(IS_MDMA_TRANSFER_LENGTH(pNodeConfig->BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(pNodeConfig->BlockCount));


  /* Configure next Link node Address Register to zero */
  pNode->CLAR =  0;
2400fbae:	687b      	ldr	r3, [r7, #4]
2400fbb0:	2200      	movs	r2, #0
2400fbb2:	615a      	str	r2, [r3, #20]

  /* Configure the Link Node registers*/
  pNode->CTBR   = 0;
2400fbb4:	687b      	ldr	r3, [r7, #4]
2400fbb6:	2200      	movs	r2, #0
2400fbb8:	619a      	str	r2, [r3, #24]
  pNode->CMAR   = 0;
2400fbba:	687b      	ldr	r3, [r7, #4]
2400fbbc:	2200      	movs	r2, #0
2400fbbe:	621a      	str	r2, [r3, #32]
  pNode->CMDR   = 0;
2400fbc0:	687b      	ldr	r3, [r7, #4]
2400fbc2:	2200      	movs	r2, #0
2400fbc4:	625a      	str	r2, [r3, #36]	; 0x24
  pNode->Reserved = 0;
2400fbc6:	687b      	ldr	r3, [r7, #4]
2400fbc8:	2200      	movs	r2, #0
2400fbca:	61da      	str	r2, [r3, #28]

  /* Write new CTCR Register value */
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400fbcc:	683b      	ldr	r3, [r7, #0]
2400fbce:	691a      	ldr	r2, [r3, #16]
2400fbd0:	683b      	ldr	r3, [r7, #0]
2400fbd2:	695b      	ldr	r3, [r3, #20]
2400fbd4:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400fbd6:	683b      	ldr	r3, [r7, #0]
2400fbd8:	699b      	ldr	r3, [r3, #24]
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400fbda:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400fbdc:	683b      	ldr	r3, [r7, #0]
2400fbde:	69db      	ldr	r3, [r3, #28]
2400fbe0:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400fbe2:	683b      	ldr	r3, [r7, #0]
2400fbe4:	6a1b      	ldr	r3, [r3, #32]
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400fbe6:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400fbe8:	683b      	ldr	r3, [r7, #0]
2400fbea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2400fbec:	431a      	orrs	r2, r3
        pNodeConfig->Init.DestBurst                                             | \
2400fbee:	683b      	ldr	r3, [r7, #0]
2400fbf0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400fbf2:	431a      	orrs	r2, r3
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400fbf4:	683b      	ldr	r3, [r7, #0]
2400fbf6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fbf8:	3b01      	subs	r3, #1
2400fbfa:	049b      	lsls	r3, r3, #18
        pNodeConfig->Init.DestBurst                                             | \
2400fbfc:	431a      	orrs	r2, r3
            pNodeConfig->Init.TransferTriggerMode;
2400fbfe:	683b      	ldr	r3, [r7, #0]
2400fc00:	685b      	ldr	r3, [r3, #4]
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400fc02:	431a      	orrs	r2, r3
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400fc04:	687b      	ldr	r3, [r7, #4]
2400fc06:	601a      	str	r2, [r3, #0]

  /* If SW request set the CTCR register to SW Request Mode*/
  if(pNodeConfig->Init.Request == MDMA_REQUEST_SW)
2400fc08:	683b      	ldr	r3, [r7, #0]
2400fc0a:	681b      	ldr	r3, [r3, #0]
2400fc0c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400fc10:	d105      	bne.n	2400fc1e <HAL_MDMA_LinkedList_CreateNode+0x8a>
  {
    pNode->CTCR |= MDMA_CTCR_SWRM;
2400fc12:	687b      	ldr	r3, [r7, #4]
2400fc14:	681b      	ldr	r3, [r3, #0]
2400fc16:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
2400fc1a:	687b      	ldr	r3, [r7, #4]
2400fc1c:	601a      	str	r2, [r3, #0]
  -If the request is done by SW : BWM could be set to 1 or 0.
  -If the request is done by a peripheral :
     If mask address not set (0) => BWM must be set to 0
     If mask address set (different than 0) => BWM could be set to 1 or 0
  */
  if((pNodeConfig->Init.Request == MDMA_REQUEST_SW) || (pNodeConfig->PostRequestMaskAddress != 0U))
2400fc1e:	683b      	ldr	r3, [r7, #0]
2400fc20:	681b      	ldr	r3, [r3, #0]
2400fc22:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400fc26:	d003      	beq.n	2400fc30 <HAL_MDMA_LinkedList_CreateNode+0x9c>
2400fc28:	683b      	ldr	r3, [r7, #0]
2400fc2a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400fc2c:	2b00      	cmp	r3, #0
2400fc2e:	d005      	beq.n	2400fc3c <HAL_MDMA_LinkedList_CreateNode+0xa8>
  {
    pNode->CTCR |=  MDMA_CTCR_BWM;
2400fc30:	687b      	ldr	r3, [r7, #4]
2400fc32:	681b      	ldr	r3, [r3, #0]
2400fc34:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
2400fc38:	687b      	ldr	r3, [r7, #4]
2400fc3a:	601a      	str	r2, [r3, #0]
  }

  /* Set the new CBNDTR Register value */
  pNode->CBNDTR = ((pNodeConfig->BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC;
2400fc3c:	683b      	ldr	r3, [r7, #0]
2400fc3e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400fc40:	3b01      	subs	r3, #1
2400fc42:	051a      	lsls	r2, r3, #20
2400fc44:	687b      	ldr	r3, [r7, #4]
2400fc46:	605a      	str	r2, [r3, #4]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(pNodeConfig->Init.SourceBlockAddressOffset < 0)
2400fc48:	683b      	ldr	r3, [r7, #0]
2400fc4a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400fc4c:	2b00      	cmp	r3, #0
2400fc4e:	da0e      	bge.n	2400fc6e <HAL_MDMA_LinkedList_CreateNode+0xda>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRSUM;
2400fc50:	687b      	ldr	r3, [r7, #4]
2400fc52:	685b      	ldr	r3, [r3, #4]
2400fc54:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
2400fc58:	687b      	ldr	r3, [r7, #4]
2400fc5a:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.SourceBlockAddressOffset);
2400fc5c:	683b      	ldr	r3, [r7, #0]
2400fc5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400fc60:	425b      	negs	r3, r3
2400fc62:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR = blockoffset & 0x0000FFFFU;
2400fc64:	68fb      	ldr	r3, [r7, #12]
2400fc66:	b29a      	uxth	r2, r3
2400fc68:	687b      	ldr	r3, [r7, #4]
2400fc6a:	611a      	str	r2, [r3, #16]
2400fc6c:	e004      	b.n	2400fc78 <HAL_MDMA_LinkedList_CreateNode+0xe4>
  }
  else
  {
    /*write new CBRUR Register value : source repeat block offset */
    pNode->CBRUR = (((uint32_t) pNodeConfig->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
2400fc6e:	683b      	ldr	r3, [r7, #0]
2400fc70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400fc72:	b29a      	uxth	r2, r3
2400fc74:	687b      	ldr	r3, [r7, #4]
2400fc76:	611a      	str	r2, [r3, #16]
  }

  /* if block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(pNodeConfig->Init.DestBlockAddressOffset < 0)
2400fc78:	683b      	ldr	r3, [r7, #0]
2400fc7a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400fc7c:	2b00      	cmp	r3, #0
2400fc7e:	da11      	bge.n	2400fca4 <HAL_MDMA_LinkedList_CreateNode+0x110>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRDUM;
2400fc80:	687b      	ldr	r3, [r7, #4]
2400fc82:	685b      	ldr	r3, [r3, #4]
2400fc84:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
2400fc88:	687b      	ldr	r3, [r7, #4]
2400fc8a:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.DestBlockAddressOffset);
2400fc8c:	683b      	ldr	r3, [r7, #0]
2400fc8e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400fc90:	425b      	negs	r3, r3
2400fc92:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400fc94:	687b      	ldr	r3, [r7, #4]
2400fc96:	691a      	ldr	r2, [r3, #16]
2400fc98:	68fb      	ldr	r3, [r7, #12]
2400fc9a:	041b      	lsls	r3, r3, #16
2400fc9c:	431a      	orrs	r2, r3
2400fc9e:	687b      	ldr	r3, [r7, #4]
2400fca0:	611a      	str	r2, [r3, #16]
2400fca2:	e007      	b.n	2400fcb4 <HAL_MDMA_LinkedList_CreateNode+0x120>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400fca4:	687b      	ldr	r3, [r7, #4]
2400fca6:	691a      	ldr	r2, [r3, #16]
2400fca8:	683b      	ldr	r3, [r7, #0]
2400fcaa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400fcac:	041b      	lsls	r3, r3, #16
2400fcae:	431a      	orrs	r2, r3
2400fcb0:	687b      	ldr	r3, [r7, #4]
2400fcb2:	611a      	str	r2, [r3, #16]
  }

  /* Configure MDMA Link Node data length */
  pNode->CBNDTR |=  pNodeConfig->BlockDataLength;
2400fcb4:	687b      	ldr	r3, [r7, #4]
2400fcb6:	685a      	ldr	r2, [r3, #4]
2400fcb8:	683b      	ldr	r3, [r7, #0]
2400fcba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400fcbc:	431a      	orrs	r2, r3
2400fcbe:	687b      	ldr	r3, [r7, #4]
2400fcc0:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Link Node destination address */
  pNode->CDAR = pNodeConfig->DstAddress;
2400fcc2:	683b      	ldr	r3, [r7, #0]
2400fcc4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2400fcc6:	687b      	ldr	r3, [r7, #4]
2400fcc8:	60da      	str	r2, [r3, #12]

  /* Configure MDMA Link Node Source address */
  pNode->CSAR = pNodeConfig->SrcAddress;
2400fcca:	683b      	ldr	r3, [r7, #0]
2400fccc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
2400fcce:	687b      	ldr	r3, [r7, #4]
2400fcd0:	609a      	str	r2, [r3, #8]

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData,  */
  if(pNodeConfig->Init.Request != MDMA_REQUEST_SW)
2400fcd2:	683b      	ldr	r3, [r7, #0]
2400fcd4:	681b      	ldr	r3, [r3, #0]
2400fcd6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400fcda:	d00c      	beq.n	2400fcf6 <HAL_MDMA_LinkedList_CreateNode+0x162>
  {
    /* Set the HW request in CTBR register  */
    pNode->CTBR = pNodeConfig->Init.Request & MDMA_CTBR_TSEL;
2400fcdc:	683b      	ldr	r3, [r7, #0]
2400fcde:	681b      	ldr	r3, [r3, #0]
2400fce0:	b2da      	uxtb	r2, r3
2400fce2:	687b      	ldr	r3, [r7, #4]
2400fce4:	619a      	str	r2, [r3, #24]
    /* Set the HW request clear Mask and Data */
    pNode->CMAR = pNodeConfig->PostRequestMaskAddress;
2400fce6:	683b      	ldr	r3, [r7, #0]
2400fce8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
2400fcea:	687b      	ldr	r3, [r7, #4]
2400fcec:	621a      	str	r2, [r3, #32]
    pNode->CMDR = pNodeConfig->PostRequestMaskData;
2400fcee:	683b      	ldr	r3, [r7, #0]
2400fcf0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
2400fcf2:	687b      	ldr	r3, [r7, #4]
2400fcf4:	625a      	str	r2, [r3, #36]	; 0x24
  }

  addressMask = pNodeConfig->SrcAddress & 0xFF000000U;
2400fcf6:	683b      	ldr	r3, [r7, #0]
2400fcf8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400fcfa:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400fcfe:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400fd00:	68bb      	ldr	r3, [r7, #8]
2400fd02:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400fd06:	d002      	beq.n	2400fd0e <HAL_MDMA_LinkedList_CreateNode+0x17a>
2400fd08:	68bb      	ldr	r3, [r7, #8]
2400fd0a:	2b00      	cmp	r3, #0
2400fd0c:	d105      	bne.n	2400fd1a <HAL_MDMA_LinkedList_CreateNode+0x186>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_SBUS;
2400fd0e:	687b      	ldr	r3, [r7, #4]
2400fd10:	699b      	ldr	r3, [r3, #24]
2400fd12:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
2400fd16:	687b      	ldr	r3, [r7, #4]
2400fd18:	619a      	str	r2, [r3, #24]
  }

  addressMask = pNodeConfig->DstAddress & 0xFF000000U;
2400fd1a:	683b      	ldr	r3, [r7, #0]
2400fd1c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400fd1e:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400fd22:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400fd24:	68bb      	ldr	r3, [r7, #8]
2400fd26:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400fd2a:	d002      	beq.n	2400fd32 <HAL_MDMA_LinkedList_CreateNode+0x19e>
2400fd2c:	68bb      	ldr	r3, [r7, #8]
2400fd2e:	2b00      	cmp	r3, #0
2400fd30:	d105      	bne.n	2400fd3e <HAL_MDMA_LinkedList_CreateNode+0x1aa>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_DBUS;
2400fd32:	687b      	ldr	r3, [r7, #4]
2400fd34:	699b      	ldr	r3, [r3, #24]
2400fd36:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
2400fd3a:	687b      	ldr	r3, [r7, #4]
2400fd3c:	619a      	str	r2, [r3, #24]
  }

  return HAL_OK;
2400fd3e:	2300      	movs	r3, #0
}
2400fd40:	4618      	mov	r0, r3
2400fd42:	3714      	adds	r7, #20
2400fd44:	46bd      	mov	sp, r7
2400fd46:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fd4a:	4770      	bx	lr

2400fd4c <HAL_MDMA_LinkedList_AddNode>:
  *                    at the end of the list
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_AddNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNewNode, MDMA_LinkNodeTypeDef *pPrevNode)
{
2400fd4c:	b480      	push	{r7}
2400fd4e:	b089      	sub	sp, #36	; 0x24
2400fd50:	af00      	add	r7, sp, #0
2400fd52:	60f8      	str	r0, [r7, #12]
2400fd54:	60b9      	str	r1, [r7, #8]
2400fd56:	607a      	str	r2, [r7, #4]
  MDMA_LinkNodeTypeDef *pNode;
  uint32_t counter = 0, nodeInserted = 0;
2400fd58:	2300      	movs	r3, #0
2400fd5a:	61bb      	str	r3, [r7, #24]
2400fd5c:	2300      	movs	r3, #0
2400fd5e:	617b      	str	r3, [r7, #20]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400fd60:	2300      	movs	r3, #0
2400fd62:	74fb      	strb	r3, [r7, #19]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNewNode == NULL))
2400fd64:	68fb      	ldr	r3, [r7, #12]
2400fd66:	2b00      	cmp	r3, #0
2400fd68:	d002      	beq.n	2400fd70 <HAL_MDMA_LinkedList_AddNode+0x24>
2400fd6a:	68bb      	ldr	r3, [r7, #8]
2400fd6c:	2b00      	cmp	r3, #0
2400fd6e:	d101      	bne.n	2400fd74 <HAL_MDMA_LinkedList_AddNode+0x28>
  {
    return HAL_ERROR;
2400fd70:	2301      	movs	r3, #1
2400fd72:	e0a9      	b.n	2400fec8 <HAL_MDMA_LinkedList_AddNode+0x17c>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fd74:	68fb      	ldr	r3, [r7, #12]
2400fd76:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fd7a:	2b01      	cmp	r3, #1
2400fd7c:	d101      	bne.n	2400fd82 <HAL_MDMA_LinkedList_AddNode+0x36>
2400fd7e:	2302      	movs	r3, #2
2400fd80:	e0a2      	b.n	2400fec8 <HAL_MDMA_LinkedList_AddNode+0x17c>
2400fd82:	68fb      	ldr	r3, [r7, #12]
2400fd84:	2201      	movs	r2, #1
2400fd86:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fd8a:	68fb      	ldr	r3, [r7, #12]
2400fd8c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400fd90:	b2db      	uxtb	r3, r3
2400fd92:	2b01      	cmp	r3, #1
2400fd94:	f040 8093 	bne.w	2400febe <HAL_MDMA_LinkedList_AddNode+0x172>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400fd98:	68fb      	ldr	r3, [r7, #12]
2400fd9a:	2202      	movs	r2, #2
2400fd9c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Check if this is the first node (after the Inititlization node) */
    if((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U)
2400fda0:	68fb      	ldr	r3, [r7, #12]
2400fda2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fda4:	2b00      	cmp	r3, #0
2400fda6:	d116      	bne.n	2400fdd6 <HAL_MDMA_LinkedList_AddNode+0x8a>
    {
      if(pPrevNode == NULL)
2400fda8:	687b      	ldr	r3, [r7, #4]
2400fdaa:	2b00      	cmp	r3, #0
2400fdac:	d110      	bne.n	2400fdd0 <HAL_MDMA_LinkedList_AddNode+0x84>
      {
        /* if this is the first node after the initialization
        connect this node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = (uint32_t)pNewNode;
2400fdae:	68fb      	ldr	r3, [r7, #12]
2400fdb0:	681b      	ldr	r3, [r3, #0]
2400fdb2:	68ba      	ldr	r2, [r7, #8]
2400fdb4:	625a      	str	r2, [r3, #36]	; 0x24
        /* Set the MDMA handle First linked List node*/
        hmdma->FirstLinkedListNodeAddress = pNewNode;
2400fdb6:	68fb      	ldr	r3, [r7, #12]
2400fdb8:	68ba      	ldr	r2, [r7, #8]
2400fdba:	65da      	str	r2, [r3, #92]	; 0x5c

        /*reset New node link */
        pNewNode->CLAR = 0;
2400fdbc:	68bb      	ldr	r3, [r7, #8]
2400fdbe:	2200      	movs	r2, #0
2400fdc0:	615a      	str	r2, [r3, #20]

        /* Update the Handle last node address */
        hmdma->LastLinkedListNodeAddress = pNewNode;
2400fdc2:	68fb      	ldr	r3, [r7, #12]
2400fdc4:	68ba      	ldr	r2, [r7, #8]
2400fdc6:	661a      	str	r2, [r3, #96]	; 0x60

        hmdma->LinkedListNodeCounter = 1;
2400fdc8:	68fb      	ldr	r3, [r7, #12]
2400fdca:	2201      	movs	r2, #1
2400fdcc:	665a      	str	r2, [r3, #100]	; 0x64
2400fdce:	e06c      	b.n	2400feaa <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
      else
      {
        hal_status = HAL_ERROR;
2400fdd0:	2301      	movs	r3, #1
2400fdd2:	74fb      	strb	r3, [r7, #19]
2400fdd4:	e069      	b.n	2400feaa <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
    }
    else if(hmdma->FirstLinkedListNodeAddress != pNewNode)
2400fdd6:	68fb      	ldr	r3, [r7, #12]
2400fdd8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fdda:	68ba      	ldr	r2, [r7, #8]
2400fddc:	429a      	cmp	r2, r3
2400fdde:	d062      	beq.n	2400fea6 <HAL_MDMA_LinkedList_AddNode+0x15a>
    {
      /* Check if the node to insert already exists*/
      pNode = hmdma->FirstLinkedListNodeAddress;
2400fde0:	68fb      	ldr	r3, [r7, #12]
2400fde2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fde4:	61fb      	str	r3, [r7, #28]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
2400fde6:	e00c      	b.n	2400fe02 <HAL_MDMA_LinkedList_AddNode+0xb6>
      {
        if(pNode->CLAR == (uint32_t)pNewNode)
2400fde8:	69fb      	ldr	r3, [r7, #28]
2400fdea:	695a      	ldr	r2, [r3, #20]
2400fdec:	68bb      	ldr	r3, [r7, #8]
2400fdee:	429a      	cmp	r2, r3
2400fdf0:	d101      	bne.n	2400fdf6 <HAL_MDMA_LinkedList_AddNode+0xaa>
        {
          hal_status = HAL_ERROR; /* error this node already exist in the linked list and it is not first node */
2400fdf2:	2301      	movs	r3, #1
2400fdf4:	74fb      	strb	r3, [r7, #19]
        }
        pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2400fdf6:	69fb      	ldr	r3, [r7, #28]
2400fdf8:	695b      	ldr	r3, [r3, #20]
2400fdfa:	61fb      	str	r3, [r7, #28]
        counter++;
2400fdfc:	69bb      	ldr	r3, [r7, #24]
2400fdfe:	3301      	adds	r3, #1
2400fe00:	61bb      	str	r3, [r7, #24]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
2400fe02:	68fb      	ldr	r3, [r7, #12]
2400fe04:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fe06:	69ba      	ldr	r2, [r7, #24]
2400fe08:	429a      	cmp	r2, r3
2400fe0a:	d202      	bcs.n	2400fe12 <HAL_MDMA_LinkedList_AddNode+0xc6>
2400fe0c:	7cfb      	ldrb	r3, [r7, #19]
2400fe0e:	2b00      	cmp	r3, #0
2400fe10:	d0ea      	beq.n	2400fde8 <HAL_MDMA_LinkedList_AddNode+0x9c>
      }

      if(hal_status == HAL_OK)
2400fe12:	7cfb      	ldrb	r3, [r7, #19]
2400fe14:	2b00      	cmp	r3, #0
2400fe16:	d148      	bne.n	2400feaa <HAL_MDMA_LinkedList_AddNode+0x15e>
      {
        /* Check if the previous node is the last one in the current list or zero */
        if((pPrevNode == hmdma->LastLinkedListNodeAddress) || (pPrevNode == NULL))
2400fe18:	68fb      	ldr	r3, [r7, #12]
2400fe1a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fe1c:	687a      	ldr	r2, [r7, #4]
2400fe1e:	429a      	cmp	r2, r3
2400fe20:	d002      	beq.n	2400fe28 <HAL_MDMA_LinkedList_AddNode+0xdc>
2400fe22:	687b      	ldr	r3, [r7, #4]
2400fe24:	2b00      	cmp	r3, #0
2400fe26:	d111      	bne.n	2400fe4c <HAL_MDMA_LinkedList_AddNode+0x100>
        {
          /* insert the new node at the end of the list */
          pNewNode->CLAR = hmdma->LastLinkedListNodeAddress->CLAR;
2400fe28:	68fb      	ldr	r3, [r7, #12]
2400fe2a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fe2c:	695a      	ldr	r2, [r3, #20]
2400fe2e:	68bb      	ldr	r3, [r7, #8]
2400fe30:	615a      	str	r2, [r3, #20]
          hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)pNewNode;
2400fe32:	68fb      	ldr	r3, [r7, #12]
2400fe34:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fe36:	68ba      	ldr	r2, [r7, #8]
2400fe38:	615a      	str	r2, [r3, #20]
          /* Update the Handle last node address */
          hmdma->LastLinkedListNodeAddress = pNewNode;
2400fe3a:	68fb      	ldr	r3, [r7, #12]
2400fe3c:	68ba      	ldr	r2, [r7, #8]
2400fe3e:	661a      	str	r2, [r3, #96]	; 0x60
          /* Increment the linked list node counter */
          hmdma->LinkedListNodeCounter++;
2400fe40:	68fb      	ldr	r3, [r7, #12]
2400fe42:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fe44:	1c5a      	adds	r2, r3, #1
2400fe46:	68fb      	ldr	r3, [r7, #12]
2400fe48:	665a      	str	r2, [r3, #100]	; 0x64
2400fe4a:	e02e      	b.n	2400feaa <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
        else
        {
          /*insert the new node after the pPreviousNode node */
          pNode = hmdma->FirstLinkedListNodeAddress;
2400fe4c:	68fb      	ldr	r3, [r7, #12]
2400fe4e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fe50:	61fb      	str	r3, [r7, #28]
          counter = 0;
2400fe52:	2300      	movs	r3, #0
2400fe54:	61bb      	str	r3, [r7, #24]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2400fe56:	e018      	b.n	2400fe8a <HAL_MDMA_LinkedList_AddNode+0x13e>
          {
            counter++;
2400fe58:	69bb      	ldr	r3, [r7, #24]
2400fe5a:	3301      	adds	r3, #1
2400fe5c:	61bb      	str	r3, [r7, #24]
            if(pNode == pPrevNode)
2400fe5e:	69fa      	ldr	r2, [r7, #28]
2400fe60:	687b      	ldr	r3, [r7, #4]
2400fe62:	429a      	cmp	r2, r3
2400fe64:	d10e      	bne.n	2400fe84 <HAL_MDMA_LinkedList_AddNode+0x138>
            {
              /*Insert the new node after the previous one */
              pNewNode->CLAR = pNode->CLAR;
2400fe66:	69fb      	ldr	r3, [r7, #28]
2400fe68:	695a      	ldr	r2, [r3, #20]
2400fe6a:	68bb      	ldr	r3, [r7, #8]
2400fe6c:	615a      	str	r2, [r3, #20]
              pNode->CLAR = (uint32_t)pNewNode;
2400fe6e:	68ba      	ldr	r2, [r7, #8]
2400fe70:	69fb      	ldr	r3, [r7, #28]
2400fe72:	615a      	str	r2, [r3, #20]
              /* Increment the linked list node counter */
              hmdma->LinkedListNodeCounter++;
2400fe74:	68fb      	ldr	r3, [r7, #12]
2400fe76:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fe78:	1c5a      	adds	r2, r3, #1
2400fe7a:	68fb      	ldr	r3, [r7, #12]
2400fe7c:	665a      	str	r2, [r3, #100]	; 0x64
              nodeInserted = 1;
2400fe7e:	2301      	movs	r3, #1
2400fe80:	617b      	str	r3, [r7, #20]
2400fe82:	e002      	b.n	2400fe8a <HAL_MDMA_LinkedList_AddNode+0x13e>
            }
            else
            {
              pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2400fe84:	69fb      	ldr	r3, [r7, #28]
2400fe86:	695b      	ldr	r3, [r3, #20]
2400fe88:	61fb      	str	r3, [r7, #28]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2400fe8a:	68fb      	ldr	r3, [r7, #12]
2400fe8c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fe8e:	69ba      	ldr	r2, [r7, #24]
2400fe90:	429a      	cmp	r2, r3
2400fe92:	d202      	bcs.n	2400fe9a <HAL_MDMA_LinkedList_AddNode+0x14e>
2400fe94:	697b      	ldr	r3, [r7, #20]
2400fe96:	2b00      	cmp	r3, #0
2400fe98:	d0de      	beq.n	2400fe58 <HAL_MDMA_LinkedList_AddNode+0x10c>
            }
          }

          if(nodeInserted == 0U)
2400fe9a:	697b      	ldr	r3, [r7, #20]
2400fe9c:	2b00      	cmp	r3, #0
2400fe9e:	d104      	bne.n	2400feaa <HAL_MDMA_LinkedList_AddNode+0x15e>
          {
            hal_status = HAL_ERROR;
2400fea0:	2301      	movs	r3, #1
2400fea2:	74fb      	strb	r3, [r7, #19]
2400fea4:	e001      	b.n	2400feaa <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
      }
    }
    else
    {
      hal_status = HAL_ERROR;
2400fea6:	2301      	movs	r3, #1
2400fea8:	74fb      	strb	r3, [r7, #19]
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400feaa:	68fb      	ldr	r3, [r7, #12]
2400feac:	2200      	movs	r2, #0
2400feae:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400feb2:	68fb      	ldr	r3, [r7, #12]
2400feb4:	2201      	movs	r2, #1
2400feb6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
2400feba:	7cfb      	ldrb	r3, [r7, #19]
2400febc:	e004      	b.n	2400fec8 <HAL_MDMA_LinkedList_AddNode+0x17c>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400febe:	68fb      	ldr	r3, [r7, #12]
2400fec0:	2200      	movs	r2, #0
2400fec2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400fec6:	2302      	movs	r3, #2
  }
}
2400fec8:	4618      	mov	r0, r3
2400feca:	3724      	adds	r7, #36	; 0x24
2400fecc:	46bd      	mov	sp, r7
2400fece:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fed2:	4770      	bx	lr

2400fed4 <HAL_MDMA_LinkedList_RemoveNode>:
  *                 to be removed from the list.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_RemoveNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNode)
{
2400fed4:	b480      	push	{r7}
2400fed6:	b087      	sub	sp, #28
2400fed8:	af00      	add	r7, sp, #0
2400feda:	6078      	str	r0, [r7, #4]
2400fedc:	6039      	str	r1, [r7, #0]
  MDMA_LinkNodeTypeDef *ptmpNode;
  uint32_t counter = 0, nodeDeleted = 0;
2400fede:	2300      	movs	r3, #0
2400fee0:	613b      	str	r3, [r7, #16]
2400fee2:	2300      	movs	r3, #0
2400fee4:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400fee6:	2300      	movs	r3, #0
2400fee8:	72fb      	strb	r3, [r7, #11]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNode == NULL))
2400feea:	687b      	ldr	r3, [r7, #4]
2400feec:	2b00      	cmp	r3, #0
2400feee:	d002      	beq.n	2400fef6 <HAL_MDMA_LinkedList_RemoveNode+0x22>
2400fef0:	683b      	ldr	r3, [r7, #0]
2400fef2:	2b00      	cmp	r3, #0
2400fef4:	d101      	bne.n	2400fefa <HAL_MDMA_LinkedList_RemoveNode+0x26>
  {
    return HAL_ERROR;
2400fef6:	2301      	movs	r3, #1
2400fef8:	e099      	b.n	2401002e <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fefa:	687b      	ldr	r3, [r7, #4]
2400fefc:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400ff00:	2b01      	cmp	r3, #1
2400ff02:	d101      	bne.n	2400ff08 <HAL_MDMA_LinkedList_RemoveNode+0x34>
2400ff04:	2302      	movs	r3, #2
2400ff06:	e092      	b.n	2401002e <HAL_MDMA_LinkedList_RemoveNode+0x15a>
2400ff08:	687b      	ldr	r3, [r7, #4]
2400ff0a:	2201      	movs	r2, #1
2400ff0c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400ff10:	687b      	ldr	r3, [r7, #4]
2400ff12:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ff16:	b2db      	uxtb	r3, r3
2400ff18:	2b01      	cmp	r3, #1
2400ff1a:	f040 8083 	bne.w	24010024 <HAL_MDMA_LinkedList_RemoveNode+0x150>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400ff1e:	687b      	ldr	r3, [r7, #4]
2400ff20:	2202      	movs	r2, #2
2400ff22:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400ff26:	687b      	ldr	r3, [r7, #4]
2400ff28:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400ff2a:	2b00      	cmp	r3, #0
2400ff2c:	d007      	beq.n	2400ff3e <HAL_MDMA_LinkedList_RemoveNode+0x6a>
2400ff2e:	687b      	ldr	r3, [r7, #4]
2400ff30:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400ff32:	2b00      	cmp	r3, #0
2400ff34:	d003      	beq.n	2400ff3e <HAL_MDMA_LinkedList_RemoveNode+0x6a>
2400ff36:	687b      	ldr	r3, [r7, #4]
2400ff38:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400ff3a:	2b00      	cmp	r3, #0
2400ff3c:	d102      	bne.n	2400ff44 <HAL_MDMA_LinkedList_RemoveNode+0x70>
    {
      hal_status = HAL_ERROR;
2400ff3e:	2301      	movs	r3, #1
2400ff40:	72fb      	strb	r3, [r7, #11]
2400ff42:	e065      	b.n	24010010 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
    }
    else if(hmdma->FirstLinkedListNodeAddress == pNode) /* Deleting first node */
2400ff44:	687b      	ldr	r3, [r7, #4]
2400ff46:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400ff48:	683a      	ldr	r2, [r7, #0]
2400ff4a:	429a      	cmp	r2, r3
2400ff4c:	d130      	bne.n	2400ffb0 <HAL_MDMA_LinkedList_RemoveNode+0xdc>
    {
      /* Delete 1st node */
      if(hmdma->LastLinkedListNodeAddress == pNode)
2400ff4e:	687b      	ldr	r3, [r7, #4]
2400ff50:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400ff52:	683a      	ldr	r2, [r7, #0]
2400ff54:	429a      	cmp	r2, r3
2400ff56:	d10d      	bne.n	2400ff74 <HAL_MDMA_LinkedList_RemoveNode+0xa0>
      {
        /*if the last node is at the same time the first one (1 single node after the init node 0)
        then update the last node too */

        hmdma->FirstLinkedListNodeAddress = 0;
2400ff58:	687b      	ldr	r3, [r7, #4]
2400ff5a:	2200      	movs	r2, #0
2400ff5c:	65da      	str	r2, [r3, #92]	; 0x5c
        hmdma->LastLinkedListNodeAddress  = 0;
2400ff5e:	687b      	ldr	r3, [r7, #4]
2400ff60:	2200      	movs	r2, #0
2400ff62:	661a      	str	r2, [r3, #96]	; 0x60
        hmdma->LinkedListNodeCounter = 0;
2400ff64:	687b      	ldr	r3, [r7, #4]
2400ff66:	2200      	movs	r2, #0
2400ff68:	665a      	str	r2, [r3, #100]	; 0x64

        hmdma->Instance->CLAR = 0;
2400ff6a:	687b      	ldr	r3, [r7, #4]
2400ff6c:	681b      	ldr	r3, [r3, #0]
2400ff6e:	2200      	movs	r2, #0
2400ff70:	625a      	str	r2, [r3, #36]	; 0x24
2400ff72:	e04d      	b.n	24010010 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
      else
      {
        if((uint32_t)hmdma->FirstLinkedListNodeAddress == hmdma->LastLinkedListNodeAddress->CLAR)
2400ff74:	687b      	ldr	r3, [r7, #4]
2400ff76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400ff78:	461a      	mov	r2, r3
2400ff7a:	687b      	ldr	r3, [r7, #4]
2400ff7c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400ff7e:	695b      	ldr	r3, [r3, #20]
2400ff80:	429a      	cmp	r2, r3
2400ff82:	d104      	bne.n	2400ff8e <HAL_MDMA_LinkedList_RemoveNode+0xba>
        {
          /* if last node is looping to first (circular list) one update the last node connection */
          hmdma->LastLinkedListNodeAddress->CLAR = pNode->CLAR;
2400ff84:	687b      	ldr	r3, [r7, #4]
2400ff86:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400ff88:	683a      	ldr	r2, [r7, #0]
2400ff8a:	6952      	ldr	r2, [r2, #20]
2400ff8c:	615a      	str	r2, [r3, #20]
        }

        /* if deleting the first node after the initialization
        connect the next node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = pNode->CLAR;
2400ff8e:	687b      	ldr	r3, [r7, #4]
2400ff90:	681b      	ldr	r3, [r3, #0]
2400ff92:	683a      	ldr	r2, [r7, #0]
2400ff94:	6952      	ldr	r2, [r2, #20]
2400ff96:	625a      	str	r2, [r3, #36]	; 0x24
        hmdma->FirstLinkedListNodeAddress = (MDMA_LinkNodeTypeDef *)hmdma->Instance->CLAR;
2400ff98:	687b      	ldr	r3, [r7, #4]
2400ff9a:	681b      	ldr	r3, [r3, #0]
2400ff9c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400ff9e:	461a      	mov	r2, r3
2400ffa0:	687b      	ldr	r3, [r7, #4]
2400ffa2:	65da      	str	r2, [r3, #92]	; 0x5c
        /* Update the Handle node counter */
        hmdma->LinkedListNodeCounter--;
2400ffa4:	687b      	ldr	r3, [r7, #4]
2400ffa6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400ffa8:	1e5a      	subs	r2, r3, #1
2400ffaa:	687b      	ldr	r3, [r7, #4]
2400ffac:	665a      	str	r2, [r3, #100]	; 0x64
2400ffae:	e02f      	b.n	24010010 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
    }
    else /* Deleting any other node */
    {
      /*Deleted node is not the first one : find it  */
      ptmpNode = hmdma->FirstLinkedListNodeAddress;
2400ffb0:	687b      	ldr	r3, [r7, #4]
2400ffb2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400ffb4:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2400ffb6:	e01e      	b.n	2400fff6 <HAL_MDMA_LinkedList_RemoveNode+0x122>
      {
        counter++;
2400ffb8:	693b      	ldr	r3, [r7, #16]
2400ffba:	3301      	adds	r3, #1
2400ffbc:	613b      	str	r3, [r7, #16]
        if(ptmpNode->CLAR == ((uint32_t)pNode))
2400ffbe:	697b      	ldr	r3, [r7, #20]
2400ffc0:	695a      	ldr	r2, [r3, #20]
2400ffc2:	683b      	ldr	r3, [r7, #0]
2400ffc4:	429a      	cmp	r2, r3
2400ffc6:	d113      	bne.n	2400fff0 <HAL_MDMA_LinkedList_RemoveNode+0x11c>
        {
          /* if deleting the last node */
          if(pNode == hmdma->LastLinkedListNodeAddress)
2400ffc8:	687b      	ldr	r3, [r7, #4]
2400ffca:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400ffcc:	683a      	ldr	r2, [r7, #0]
2400ffce:	429a      	cmp	r2, r3
2400ffd0:	d102      	bne.n	2400ffd8 <HAL_MDMA_LinkedList_RemoveNode+0x104>
          {
            /*Update the linked list last node address in the handle*/
            hmdma->LastLinkedListNodeAddress = ptmpNode;
2400ffd2:	687b      	ldr	r3, [r7, #4]
2400ffd4:	697a      	ldr	r2, [r7, #20]
2400ffd6:	661a      	str	r2, [r3, #96]	; 0x60
          }
          /* update the next node link after deleting pMDMA_LinkedListNode */
          ptmpNode->CLAR = pNode->CLAR;
2400ffd8:	683b      	ldr	r3, [r7, #0]
2400ffda:	695a      	ldr	r2, [r3, #20]
2400ffdc:	697b      	ldr	r3, [r7, #20]
2400ffde:	615a      	str	r2, [r3, #20]
          nodeDeleted = 1;
2400ffe0:	2301      	movs	r3, #1
2400ffe2:	60fb      	str	r3, [r7, #12]
          /* Update the Handle node counter */
          hmdma->LinkedListNodeCounter--;
2400ffe4:	687b      	ldr	r3, [r7, #4]
2400ffe6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400ffe8:	1e5a      	subs	r2, r3, #1
2400ffea:	687b      	ldr	r3, [r7, #4]
2400ffec:	665a      	str	r2, [r3, #100]	; 0x64
2400ffee:	e002      	b.n	2400fff6 <HAL_MDMA_LinkedList_RemoveNode+0x122>
        }
        else
        {
          ptmpNode = (MDMA_LinkNodeTypeDef *)ptmpNode->CLAR;
2400fff0:	697b      	ldr	r3, [r7, #20]
2400fff2:	695b      	ldr	r3, [r3, #20]
2400fff4:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2400fff6:	687b      	ldr	r3, [r7, #4]
2400fff8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fffa:	693a      	ldr	r2, [r7, #16]
2400fffc:	429a      	cmp	r2, r3
2400fffe:	d202      	bcs.n	24010006 <HAL_MDMA_LinkedList_RemoveNode+0x132>
24010000:	68fb      	ldr	r3, [r7, #12]
24010002:	2b00      	cmp	r3, #0
24010004:	d0d8      	beq.n	2400ffb8 <HAL_MDMA_LinkedList_RemoveNode+0xe4>
        }
      }

      if(nodeDeleted == 0U)
24010006:	68fb      	ldr	r3, [r7, #12]
24010008:	2b00      	cmp	r3, #0
2401000a:	d101      	bne.n	24010010 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      {
        /* last node reashed without finding the node to delete : return error */
        hal_status = HAL_ERROR;
2401000c:	2301      	movs	r3, #1
2401000e:	72fb      	strb	r3, [r7, #11]
      }
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
24010010:	687b      	ldr	r3, [r7, #4]
24010012:	2200      	movs	r2, #0
24010014:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
24010018:	687b      	ldr	r3, [r7, #4]
2401001a:	2201      	movs	r2, #1
2401001c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
24010020:	7afb      	ldrb	r3, [r7, #11]
24010022:	e004      	b.n	2401002e <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
24010024:	687b      	ldr	r3, [r7, #4]
24010026:	2200      	movs	r2, #0
24010028:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2401002c:	2302      	movs	r3, #2
  }
}
2401002e:	4618      	mov	r0, r3
24010030:	371c      	adds	r7, #28
24010032:	46bd      	mov	sp, r7
24010034:	f85d 7b04 	ldr.w	r7, [sp], #4
24010038:	4770      	bx	lr

2401003a <HAL_MDMA_LinkedList_EnableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_EnableCircularMode(MDMA_HandleTypeDef *hmdma)
{
2401003a:	b480      	push	{r7}
2401003c:	b085      	sub	sp, #20
2401003e:	af00      	add	r7, sp, #0
24010040:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
24010042:	2300      	movs	r3, #0
24010044:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
24010046:	687b      	ldr	r3, [r7, #4]
24010048:	2b00      	cmp	r3, #0
2401004a:	d101      	bne.n	24010050 <HAL_MDMA_LinkedList_EnableCircularMode+0x16>
  {
    return HAL_ERROR;
2401004c:	2301      	movs	r3, #1
2401004e:	e031      	b.n	240100b4 <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
24010050:	687b      	ldr	r3, [r7, #4]
24010052:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
24010056:	2b01      	cmp	r3, #1
24010058:	d101      	bne.n	2401005e <HAL_MDMA_LinkedList_EnableCircularMode+0x24>
2401005a:	2302      	movs	r3, #2
2401005c:	e02a      	b.n	240100b4 <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
2401005e:	687b      	ldr	r3, [r7, #4]
24010060:	2201      	movs	r2, #1
24010062:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
24010066:	687b      	ldr	r3, [r7, #4]
24010068:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401006c:	b2db      	uxtb	r3, r3
2401006e:	2b01      	cmp	r3, #1
24010070:	d117      	bne.n	240100a2 <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
24010072:	687b      	ldr	r3, [r7, #4]
24010074:	2202      	movs	r2, #2
24010076:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2401007a:	687b      	ldr	r3, [r7, #4]
2401007c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2401007e:	2b00      	cmp	r3, #0
24010080:	d007      	beq.n	24010092 <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
24010082:	687b      	ldr	r3, [r7, #4]
24010084:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24010086:	2b00      	cmp	r3, #0
24010088:	d003      	beq.n	24010092 <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
2401008a:	687b      	ldr	r3, [r7, #4]
2401008c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2401008e:	2b00      	cmp	r3, #0
24010090:	d102      	bne.n	24010098 <HAL_MDMA_LinkedList_EnableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
24010092:	2301      	movs	r3, #1
24010094:	73fb      	strb	r3, [r7, #15]
24010096:	e004      	b.n	240100a2 <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
    }
    else
    {
      /* to enable circular mode Last Node should be connected to first node */
      hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
24010098:	687b      	ldr	r3, [r7, #4]
2401009a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
2401009c:	687b      	ldr	r3, [r7, #4]
2401009e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240100a0:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
240100a2:	687b      	ldr	r3, [r7, #4]
240100a4:	2200      	movs	r2, #0
240100a6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
240100aa:	687b      	ldr	r3, [r7, #4]
240100ac:	2201      	movs	r2, #1
240100ae:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
240100b2:	7bfb      	ldrb	r3, [r7, #15]
}
240100b4:	4618      	mov	r0, r3
240100b6:	3714      	adds	r7, #20
240100b8:	46bd      	mov	sp, r7
240100ba:	f85d 7b04 	ldr.w	r7, [sp], #4
240100be:	4770      	bx	lr

240100c0 <HAL_MDMA_LinkedList_DisableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_DisableCircularMode(MDMA_HandleTypeDef *hmdma)
{
240100c0:	b480      	push	{r7}
240100c2:	b085      	sub	sp, #20
240100c4:	af00      	add	r7, sp, #0
240100c6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
240100c8:	2300      	movs	r3, #0
240100ca:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
240100cc:	687b      	ldr	r3, [r7, #4]
240100ce:	2b00      	cmp	r3, #0
240100d0:	d101      	bne.n	240100d6 <HAL_MDMA_LinkedList_DisableCircularMode+0x16>
  {
    return HAL_ERROR;
240100d2:	2301      	movs	r3, #1
240100d4:	e030      	b.n	24010138 <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
240100d6:	687b      	ldr	r3, [r7, #4]
240100d8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
240100dc:	2b01      	cmp	r3, #1
240100de:	d101      	bne.n	240100e4 <HAL_MDMA_LinkedList_DisableCircularMode+0x24>
240100e0:	2302      	movs	r3, #2
240100e2:	e029      	b.n	24010138 <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
240100e4:	687b      	ldr	r3, [r7, #4]
240100e6:	2201      	movs	r2, #1
240100e8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
240100ec:	687b      	ldr	r3, [r7, #4]
240100ee:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
240100f2:	b2db      	uxtb	r3, r3
240100f4:	2b01      	cmp	r3, #1
240100f6:	d116      	bne.n	24010126 <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
240100f8:	687b      	ldr	r3, [r7, #4]
240100fa:	2202      	movs	r2, #2
240100fc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
24010100:	687b      	ldr	r3, [r7, #4]
24010102:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24010104:	2b00      	cmp	r3, #0
24010106:	d007      	beq.n	24010118 <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
24010108:	687b      	ldr	r3, [r7, #4]
2401010a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2401010c:	2b00      	cmp	r3, #0
2401010e:	d003      	beq.n	24010118 <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
24010110:	687b      	ldr	r3, [r7, #4]
24010112:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24010114:	2b00      	cmp	r3, #0
24010116:	d102      	bne.n	2401011e <HAL_MDMA_LinkedList_DisableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
24010118:	2301      	movs	r3, #1
2401011a:	73fb      	strb	r3, [r7, #15]
2401011c:	e003      	b.n	24010126 <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
    }
    else
    {
      /* to disable circular mode Last Node should be connected to NULL */
      hmdma->LastLinkedListNodeAddress->CLAR = 0;
2401011e:	687b      	ldr	r3, [r7, #4]
24010120:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24010122:	2200      	movs	r2, #0
24010124:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
24010126:	687b      	ldr	r3, [r7, #4]
24010128:	2200      	movs	r2, #0
2401012a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
2401012e:	687b      	ldr	r3, [r7, #4]
24010130:	2201      	movs	r2, #1
24010132:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
24010136:	7bfb      	ldrb	r3, [r7, #15]
}
24010138:	4618      	mov	r0, r3
2401013a:	3714      	adds	r7, #20
2401013c:	46bd      	mov	sp, r7
2401013e:	f85d 7b04 	ldr.w	r7, [sp], #4
24010142:	4770      	bx	lr

24010144 <HAL_MDMA_Start>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
24010144:	b580      	push	{r7, lr}
24010146:	b086      	sub	sp, #24
24010148:	af02      	add	r7, sp, #8
2401014a:	60f8      	str	r0, [r7, #12]
2401014c:	60b9      	str	r1, [r7, #8]
2401014e:	607a      	str	r2, [r7, #4]
24010150:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
24010152:	68fb      	ldr	r3, [r7, #12]
24010154:	2b00      	cmp	r3, #0
24010156:	d101      	bne.n	2401015c <HAL_MDMA_Start+0x18>
  {
    return HAL_ERROR;
24010158:	2301      	movs	r3, #1
2401015a:	e044      	b.n	240101e6 <HAL_MDMA_Start+0xa2>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2401015c:	68fb      	ldr	r3, [r7, #12]
2401015e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
24010162:	2b01      	cmp	r3, #1
24010164:	d101      	bne.n	2401016a <HAL_MDMA_Start+0x26>
24010166:	2302      	movs	r3, #2
24010168:	e03d      	b.n	240101e6 <HAL_MDMA_Start+0xa2>
2401016a:	68fb      	ldr	r3, [r7, #12]
2401016c:	2201      	movs	r2, #1
2401016e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
24010172:	68fb      	ldr	r3, [r7, #12]
24010174:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24010178:	b2db      	uxtb	r3, r3
2401017a:	2b01      	cmp	r3, #1
2401017c:	d12c      	bne.n	240101d8 <HAL_MDMA_Start+0x94>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2401017e:	68fb      	ldr	r3, [r7, #12]
24010180:	2202      	movs	r2, #2
24010182:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
24010186:	68fb      	ldr	r3, [r7, #12]
24010188:	2200      	movs	r2, #0
2401018a:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
2401018c:	68fb      	ldr	r3, [r7, #12]
2401018e:	681b      	ldr	r3, [r3, #0]
24010190:	68da      	ldr	r2, [r3, #12]
24010192:	68fb      	ldr	r3, [r7, #12]
24010194:	681b      	ldr	r3, [r3, #0]
24010196:	f022 0201 	bic.w	r2, r2, #1
2401019a:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
2401019c:	69bb      	ldr	r3, [r7, #24]
2401019e:	9300      	str	r3, [sp, #0]
240101a0:	683b      	ldr	r3, [r7, #0]
240101a2:	687a      	ldr	r2, [r7, #4]
240101a4:	68b9      	ldr	r1, [r7, #8]
240101a6:	68f8      	ldr	r0, [r7, #12]
240101a8:	f000 fb96 	bl	240108d8 <MDMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
240101ac:	68fb      	ldr	r3, [r7, #12]
240101ae:	681b      	ldr	r3, [r3, #0]
240101b0:	68da      	ldr	r2, [r3, #12]
240101b2:	68fb      	ldr	r3, [r7, #12]
240101b4:	681b      	ldr	r3, [r3, #0]
240101b6:	f042 0201 	orr.w	r2, r2, #1
240101ba:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
240101bc:	68fb      	ldr	r3, [r7, #12]
240101be:	685b      	ldr	r3, [r3, #4]
240101c0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240101c4:	d10e      	bne.n	240101e4 <HAL_MDMA_Start+0xa0>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
240101c6:	68fb      	ldr	r3, [r7, #12]
240101c8:	681b      	ldr	r3, [r3, #0]
240101ca:	68da      	ldr	r2, [r3, #12]
240101cc:	68fb      	ldr	r3, [r7, #12]
240101ce:	681b      	ldr	r3, [r3, #0]
240101d0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
240101d4:	60da      	str	r2, [r3, #12]
240101d6:	e005      	b.n	240101e4 <HAL_MDMA_Start+0xa0>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
240101d8:	68fb      	ldr	r3, [r7, #12]
240101da:	2200      	movs	r2, #0
240101dc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
240101e0:	2302      	movs	r3, #2
240101e2:	e000      	b.n	240101e6 <HAL_MDMA_Start+0xa2>
  }

  return HAL_OK;
240101e4:	2300      	movs	r3, #0
}
240101e6:	4618      	mov	r0, r3
240101e8:	3710      	adds	r7, #16
240101ea:	46bd      	mov	sp, r7
240101ec:	bd80      	pop	{r7, pc}

240101ee <HAL_MDMA_Start_IT>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start_IT(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
240101ee:	b580      	push	{r7, lr}
240101f0:	b086      	sub	sp, #24
240101f2:	af02      	add	r7, sp, #8
240101f4:	60f8      	str	r0, [r7, #12]
240101f6:	60b9      	str	r1, [r7, #8]
240101f8:	607a      	str	r2, [r7, #4]
240101fa:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
240101fc:	68fb      	ldr	r3, [r7, #12]
240101fe:	2b00      	cmp	r3, #0
24010200:	d101      	bne.n	24010206 <HAL_MDMA_Start_IT+0x18>
  {
    return HAL_ERROR;
24010202:	2301      	movs	r3, #1
24010204:	e070      	b.n	240102e8 <HAL_MDMA_Start_IT+0xfa>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
24010206:	68fb      	ldr	r3, [r7, #12]
24010208:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401020c:	2b01      	cmp	r3, #1
2401020e:	d101      	bne.n	24010214 <HAL_MDMA_Start_IT+0x26>
24010210:	2302      	movs	r3, #2
24010212:	e069      	b.n	240102e8 <HAL_MDMA_Start_IT+0xfa>
24010214:	68fb      	ldr	r3, [r7, #12]
24010216:	2201      	movs	r2, #1
24010218:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2401021c:	68fb      	ldr	r3, [r7, #12]
2401021e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24010222:	b2db      	uxtb	r3, r3
24010224:	2b01      	cmp	r3, #1
24010226:	d158      	bne.n	240102da <HAL_MDMA_Start_IT+0xec>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
24010228:	68fb      	ldr	r3, [r7, #12]
2401022a:	2202      	movs	r2, #2
2401022c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
24010230:	68fb      	ldr	r3, [r7, #12]
24010232:	2200      	movs	r2, #0
24010234:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
24010236:	68fb      	ldr	r3, [r7, #12]
24010238:	681b      	ldr	r3, [r3, #0]
2401023a:	68da      	ldr	r2, [r3, #12]
2401023c:	68fb      	ldr	r3, [r7, #12]
2401023e:	681b      	ldr	r3, [r3, #0]
24010240:	f022 0201 	bic.w	r2, r2, #1
24010244:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
24010246:	69bb      	ldr	r3, [r7, #24]
24010248:	9300      	str	r3, [sp, #0]
2401024a:	683b      	ldr	r3, [r7, #0]
2401024c:	687a      	ldr	r2, [r7, #4]
2401024e:	68b9      	ldr	r1, [r7, #8]
24010250:	68f8      	ldr	r0, [r7, #12]
24010252:	f000 fb41 	bl	240108d8 <MDMA_SetConfig>

    /* Enable Common interrupts i.e Transfer Error IT and Channel Transfer Complete IT*/
    __HAL_MDMA_ENABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC));
24010256:	68fb      	ldr	r3, [r7, #12]
24010258:	681b      	ldr	r3, [r3, #0]
2401025a:	68da      	ldr	r2, [r3, #12]
2401025c:	68fb      	ldr	r3, [r7, #12]
2401025e:	681b      	ldr	r3, [r3, #0]
24010260:	f042 0206 	orr.w	r2, r2, #6
24010264:	60da      	str	r2, [r3, #12]

    if(hmdma->XferBlockCpltCallback != NULL)
24010266:	68fb      	ldr	r3, [r7, #12]
24010268:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401026a:	2b00      	cmp	r3, #0
2401026c:	d007      	beq.n	2401027e <HAL_MDMA_Start_IT+0x90>
    {
      /* if Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BT);
2401026e:	68fb      	ldr	r3, [r7, #12]
24010270:	681b      	ldr	r3, [r3, #0]
24010272:	68da      	ldr	r2, [r3, #12]
24010274:	68fb      	ldr	r3, [r7, #12]
24010276:	681b      	ldr	r3, [r3, #0]
24010278:	f042 0210 	orr.w	r2, r2, #16
2401027c:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferRepeatBlockCpltCallback != NULL)
2401027e:	68fb      	ldr	r3, [r7, #12]
24010280:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24010282:	2b00      	cmp	r3, #0
24010284:	d007      	beq.n	24010296 <HAL_MDMA_Start_IT+0xa8>
    {
      /* if Repeated Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BRT);
24010286:	68fb      	ldr	r3, [r7, #12]
24010288:	681b      	ldr	r3, [r3, #0]
2401028a:	68da      	ldr	r2, [r3, #12]
2401028c:	68fb      	ldr	r3, [r7, #12]
2401028e:	681b      	ldr	r3, [r3, #0]
24010290:	f042 0208 	orr.w	r2, r2, #8
24010294:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferBufferCpltCallback != NULL)
24010296:	68fb      	ldr	r3, [r7, #12]
24010298:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2401029a:	2b00      	cmp	r3, #0
2401029c:	d007      	beq.n	240102ae <HAL_MDMA_Start_IT+0xc0>
    {
      /* if buffer transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BFTC);
2401029e:	68fb      	ldr	r3, [r7, #12]
240102a0:	681b      	ldr	r3, [r3, #0]
240102a2:	68da      	ldr	r2, [r3, #12]
240102a4:	68fb      	ldr	r3, [r7, #12]
240102a6:	681b      	ldr	r3, [r3, #0]
240102a8:	f042 0220 	orr.w	r2, r2, #32
240102ac:	60da      	str	r2, [r3, #12]
    }

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
240102ae:	68fb      	ldr	r3, [r7, #12]
240102b0:	681b      	ldr	r3, [r3, #0]
240102b2:	68da      	ldr	r2, [r3, #12]
240102b4:	68fb      	ldr	r3, [r7, #12]
240102b6:	681b      	ldr	r3, [r3, #0]
240102b8:	f042 0201 	orr.w	r2, r2, #1
240102bc:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
240102be:	68fb      	ldr	r3, [r7, #12]
240102c0:	685b      	ldr	r3, [r3, #4]
240102c2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240102c6:	d10e      	bne.n	240102e6 <HAL_MDMA_Start_IT+0xf8>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
240102c8:	68fb      	ldr	r3, [r7, #12]
240102ca:	681b      	ldr	r3, [r3, #0]
240102cc:	68da      	ldr	r2, [r3, #12]
240102ce:	68fb      	ldr	r3, [r7, #12]
240102d0:	681b      	ldr	r3, [r3, #0]
240102d2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
240102d6:	60da      	str	r2, [r3, #12]
240102d8:	e005      	b.n	240102e6 <HAL_MDMA_Start_IT+0xf8>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
240102da:	68fb      	ldr	r3, [r7, #12]
240102dc:	2200      	movs	r2, #0
240102de:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
240102e2:	2302      	movs	r3, #2
240102e4:	e000      	b.n	240102e8 <HAL_MDMA_Start_IT+0xfa>
  }

  return HAL_OK;
240102e6:	2300      	movs	r3, #0
}
240102e8:	4618      	mov	r0, r3
240102ea:	3710      	adds	r7, #16
240102ec:	46bd      	mov	sp, r7
240102ee:	bd80      	pop	{r7, pc}

240102f0 <HAL_MDMA_Abort>:
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort(MDMA_HandleTypeDef *hmdma)
{
240102f0:	b580      	push	{r7, lr}
240102f2:	b084      	sub	sp, #16
240102f4:	af00      	add	r7, sp, #0
240102f6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart =  HAL_GetTick();
240102f8:	f7f1 fe90 	bl	2400201c <HAL_GetTick>
240102fc:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
240102fe:	687b      	ldr	r3, [r7, #4]
24010300:	2b00      	cmp	r3, #0
24010302:	d101      	bne.n	24010308 <HAL_MDMA_Abort+0x18>
  {
    return HAL_ERROR;
24010304:	2301      	movs	r3, #1
24010306:	e04a      	b.n	2401039e <HAL_MDMA_Abort+0xae>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
24010308:	687b      	ldr	r3, [r7, #4]
2401030a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401030e:	b2db      	uxtb	r3, r3
24010310:	2b02      	cmp	r3, #2
24010312:	d008      	beq.n	24010326 <HAL_MDMA_Abort+0x36>
  {
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
24010314:	687b      	ldr	r3, [r7, #4]
24010316:	2280      	movs	r2, #128	; 0x80
24010318:	669a      	str	r2, [r3, #104]	; 0x68

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2401031a:	687b      	ldr	r3, [r7, #4]
2401031c:	2200      	movs	r2, #0
2401031e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_ERROR;
24010322:	2301      	movs	r3, #1
24010324:	e03b      	b.n	2401039e <HAL_MDMA_Abort+0xae>
  }
  else
  {
    /* Disable all the transfer interrupts */
    __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
24010326:	687b      	ldr	r3, [r7, #4]
24010328:	681b      	ldr	r3, [r3, #0]
2401032a:	68da      	ldr	r2, [r3, #12]
2401032c:	687b      	ldr	r3, [r7, #4]
2401032e:	681b      	ldr	r3, [r3, #0]
24010330:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
24010334:	60da      	str	r2, [r3, #12]

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
24010336:	687b      	ldr	r3, [r7, #4]
24010338:	681b      	ldr	r3, [r3, #0]
2401033a:	68da      	ldr	r2, [r3, #12]
2401033c:	687b      	ldr	r3, [r7, #4]
2401033e:	681b      	ldr	r3, [r3, #0]
24010340:	f022 0201 	bic.w	r2, r2, #1
24010344:	60da      	str	r2, [r3, #12]

    /* Check if the MDMA Channel is effectively disabled */
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
24010346:	e016      	b.n	24010376 <HAL_MDMA_Abort+0x86>
    {
      /* Check for the Timeout */
      if( (HAL_GetTick()  - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
24010348:	f7f1 fe68 	bl	2400201c <HAL_GetTick>
2401034c:	4602      	mov	r2, r0
2401034e:	68fb      	ldr	r3, [r7, #12]
24010350:	1ad3      	subs	r3, r2, r3
24010352:	2b05      	cmp	r3, #5
24010354:	d90f      	bls.n	24010376 <HAL_MDMA_Abort+0x86>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
24010356:	687b      	ldr	r3, [r7, #4]
24010358:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2401035a:	f043 0240 	orr.w	r2, r3, #64	; 0x40
2401035e:	687b      	ldr	r3, [r7, #4]
24010360:	669a      	str	r2, [r3, #104]	; 0x68

        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
24010362:	687b      	ldr	r3, [r7, #4]
24010364:	2200      	movs	r2, #0
24010366:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the MDMA state */
        hmdma->State = HAL_MDMA_STATE_ERROR;
2401036a:	687b      	ldr	r3, [r7, #4]
2401036c:	2203      	movs	r2, #3
2401036e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        return HAL_ERROR;
24010372:	2301      	movs	r3, #1
24010374:	e013      	b.n	2401039e <HAL_MDMA_Abort+0xae>
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
24010376:	687b      	ldr	r3, [r7, #4]
24010378:	681b      	ldr	r3, [r3, #0]
2401037a:	68db      	ldr	r3, [r3, #12]
2401037c:	f003 0301 	and.w	r3, r3, #1
24010380:	2b00      	cmp	r3, #0
24010382:	d1e1      	bne.n	24010348 <HAL_MDMA_Abort+0x58>
      }
    }

    /* Clear all interrupt flags */
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BT | MDMA_FLAG_BRT | MDMA_FLAG_BFTC));
24010384:	687b      	ldr	r3, [r7, #4]
24010386:	681b      	ldr	r3, [r3, #0]
24010388:	221f      	movs	r2, #31
2401038a:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2401038c:	687b      	ldr	r3, [r7, #4]
2401038e:	2200      	movs	r2, #0
24010390:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Change the MDMA state*/
    hmdma->State = HAL_MDMA_STATE_READY;
24010394:	687b      	ldr	r3, [r7, #4]
24010396:	2201      	movs	r2, #1
24010398:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }

  return HAL_OK;
2401039c:	2300      	movs	r3, #0
}
2401039e:	4618      	mov	r0, r3
240103a0:	3710      	adds	r7, #16
240103a2:	46bd      	mov	sp, r7
240103a4:	bd80      	pop	{r7, pc}

240103a6 <HAL_MDMA_Abort_IT>:
  * @param  hmdma  : pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort_IT(MDMA_HandleTypeDef *hmdma)
{
240103a6:	b480      	push	{r7}
240103a8:	b083      	sub	sp, #12
240103aa:	af00      	add	r7, sp, #0
240103ac:	6078      	str	r0, [r7, #4]
  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
240103ae:	687b      	ldr	r3, [r7, #4]
240103b0:	2b00      	cmp	r3, #0
240103b2:	d101      	bne.n	240103b8 <HAL_MDMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
240103b4:	2301      	movs	r3, #1
240103b6:	e017      	b.n	240103e8 <HAL_MDMA_Abort_IT+0x42>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
240103b8:	687b      	ldr	r3, [r7, #4]
240103ba:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
240103be:	b2db      	uxtb	r3, r3
240103c0:	2b02      	cmp	r3, #2
240103c2:	d004      	beq.n	240103ce <HAL_MDMA_Abort_IT+0x28>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
240103c4:	687b      	ldr	r3, [r7, #4]
240103c6:	2280      	movs	r2, #128	; 0x80
240103c8:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
240103ca:	2301      	movs	r3, #1
240103cc:	e00c      	b.n	240103e8 <HAL_MDMA_Abort_IT+0x42>
  }
  else
  {
    /* Set Abort State  */
    hmdma->State = HAL_MDMA_STATE_ABORT;
240103ce:	687b      	ldr	r3, [r7, #4]
240103d0:	2204      	movs	r2, #4
240103d2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the stream */
    __HAL_MDMA_DISABLE(hmdma);
240103d6:	687b      	ldr	r3, [r7, #4]
240103d8:	681b      	ldr	r3, [r3, #0]
240103da:	68da      	ldr	r2, [r3, #12]
240103dc:	687b      	ldr	r3, [r7, #4]
240103de:	681b      	ldr	r3, [r3, #0]
240103e0:	f022 0201 	bic.w	r2, r2, #1
240103e4:	60da      	str	r2, [r3, #12]
  }

  return HAL_OK;
240103e6:	2300      	movs	r3, #0
}
240103e8:	4618      	mov	r0, r3
240103ea:	370c      	adds	r7, #12
240103ec:	46bd      	mov	sp, r7
240103ee:	f85d 7b04 	ldr.w	r7, [sp], #4
240103f2:	4770      	bx	lr

240103f4 <HAL_MDMA_PollForTransfer>:
  * @param  CompleteLevel: Specifies the MDMA level complete.
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_PollForTransfer(MDMA_HandleTypeDef *hmdma, HAL_MDMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
240103f4:	b580      	push	{r7, lr}
240103f6:	b088      	sub	sp, #32
240103f8:	af00      	add	r7, sp, #0
240103fa:	60f8      	str	r0, [r7, #12]
240103fc:	460b      	mov	r3, r1
240103fe:	607a      	str	r2, [r7, #4]
24010400:	72fb      	strb	r3, [r7, #11]

  /* Check the parameters */
  assert_param(IS_MDMA_LEVEL_COMPLETE(CompleteLevel));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
24010402:	68fb      	ldr	r3, [r7, #12]
24010404:	2b00      	cmp	r3, #0
24010406:	d101      	bne.n	2401040c <HAL_MDMA_PollForTransfer+0x18>
  {
    return HAL_ERROR;
24010408:	2301      	movs	r3, #1
2401040a:	e0b9      	b.n	24010580 <HAL_MDMA_PollForTransfer+0x18c>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2401040c:	68fb      	ldr	r3, [r7, #12]
2401040e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24010412:	b2db      	uxtb	r3, r3
24010414:	2b02      	cmp	r3, #2
24010416:	d004      	beq.n	24010422 <HAL_MDMA_PollForTransfer+0x2e>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
24010418:	68fb      	ldr	r3, [r7, #12]
2401041a:	2280      	movs	r2, #128	; 0x80
2401041c:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2401041e:	2301      	movs	r3, #1
24010420:	e0ae      	b.n	24010580 <HAL_MDMA_PollForTransfer+0x18c>
  }

  /* Get the level transfer complete flag */
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
24010422:	7afb      	ldrb	r3, [r7, #11]
24010424:	2b00      	cmp	r3, #0
24010426:	d00b      	beq.n	24010440 <HAL_MDMA_PollForTransfer+0x4c>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
24010428:	7afb      	ldrb	r3, [r7, #11]
2401042a:	2b01      	cmp	r3, #1
2401042c:	d006      	beq.n	2401043c <HAL_MDMA_PollForTransfer+0x48>
               (CompleteLevel == HAL_MDMA_BLOCK_TRANSFER) ? MDMA_FLAG_BT   : \
2401042e:	7afb      	ldrb	r3, [r7, #11]
24010430:	2b02      	cmp	r3, #2
24010432:	d101      	bne.n	24010438 <HAL_MDMA_PollForTransfer+0x44>
24010434:	2308      	movs	r3, #8
24010436:	e004      	b.n	24010442 <HAL_MDMA_PollForTransfer+0x4e>
24010438:	2304      	movs	r3, #4
2401043a:	e002      	b.n	24010442 <HAL_MDMA_PollForTransfer+0x4e>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
2401043c:	2310      	movs	r3, #16
2401043e:	e000      	b.n	24010442 <HAL_MDMA_PollForTransfer+0x4e>
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
24010440:	2302      	movs	r3, #2
24010442:	61fb      	str	r3, [r7, #28]
               MDMA_FLAG_BRT);


  /* Get timeout */
  tickstart = HAL_GetTick();
24010444:	f7f1 fdea 	bl	2400201c <HAL_GetTick>
24010448:	61b8      	str	r0, [r7, #24]

  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
2401044a:	e067      	b.n	2401051c <HAL_MDMA_PollForTransfer+0x128>
  {
    if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
2401044c:	68fb      	ldr	r3, [r7, #12]
2401044e:	681b      	ldr	r3, [r3, #0]
24010450:	681b      	ldr	r3, [r3, #0]
24010452:	f003 0301 	and.w	r3, r3, #1
24010456:	2b00      	cmp	r3, #0
24010458:	d046      	beq.n	240104e8 <HAL_MDMA_PollForTransfer+0xf4>
    {
      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
2401045a:	68fb      	ldr	r3, [r7, #12]
2401045c:	681b      	ldr	r3, [r3, #0]
2401045e:	689b      	ldr	r3, [r3, #8]
24010460:	617b      	str	r3, [r7, #20]

      if((errorFlag & MDMA_CESR_TED) == 0U)
24010462:	697b      	ldr	r3, [r7, #20]
24010464:	f003 0380 	and.w	r3, r3, #128	; 0x80
24010468:	2b00      	cmp	r3, #0
2401046a:	d106      	bne.n	2401047a <HAL_MDMA_PollForTransfer+0x86>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
2401046c:	68fb      	ldr	r3, [r7, #12]
2401046e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010470:	f043 0201 	orr.w	r2, r3, #1
24010474:	68fb      	ldr	r3, [r7, #12]
24010476:	669a      	str	r2, [r3, #104]	; 0x68
24010478:	e005      	b.n	24010486 <HAL_MDMA_PollForTransfer+0x92>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
2401047a:	68fb      	ldr	r3, [r7, #12]
2401047c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2401047e:	f043 0202 	orr.w	r2, r3, #2
24010482:	68fb      	ldr	r3, [r7, #12]
24010484:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
24010486:	697b      	ldr	r3, [r7, #20]
24010488:	f403 7300 	and.w	r3, r3, #512	; 0x200
2401048c:	2b00      	cmp	r3, #0
2401048e:	d005      	beq.n	2401049c <HAL_MDMA_PollForTransfer+0xa8>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
24010490:	68fb      	ldr	r3, [r7, #12]
24010492:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010494:	f043 0204 	orr.w	r2, r3, #4
24010498:	68fb      	ldr	r3, [r7, #12]
2401049a:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
2401049c:	697b      	ldr	r3, [r7, #20]
2401049e:	f403 7380 	and.w	r3, r3, #256	; 0x100
240104a2:	2b00      	cmp	r3, #0
240104a4:	d005      	beq.n	240104b2 <HAL_MDMA_PollForTransfer+0xbe>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
240104a6:	68fb      	ldr	r3, [r7, #12]
240104a8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240104aa:	f043 0208 	orr.w	r2, r3, #8
240104ae:	68fb      	ldr	r3, [r7, #12]
240104b0:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
240104b2:	697b      	ldr	r3, [r7, #20]
240104b4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240104b8:	2b00      	cmp	r3, #0
240104ba:	d005      	beq.n	240104c8 <HAL_MDMA_PollForTransfer+0xd4>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
240104bc:	68fb      	ldr	r3, [r7, #12]
240104be:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240104c0:	f043 0210 	orr.w	r2, r3, #16
240104c4:	68fb      	ldr	r3, [r7, #12]
240104c6:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
240104c8:	697b      	ldr	r3, [r7, #20]
240104ca:	f403 6300 	and.w	r3, r3, #2048	; 0x800
240104ce:	2b00      	cmp	r3, #0
240104d0:	d005      	beq.n	240104de <HAL_MDMA_PollForTransfer+0xea>
      {
        /* Update error code : Block Size error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
240104d2:	68fb      	ldr	r3, [r7, #12]
240104d4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240104d6:	f043 0220 	orr.w	r2, r3, #32
240104da:	68fb      	ldr	r3, [r7, #12]
240104dc:	669a      	str	r2, [r3, #104]	; 0x68
      }

      (void) HAL_MDMA_Abort(hmdma); /* if error then abort the current transfer */
240104de:	68f8      	ldr	r0, [r7, #12]
240104e0:	f7ff ff06 	bl	240102f0 <HAL_MDMA_Abort>
          - Clear all transfer flags
          - Unlock
          - Set the State
      */

      return HAL_ERROR;
240104e4:	2301      	movs	r3, #1
240104e6:	e04b      	b.n	24010580 <HAL_MDMA_PollForTransfer+0x18c>

    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
240104e8:	687b      	ldr	r3, [r7, #4]
240104ea:	f1b3 3fff 	cmp.w	r3, #4294967295
240104ee:	d015      	beq.n	2401051c <HAL_MDMA_PollForTransfer+0x128>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))
240104f0:	f7f1 fd94 	bl	2400201c <HAL_GetTick>
240104f4:	4602      	mov	r2, r0
240104f6:	69bb      	ldr	r3, [r7, #24]
240104f8:	1ad3      	subs	r3, r2, r3
240104fa:	687a      	ldr	r2, [r7, #4]
240104fc:	429a      	cmp	r2, r3
240104fe:	d302      	bcc.n	24010506 <HAL_MDMA_PollForTransfer+0x112>
24010500:	687b      	ldr	r3, [r7, #4]
24010502:	2b00      	cmp	r3, #0
24010504:	d10a      	bne.n	2401051c <HAL_MDMA_PollForTransfer+0x128>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
24010506:	68fb      	ldr	r3, [r7, #12]
24010508:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2401050a:	f043 0240 	orr.w	r2, r3, #64	; 0x40
2401050e:	68fb      	ldr	r3, [r7, #12]
24010510:	669a      	str	r2, [r3, #104]	; 0x68

        (void) HAL_MDMA_Abort(hmdma); /* if timeout then abort the current transfer */
24010512:	68f8      	ldr	r0, [r7, #12]
24010514:	f7ff feec 	bl	240102f0 <HAL_MDMA_Abort>
            - Clear all transfer flags
            - Unlock
            - Set the State
        */

        return HAL_ERROR;
24010518:	2301      	movs	r3, #1
2401051a:	e031      	b.n	24010580 <HAL_MDMA_PollForTransfer+0x18c>
  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
2401051c:	68fb      	ldr	r3, [r7, #12]
2401051e:	681b      	ldr	r3, [r3, #0]
24010520:	681a      	ldr	r2, [r3, #0]
24010522:	69fb      	ldr	r3, [r7, #28]
24010524:	4013      	ands	r3, r2
24010526:	2b00      	cmp	r3, #0
24010528:	d090      	beq.n	2401044c <HAL_MDMA_PollForTransfer+0x58>
      }
    }
  }

  /* Clear the transfer level flag */
  if(CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)
2401052a:	7afb      	ldrb	r3, [r7, #11]
2401052c:	2b01      	cmp	r3, #1
2401052e:	d104      	bne.n	2401053a <HAL_MDMA_PollForTransfer+0x146>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
24010530:	68fb      	ldr	r3, [r7, #12]
24010532:	681b      	ldr	r3, [r3, #0]
24010534:	2210      	movs	r2, #16
24010536:	605a      	str	r2, [r3, #4]
24010538:	e021      	b.n	2401057e <HAL_MDMA_PollForTransfer+0x18a>

  }
  else if(CompleteLevel == HAL_MDMA_BLOCK_TRANSFER)
2401053a:	7afb      	ldrb	r3, [r7, #11]
2401053c:	2b02      	cmp	r3, #2
2401053e:	d104      	bne.n	2401054a <HAL_MDMA_PollForTransfer+0x156>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT));
24010540:	68fb      	ldr	r3, [r7, #12]
24010542:	681b      	ldr	r3, [r3, #0]
24010544:	2218      	movs	r2, #24
24010546:	605a      	str	r2, [r3, #4]
24010548:	e019      	b.n	2401057e <HAL_MDMA_PollForTransfer+0x18a>

  }
  else if(CompleteLevel == HAL_MDMA_REPEAT_BLOCK_TRANSFER)
2401054a:	7afb      	ldrb	r3, [r7, #11]
2401054c:	2b03      	cmp	r3, #3
2401054e:	d104      	bne.n	2401055a <HAL_MDMA_PollForTransfer+0x166>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT | MDMA_FLAG_BRT));
24010550:	68fb      	ldr	r3, [r7, #12]
24010552:	681b      	ldr	r3, [r3, #0]
24010554:	221c      	movs	r2, #28
24010556:	605a      	str	r2, [r3, #4]
24010558:	e011      	b.n	2401057e <HAL_MDMA_PollForTransfer+0x18a>
  }
  else if(CompleteLevel == HAL_MDMA_FULL_TRANSFER)
2401055a:	7afb      	ldrb	r3, [r7, #11]
2401055c:	2b00      	cmp	r3, #0
2401055e:	d10c      	bne.n	2401057a <HAL_MDMA_PollForTransfer+0x186>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC | MDMA_FLAG_CTC));
24010560:	68fb      	ldr	r3, [r7, #12]
24010562:	681b      	ldr	r3, [r3, #0]
24010564:	221e      	movs	r2, #30
24010566:	605a      	str	r2, [r3, #4]

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
24010568:	68fb      	ldr	r3, [r7, #12]
2401056a:	2200      	movs	r2, #0
2401056c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
24010570:	68fb      	ldr	r3, [r7, #12]
24010572:	2201      	movs	r2, #1
24010574:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
24010578:	e001      	b.n	2401057e <HAL_MDMA_PollForTransfer+0x18a>
  }
  else
  {
    return HAL_ERROR;
2401057a:	2301      	movs	r3, #1
2401057c:	e000      	b.n	24010580 <HAL_MDMA_PollForTransfer+0x18c>
  }

  return HAL_OK;
2401057e:	2300      	movs	r3, #0
}
24010580:	4618      	mov	r0, r3
24010582:	3720      	adds	r7, #32
24010584:	46bd      	mov	sp, r7
24010586:	bd80      	pop	{r7, pc}

24010588 <HAL_MDMA_GenerateSWRequest>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_GenerateSWRequest(MDMA_HandleTypeDef *hmdma)
{
24010588:	b480      	push	{r7}
2401058a:	b085      	sub	sp, #20
2401058c:	af00      	add	r7, sp, #0
2401058e:	6078      	str	r0, [r7, #4]
  uint32_t request_mode;

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
24010590:	687b      	ldr	r3, [r7, #4]
24010592:	2b00      	cmp	r3, #0
24010594:	d101      	bne.n	2401059a <HAL_MDMA_GenerateSWRequest+0x12>
  {
    return HAL_ERROR;
24010596:	2301      	movs	r3, #1
24010598:	e02a      	b.n	240105f0 <HAL_MDMA_GenerateSWRequest+0x68>
  }

  /* Get the softawre request mode */
  request_mode = hmdma->Instance->CTCR & MDMA_CTCR_SWRM;
2401059a:	687b      	ldr	r3, [r7, #4]
2401059c:	681b      	ldr	r3, [r3, #0]
2401059e:	691b      	ldr	r3, [r3, #16]
240105a0:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
240105a4:	60fb      	str	r3, [r7, #12]

  if((hmdma->Instance->CCR &  MDMA_CCR_EN) == 0U)
240105a6:	687b      	ldr	r3, [r7, #4]
240105a8:	681b      	ldr	r3, [r3, #0]
240105aa:	68db      	ldr	r3, [r3, #12]
240105ac:	f003 0301 	and.w	r3, r3, #1
240105b0:	2b00      	cmp	r3, #0
240105b2:	d104      	bne.n	240105be <HAL_MDMA_GenerateSWRequest+0x36>
  {
    /* if no Transfer on going (MDMA enable bit not set) return error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
240105b4:	687b      	ldr	r3, [r7, #4]
240105b6:	2280      	movs	r2, #128	; 0x80
240105b8:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
240105ba:	2301      	movs	r3, #1
240105bc:	e018      	b.n	240105f0 <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else if(((hmdma->Instance->CISR &  MDMA_CISR_CRQA) != 0U) || (request_mode == 0U))
240105be:	687b      	ldr	r3, [r7, #4]
240105c0:	681b      	ldr	r3, [r3, #0]
240105c2:	681b      	ldr	r3, [r3, #0]
240105c4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240105c8:	2b00      	cmp	r3, #0
240105ca:	d102      	bne.n	240105d2 <HAL_MDMA_GenerateSWRequest+0x4a>
240105cc:	68fb      	ldr	r3, [r7, #12]
240105ce:	2b00      	cmp	r3, #0
240105d0:	d105      	bne.n	240105de <HAL_MDMA_GenerateSWRequest+0x56>
  {
    /* if an MDMA ongoing request has not yet end or if request mode is not SW request return error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_BUSY;
240105d2:	687b      	ldr	r3, [r7, #4]
240105d4:	f44f 7280 	mov.w	r2, #256	; 0x100
240105d8:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
240105da:	2301      	movs	r3, #1
240105dc:	e008      	b.n	240105f0 <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else
  {
    /* Set the SW request bit to activate the request on the Channel */
    hmdma->Instance->CCR |= MDMA_CCR_SWRQ;
240105de:	687b      	ldr	r3, [r7, #4]
240105e0:	681b      	ldr	r3, [r3, #0]
240105e2:	68da      	ldr	r2, [r3, #12]
240105e4:	687b      	ldr	r3, [r7, #4]
240105e6:	681b      	ldr	r3, [r3, #0]
240105e8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
240105ec:	60da      	str	r2, [r3, #12]

    return HAL_OK;
240105ee:	2300      	movs	r3, #0
  }
}
240105f0:	4618      	mov	r0, r3
240105f2:	3714      	adds	r7, #20
240105f4:	46bd      	mov	sp, r7
240105f6:	f85d 7b04 	ldr.w	r7, [sp], #4
240105fa:	4770      	bx	lr

240105fc <HAL_MDMA_IRQHandler>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval None
  */
void HAL_MDMA_IRQHandler(MDMA_HandleTypeDef *hmdma)
{
240105fc:	b580      	push	{r7, lr}
240105fe:	b086      	sub	sp, #24
24010600:	af00      	add	r7, sp, #0
24010602:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0;
24010604:	2300      	movs	r3, #0
24010606:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
24010608:	4b91      	ldr	r3, [pc, #580]	; (24010850 <HAL_MDMA_IRQHandler+0x254>)
2401060a:	681b      	ldr	r3, [r3, #0]
2401060c:	4a91      	ldr	r2, [pc, #580]	; (24010854 <HAL_MDMA_IRQHandler+0x258>)
2401060e:	fba2 2303 	umull	r2, r3, r2, r3
24010612:	0a9b      	lsrs	r3, r3, #10
24010614:	617b      	str	r3, [r7, #20]

  uint32_t generalIntFlag, errorFlag;

  /* General Interrupt Flag management ****************************************/
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
24010616:	687b      	ldr	r3, [r7, #4]
24010618:	681b      	ldr	r3, [r3, #0]
2401061a:	461a      	mov	r2, r3
2401061c:	4b8e      	ldr	r3, [pc, #568]	; (24010858 <HAL_MDMA_IRQHandler+0x25c>)
2401061e:	4413      	add	r3, r2
24010620:	099b      	lsrs	r3, r3, #6
24010622:	f003 031f 	and.w	r3, r3, #31
24010626:	2201      	movs	r2, #1
24010628:	fa02 f303 	lsl.w	r3, r2, r3
2401062c:	613b      	str	r3, [r7, #16]
  if((MDMA->GISR0 & generalIntFlag) == 0U)
2401062e:	f04f 43a4 	mov.w	r3, #1375731712	; 0x52000000
24010632:	681a      	ldr	r2, [r3, #0]
24010634:	693b      	ldr	r3, [r7, #16]
24010636:	4013      	ands	r3, r2
24010638:	2b00      	cmp	r3, #0
2401063a:	f000 812d 	beq.w	24010898 <HAL_MDMA_IRQHandler+0x29c>
  {
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
  }

  /* Transfer Error Interrupt management ***************************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
2401063e:	687b      	ldr	r3, [r7, #4]
24010640:	681b      	ldr	r3, [r3, #0]
24010642:	681b      	ldr	r3, [r3, #0]
24010644:	f003 0301 	and.w	r3, r3, #1
24010648:	2b00      	cmp	r3, #0
2401064a:	d054      	beq.n	240106f6 <HAL_MDMA_IRQHandler+0xfa>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_TE) != 0U)
2401064c:	687b      	ldr	r3, [r7, #4]
2401064e:	681b      	ldr	r3, [r3, #0]
24010650:	68db      	ldr	r3, [r3, #12]
24010652:	f003 0302 	and.w	r3, r3, #2
24010656:	2b00      	cmp	r3, #0
24010658:	d04d      	beq.n	240106f6 <HAL_MDMA_IRQHandler+0xfa>
    {
      /* Disable the transfer error interrupt */
      __HAL_MDMA_DISABLE_IT(hmdma, MDMA_IT_TE);
2401065a:	687b      	ldr	r3, [r7, #4]
2401065c:	681b      	ldr	r3, [r3, #0]
2401065e:	68da      	ldr	r2, [r3, #12]
24010660:	687b      	ldr	r3, [r7, #4]
24010662:	681b      	ldr	r3, [r3, #0]
24010664:	f022 0202 	bic.w	r2, r2, #2
24010668:	60da      	str	r2, [r3, #12]

      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
2401066a:	687b      	ldr	r3, [r7, #4]
2401066c:	681b      	ldr	r3, [r3, #0]
2401066e:	689b      	ldr	r3, [r3, #8]
24010670:	60fb      	str	r3, [r7, #12]

      if((errorFlag & MDMA_CESR_TED) == 0U)
24010672:	68fb      	ldr	r3, [r7, #12]
24010674:	f003 0380 	and.w	r3, r3, #128	; 0x80
24010678:	2b00      	cmp	r3, #0
2401067a:	d106      	bne.n	2401068a <HAL_MDMA_IRQHandler+0x8e>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
2401067c:	687b      	ldr	r3, [r7, #4]
2401067e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010680:	f043 0201 	orr.w	r2, r3, #1
24010684:	687b      	ldr	r3, [r7, #4]
24010686:	669a      	str	r2, [r3, #104]	; 0x68
24010688:	e005      	b.n	24010696 <HAL_MDMA_IRQHandler+0x9a>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
2401068a:	687b      	ldr	r3, [r7, #4]
2401068c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2401068e:	f043 0202 	orr.w	r2, r3, #2
24010692:	687b      	ldr	r3, [r7, #4]
24010694:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
24010696:	68fb      	ldr	r3, [r7, #12]
24010698:	f403 7300 	and.w	r3, r3, #512	; 0x200
2401069c:	2b00      	cmp	r3, #0
2401069e:	d005      	beq.n	240106ac <HAL_MDMA_IRQHandler+0xb0>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
240106a0:	687b      	ldr	r3, [r7, #4]
240106a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240106a4:	f043 0204 	orr.w	r2, r3, #4
240106a8:	687b      	ldr	r3, [r7, #4]
240106aa:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
240106ac:	68fb      	ldr	r3, [r7, #12]
240106ae:	f403 7380 	and.w	r3, r3, #256	; 0x100
240106b2:	2b00      	cmp	r3, #0
240106b4:	d005      	beq.n	240106c2 <HAL_MDMA_IRQHandler+0xc6>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
240106b6:	687b      	ldr	r3, [r7, #4]
240106b8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240106ba:	f043 0208 	orr.w	r2, r3, #8
240106be:	687b      	ldr	r3, [r7, #4]
240106c0:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
240106c2:	68fb      	ldr	r3, [r7, #12]
240106c4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240106c8:	2b00      	cmp	r3, #0
240106ca:	d005      	beq.n	240106d8 <HAL_MDMA_IRQHandler+0xdc>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
240106cc:	687b      	ldr	r3, [r7, #4]
240106ce:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240106d0:	f043 0210 	orr.w	r2, r3, #16
240106d4:	687b      	ldr	r3, [r7, #4]
240106d6:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
240106d8:	68fb      	ldr	r3, [r7, #12]
240106da:	f403 6300 	and.w	r3, r3, #2048	; 0x800
240106de:	2b00      	cmp	r3, #0
240106e0:	d005      	beq.n	240106ee <HAL_MDMA_IRQHandler+0xf2>
      {
        /* Update error code : Block Size error error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
240106e2:	687b      	ldr	r3, [r7, #4]
240106e4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240106e6:	f043 0220 	orr.w	r2, r3, #32
240106ea:	687b      	ldr	r3, [r7, #4]
240106ec:	669a      	str	r2, [r3, #104]	; 0x68
      }

      /* Clear the transfer error flags */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE);
240106ee:	687b      	ldr	r3, [r7, #4]
240106f0:	681b      	ldr	r3, [r3, #0]
240106f2:	2201      	movs	r2, #1
240106f4:	605a      	str	r2, [r3, #4]
    }
  }

  /* Buffer Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BFTC) != 0U))
240106f6:	687b      	ldr	r3, [r7, #4]
240106f8:	681b      	ldr	r3, [r3, #0]
240106fa:	681b      	ldr	r3, [r3, #0]
240106fc:	f003 0310 	and.w	r3, r3, #16
24010700:	2b00      	cmp	r3, #0
24010702:	d012      	beq.n	2401072a <HAL_MDMA_IRQHandler+0x12e>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BFTC) != 0U)
24010704:	687b      	ldr	r3, [r7, #4]
24010706:	681b      	ldr	r3, [r3, #0]
24010708:	68db      	ldr	r3, [r3, #12]
2401070a:	f003 0320 	and.w	r3, r3, #32
2401070e:	2b00      	cmp	r3, #0
24010710:	d00b      	beq.n	2401072a <HAL_MDMA_IRQHandler+0x12e>
    {
      /* Clear the buffer transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
24010712:	687b      	ldr	r3, [r7, #4]
24010714:	681b      	ldr	r3, [r3, #0]
24010716:	2210      	movs	r2, #16
24010718:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBufferCpltCallback != NULL)
2401071a:	687b      	ldr	r3, [r7, #4]
2401071c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2401071e:	2b00      	cmp	r3, #0
24010720:	d003      	beq.n	2401072a <HAL_MDMA_IRQHandler+0x12e>
      {
        /* Buffer transfer callback */
        hmdma->XferBufferCpltCallback(hmdma);
24010722:	687b      	ldr	r3, [r7, #4]
24010724:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24010726:	6878      	ldr	r0, [r7, #4]
24010728:	4798      	blx	r3
      }
    }
  }

  /* Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BT) != 0U))
2401072a:	687b      	ldr	r3, [r7, #4]
2401072c:	681b      	ldr	r3, [r3, #0]
2401072e:	681b      	ldr	r3, [r3, #0]
24010730:	f003 0308 	and.w	r3, r3, #8
24010734:	2b00      	cmp	r3, #0
24010736:	d012      	beq.n	2401075e <HAL_MDMA_IRQHandler+0x162>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BT) != 0U)
24010738:	687b      	ldr	r3, [r7, #4]
2401073a:	681b      	ldr	r3, [r3, #0]
2401073c:	68db      	ldr	r3, [r3, #12]
2401073e:	f003 0310 	and.w	r3, r3, #16
24010742:	2b00      	cmp	r3, #0
24010744:	d00b      	beq.n	2401075e <HAL_MDMA_IRQHandler+0x162>
    {
      /* Clear the block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BT);
24010746:	687b      	ldr	r3, [r7, #4]
24010748:	681b      	ldr	r3, [r3, #0]
2401074a:	2208      	movs	r2, #8
2401074c:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBlockCpltCallback != NULL)
2401074e:	687b      	ldr	r3, [r7, #4]
24010750:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24010752:	2b00      	cmp	r3, #0
24010754:	d003      	beq.n	2401075e <HAL_MDMA_IRQHandler+0x162>
      {
        /* Block transfer callback */
        hmdma->XferBlockCpltCallback(hmdma);
24010756:	687b      	ldr	r3, [r7, #4]
24010758:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401075a:	6878      	ldr	r0, [r7, #4]
2401075c:	4798      	blx	r3
      }
    }
  }

  /* Repeated Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BRT) != 0U))
2401075e:	687b      	ldr	r3, [r7, #4]
24010760:	681b      	ldr	r3, [r3, #0]
24010762:	681b      	ldr	r3, [r3, #0]
24010764:	f003 0304 	and.w	r3, r3, #4
24010768:	2b00      	cmp	r3, #0
2401076a:	d012      	beq.n	24010792 <HAL_MDMA_IRQHandler+0x196>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BRT) != 0U)
2401076c:	687b      	ldr	r3, [r7, #4]
2401076e:	681b      	ldr	r3, [r3, #0]
24010770:	68db      	ldr	r3, [r3, #12]
24010772:	f003 0308 	and.w	r3, r3, #8
24010776:	2b00      	cmp	r3, #0
24010778:	d00b      	beq.n	24010792 <HAL_MDMA_IRQHandler+0x196>
    {
      /* Clear the repeat block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BRT);
2401077a:	687b      	ldr	r3, [r7, #4]
2401077c:	681b      	ldr	r3, [r3, #0]
2401077e:	2204      	movs	r2, #4
24010780:	605a      	str	r2, [r3, #4]

      if(hmdma->XferRepeatBlockCpltCallback != NULL)
24010782:	687b      	ldr	r3, [r7, #4]
24010784:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24010786:	2b00      	cmp	r3, #0
24010788:	d003      	beq.n	24010792 <HAL_MDMA_IRQHandler+0x196>
      {
        /* Repeated Block transfer callback */
        hmdma->XferRepeatBlockCpltCallback(hmdma);
2401078a:	687b      	ldr	r3, [r7, #4]
2401078c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401078e:	6878      	ldr	r0, [r7, #4]
24010790:	4798      	blx	r3
      }
    }
  }

  /* Channel Transfer Complete Interrupt management ***********************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_CTC) != 0U))
24010792:	687b      	ldr	r3, [r7, #4]
24010794:	681b      	ldr	r3, [r3, #0]
24010796:	681b      	ldr	r3, [r3, #0]
24010798:	f003 0302 	and.w	r3, r3, #2
2401079c:	2b00      	cmp	r3, #0
2401079e:	d039      	beq.n	24010814 <HAL_MDMA_IRQHandler+0x218>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_CTC) != 0U)
240107a0:	687b      	ldr	r3, [r7, #4]
240107a2:	681b      	ldr	r3, [r3, #0]
240107a4:	68db      	ldr	r3, [r3, #12]
240107a6:	f003 0304 	and.w	r3, r3, #4
240107aa:	2b00      	cmp	r3, #0
240107ac:	d032      	beq.n	24010814 <HAL_MDMA_IRQHandler+0x218>
    {
      /* Disable all the transfer interrupts */
      __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
240107ae:	687b      	ldr	r3, [r7, #4]
240107b0:	681b      	ldr	r3, [r3, #0]
240107b2:	68da      	ldr	r2, [r3, #12]
240107b4:	687b      	ldr	r3, [r7, #4]
240107b6:	681b      	ldr	r3, [r3, #0]
240107b8:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
240107bc:	60da      	str	r2, [r3, #12]

      if(HAL_MDMA_STATE_ABORT == hmdma->State)
240107be:	687b      	ldr	r3, [r7, #4]
240107c0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
240107c4:	b2db      	uxtb	r3, r3
240107c6:	2b04      	cmp	r3, #4
240107c8:	d110      	bne.n	240107ec <HAL_MDMA_IRQHandler+0x1f0>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
240107ca:	687b      	ldr	r3, [r7, #4]
240107cc:	2200      	movs	r2, #0
240107ce:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the DMA state */
        hmdma->State = HAL_MDMA_STATE_READY;
240107d2:	687b      	ldr	r3, [r7, #4]
240107d4:	2201      	movs	r2, #1
240107d6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        if(hmdma->XferAbortCallback != NULL)
240107da:	687b      	ldr	r3, [r7, #4]
240107dc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240107de:	2b00      	cmp	r3, #0
240107e0:	d05c      	beq.n	2401089c <HAL_MDMA_IRQHandler+0x2a0>
        {
          hmdma->XferAbortCallback(hmdma);
240107e2:	687b      	ldr	r3, [r7, #4]
240107e4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240107e6:	6878      	ldr	r0, [r7, #4]
240107e8:	4798      	blx	r3
        }
        return;
240107ea:	e057      	b.n	2401089c <HAL_MDMA_IRQHandler+0x2a0>
      }

      /* Clear the Channel Transfer Complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_CTC);
240107ec:	687b      	ldr	r3, [r7, #4]
240107ee:	681b      	ldr	r3, [r3, #0]
240107f0:	2202      	movs	r2, #2
240107f2:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hmdma);
240107f4:	687b      	ldr	r3, [r7, #4]
240107f6:	2200      	movs	r2, #0
240107f8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

      /* Change MDMA peripheral state */
      hmdma->State = HAL_MDMA_STATE_READY;
240107fc:	687b      	ldr	r3, [r7, #4]
240107fe:	2201      	movs	r2, #1
24010800:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      if(hmdma->XferCpltCallback != NULL)
24010804:	687b      	ldr	r3, [r7, #4]
24010806:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010808:	2b00      	cmp	r3, #0
2401080a:	d003      	beq.n	24010814 <HAL_MDMA_IRQHandler+0x218>
      {
        /* Channel Transfer Complete callback */
        hmdma->XferCpltCallback(hmdma);
2401080c:	687b      	ldr	r3, [r7, #4]
2401080e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010810:	6878      	ldr	r0, [r7, #4]
24010812:	4798      	blx	r3
      }
    }
  }

  /* manage error case */
  if(hmdma->ErrorCode != HAL_MDMA_ERROR_NONE)
24010814:	687b      	ldr	r3, [r7, #4]
24010816:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010818:	2b00      	cmp	r3, #0
2401081a:	d040      	beq.n	2401089e <HAL_MDMA_IRQHandler+0x2a2>
  {
    hmdma->State = HAL_MDMA_STATE_ABORT;
2401081c:	687b      	ldr	r3, [r7, #4]
2401081e:	2204      	movs	r2, #4
24010820:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
24010824:	687b      	ldr	r3, [r7, #4]
24010826:	681b      	ldr	r3, [r3, #0]
24010828:	68da      	ldr	r2, [r3, #12]
2401082a:	687b      	ldr	r3, [r7, #4]
2401082c:	681b      	ldr	r3, [r3, #0]
2401082e:	f022 0201 	bic.w	r2, r2, #1
24010832:	60da      	str	r2, [r3, #12]

    do
    {
      if (++count > timeout)
24010834:	68bb      	ldr	r3, [r7, #8]
24010836:	3301      	adds	r3, #1
24010838:	60bb      	str	r3, [r7, #8]
2401083a:	697a      	ldr	r2, [r7, #20]
2401083c:	429a      	cmp	r2, r3
2401083e:	d30d      	bcc.n	2401085c <HAL_MDMA_IRQHandler+0x260>
      {
        break;
      }
    }
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U);
24010840:	687b      	ldr	r3, [r7, #4]
24010842:	681b      	ldr	r3, [r3, #0]
24010844:	68db      	ldr	r3, [r3, #12]
24010846:	f003 0301 	and.w	r3, r3, #1
2401084a:	2b00      	cmp	r3, #0
2401084c:	d1f2      	bne.n	24010834 <HAL_MDMA_IRQHandler+0x238>
2401084e:	e006      	b.n	2401085e <HAL_MDMA_IRQHandler+0x262>
24010850:	240004b0 	.word	0x240004b0
24010854:	1b4e81b5 	.word	0x1b4e81b5
24010858:	adffffc0 	.word	0xadffffc0
        break;
2401085c:	bf00      	nop

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2401085e:	687b      	ldr	r3, [r7, #4]
24010860:	2200      	movs	r2, #0
24010862:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    if((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
24010866:	687b      	ldr	r3, [r7, #4]
24010868:	681b      	ldr	r3, [r3, #0]
2401086a:	68db      	ldr	r3, [r3, #12]
2401086c:	f003 0301 	and.w	r3, r3, #1
24010870:	2b00      	cmp	r3, #0
24010872:	d004      	beq.n	2401087e <HAL_MDMA_IRQHandler+0x282>
    {
      /* Change the MDMA state to error if MDMA disable fails */
      hmdma->State = HAL_MDMA_STATE_ERROR;
24010874:	687b      	ldr	r3, [r7, #4]
24010876:	2203      	movs	r2, #3
24010878:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
2401087c:	e003      	b.n	24010886 <HAL_MDMA_IRQHandler+0x28a>
    }
    else
    {
      /* Change the MDMA state to Ready if MDMA disable success */
      hmdma->State = HAL_MDMA_STATE_READY;
2401087e:	687b      	ldr	r3, [r7, #4]
24010880:	2201      	movs	r2, #1
24010882:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }


    if (hmdma->XferErrorCallback != NULL)
24010886:	687b      	ldr	r3, [r7, #4]
24010888:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401088a:	2b00      	cmp	r3, #0
2401088c:	d007      	beq.n	2401089e <HAL_MDMA_IRQHandler+0x2a2>
    {
      /* Transfer error callback */
      hmdma->XferErrorCallback(hmdma);
2401088e:	687b      	ldr	r3, [r7, #4]
24010890:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24010892:	6878      	ldr	r0, [r7, #4]
24010894:	4798      	blx	r3
24010896:	e002      	b.n	2401089e <HAL_MDMA_IRQHandler+0x2a2>
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
24010898:	bf00      	nop
2401089a:	e000      	b.n	2401089e <HAL_MDMA_IRQHandler+0x2a2>
        return;
2401089c:	bf00      	nop
    }
  }
}
2401089e:	3718      	adds	r7, #24
240108a0:	46bd      	mov	sp, r7
240108a2:	bd80      	pop	{r7, pc}

240108a4 <HAL_MDMA_GetState>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL state
  */
HAL_MDMA_StateTypeDef HAL_MDMA_GetState(MDMA_HandleTypeDef *hmdma)
{
240108a4:	b480      	push	{r7}
240108a6:	b083      	sub	sp, #12
240108a8:	af00      	add	r7, sp, #0
240108aa:	6078      	str	r0, [r7, #4]
  return hmdma->State;
240108ac:	687b      	ldr	r3, [r7, #4]
240108ae:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
240108b2:	b2db      	uxtb	r3, r3
}
240108b4:	4618      	mov	r0, r3
240108b6:	370c      	adds	r7, #12
240108b8:	46bd      	mov	sp, r7
240108ba:	f85d 7b04 	ldr.w	r7, [sp], #4
240108be:	4770      	bx	lr

240108c0 <HAL_MDMA_GetError>:
  * @param  hmdma : pointer to a MDMA_HandleTypeDef structure that contains
  *              the configuration information for the specified MDMA Channel.
  * @retval MDMA Error Code
  */
uint32_t HAL_MDMA_GetError(MDMA_HandleTypeDef *hmdma)
{
240108c0:	b480      	push	{r7}
240108c2:	b083      	sub	sp, #12
240108c4:	af00      	add	r7, sp, #0
240108c6:	6078      	str	r0, [r7, #4]
  return hmdma->ErrorCode;
240108c8:	687b      	ldr	r3, [r7, #4]
240108ca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
}
240108cc:	4618      	mov	r0, r3
240108ce:	370c      	adds	r7, #12
240108d0:	46bd      	mov	sp, r7
240108d2:	f85d 7b04 	ldr.w	r7, [sp], #4
240108d6:	4770      	bx	lr

240108d8 <MDMA_SetConfig>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount: The number of blocks to be transferred
  * @retval HAL status
  */
static void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
240108d8:	b480      	push	{r7}
240108da:	b087      	sub	sp, #28
240108dc:	af00      	add	r7, sp, #0
240108de:	60f8      	str	r0, [r7, #12]
240108e0:	60b9      	str	r1, [r7, #8]
240108e2:	607a      	str	r2, [r7, #4]
240108e4:	603b      	str	r3, [r7, #0]
  uint32_t addressMask;

  /* Configure the MDMA Channel data length */
  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));
240108e6:	68fb      	ldr	r3, [r7, #12]
240108e8:	681b      	ldr	r3, [r3, #0]
240108ea:	695a      	ldr	r2, [r3, #20]
240108ec:	4b31      	ldr	r3, [pc, #196]	; (240109b4 <MDMA_SetConfig+0xdc>)
240108ee:	4013      	ands	r3, r2
240108f0:	683a      	ldr	r2, [r7, #0]
240108f2:	f3c2 0110 	ubfx	r1, r2, #0, #17
240108f6:	68fa      	ldr	r2, [r7, #12]
240108f8:	6812      	ldr	r2, [r2, #0]
240108fa:	430b      	orrs	r3, r1
240108fc:	6153      	str	r3, [r2, #20]

  /* Configure the MDMA block repeat count */
  MODIFY_REG(hmdma->Instance->CBNDTR , MDMA_CBNDTR_BRC , ((BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC);
240108fe:	68fb      	ldr	r3, [r7, #12]
24010900:	681b      	ldr	r3, [r3, #0]
24010902:	695b      	ldr	r3, [r3, #20]
24010904:	f3c3 0113 	ubfx	r1, r3, #0, #20
24010908:	6a3b      	ldr	r3, [r7, #32]
2401090a:	3b01      	subs	r3, #1
2401090c:	051a      	lsls	r2, r3, #20
2401090e:	68fb      	ldr	r3, [r7, #12]
24010910:	681b      	ldr	r3, [r3, #0]
24010912:	430a      	orrs	r2, r1
24010914:	615a      	str	r2, [r3, #20]

  /* Clear all interrupt flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_CISR_BRTIF | MDMA_CISR_BTIF | MDMA_CISR_TCIF);
24010916:	68fb      	ldr	r3, [r7, #12]
24010918:	681b      	ldr	r3, [r3, #0]
2401091a:	221f      	movs	r2, #31
2401091c:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Channel destination address */
  hmdma->Instance->CDAR = DstAddress;
2401091e:	68fb      	ldr	r3, [r7, #12]
24010920:	681b      	ldr	r3, [r3, #0]
24010922:	687a      	ldr	r2, [r7, #4]
24010924:	61da      	str	r2, [r3, #28]

  /* Configure MDMA Channel Source address */
  hmdma->Instance->CSAR = SrcAddress;
24010926:	68fb      	ldr	r3, [r7, #12]
24010928:	681b      	ldr	r3, [r3, #0]
2401092a:	68ba      	ldr	r2, [r7, #8]
2401092c:	619a      	str	r2, [r3, #24]

  addressMask = SrcAddress & 0xFF000000U;
2401092e:	68bb      	ldr	r3, [r7, #8]
24010930:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
24010934:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
24010936:	697b      	ldr	r3, [r7, #20]
24010938:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401093c:	d002      	beq.n	24010944 <MDMA_SetConfig+0x6c>
2401093e:	697b      	ldr	r3, [r7, #20]
24010940:	2b00      	cmp	r3, #0
24010942:	d108      	bne.n	24010956 <MDMA_SetConfig+0x7e>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_SBUS;
24010944:	68fb      	ldr	r3, [r7, #12]
24010946:	681b      	ldr	r3, [r3, #0]
24010948:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2401094a:	68fb      	ldr	r3, [r7, #12]
2401094c:	681b      	ldr	r3, [r3, #0]
2401094e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24010952:	629a      	str	r2, [r3, #40]	; 0x28
24010954:	e007      	b.n	24010966 <MDMA_SetConfig+0x8e>
  }
  else
  {
    /*The AXI bus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);
24010956:	68fb      	ldr	r3, [r7, #12]
24010958:	681b      	ldr	r3, [r3, #0]
2401095a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2401095c:	68fb      	ldr	r3, [r7, #12]
2401095e:	681b      	ldr	r3, [r3, #0]
24010960:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
24010964:	629a      	str	r2, [r3, #40]	; 0x28
  }

  addressMask = DstAddress & 0xFF000000U;
24010966:	687b      	ldr	r3, [r7, #4]
24010968:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2401096c:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2401096e:	697b      	ldr	r3, [r7, #20]
24010970:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24010974:	d002      	beq.n	2401097c <MDMA_SetConfig+0xa4>
24010976:	697b      	ldr	r3, [r7, #20]
24010978:	2b00      	cmp	r3, #0
2401097a:	d108      	bne.n	2401098e <MDMA_SetConfig+0xb6>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_DBUS;
2401097c:	68fb      	ldr	r3, [r7, #12]
2401097e:	681b      	ldr	r3, [r3, #0]
24010980:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010982:	68fb      	ldr	r3, [r7, #12]
24010984:	681b      	ldr	r3, [r3, #0]
24010986:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2401098a:	629a      	str	r2, [r3, #40]	; 0x28
2401098c:	e007      	b.n	2401099e <MDMA_SetConfig+0xc6>
  }
  else
  {
    /*The AXI bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_DBUS);
2401098e:	68fb      	ldr	r3, [r7, #12]
24010990:	681b      	ldr	r3, [r3, #0]
24010992:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010994:	68fb      	ldr	r3, [r7, #12]
24010996:	681b      	ldr	r3, [r3, #0]
24010998:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
2401099c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Set the linked list register to the first node of the list */
  hmdma->Instance->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
2401099e:	68fb      	ldr	r3, [r7, #12]
240109a0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
240109a2:	68fb      	ldr	r3, [r7, #12]
240109a4:	681b      	ldr	r3, [r3, #0]
240109a6:	625a      	str	r2, [r3, #36]	; 0x24
}
240109a8:	bf00      	nop
240109aa:	371c      	adds	r7, #28
240109ac:	46bd      	mov	sp, r7
240109ae:	f85d 7b04 	ldr.w	r7, [sp], #4
240109b2:	4770      	bx	lr
240109b4:	fffe0000 	.word	0xfffe0000

240109b8 <MDMA_Init>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Channel.
  * @retval None
  */
static void MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
240109b8:	b480      	push	{r7}
240109ba:	b085      	sub	sp, #20
240109bc:	af00      	add	r7, sp, #0
240109be:	6078      	str	r0, [r7, #4]
  uint32_t blockoffset;

  /* Prepare the MDMA Channel configuration */
  hmdma->Instance->CCR = hmdma->Init.Priority  | hmdma->Init.Endianness;
240109c0:	687b      	ldr	r3, [r7, #4]
240109c2:	68d9      	ldr	r1, [r3, #12]
240109c4:	687b      	ldr	r3, [r7, #4]
240109c6:	691a      	ldr	r2, [r3, #16]
240109c8:	687b      	ldr	r3, [r7, #4]
240109ca:	681b      	ldr	r3, [r3, #0]
240109cc:	430a      	orrs	r2, r1
240109ce:	60da      	str	r2, [r3, #12]

  /* Write new CTCR Register value */
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
240109d0:	687b      	ldr	r3, [r7, #4]
240109d2:	695a      	ldr	r2, [r3, #20]
240109d4:	687b      	ldr	r3, [r7, #4]
240109d6:	699b      	ldr	r3, [r3, #24]
240109d8:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
240109da:	687b      	ldr	r3, [r7, #4]
240109dc:	69db      	ldr	r3, [r3, #28]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
240109de:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
240109e0:	687b      	ldr	r3, [r7, #4]
240109e2:	6a1b      	ldr	r3, [r3, #32]
240109e4:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
240109e6:	687b      	ldr	r3, [r7, #4]
240109e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
240109ea:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
240109ec:	687b      	ldr	r3, [r7, #4]
240109ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240109f0:	431a      	orrs	r2, r3
                           hmdma->Init.DestBurst                                   | \
240109f2:	687b      	ldr	r3, [r7, #4]
240109f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
240109f6:	431a      	orrs	r2, r3
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
240109f8:	687b      	ldr	r3, [r7, #4]
240109fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240109fc:	3b01      	subs	r3, #1
240109fe:	049b      	lsls	r3, r3, #18
                           hmdma->Init.DestBurst                                   | \
24010a00:	ea42 0103 	orr.w	r1, r2, r3
                           hmdma->Init.TransferTriggerMode;
24010a04:	687b      	ldr	r3, [r7, #4]
24010a06:	689a      	ldr	r2, [r3, #8]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
24010a08:	687b      	ldr	r3, [r7, #4]
24010a0a:	681b      	ldr	r3, [r3, #0]
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
24010a0c:	430a      	orrs	r2, r1
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
24010a0e:	611a      	str	r2, [r3, #16]

  /* If SW request set the CTCR register to SW Request Mode */
  if(hmdma->Init.Request == MDMA_REQUEST_SW)
24010a10:	687b      	ldr	r3, [r7, #4]
24010a12:	685b      	ldr	r3, [r3, #4]
24010a14:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24010a18:	d107      	bne.n	24010a2a <MDMA_Init+0x72>
    -If the request is done by SW : BWM could be set to 1 or 0.
    -If the request is done by a peripheral :
    If mask address not set (0) => BWM must be set to 0
    If mask address set (different than 0) => BWM could be set to 1 or 0
    */
    hmdma->Instance->CTCR |= (MDMA_CTCR_SWRM | MDMA_CTCR_BWM);
24010a1a:	687b      	ldr	r3, [r7, #4]
24010a1c:	681b      	ldr	r3, [r3, #0]
24010a1e:	691a      	ldr	r2, [r3, #16]
24010a20:	687b      	ldr	r3, [r7, #4]
24010a22:	681b      	ldr	r3, [r3, #0]
24010a24:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
24010a28:	611a      	str	r2, [r3, #16]
  }

  /* Reset CBNDTR Register */
  hmdma->Instance->CBNDTR = 0;
24010a2a:	687b      	ldr	r3, [r7, #4]
24010a2c:	681b      	ldr	r3, [r3, #0]
24010a2e:	2200      	movs	r2, #0
24010a30:	615a      	str	r2, [r3, #20]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(hmdma->Init.SourceBlockAddressOffset < 0)
24010a32:	687b      	ldr	r3, [r7, #4]
24010a34:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24010a36:	2b00      	cmp	r3, #0
24010a38:	da11      	bge.n	24010a5e <MDMA_Init+0xa6>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;
24010a3a:	687b      	ldr	r3, [r7, #4]
24010a3c:	681b      	ldr	r3, [r3, #0]
24010a3e:	695a      	ldr	r2, [r3, #20]
24010a40:	687b      	ldr	r3, [r7, #4]
24010a42:	681b      	ldr	r3, [r3, #0]
24010a44:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24010a48:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.SourceBlockAddressOffset);
24010a4a:	687b      	ldr	r3, [r7, #4]
24010a4c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24010a4e:	425b      	negs	r3, r3
24010a50:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR = (blockoffset & 0x0000FFFFU);
24010a52:	687b      	ldr	r3, [r7, #4]
24010a54:	681b      	ldr	r3, [r3, #0]
24010a56:	68fa      	ldr	r2, [r7, #12]
24010a58:	b292      	uxth	r2, r2
24010a5a:	621a      	str	r2, [r3, #32]
24010a5c:	e006      	b.n	24010a6c <MDMA_Init+0xb4>
  }
  else
  {
    /* Write new CBRUR Register value : source repeat block offset */
    hmdma->Instance->CBRUR = (((uint32_t)hmdma->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
24010a5e:	687b      	ldr	r3, [r7, #4]
24010a60:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24010a62:	461a      	mov	r2, r3
24010a64:	687b      	ldr	r3, [r7, #4]
24010a66:	681b      	ldr	r3, [r3, #0]
24010a68:	b292      	uxth	r2, r2
24010a6a:	621a      	str	r2, [r3, #32]
  }

  /* If block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(hmdma->Init.DestBlockAddressOffset < 0)
24010a6c:	687b      	ldr	r3, [r7, #4]
24010a6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010a70:	2b00      	cmp	r3, #0
24010a72:	da15      	bge.n	24010aa0 <MDMA_Init+0xe8>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;
24010a74:	687b      	ldr	r3, [r7, #4]
24010a76:	681b      	ldr	r3, [r3, #0]
24010a78:	695a      	ldr	r2, [r3, #20]
24010a7a:	687b      	ldr	r3, [r7, #4]
24010a7c:	681b      	ldr	r3, [r3, #0]
24010a7e:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
24010a82:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.DestBlockAddressOffset);
24010a84:	687b      	ldr	r3, [r7, #4]
24010a86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010a88:	425b      	negs	r3, r3
24010a8a:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24010a8c:	687b      	ldr	r3, [r7, #4]
24010a8e:	681b      	ldr	r3, [r3, #0]
24010a90:	6a19      	ldr	r1, [r3, #32]
24010a92:	68fb      	ldr	r3, [r7, #12]
24010a94:	041a      	lsls	r2, r3, #16
24010a96:	687b      	ldr	r3, [r7, #4]
24010a98:	681b      	ldr	r3, [r3, #0]
24010a9a:	430a      	orrs	r2, r1
24010a9c:	621a      	str	r2, [r3, #32]
24010a9e:	e009      	b.n	24010ab4 <MDMA_Init+0xfc>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24010aa0:	687b      	ldr	r3, [r7, #4]
24010aa2:	681b      	ldr	r3, [r3, #0]
24010aa4:	6a19      	ldr	r1, [r3, #32]
24010aa6:	687b      	ldr	r3, [r7, #4]
24010aa8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010aaa:	041a      	lsls	r2, r3, #16
24010aac:	687b      	ldr	r3, [r7, #4]
24010aae:	681b      	ldr	r3, [r3, #0]
24010ab0:	430a      	orrs	r2, r1
24010ab2:	621a      	str	r2, [r3, #32]
  }

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData, */
  if(hmdma->Init.Request != MDMA_REQUEST_SW)
24010ab4:	687b      	ldr	r3, [r7, #4]
24010ab6:	685b      	ldr	r3, [r3, #4]
24010ab8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24010abc:	d006      	beq.n	24010acc <MDMA_Init+0x114>
  {
    /* Set the HW request in CTRB register  */
    hmdma->Instance->CTBR = hmdma->Init.Request & MDMA_CTBR_TSEL;
24010abe:	687b      	ldr	r3, [r7, #4]
24010ac0:	685a      	ldr	r2, [r3, #4]
24010ac2:	687b      	ldr	r3, [r7, #4]
24010ac4:	681b      	ldr	r3, [r3, #0]
24010ac6:	b2d2      	uxtb	r2, r2
24010ac8:	629a      	str	r2, [r3, #40]	; 0x28
24010aca:	e003      	b.n	24010ad4 <MDMA_Init+0x11c>
  }
  else /* SW request : reset the CTBR register */
  {
    hmdma->Instance->CTBR = 0;
24010acc:	687b      	ldr	r3, [r7, #4]
24010ace:	681b      	ldr	r3, [r3, #0]
24010ad0:	2200      	movs	r2, #0
24010ad2:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Write Link Address Register */
  hmdma->Instance->CLAR =  0;
24010ad4:	687b      	ldr	r3, [r7, #4]
24010ad6:	681b      	ldr	r3, [r3, #0]
24010ad8:	2200      	movs	r2, #0
24010ada:	625a      	str	r2, [r3, #36]	; 0x24
}
24010adc:	bf00      	nop
24010ade:	3714      	adds	r7, #20
24010ae0:	46bd      	mov	sp, r7
24010ae2:	f85d 7b04 	ldr.w	r7, [sp], #4
24010ae6:	4770      	bx	lr

24010ae8 <HAL_PWR_DeInit>:
  *         The prototype is kept just to maintain compatibility with other
  *         products.
  * @retval None.
  */
void HAL_PWR_DeInit (void)
{
24010ae8:	b480      	push	{r7}
24010aea:	af00      	add	r7, sp, #0
}
24010aec:	bf00      	nop
24010aee:	46bd      	mov	sp, r7
24010af0:	f85d 7b04 	ldr.w	r7, [sp], #4
24010af4:	4770      	bx	lr
	...

24010af8 <HAL_PWR_EnableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_EnableBkUpAccess (void)
{
24010af8:	b480      	push	{r7}
24010afa:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT (PWR->CR1, PWR_CR1_DBP);
24010afc:	4b05      	ldr	r3, [pc, #20]	; (24010b14 <HAL_PWR_EnableBkUpAccess+0x1c>)
24010afe:	681b      	ldr	r3, [r3, #0]
24010b00:	4a04      	ldr	r2, [pc, #16]	; (24010b14 <HAL_PWR_EnableBkUpAccess+0x1c>)
24010b02:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24010b06:	6013      	str	r3, [r2, #0]
}
24010b08:	bf00      	nop
24010b0a:	46bd      	mov	sp, r7
24010b0c:	f85d 7b04 	ldr.w	r7, [sp], #4
24010b10:	4770      	bx	lr
24010b12:	bf00      	nop
24010b14:	58024800 	.word	0x58024800

24010b18 <HAL_PWR_DisableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_DisableBkUpAccess (void)
{
24010b18:	b480      	push	{r7}
24010b1a:	af00      	add	r7, sp, #0
  /* Disable access to RTC and backup registers */
  CLEAR_BIT (PWR->CR1, PWR_CR1_DBP);
24010b1c:	4b05      	ldr	r3, [pc, #20]	; (24010b34 <HAL_PWR_DisableBkUpAccess+0x1c>)
24010b1e:	681b      	ldr	r3, [r3, #0]
24010b20:	4a04      	ldr	r2, [pc, #16]	; (24010b34 <HAL_PWR_DisableBkUpAccess+0x1c>)
24010b22:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24010b26:	6013      	str	r3, [r2, #0]
}
24010b28:	bf00      	nop
24010b2a:	46bd      	mov	sp, r7
24010b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
24010b30:	4770      	bx	lr
24010b32:	bf00      	nop
24010b34:	58024800 	.word	0x58024800

24010b38 <HAL_PWR_ConfigPVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 or wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWR_ConfigPVD (PWR_PVDTypeDef *sConfigPVD)
{
24010b38:	b480      	push	{r7}
24010b3a:	b083      	sub	sp, #12
24010b3c:	af00      	add	r7, sp, #0
24010b3e:	6078      	str	r0, [r7, #4]
  /* Check the PVD configuration parameter */
  if (sConfigPVD == NULL)
24010b40:	687b      	ldr	r3, [r7, #4]
24010b42:	2b00      	cmp	r3, #0
24010b44:	d069      	beq.n	24010c1a <HAL_PWR_ConfigPVD+0xe2>
  /* Check the parameters */
  assert_param (IS_PWR_PVD_LEVEL (sConfigPVD->PVDLevel));
  assert_param (IS_PWR_PVD_MODE (sConfigPVD->Mode));

  /* Set PLS[7:5] bits according to PVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
24010b46:	4b38      	ldr	r3, [pc, #224]	; (24010c28 <HAL_PWR_ConfigPVD+0xf0>)
24010b48:	681b      	ldr	r3, [r3, #0]
24010b4a:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
24010b4e:	687b      	ldr	r3, [r7, #4]
24010b50:	681b      	ldr	r3, [r3, #0]
24010b52:	4935      	ldr	r1, [pc, #212]	; (24010c28 <HAL_PWR_ConfigPVD+0xf0>)
24010b54:	4313      	orrs	r3, r2
24010b56:	600b      	str	r3, [r1, #0]

  /* Clear previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT ();
24010b58:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010b5c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24010b60:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010b64:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010b68:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_PVD_EXTI_DISABLE_IT ();
24010b6c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010b70:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24010b74:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010b78:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010b7c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE ();
24010b80:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010b84:	681b      	ldr	r3, [r3, #0]
24010b86:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010b8a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010b8e:	6013      	str	r3, [r2, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE ();
24010b90:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010b94:	685b      	ldr	r3, [r3, #4]
24010b96:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010b9a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010b9e:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Interrupt mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
24010ba0:	687b      	ldr	r3, [r7, #4]
24010ba2:	685b      	ldr	r3, [r3, #4]
24010ba4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24010ba8:	2b00      	cmp	r3, #0
24010baa:	d009      	beq.n	24010bc0 <HAL_PWR_ConfigPVD+0x88>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT ();
24010bac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010bb0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24010bb4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010bb8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010bbc:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Event mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
24010bc0:	687b      	ldr	r3, [r7, #4]
24010bc2:	685b      	ldr	r3, [r3, #4]
24010bc4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24010bc8:	2b00      	cmp	r3, #0
24010bca:	d009      	beq.n	24010be0 <HAL_PWR_ConfigPVD+0xa8>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT ();
24010bcc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010bd0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24010bd4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010bd8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010bdc:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
24010be0:	687b      	ldr	r3, [r7, #4]
24010be2:	685b      	ldr	r3, [r3, #4]
24010be4:	f003 0301 	and.w	r3, r3, #1
24010be8:	2b00      	cmp	r3, #0
24010bea:	d007      	beq.n	24010bfc <HAL_PWR_ConfigPVD+0xc4>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE ();
24010bec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010bf0:	681b      	ldr	r3, [r3, #0]
24010bf2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010bf6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010bfa:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
24010bfc:	687b      	ldr	r3, [r7, #4]
24010bfe:	685b      	ldr	r3, [r3, #4]
24010c00:	f003 0302 	and.w	r3, r3, #2
24010c04:	2b00      	cmp	r3, #0
24010c06:	d009      	beq.n	24010c1c <HAL_PWR_ConfigPVD+0xe4>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE ();
24010c08:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010c0c:	685b      	ldr	r3, [r3, #4]
24010c0e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010c12:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010c16:	6053      	str	r3, [r2, #4]
24010c18:	e000      	b.n	24010c1c <HAL_PWR_ConfigPVD+0xe4>
    return;
24010c1a:	bf00      	nop
  }
}
24010c1c:	370c      	adds	r7, #12
24010c1e:	46bd      	mov	sp, r7
24010c20:	f85d 7b04 	ldr.w	r7, [sp], #4
24010c24:	4770      	bx	lr
24010c26:	bf00      	nop
24010c28:	58024800 	.word	0x58024800

24010c2c <HAL_PWR_EnablePVD>:
/**
  * @brief Enable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_EnablePVD (void)
{
24010c2c:	b480      	push	{r7}
24010c2e:	af00      	add	r7, sp, #0
  /* Enable the power voltage detector */
  SET_BIT (PWR->CR1, PWR_CR1_PVDEN);
24010c30:	4b05      	ldr	r3, [pc, #20]	; (24010c48 <HAL_PWR_EnablePVD+0x1c>)
24010c32:	681b      	ldr	r3, [r3, #0]
24010c34:	4a04      	ldr	r2, [pc, #16]	; (24010c48 <HAL_PWR_EnablePVD+0x1c>)
24010c36:	f043 0310 	orr.w	r3, r3, #16
24010c3a:	6013      	str	r3, [r2, #0]
}
24010c3c:	bf00      	nop
24010c3e:	46bd      	mov	sp, r7
24010c40:	f85d 7b04 	ldr.w	r7, [sp], #4
24010c44:	4770      	bx	lr
24010c46:	bf00      	nop
24010c48:	58024800 	.word	0x58024800

24010c4c <HAL_PWR_DisablePVD>:
/**
  * @brief Disable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_DisablePVD (void)
{
24010c4c:	b480      	push	{r7}
24010c4e:	af00      	add	r7, sp, #0
  /* Disable the power voltage detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_PVDEN);
24010c50:	4b05      	ldr	r3, [pc, #20]	; (24010c68 <HAL_PWR_DisablePVD+0x1c>)
24010c52:	681b      	ldr	r3, [r3, #0]
24010c54:	4a04      	ldr	r2, [pc, #16]	; (24010c68 <HAL_PWR_DisablePVD+0x1c>)
24010c56:	f023 0310 	bic.w	r3, r3, #16
24010c5a:	6013      	str	r3, [r2, #0]
}
24010c5c:	bf00      	nop
24010c5e:	46bd      	mov	sp, r7
24010c60:	f85d 7b04 	ldr.w	r7, [sp], #4
24010c64:	4770      	bx	lr
24010c66:	bf00      	nop
24010c68:	58024800 	.word	0x58024800

24010c6c <HAL_PWR_EnableWakeUpPin>:
  *         and PWR_WAKEUP_PIN5_LOW are available only for devices that includes
  *         GPIOI port.
  * @retval None.
  */
void HAL_PWR_EnableWakeUpPin (uint32_t WakeUpPinPolarity)
{
24010c6c:	b480      	push	{r7}
24010c6e:	b083      	sub	sp, #12
24010c70:	af00      	add	r7, sp, #0
24010c72:	6078      	str	r0, [r7, #4]

  /*
     Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge).
  */
  MODIFY_REG (PWR->WKUPEPR, PWR_EWUP_MASK, WakeUpPinPolarity);
24010c74:	4b06      	ldr	r3, [pc, #24]	; (24010c90 <HAL_PWR_EnableWakeUpPin+0x24>)
24010c76:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010c78:	4b06      	ldr	r3, [pc, #24]	; (24010c94 <HAL_PWR_EnableWakeUpPin+0x28>)
24010c7a:	4013      	ands	r3, r2
24010c7c:	4904      	ldr	r1, [pc, #16]	; (24010c90 <HAL_PWR_EnableWakeUpPin+0x24>)
24010c7e:	687a      	ldr	r2, [r7, #4]
24010c80:	4313      	orrs	r3, r2
24010c82:	628b      	str	r3, [r1, #40]	; 0x28
}
24010c84:	bf00      	nop
24010c86:	370c      	adds	r7, #12
24010c88:	46bd      	mov	sp, r7
24010c8a:	f85d 7b04 	ldr.w	r7, [sp], #4
24010c8e:	4770      	bx	lr
24010c90:	58024800 	.word	0x58024800
24010c94:	f000c0c0 	.word	0xf000c0c0

24010c98 <HAL_PWR_DisableWakeUpPin>:
  *         and PWR_WAKEUP_PIN5_LOW are available only for devices that includes
  *         GPIOI port.
  * @retval None.
  */
void HAL_PWR_DisableWakeUpPin (uint32_t WakeUpPinx)
{
24010c98:	b480      	push	{r7}
24010c9a:	b083      	sub	sp, #12
24010c9c:	af00      	add	r7, sp, #0
24010c9e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinx));

  /* Disable the wake up pin selected */
  CLEAR_BIT (PWR->WKUPEPR, (PWR_WKUPEPR_WKUPEN & WakeUpPinx));
24010ca0:	4b07      	ldr	r3, [pc, #28]	; (24010cc0 <HAL_PWR_DisableWakeUpPin+0x28>)
24010ca2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010ca4:	687b      	ldr	r3, [r7, #4]
24010ca6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24010caa:	43db      	mvns	r3, r3
24010cac:	4904      	ldr	r1, [pc, #16]	; (24010cc0 <HAL_PWR_DisableWakeUpPin+0x28>)
24010cae:	4013      	ands	r3, r2
24010cb0:	628b      	str	r3, [r1, #40]	; 0x28
}
24010cb2:	bf00      	nop
24010cb4:	370c      	adds	r7, #12
24010cb6:	46bd      	mov	sp, r7
24010cb8:	f85d 7b04 	ldr.w	r7, [sp], #4
24010cbc:	4770      	bx	lr
24010cbe:	bf00      	nop
24010cc0:	58024800 	.word	0x58024800

24010cc4 <HAL_PWR_EnterSLEEPMode>:
  * @note   Ensure to clear pending events before calling this API through
  *         HAL_PWREx_ClearPendingEvent() when the SLEEP entry is WFE.
  * @retval None.
  */
void HAL_PWR_EnterSLEEPMode (uint32_t Regulator, uint8_t SLEEPEntry)
{
24010cc4:	b480      	push	{r7}
24010cc6:	b083      	sub	sp, #12
24010cc8:	af00      	add	r7, sp, #0
24010cca:	6078      	str	r0, [r7, #4]
24010ccc:	460b      	mov	r3, r1
24010cce:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_SLEEP_ENTRY (SLEEPEntry));

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010cd0:	4b08      	ldr	r3, [pc, #32]	; (24010cf4 <HAL_PWR_EnterSLEEPMode+0x30>)
24010cd2:	691b      	ldr	r3, [r3, #16]
24010cd4:	4a07      	ldr	r2, [pc, #28]	; (24010cf4 <HAL_PWR_EnterSLEEPMode+0x30>)
24010cd6:	f023 0304 	bic.w	r3, r3, #4
24010cda:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry */
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
24010cdc:	78fb      	ldrb	r3, [r7, #3]
24010cde:	2b01      	cmp	r3, #1
24010ce0:	d101      	bne.n	24010ce6 <HAL_PWR_EnterSLEEPMode+0x22>
  {
    /* Request Wait For Interrupt */
    __WFI ();
24010ce2:	bf30      	wfi
  else
  {
    /* Request Wait For Event */
    __WFE ();
  }
}
24010ce4:	e000      	b.n	24010ce8 <HAL_PWR_EnterSLEEPMode+0x24>
    __WFE ();
24010ce6:	bf20      	wfe
}
24010ce8:	bf00      	nop
24010cea:	370c      	adds	r7, #12
24010cec:	46bd      	mov	sp, r7
24010cee:	f85d 7b04 	ldr.w	r7, [sp], #4
24010cf2:	4770      	bx	lr
24010cf4:	e000ed00 	.word	0xe000ed00

24010cf8 <HAL_PWR_EnterSTOPMode>:
  *         is waking up. By keeping the internal regulator ON during STOP mode,
  *         the consumption is higher although the startup time is reduced.
  * @retval None.
  */
void HAL_PWR_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry)
{
24010cf8:	b480      	push	{r7}
24010cfa:	b083      	sub	sp, #12
24010cfc:	af00      	add	r7, sp, #0
24010cfe:	6078      	str	r0, [r7, #4]
24010d00:	460b      	mov	r3, r1
24010d02:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));

  /* Select the regulator state in STOP mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
24010d04:	4b18      	ldr	r3, [pc, #96]	; (24010d68 <HAL_PWR_EnterSTOPMode+0x70>)
24010d06:	681b      	ldr	r3, [r3, #0]
24010d08:	f023 0201 	bic.w	r2, r3, #1
24010d0c:	4916      	ldr	r1, [pc, #88]	; (24010d68 <HAL_PWR_EnterSTOPMode+0x70>)
24010d0e:	687b      	ldr	r3, [r7, #4]
24010d10:	4313      	orrs	r3, r2
24010d12:	600b      	str	r3, [r1, #0]
    /* Keep DSTOP mode when Cortex-M4 enters DEEP-SLEEP */
    CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
  }
#else /* Single core devices */
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
24010d14:	4b14      	ldr	r3, [pc, #80]	; (24010d68 <HAL_PWR_EnterSTOPMode+0x70>)
24010d16:	691b      	ldr	r3, [r3, #16]
24010d18:	4a13      	ldr	r2, [pc, #76]	; (24010d68 <HAL_PWR_EnterSTOPMode+0x70>)
24010d1a:	f023 0305 	bic.w	r3, r3, #5
24010d1e:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
24010d20:	4b11      	ldr	r3, [pc, #68]	; (24010d68 <HAL_PWR_EnterSTOPMode+0x70>)
24010d22:	691b      	ldr	r3, [r3, #16]
24010d24:	4a10      	ldr	r2, [pc, #64]	; (24010d68 <HAL_PWR_EnterSTOPMode+0x70>)
24010d26:	f023 0302 	bic.w	r3, r3, #2
24010d2a:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010d2c:	4b0f      	ldr	r3, [pc, #60]	; (24010d6c <HAL_PWR_EnterSTOPMode+0x74>)
24010d2e:	691b      	ldr	r3, [r3, #16]
24010d30:	4a0e      	ldr	r2, [pc, #56]	; (24010d6c <HAL_PWR_EnterSTOPMode+0x74>)
24010d32:	f043 0304 	orr.w	r3, r3, #4
24010d36:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
24010d38:	f3bf 8f4f 	dsb	sy
}
24010d3c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
24010d3e:	f3bf 8f6f 	isb	sy
}
24010d42:	bf00      	nop
  /* Ensure that all instructions are done before entering STOP mode */
  __DSB ();
  __ISB ();

  /* Select STOP mode entry */
  if (STOPEntry == PWR_STOPENTRY_WFI)
24010d44:	78fb      	ldrb	r3, [r7, #3]
24010d46:	2b01      	cmp	r3, #1
24010d48:	d101      	bne.n	24010d4e <HAL_PWR_EnterSTOPMode+0x56>
  {
    /* Request Wait For Interrupt */
    __WFI ();
24010d4a:	bf30      	wfi
24010d4c:	e000      	b.n	24010d50 <HAL_PWR_EnterSTOPMode+0x58>
  }
  else
  {
    /* Request Wait For Event */
    __WFE ();
24010d4e:	bf20      	wfe
  }

  /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010d50:	4b06      	ldr	r3, [pc, #24]	; (24010d6c <HAL_PWR_EnterSTOPMode+0x74>)
24010d52:	691b      	ldr	r3, [r3, #16]
24010d54:	4a05      	ldr	r2, [pc, #20]	; (24010d6c <HAL_PWR_EnterSTOPMode+0x74>)
24010d56:	f023 0304 	bic.w	r3, r3, #4
24010d5a:	6113      	str	r3, [r2, #16]
}
24010d5c:	bf00      	nop
24010d5e:	370c      	adds	r7, #12
24010d60:	46bd      	mov	sp, r7
24010d62:	f85d 7b04 	ldr.w	r7, [sp], #4
24010d66:	4770      	bx	lr
24010d68:	58024800 	.word	0x58024800
24010d6c:	e000ed00 	.word	0xe000ed00

24010d70 <HAL_PWR_EnterSTANDBYMode>:
  * @note   It is recommended to disable all regulators before entring STANDBY
  *         mode for power consumption saving purpose.
  * @retval None.
  */
void HAL_PWR_EnterSTANDBYMode (void)
{
24010d70:	b480      	push	{r7}
24010d72:	af00      	add	r7, sp, #0
    SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
    SET_BIT (PWR->CPU2CR, (PWR_CPU2CR_PDDS_D2 | PWR_CPU2CR_PDDS_D3));
  }
#else /* Single core devices */
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
24010d74:	4b0e      	ldr	r3, [pc, #56]	; (24010db0 <HAL_PWR_EnterSTANDBYMode+0x40>)
24010d76:	691b      	ldr	r3, [r3, #16]
24010d78:	4a0d      	ldr	r2, [pc, #52]	; (24010db0 <HAL_PWR_EnterSTANDBYMode+0x40>)
24010d7a:	f043 0305 	orr.w	r3, r3, #5
24010d7e:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
24010d80:	4b0b      	ldr	r3, [pc, #44]	; (24010db0 <HAL_PWR_EnterSTANDBYMode+0x40>)
24010d82:	691b      	ldr	r3, [r3, #16]
24010d84:	4a0a      	ldr	r2, [pc, #40]	; (24010db0 <HAL_PWR_EnterSTANDBYMode+0x40>)
24010d86:	f043 0302 	orr.w	r3, r3, #2
24010d8a:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010d8c:	4b09      	ldr	r3, [pc, #36]	; (24010db4 <HAL_PWR_EnterSTANDBYMode+0x44>)
24010d8e:	691b      	ldr	r3, [r3, #16]
24010d90:	4a08      	ldr	r2, [pc, #32]	; (24010db4 <HAL_PWR_EnterSTANDBYMode+0x44>)
24010d92:	f043 0304 	orr.w	r3, r3, #4
24010d96:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
24010d98:	f3bf 8f4f 	dsb	sy
}
24010d9c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
24010d9e:	f3bf 8f6f 	isb	sy
}
24010da2:	bf00      	nop
#if defined (__CC_ARM)
  __force_stores();
#endif /* defined (__CC_ARM) */

  /* Request Wait For Interrupt */
  __WFI ();
24010da4:	bf30      	wfi
}
24010da6:	bf00      	nop
24010da8:	46bd      	mov	sp, r7
24010daa:	f85d 7b04 	ldr.w	r7, [sp], #4
24010dae:	4770      	bx	lr
24010db0:	58024800 	.word	0x58024800
24010db4:	e000ed00 	.word	0xe000ed00

24010db8 <HAL_PWR_EnableSleepOnExit>:
  *         Setting this bit is useful when the processor is expected to run
  *         only on interruptions handling.
  * @retval None.
  */
void HAL_PWR_EnableSleepOnExit (void)
{
24010db8:	b480      	push	{r7}
24010dba:	af00      	add	r7, sp, #0
  /* Set SLEEPONEXIT bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
24010dbc:	4b05      	ldr	r3, [pc, #20]	; (24010dd4 <HAL_PWR_EnableSleepOnExit+0x1c>)
24010dbe:	691b      	ldr	r3, [r3, #16]
24010dc0:	4a04      	ldr	r2, [pc, #16]	; (24010dd4 <HAL_PWR_EnableSleepOnExit+0x1c>)
24010dc2:	f043 0302 	orr.w	r3, r3, #2
24010dc6:	6113      	str	r3, [r2, #16]
}
24010dc8:	bf00      	nop
24010dca:	46bd      	mov	sp, r7
24010dcc:	f85d 7b04 	ldr.w	r7, [sp], #4
24010dd0:	4770      	bx	lr
24010dd2:	bf00      	nop
24010dd4:	e000ed00 	.word	0xe000ed00

24010dd8 <HAL_PWR_DisableSleepOnExit>:
  * @note   Clears SLEEPONEXIT bit of SCR register. When this bit is set, the
  *         processor re-enters SLEEP mode when an interruption handling is over.
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit (void)
{
24010dd8:	b480      	push	{r7}
24010dda:	af00      	add	r7, sp, #0
  /* Clear SLEEPONEXIT bit of Cortex-Mx System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
24010ddc:	4b05      	ldr	r3, [pc, #20]	; (24010df4 <HAL_PWR_DisableSleepOnExit+0x1c>)
24010dde:	691b      	ldr	r3, [r3, #16]
24010de0:	4a04      	ldr	r2, [pc, #16]	; (24010df4 <HAL_PWR_DisableSleepOnExit+0x1c>)
24010de2:	f023 0302 	bic.w	r3, r3, #2
24010de6:	6113      	str	r3, [r2, #16]
}
24010de8:	bf00      	nop
24010dea:	46bd      	mov	sp, r7
24010dec:	f85d 7b04 	ldr.w	r7, [sp], #4
24010df0:	4770      	bx	lr
24010df2:	bf00      	nop
24010df4:	e000ed00 	.word	0xe000ed00

24010df8 <HAL_PWR_EnableSEVOnPend>:
  *         pending event / interrupt even if it's disabled or has insufficient
  *         priority to cause exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_EnableSEVOnPend (void)
{
24010df8:	b480      	push	{r7}
24010dfa:	af00      	add	r7, sp, #0
  /* Set SEVONPEND bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
24010dfc:	4b05      	ldr	r3, [pc, #20]	; (24010e14 <HAL_PWR_EnableSEVOnPend+0x1c>)
24010dfe:	691b      	ldr	r3, [r3, #16]
24010e00:	4a04      	ldr	r2, [pc, #16]	; (24010e14 <HAL_PWR_EnableSEVOnPend+0x1c>)
24010e02:	f043 0310 	orr.w	r3, r3, #16
24010e06:	6113      	str	r3, [r2, #16]
}
24010e08:	bf00      	nop
24010e0a:	46bd      	mov	sp, r7
24010e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
24010e10:	4770      	bx	lr
24010e12:	bf00      	nop
24010e14:	e000ed00 	.word	0xe000ed00

24010e18 <HAL_PWR_DisableSEVOnPend>:
  * @note   Resets SEVONPEND bit of SCR register. When this bit is reset, only
  *         enabled pending causes exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_DisableSEVOnPend (void)
{
24010e18:	b480      	push	{r7}
24010e1a:	af00      	add	r7, sp, #0
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
24010e1c:	4b05      	ldr	r3, [pc, #20]	; (24010e34 <HAL_PWR_DisableSEVOnPend+0x1c>)
24010e1e:	691b      	ldr	r3, [r3, #16]
24010e20:	4a04      	ldr	r2, [pc, #16]	; (24010e34 <HAL_PWR_DisableSEVOnPend+0x1c>)
24010e22:	f023 0310 	bic.w	r3, r3, #16
24010e26:	6113      	str	r3, [r2, #16]
}
24010e28:	bf00      	nop
24010e2a:	46bd      	mov	sp, r7
24010e2c:	f85d 7b04 	ldr.w	r7, [sp], #4
24010e30:	4770      	bx	lr
24010e32:	bf00      	nop
24010e34:	e000ed00 	.word	0xe000ed00

24010e38 <HAL_PWR_PVD_IRQHandler>:
  * @brief  This function handles the PWR PVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None.
  */
void HAL_PWR_PVD_IRQHandler (void)
{
24010e38:	b580      	push	{r7, lr}
24010e3a:	af00      	add	r7, sp, #0
      HAL_PWR_PVDCallback ();
    }
  }
#else /* Single core devices */
  /* PVD EXTI line interrupt detected */
  if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
24010e3c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010e40:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010e44:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24010e48:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24010e4c:	d10b      	bne.n	24010e66 <HAL_PWR_PVD_IRQHandler+0x2e>
  {
    /* Clear PWR EXTI pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
24010e4e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010e52:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010e56:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010e5a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010e5e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback ();
24010e62:	f000 f802 	bl	24010e6a <HAL_PWR_PVDCallback>
  }
#endif /* defined (DUAL_CORE) */
}
24010e66:	bf00      	nop
24010e68:	bd80      	pop	{r7, pc}

24010e6a <HAL_PWR_PVDCallback>:
/**
  * @brief  PWR PVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWR_PVDCallback (void)
{
24010e6a:	b480      	push	{r7}
24010e6c:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback can be implemented in the user file
  */
}
24010e6e:	bf00      	nop
24010e70:	46bd      	mov	sp, r7
24010e72:	f85d 7b04 	ldr.w	r7, [sp], #4
24010e76:	4770      	bx	lr

24010e78 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
24010e78:	b580      	push	{r7, lr}
24010e7a:	b084      	sub	sp, #16
24010e7c:	af00      	add	r7, sp, #0
24010e7e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
24010e80:	4b19      	ldr	r3, [pc, #100]	; (24010ee8 <HAL_PWREx_ConfigSupply+0x70>)
24010e82:	68db      	ldr	r3, [r3, #12]
24010e84:	f003 0304 	and.w	r3, r3, #4
24010e88:	2b04      	cmp	r3, #4
24010e8a:	d00a      	beq.n	24010ea2 <HAL_PWREx_ConfigSupply+0x2a>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
24010e8c:	4b16      	ldr	r3, [pc, #88]	; (24010ee8 <HAL_PWREx_ConfigSupply+0x70>)
24010e8e:	68db      	ldr	r3, [r3, #12]
24010e90:	f003 0307 	and.w	r3, r3, #7
24010e94:	687a      	ldr	r2, [r7, #4]
24010e96:	429a      	cmp	r2, r3
24010e98:	d001      	beq.n	24010e9e <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
24010e9a:	2301      	movs	r3, #1
24010e9c:	e01f      	b.n	24010ede <HAL_PWREx_ConfigSupply+0x66>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
24010e9e:	2300      	movs	r3, #0
24010ea0:	e01d      	b.n	24010ede <HAL_PWREx_ConfigSupply+0x66>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
24010ea2:	4b11      	ldr	r3, [pc, #68]	; (24010ee8 <HAL_PWREx_ConfigSupply+0x70>)
24010ea4:	68db      	ldr	r3, [r3, #12]
24010ea6:	f023 0207 	bic.w	r2, r3, #7
24010eaa:	490f      	ldr	r1, [pc, #60]	; (24010ee8 <HAL_PWREx_ConfigSupply+0x70>)
24010eac:	687b      	ldr	r3, [r7, #4]
24010eae:	4313      	orrs	r3, r2
24010eb0:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
24010eb2:	f7f1 f8b3 	bl	2400201c <HAL_GetTick>
24010eb6:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010eb8:	e009      	b.n	24010ece <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
24010eba:	f7f1 f8af 	bl	2400201c <HAL_GetTick>
24010ebe:	4602      	mov	r2, r0
24010ec0:	68fb      	ldr	r3, [r7, #12]
24010ec2:	1ad3      	subs	r3, r2, r3
24010ec4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24010ec8:	d901      	bls.n	24010ece <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
24010eca:	2301      	movs	r3, #1
24010ecc:	e007      	b.n	24010ede <HAL_PWREx_ConfigSupply+0x66>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010ece:	4b06      	ldr	r3, [pc, #24]	; (24010ee8 <HAL_PWREx_ConfigSupply+0x70>)
24010ed0:	685b      	ldr	r3, [r3, #4]
24010ed2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24010ed6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24010eda:	d1ee      	bne.n	24010eba <HAL_PWREx_ConfigSupply+0x42>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
24010edc:	2300      	movs	r3, #0
}
24010ede:	4618      	mov	r0, r3
24010ee0:	3710      	adds	r7, #16
24010ee2:	46bd      	mov	sp, r7
24010ee4:	bd80      	pop	{r7, pc}
24010ee6:	bf00      	nop
24010ee8:	58024800 	.word	0x58024800

24010eec <HAL_PWREx_GetSupplyConfig>:
/**
  * @brief Get the power supply configuration.
  * @retval The supply configuration.
  */
uint32_t HAL_PWREx_GetSupplyConfig (void)
{
24010eec:	b480      	push	{r7}
24010eee:	af00      	add	r7, sp, #0
  return (PWR->CR3 & PWR_SUPPLY_CONFIG_MASK);
24010ef0:	4b04      	ldr	r3, [pc, #16]	; (24010f04 <HAL_PWREx_GetSupplyConfig+0x18>)
24010ef2:	68db      	ldr	r3, [r3, #12]
24010ef4:	f003 0307 	and.w	r3, r3, #7
}
24010ef8:	4618      	mov	r0, r3
24010efa:	46bd      	mov	sp, r7
24010efc:	f85d 7b04 	ldr.w	r7, [sp], #4
24010f00:	4770      	bx	lr
24010f02:	bf00      	nop
24010f04:	58024800 	.word	0x58024800

24010f08 <HAL_PWREx_ControlVoltageScaling>:
  *         Voltage Scale 0 then first switch to Voltage Scale 1 before entering
  *         low power mode.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling (uint32_t VoltageScaling)
{
24010f08:	b580      	push	{r7, lr}
24010f0a:	b084      	sub	sp, #16
24010f0c:	af00      	add	r7, sp, #0
24010f0e:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR_VOLTAGE (VoltageScaling));

  /* Get the voltage scaling  */
  if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == VoltageScaling)
24010f10:	4b3f      	ldr	r3, [pc, #252]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010f12:	685b      	ldr	r3, [r3, #4]
24010f14:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
24010f18:	687a      	ldr	r2, [r7, #4]
24010f1a:	429a      	cmp	r2, r3
24010f1c:	d101      	bne.n	24010f22 <HAL_PWREx_ControlVoltageScaling+0x1a>
  {
    /* Old and new voltage scaling configuration match : nothing to do */
    return HAL_OK;
24010f1e:	2300      	movs	r3, #0
24010f20:	e072      	b.n	24011008 <HAL_PWREx_ControlVoltageScaling+0x100>
#if defined (PWR_SRDCR_VOS)
  /* Set the voltage range */
  MODIFY_REG (PWR->SRDCR, PWR_SRDCR_VOS, VoltageScaling);
#else
#if defined(SYSCFG_PWRCR_ODEN) /* STM32H74xxx and STM32H75xxx lines */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE0)
24010f22:	687b      	ldr	r3, [r7, #4]
24010f24:	2b00      	cmp	r3, #0
24010f26:	d129      	bne.n	24010f7c <HAL_PWREx_ControlVoltageScaling+0x74>
  {
    if ((PWR->CR3 & PWR_CR3_LDOEN) == PWR_CR3_LDOEN)
24010f28:	4b39      	ldr	r3, [pc, #228]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010f2a:	68db      	ldr	r3, [r3, #12]
24010f2c:	f003 0302 	and.w	r3, r3, #2
24010f30:	2b02      	cmp	r3, #2
24010f32:	d121      	bne.n	24010f78 <HAL_PWREx_ControlVoltageScaling+0x70>
    {
      /* Set the voltage range */
      MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
24010f34:	4b36      	ldr	r3, [pc, #216]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010f36:	699b      	ldr	r3, [r3, #24]
24010f38:	4a35      	ldr	r2, [pc, #212]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010f3a:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
24010f3e:	6193      	str	r3, [r2, #24]

      /* Get tick */
      tickstart = HAL_GetTick ();
24010f40:	f7f1 f86c 	bl	2400201c <HAL_GetTick>
24010f44:	60f8      	str	r0, [r7, #12]

      /* Wait till voltage level flag is set */
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010f46:	e009      	b.n	24010f5c <HAL_PWREx_ControlVoltageScaling+0x54>
      {
        if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
24010f48:	f7f1 f868 	bl	2400201c <HAL_GetTick>
24010f4c:	4602      	mov	r2, r0
24010f4e:	68fb      	ldr	r3, [r7, #12]
24010f50:	1ad3      	subs	r3, r2, r3
24010f52:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24010f56:	d901      	bls.n	24010f5c <HAL_PWREx_ControlVoltageScaling+0x54>
        {
          return HAL_ERROR;
24010f58:	2301      	movs	r3, #1
24010f5a:	e055      	b.n	24011008 <HAL_PWREx_ControlVoltageScaling+0x100>
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010f5c:	4b2c      	ldr	r3, [pc, #176]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010f5e:	685b      	ldr	r3, [r3, #4]
24010f60:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24010f64:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24010f68:	d1ee      	bne.n	24010f48 <HAL_PWREx_ControlVoltageScaling+0x40>
        }
      }

      /* Enable the PWR overdrive */
      SET_BIT (SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
24010f6a:	4b2a      	ldr	r3, [pc, #168]	; (24011014 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010f6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010f6e:	4a29      	ldr	r2, [pc, #164]	; (24011014 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010f70:	f043 0301 	orr.w	r3, r3, #1
24010f74:	62d3      	str	r3, [r2, #44]	; 0x2c
24010f76:	e031      	b.n	24010fdc <HAL_PWREx_ControlVoltageScaling+0xd4>
    }
    else
    {
      /* The voltage scale 0 is only possible when LDO regulator is enabled */
      return HAL_ERROR;
24010f78:	2301      	movs	r3, #1
24010f7a:	e045      	b.n	24011008 <HAL_PWREx_ControlVoltageScaling+0x100>
    }
  }
  else
  {
    if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == PWR_REGULATOR_VOLTAGE_SCALE1)
24010f7c:	4b24      	ldr	r3, [pc, #144]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010f7e:	685b      	ldr	r3, [r3, #4]
24010f80:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
24010f84:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
24010f88:	d120      	bne.n	24010fcc <HAL_PWREx_ControlVoltageScaling+0xc4>
    {
      if ((SYSCFG->PWRCR & SYSCFG_PWRCR_ODEN) != 0U)
24010f8a:	4b22      	ldr	r3, [pc, #136]	; (24011014 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010f8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010f8e:	f003 0301 	and.w	r3, r3, #1
24010f92:	2b00      	cmp	r3, #0
24010f94:	d01a      	beq.n	24010fcc <HAL_PWREx_ControlVoltageScaling+0xc4>
      {
        /* Disable the PWR overdrive */
        CLEAR_BIT(SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
24010f96:	4b1f      	ldr	r3, [pc, #124]	; (24011014 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010f98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010f9a:	4a1e      	ldr	r2, [pc, #120]	; (24011014 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010f9c:	f023 0301 	bic.w	r3, r3, #1
24010fa0:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Get tick */
        tickstart = HAL_GetTick ();
24010fa2:	f7f1 f83b 	bl	2400201c <HAL_GetTick>
24010fa6:	60f8      	str	r0, [r7, #12]

        /* Wait till voltage level flag is set */
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010fa8:	e009      	b.n	24010fbe <HAL_PWREx_ControlVoltageScaling+0xb6>
        {
          if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
24010faa:	f7f1 f837 	bl	2400201c <HAL_GetTick>
24010fae:	4602      	mov	r2, r0
24010fb0:	68fb      	ldr	r3, [r7, #12]
24010fb2:	1ad3      	subs	r3, r2, r3
24010fb4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24010fb8:	d901      	bls.n	24010fbe <HAL_PWREx_ControlVoltageScaling+0xb6>
          {
            return HAL_ERROR;
24010fba:	2301      	movs	r3, #1
24010fbc:	e024      	b.n	24011008 <HAL_PWREx_ControlVoltageScaling+0x100>
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010fbe:	4b14      	ldr	r3, [pc, #80]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010fc0:	685b      	ldr	r3, [r3, #4]
24010fc2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24010fc6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24010fca:	d1ee      	bne.n	24010faa <HAL_PWREx_ControlVoltageScaling+0xa2>
        }
      }
    }

    /* Set the voltage range */
    MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
24010fcc:	4b10      	ldr	r3, [pc, #64]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010fce:	699b      	ldr	r3, [r3, #24]
24010fd0:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
24010fd4:	490e      	ldr	r1, [pc, #56]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010fd6:	687b      	ldr	r3, [r7, #4]
24010fd8:	4313      	orrs	r3, r2
24010fda:	618b      	str	r3, [r1, #24]
  MODIFY_REG(PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
#endif /* defined (SYSCFG_PWRCR_ODEN) */
#endif /* defined (PWR_SRDCR_VOS) */

  /* Get tick */
  tickstart = HAL_GetTick ();
24010fdc:	f7f1 f81e 	bl	2400201c <HAL_GetTick>
24010fe0:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010fe2:	e009      	b.n	24010ff8 <HAL_PWREx_ControlVoltageScaling+0xf0>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
24010fe4:	f7f1 f81a 	bl	2400201c <HAL_GetTick>
24010fe8:	4602      	mov	r2, r0
24010fea:	68fb      	ldr	r3, [r7, #12]
24010fec:	1ad3      	subs	r3, r2, r3
24010fee:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24010ff2:	d901      	bls.n	24010ff8 <HAL_PWREx_ControlVoltageScaling+0xf0>
    {
      return HAL_ERROR;
24010ff4:	2301      	movs	r3, #1
24010ff6:	e007      	b.n	24011008 <HAL_PWREx_ControlVoltageScaling+0x100>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010ff8:	4b05      	ldr	r3, [pc, #20]	; (24011010 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010ffa:	685b      	ldr	r3, [r3, #4]
24010ffc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24011000:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24011004:	d1ee      	bne.n	24010fe4 <HAL_PWREx_ControlVoltageScaling+0xdc>
    }
  }

  return HAL_OK;
24011006:	2300      	movs	r3, #0
}
24011008:	4618      	mov	r0, r3
2401100a:	3710      	adds	r7, #16
2401100c:	46bd      	mov	sp, r7
2401100e:	bd80      	pop	{r7, pc}
24011010:	58024800 	.word	0x58024800
24011014:	58000400 	.word	0x58000400

24011018 <HAL_PWREx_GetVoltageRange>:
  * @brief Get the main internal regulator output voltage. Reflecting the last
  *        VOS value applied to the PMU.
  * @retval The current applied VOS selection.
  */
uint32_t HAL_PWREx_GetVoltageRange (void)
{
24011018:	b480      	push	{r7}
2401101a:	af00      	add	r7, sp, #0
  /* Get the active voltage scaling */
  return (PWR->CSR1 & PWR_CSR1_ACTVOS);
2401101c:	4b04      	ldr	r3, [pc, #16]	; (24011030 <HAL_PWREx_GetVoltageRange+0x18>)
2401101e:	685b      	ldr	r3, [r3, #4]
24011020:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
24011024:	4618      	mov	r0, r3
24011026:	46bd      	mov	sp, r7
24011028:	f85d 7b04 	ldr.w	r7, [sp], #4
2401102c:	4770      	bx	lr
2401102e:	bf00      	nop
24011030:	58024800 	.word	0x58024800

24011034 <HAL_PWREx_ControlStopModeVoltageScaling>:
  * @note   The selected SVOS4 and SVOS5 levels add an additional startup delay
  *         when exiting from system Stop mode.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlStopModeVoltageScaling (uint32_t VoltageScaling)
{
24011034:	b480      	push	{r7}
24011036:	b083      	sub	sp, #12
24011038:	af00      	add	r7, sp, #0
2401103a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_STOP_MODE_REGULATOR_VOLTAGE (VoltageScaling));

  /* Return the stop mode voltage range */
  MODIFY_REG (PWR->CR1, PWR_CR1_SVOS, VoltageScaling);
2401103c:	4b07      	ldr	r3, [pc, #28]	; (2401105c <HAL_PWREx_ControlStopModeVoltageScaling+0x28>)
2401103e:	681b      	ldr	r3, [r3, #0]
24011040:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
24011044:	4905      	ldr	r1, [pc, #20]	; (2401105c <HAL_PWREx_ControlStopModeVoltageScaling+0x28>)
24011046:	687b      	ldr	r3, [r7, #4]
24011048:	4313      	orrs	r3, r2
2401104a:	600b      	str	r3, [r1, #0]

  return HAL_OK;
2401104c:	2300      	movs	r3, #0
}
2401104e:	4618      	mov	r0, r3
24011050:	370c      	adds	r7, #12
24011052:	46bd      	mov	sp, r7
24011054:	f85d 7b04 	ldr.w	r7, [sp], #4
24011058:	4770      	bx	lr
2401105a:	bf00      	nop
2401105c:	58024800 	.word	0x58024800

24011060 <HAL_PWREx_GetStopModeVoltageRange>:
/**
  * @brief Get the main internal regulator output voltage in STOP mode.
  * @retval The actual applied VOS selection.
  */
uint32_t HAL_PWREx_GetStopModeVoltageRange (void)
{
24011060:	b480      	push	{r7}
24011062:	af00      	add	r7, sp, #0
  /* Return the stop voltage scaling */
  return (PWR->CR1 & PWR_CR1_SVOS);
24011064:	4b04      	ldr	r3, [pc, #16]	; (24011078 <HAL_PWREx_GetStopModeVoltageRange+0x18>)
24011066:	681b      	ldr	r3, [r3, #0]
24011068:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
2401106c:	4618      	mov	r0, r3
2401106e:	46bd      	mov	sp, r7
24011070:	f85d 7b04 	ldr.w	r7, [sp], #4
24011074:	4770      	bx	lr
24011076:	bf00      	nop
24011078:	58024800 	.word	0x58024800

2401107c <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
2401107c:	b480      	push	{r7}
2401107e:	b085      	sub	sp, #20
24011080:	af00      	add	r7, sp, #0
24011082:	60f8      	str	r0, [r7, #12]
24011084:	460b      	mov	r3, r1
24011086:	607a      	str	r2, [r7, #4]
24011088:	72fb      	strb	r3, [r7, #11]
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
2401108a:	4b20      	ldr	r3, [pc, #128]	; (2401110c <HAL_PWREx_EnterSTOPMode+0x90>)
2401108c:	681b      	ldr	r3, [r3, #0]
2401108e:	f023 0201 	bic.w	r2, r3, #1
24011092:	491e      	ldr	r1, [pc, #120]	; (2401110c <HAL_PWREx_EnterSTOPMode+0x90>)
24011094:	68fb      	ldr	r3, [r7, #12]
24011096:	4313      	orrs	r3, r2
24011098:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
2401109a:	687b      	ldr	r3, [r7, #4]
2401109c:	2b00      	cmp	r3, #0
2401109e:	d11e      	bne.n	240110de <HAL_PWREx_EnterSTOPMode+0x62>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
240110a0:	4b1a      	ldr	r3, [pc, #104]	; (2401110c <HAL_PWREx_EnterSTOPMode+0x90>)
240110a2:	691b      	ldr	r3, [r3, #16]
240110a4:	4a19      	ldr	r2, [pc, #100]	; (2401110c <HAL_PWREx_EnterSTOPMode+0x90>)
240110a6:	f023 0301 	bic.w	r3, r3, #1
240110aa:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
240110ac:	4b18      	ldr	r3, [pc, #96]	; (24011110 <HAL_PWREx_EnterSTOPMode+0x94>)
240110ae:	691b      	ldr	r3, [r3, #16]
240110b0:	4a17      	ldr	r2, [pc, #92]	; (24011110 <HAL_PWREx_EnterSTOPMode+0x94>)
240110b2:	f043 0304 	orr.w	r3, r3, #4
240110b6:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
240110b8:	f3bf 8f4f 	dsb	sy
}
240110bc:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
240110be:	f3bf 8f6f 	isb	sy
}
240110c2:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
240110c4:	7afb      	ldrb	r3, [r7, #11]
240110c6:	2b01      	cmp	r3, #1
240110c8:	d101      	bne.n	240110ce <HAL_PWREx_EnterSTOPMode+0x52>
    {
      /* Request Wait For Interrupt */
      __WFI ();
240110ca:	bf30      	wfi
240110cc:	e000      	b.n	240110d0 <HAL_PWREx_EnterSTOPMode+0x54>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
240110ce:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
240110d0:	4b0f      	ldr	r3, [pc, #60]	; (24011110 <HAL_PWREx_EnterSTOPMode+0x94>)
240110d2:	691b      	ldr	r3, [r3, #16]
240110d4:	4a0e      	ldr	r2, [pc, #56]	; (24011110 <HAL_PWREx_EnterSTOPMode+0x94>)
240110d6:	f023 0304 	bic.w	r3, r3, #4
240110da:	6113      	str	r3, [r2, #16]
#else
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
#endif  /* defined (DUAL_CORE) */
  }
}
240110dc:	e00f      	b.n	240110fe <HAL_PWREx_EnterSTOPMode+0x82>
  else if (Domain == PWR_D2_DOMAIN)
240110de:	687b      	ldr	r3, [r7, #4]
240110e0:	2b01      	cmp	r3, #1
240110e2:	d106      	bne.n	240110f2 <HAL_PWREx_EnterSTOPMode+0x76>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
240110e4:	4b09      	ldr	r3, [pc, #36]	; (2401110c <HAL_PWREx_EnterSTOPMode+0x90>)
240110e6:	691b      	ldr	r3, [r3, #16]
240110e8:	4a08      	ldr	r2, [pc, #32]	; (2401110c <HAL_PWREx_EnterSTOPMode+0x90>)
240110ea:	f023 0302 	bic.w	r3, r3, #2
240110ee:	6113      	str	r3, [r2, #16]
}
240110f0:	e005      	b.n	240110fe <HAL_PWREx_EnterSTOPMode+0x82>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
240110f2:	4b06      	ldr	r3, [pc, #24]	; (2401110c <HAL_PWREx_EnterSTOPMode+0x90>)
240110f4:	691b      	ldr	r3, [r3, #16]
240110f6:	4a05      	ldr	r2, [pc, #20]	; (2401110c <HAL_PWREx_EnterSTOPMode+0x90>)
240110f8:	f023 0304 	bic.w	r3, r3, #4
240110fc:	6113      	str	r3, [r2, #16]
}
240110fe:	bf00      	nop
24011100:	3714      	adds	r7, #20
24011102:	46bd      	mov	sp, r7
24011104:	f85d 7b04 	ldr.w	r7, [sp], #4
24011108:	4770      	bx	lr
2401110a:	bf00      	nop
2401110c:	58024800 	.word	0x58024800
24011110:	e000ed00 	.word	0xe000ed00

24011114 <HAL_PWREx_ClearPendingEvent>:
  *         enter low power mode using Wait For Event request.
  * @note   Cortex-M7 must be in CRUN mode when calling this API by Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
24011114:	b480      	push	{r7}
24011116:	af00      	add	r7, sp, #0
  {
    __SEV ();
    __WFE ();
  }
#else
  __WFE ();
24011118:	bf20      	wfe
#endif /* defined (DUAL_CORE) */
}
2401111a:	bf00      	nop
2401111c:	46bd      	mov	sp, r7
2401111e:	f85d 7b04 	ldr.w	r7, [sp], #4
24011122:	4770      	bx	lr

24011124 <HAL_PWREx_EnterSTANDBYMode>:
  *            @arg PWR_D2_DOMAIN: Enter D2 Domain to DSTANDBY mode.
  *            @arg PWR_D3_DOMAIN: Enter D3/SRD Domain to DSTANDBY mode.
  * @retval None
  */
void HAL_PWREx_EnterSTANDBYMode (uint32_t Domain)
{
24011124:	b480      	push	{r7}
24011126:	b083      	sub	sp, #12
24011128:	af00      	add	r7, sp, #0
2401112a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
2401112c:	687b      	ldr	r3, [r7, #4]
2401112e:	2b00      	cmp	r3, #0
24011130:	d10d      	bne.n	2401114e <HAL_PWREx_EnterSTANDBYMode+0x2a>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D1);
24011132:	4b12      	ldr	r3, [pc, #72]	; (2401117c <HAL_PWREx_EnterSTANDBYMode+0x58>)
24011134:	691b      	ldr	r3, [r3, #16]
24011136:	4a11      	ldr	r2, [pc, #68]	; (2401117c <HAL_PWREx_EnterSTANDBYMode+0x58>)
24011138:	f043 0301 	orr.w	r3, r3, #1
2401113c:	6113      	str	r3, [r2, #16]
    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D1);
#endif /*DUAL_CORE*/

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2401113e:	4b10      	ldr	r3, [pc, #64]	; (24011180 <HAL_PWREx_EnterSTANDBYMode+0x5c>)
24011140:	691b      	ldr	r3, [r3, #16]
24011142:	4a0f      	ldr	r2, [pc, #60]	; (24011180 <HAL_PWREx_EnterSTANDBYMode+0x5c>)
24011144:	f043 0304 	orr.w	r3, r3, #4
24011148:	6113      	str	r3, [r2, #16]
#if defined (__CC_ARM)
    __force_stores ();
#endif /* defined (__CC_ARM) */

    /* Request Wait For Interrupt */
    __WFI ();
2401114a:	bf30      	wfi
#if defined (DUAL_CORE)
    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */
    SET_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);
#endif /* defined (DUAL_CORE) */
  }
}
2401114c:	e00f      	b.n	2401116e <HAL_PWREx_EnterSTANDBYMode+0x4a>
  else if (Domain == PWR_D2_DOMAIN)
2401114e:	687b      	ldr	r3, [r7, #4]
24011150:	2b01      	cmp	r3, #1
24011152:	d106      	bne.n	24011162 <HAL_PWREx_EnterSTANDBYMode+0x3e>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D2);
24011154:	4b09      	ldr	r3, [pc, #36]	; (2401117c <HAL_PWREx_EnterSTANDBYMode+0x58>)
24011156:	691b      	ldr	r3, [r3, #16]
24011158:	4a08      	ldr	r2, [pc, #32]	; (2401117c <HAL_PWREx_EnterSTANDBYMode+0x58>)
2401115a:	f043 0302 	orr.w	r3, r3, #2
2401115e:	6113      	str	r3, [r2, #16]
}
24011160:	e005      	b.n	2401116e <HAL_PWREx_EnterSTANDBYMode+0x4a>
    SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
24011162:	4b06      	ldr	r3, [pc, #24]	; (2401117c <HAL_PWREx_EnterSTANDBYMode+0x58>)
24011164:	691b      	ldr	r3, [r3, #16]
24011166:	4a05      	ldr	r2, [pc, #20]	; (2401117c <HAL_PWREx_EnterSTANDBYMode+0x58>)
24011168:	f043 0304 	orr.w	r3, r3, #4
2401116c:	6113      	str	r3, [r2, #16]
}
2401116e:	bf00      	nop
24011170:	370c      	adds	r7, #12
24011172:	46bd      	mov	sp, r7
24011174:	f85d 7b04 	ldr.w	r7, [sp], #4
24011178:	4770      	bx	lr
2401117a:	bf00      	nop
2401117c:	58024800 	.word	0x58024800
24011180:	e000ed00 	.word	0xe000ed00

24011184 <HAL_PWREx_ConfigD3Domain>:
  *                                     regardless of the CPU sub-system low
  *                                     power mode.
  * @retval None
  */
void HAL_PWREx_ConfigD3Domain (uint32_t D3State)
{
24011184:	b480      	push	{r7}
24011186:	b083      	sub	sp, #12
24011188:	af00      	add	r7, sp, #0
2401118a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_D3_STATE (D3State));

  /* Keep D3/SRD in run mode */
  MODIFY_REG (PWR->CPUCR, PWR_CPUCR_RUN_D3, D3State);
2401118c:	4b06      	ldr	r3, [pc, #24]	; (240111a8 <HAL_PWREx_ConfigD3Domain+0x24>)
2401118e:	691b      	ldr	r3, [r3, #16]
24011190:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
24011194:	4904      	ldr	r1, [pc, #16]	; (240111a8 <HAL_PWREx_ConfigD3Domain+0x24>)
24011196:	687b      	ldr	r3, [r7, #4]
24011198:	4313      	orrs	r3, r2
2401119a:	610b      	str	r3, [r1, #16]
}
2401119c:	bf00      	nop
2401119e:	370c      	adds	r7, #12
240111a0:	46bd      	mov	sp, r7
240111a2:	f85d 7b04 	ldr.w	r7, [sp], #4
240111a6:	4770      	bx	lr
240111a8:	58024800 	.word	0x58024800

240111ac <HAL_PWREx_EnableFlashPowerDown>:
  *         obtain the best trade-off between low-power consumption and restart
  *         time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_EnableFlashPowerDown (void)
{
240111ac:	b480      	push	{r7}
240111ae:	af00      	add	r7, sp, #0
  /* Enable the Flash Power Down */
  SET_BIT (PWR->CR1, PWR_CR1_FLPS);
240111b0:	4b05      	ldr	r3, [pc, #20]	; (240111c8 <HAL_PWREx_EnableFlashPowerDown+0x1c>)
240111b2:	681b      	ldr	r3, [r3, #0]
240111b4:	4a04      	ldr	r2, [pc, #16]	; (240111c8 <HAL_PWREx_EnableFlashPowerDown+0x1c>)
240111b6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
240111ba:	6013      	str	r3, [r2, #0]
}
240111bc:	bf00      	nop
240111be:	46bd      	mov	sp, r7
240111c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240111c4:	4770      	bx	lr
240111c6:	bf00      	nop
240111c8:	58024800 	.word	0x58024800

240111cc <HAL_PWREx_DisableFlashPowerDown>:
  *         to obtain the best trade-off between low-power consumption and
  *         restart time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_DisableFlashPowerDown (void)
{
240111cc:	b480      	push	{r7}
240111ce:	af00      	add	r7, sp, #0
  /* Disable the Flash Power Down */
  CLEAR_BIT (PWR->CR1, PWR_CR1_FLPS);
240111d0:	4b05      	ldr	r3, [pc, #20]	; (240111e8 <HAL_PWREx_DisableFlashPowerDown+0x1c>)
240111d2:	681b      	ldr	r3, [r3, #0]
240111d4:	4a04      	ldr	r2, [pc, #16]	; (240111e8 <HAL_PWREx_DisableFlashPowerDown+0x1c>)
240111d6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
240111da:	6013      	str	r3, [r2, #0]
}
240111dc:	bf00      	nop
240111de:	46bd      	mov	sp, r7
240111e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240111e4:	4770      	bx	lr
240111e6:	bf00      	nop
240111e8:	58024800 	.word	0x58024800

240111ec <HAL_PWREx_EnableWakeUpPin>:
  *         Cortex-M7, wake up only Cortex-M4 and wake up Cortex-M7 and
  *         Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_EnableWakeUpPin (PWREx_WakeupPinTypeDef *sPinParams)
{
240111ec:	b480      	push	{r7}
240111ee:	b093      	sub	sp, #76	; 0x4c
240111f0:	af00      	add	r7, sp, #0
240111f2:	6078      	str	r0, [r7, #4]
  uint32_t pinConfig;
  uint32_t regMask;
  const uint32_t pullMask = PWR_WKUPEPR_WKUPPUPD1;
240111f4:	f44f 3340 	mov.w	r3, #196608	; 0x30000
240111f8:	647b      	str	r3, [r7, #68]	; 0x44
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (sPinParams->WakeUpPin));
  assert_param (IS_PWR_WAKEUP_PIN_POLARITY (sPinParams->PinPolarity));
  assert_param (IS_PWR_WAKEUP_PIN_PULL (sPinParams->PinPull));

  pinConfig = sPinParams->WakeUpPin | \
240111fa:	687b      	ldr	r3, [r7, #4]
240111fc:	681a      	ldr	r2, [r3, #0]
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
240111fe:	687b      	ldr	r3, [r7, #4]
24011200:	6859      	ldr	r1, [r3, #4]
24011202:	687b      	ldr	r3, [r7, #4]
24011204:	681b      	ldr	r3, [r3, #0]
24011206:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
24011208:	693b      	ldr	r3, [r7, #16]
2401120a:	fa93 f3a3 	rbit	r3, r3
2401120e:	60fb      	str	r3, [r7, #12]
  return result;
24011210:	68fb      	ldr	r3, [r7, #12]
24011212:	617b      	str	r3, [r7, #20]
  if (value == 0U)
24011214:	697b      	ldr	r3, [r7, #20]
24011216:	2b00      	cmp	r3, #0
24011218:	d101      	bne.n	2401121e <HAL_PWREx_EnableWakeUpPin+0x32>
    return 32U;
2401121a:	2320      	movs	r3, #32
2401121c:	e003      	b.n	24011226 <HAL_PWREx_EnableWakeUpPin+0x3a>
  }
  return __builtin_clz(value);
2401121e:	697b      	ldr	r3, [r7, #20]
24011220:	fab3 f383 	clz	r3, r3
24011224:	b2db      	uxtb	r3, r3
24011226:	3308      	adds	r3, #8
24011228:	f003 031f 	and.w	r3, r3, #31
2401122c:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
24011230:	431a      	orrs	r2, r3
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
24011232:	687b      	ldr	r3, [r7, #4]
24011234:	6899      	ldr	r1, [r3, #8]
24011236:	687b      	ldr	r3, [r7, #4]
24011238:	681b      	ldr	r3, [r3, #0]
2401123a:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2401123c:	69fb      	ldr	r3, [r7, #28]
2401123e:	fa93 f3a3 	rbit	r3, r3
24011242:	61bb      	str	r3, [r7, #24]
  return result;
24011244:	69bb      	ldr	r3, [r7, #24]
24011246:	623b      	str	r3, [r7, #32]
  if (value == 0U)
24011248:	6a3b      	ldr	r3, [r7, #32]
2401124a:	2b00      	cmp	r3, #0
2401124c:	d101      	bne.n	24011252 <HAL_PWREx_EnableWakeUpPin+0x66>
    return 32U;
2401124e:	2320      	movs	r3, #32
24011250:	e003      	b.n	2401125a <HAL_PWREx_EnableWakeUpPin+0x6e>
  return __builtin_clz(value);
24011252:	6a3b      	ldr	r3, [r7, #32]
24011254:	fab3 f383 	clz	r3, r3
24011258:	b2db      	uxtb	r3, r3
2401125a:	3308      	adds	r3, #8
2401125c:	005b      	lsls	r3, r3, #1
2401125e:	f003 031e 	and.w	r3, r3, #30
24011262:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
24011266:	4313      	orrs	r3, r2
24011268:	643b      	str	r3, [r7, #64]	; 0x40

  regMask   = sPinParams->WakeUpPin | \
2401126a:	687b      	ldr	r3, [r7, #4]
2401126c:	681a      	ldr	r2, [r3, #0]
              (PWR_WKUPEPR_WKUPP1 << (POSITION_VAL(sPinParams->WakeUpPin) & 0x1FU)) | \
2401126e:	687b      	ldr	r3, [r7, #4]
24011270:	681b      	ldr	r3, [r3, #0]
24011272:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
24011274:	6abb      	ldr	r3, [r7, #40]	; 0x28
24011276:	fa93 f3a3 	rbit	r3, r3
2401127a:	627b      	str	r3, [r7, #36]	; 0x24
  return result;
2401127c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401127e:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (value == 0U)
24011280:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24011282:	2b00      	cmp	r3, #0
24011284:	d101      	bne.n	2401128a <HAL_PWREx_EnableWakeUpPin+0x9e>
    return 32U;
24011286:	2320      	movs	r3, #32
24011288:	e003      	b.n	24011292 <HAL_PWREx_EnableWakeUpPin+0xa6>
  return __builtin_clz(value);
2401128a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
2401128c:	fab3 f383 	clz	r3, r3
24011290:	b2db      	uxtb	r3, r3
24011292:	f003 031f 	and.w	r3, r3, #31
24011296:	f44f 7180 	mov.w	r1, #256	; 0x100
2401129a:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
2401129e:	431a      	orrs	r2, r3
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
240112a0:	687b      	ldr	r3, [r7, #4]
240112a2:	681b      	ldr	r3, [r3, #0]
240112a4:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
240112a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240112a8:	fa93 f3a3 	rbit	r3, r3
240112ac:	633b      	str	r3, [r7, #48]	; 0x30
  return result;
240112ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240112b0:	63bb      	str	r3, [r7, #56]	; 0x38
  if (value == 0U)
240112b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240112b4:	2b00      	cmp	r3, #0
240112b6:	d101      	bne.n	240112bc <HAL_PWREx_EnableWakeUpPin+0xd0>
    return 32U;
240112b8:	2320      	movs	r3, #32
240112ba:	e003      	b.n	240112c4 <HAL_PWREx_EnableWakeUpPin+0xd8>
  return __builtin_clz(value);
240112bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240112be:	fab3 f383 	clz	r3, r3
240112c2:	b2db      	uxtb	r3, r3
240112c4:	005b      	lsls	r3, r3, #1
240112c6:	f003 031e 	and.w	r3, r3, #30
240112ca:	6c79      	ldr	r1, [r7, #68]	; 0x44
240112cc:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
240112d0:	4313      	orrs	r3, r2
240112d2:	63fb      	str	r3, [r7, #60]	; 0x3c

  /* Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge) */
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
240112d4:	4b0e      	ldr	r3, [pc, #56]	; (24011310 <HAL_PWREx_EnableWakeUpPin+0x124>)
240112d6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
240112d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
240112da:	43db      	mvns	r3, r3
240112dc:	401a      	ands	r2, r3
240112de:	490c      	ldr	r1, [pc, #48]	; (24011310 <HAL_PWREx_EnableWakeUpPin+0x124>)
240112e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
240112e2:	4313      	orrs	r3, r2
240112e4:	628b      	str	r3, [r1, #40]	; 0x28
#ifndef DUAL_CORE
  /* Configure the Wakeup Pin EXTI Line */
  MODIFY_REG (EXTI->IMR2, PWR_EXTI_WAKEUP_PINS_MASK, (sPinParams->WakeUpPin << EXTI_IMR2_IM55_Pos));
240112e6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240112ea:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
240112ee:	f023 52fc 	bic.w	r2, r3, #528482304	; 0x1f800000
240112f2:	687b      	ldr	r3, [r7, #4]
240112f4:	681b      	ldr	r3, [r3, #0]
240112f6:	05db      	lsls	r3, r3, #23
240112f8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
240112fc:	4313      	orrs	r3, r2
240112fe:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
#endif /* !DUAL_CORE */
}
24011302:	bf00      	nop
24011304:	374c      	adds	r7, #76	; 0x4c
24011306:	46bd      	mov	sp, r7
24011308:	f85d 7b04 	ldr.w	r7, [sp], #4
2401130c:	4770      	bx	lr
2401130e:	bf00      	nop
24011310:	58024800 	.word	0x58024800

24011314 <HAL_PWREx_DisableWakeUpPin>:
  * @note   The PWR_WAKEUP_PIN3 and PWR_WAKEUP_PIN5 are available only for
  *         devices that support GPIOI port.
  * @retval None
  */
void HAL_PWREx_DisableWakeUpPin (uint32_t WakeUpPin)
{
24011314:	b480      	push	{r7}
24011316:	b083      	sub	sp, #12
24011318:	af00      	add	r7, sp, #0
2401131a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPin));

  /* Disable the WakeUpPin */
  CLEAR_BIT (PWR->WKUPEPR, WakeUpPin);
2401131c:	4b06      	ldr	r3, [pc, #24]	; (24011338 <HAL_PWREx_DisableWakeUpPin+0x24>)
2401131e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24011320:	687b      	ldr	r3, [r7, #4]
24011322:	43db      	mvns	r3, r3
24011324:	4904      	ldr	r1, [pc, #16]	; (24011338 <HAL_PWREx_DisableWakeUpPin+0x24>)
24011326:	4013      	ands	r3, r2
24011328:	628b      	str	r3, [r1, #40]	; 0x28
}
2401132a:	bf00      	nop
2401132c:	370c      	adds	r7, #12
2401132e:	46bd      	mov	sp, r7
24011330:	f85d 7b04 	ldr.w	r7, [sp], #4
24011334:	4770      	bx	lr
24011336:	bf00      	nop
24011338:	58024800 	.word	0x58024800

2401133c <HAL_PWREx_GetWakeupFlag>:
  * @note   The PWR_WAKEUP_FLAG3 and PWR_WAKEUP_FLAG5 are available only for
  *         devices that support GPIOI port.
  * @retval The Wake-Up pin flag.
  */
uint32_t HAL_PWREx_GetWakeupFlag (uint32_t WakeUpFlag)
{
2401133c:	b480      	push	{r7}
2401133e:	b083      	sub	sp, #12
24011340:	af00      	add	r7, sp, #0
24011342:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Return the wake up pin flag */
  return (PWR->WKUPFR & WakeUpFlag);
24011344:	4b04      	ldr	r3, [pc, #16]	; (24011358 <HAL_PWREx_GetWakeupFlag+0x1c>)
24011346:	6a5a      	ldr	r2, [r3, #36]	; 0x24
24011348:	687b      	ldr	r3, [r7, #4]
2401134a:	4013      	ands	r3, r2
}
2401134c:	4618      	mov	r0, r3
2401134e:	370c      	adds	r7, #12
24011350:	46bd      	mov	sp, r7
24011352:	f85d 7b04 	ldr.w	r7, [sp], #4
24011356:	4770      	bx	lr
24011358:	58024800 	.word	0x58024800

2401135c <HAL_PWREx_ClearWakeupFlag>:
  * @note   The PWR_WAKEUP_FLAG3 and PWR_WAKEUP_FLAG5 are available only for
  *         devices that support GPIOI port.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ClearWakeupFlag (uint32_t WakeUpFlag)
{
2401135c:	b480      	push	{r7}
2401135e:	b083      	sub	sp, #12
24011360:	af00      	add	r7, sp, #0
24011362:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Clear the wake up event received from wake up pin x */
  SET_BIT (PWR->WKUPCR, WakeUpFlag);
24011364:	4b0a      	ldr	r3, [pc, #40]	; (24011390 <HAL_PWREx_ClearWakeupFlag+0x34>)
24011366:	6a1a      	ldr	r2, [r3, #32]
24011368:	4909      	ldr	r1, [pc, #36]	; (24011390 <HAL_PWREx_ClearWakeupFlag+0x34>)
2401136a:	687b      	ldr	r3, [r7, #4]
2401136c:	4313      	orrs	r3, r2
2401136e:	620b      	str	r3, [r1, #32]

  /* Check if the wake up event is well cleared */
  if ((PWR->WKUPFR & WakeUpFlag) != 0U)
24011370:	4b07      	ldr	r3, [pc, #28]	; (24011390 <HAL_PWREx_ClearWakeupFlag+0x34>)
24011372:	6a5a      	ldr	r2, [r3, #36]	; 0x24
24011374:	687b      	ldr	r3, [r7, #4]
24011376:	4013      	ands	r3, r2
24011378:	2b00      	cmp	r3, #0
2401137a:	d001      	beq.n	24011380 <HAL_PWREx_ClearWakeupFlag+0x24>
  {
    return HAL_ERROR;
2401137c:	2301      	movs	r3, #1
2401137e:	e000      	b.n	24011382 <HAL_PWREx_ClearWakeupFlag+0x26>
  }

  return HAL_OK;
24011380:	2300      	movs	r3, #0
}
24011382:	4618      	mov	r0, r3
24011384:	370c      	adds	r7, #12
24011386:	46bd      	mov	sp, r7
24011388:	f85d 7b04 	ldr.w	r7, [sp], #4
2401138c:	4770      	bx	lr
2401138e:	bf00      	nop
24011390:	58024800 	.word	0x58024800

24011394 <HAL_PWREx_WAKEUP_PIN_IRQHandler>:
  * @brief This function handles the PWR WAKEUP PIN interrupt request.
  * @note   This API should be called under the WAKEUP_PIN_IRQHandler().
  * @retval None.
  */
void HAL_PWREx_WAKEUP_PIN_IRQHandler (void)
{
24011394:	b580      	push	{r7, lr}
24011396:	af00      	add	r7, sp, #0
  /* Wakeup pin EXTI line interrupt detected */
  if (READ_BIT(PWR->WKUPFR, PWR_WKUPFR_WKUPF1) != 0U)
24011398:	4b2a      	ldr	r3, [pc, #168]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2401139a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401139c:	f003 0301 	and.w	r3, r3, #1
240113a0:	2b00      	cmp	r3, #0
240113a2:	d008      	beq.n	240113b6 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x22>
  {
    /* Clear PWR WKUPF1 flag */
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP1);
240113a4:	4b27      	ldr	r3, [pc, #156]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113a6:	6a1b      	ldr	r3, [r3, #32]
240113a8:	4a26      	ldr	r2, [pc, #152]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113aa:	f043 0301 	orr.w	r3, r3, #1
240113ae:	6213      	str	r3, [r2, #32]

    /* PWR WKUP1 interrupt user callback */
    HAL_PWREx_WKUP1_Callback ();
240113b0:	f000 f84a 	bl	24011448 <HAL_PWREx_WKUP1_Callback>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);

    /* PWR WKUP6 interrupt user callback */
    HAL_PWREx_WKUP6_Callback ();
  }
}
240113b4:	e043      	b.n	2401143e <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF2) != 0U)
240113b6:	4b23      	ldr	r3, [pc, #140]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240113ba:	f003 0302 	and.w	r3, r3, #2
240113be:	2b00      	cmp	r3, #0
240113c0:	d008      	beq.n	240113d4 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x40>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP2);
240113c2:	4b20      	ldr	r3, [pc, #128]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113c4:	6a1b      	ldr	r3, [r3, #32]
240113c6:	4a1f      	ldr	r2, [pc, #124]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113c8:	f043 0302 	orr.w	r3, r3, #2
240113cc:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP2_Callback ();
240113ce:	f000 f842 	bl	24011456 <HAL_PWREx_WKUP2_Callback>
}
240113d2:	e034      	b.n	2401143e <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF3) != 0U)
240113d4:	4b1b      	ldr	r3, [pc, #108]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240113d8:	f003 0304 	and.w	r3, r3, #4
240113dc:	2b00      	cmp	r3, #0
240113de:	d008      	beq.n	240113f2 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x5e>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP3);
240113e0:	4b18      	ldr	r3, [pc, #96]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113e2:	6a1b      	ldr	r3, [r3, #32]
240113e4:	4a17      	ldr	r2, [pc, #92]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113e6:	f043 0304 	orr.w	r3, r3, #4
240113ea:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP3_Callback ();
240113ec:	f000 f83a 	bl	24011464 <HAL_PWREx_WKUP3_Callback>
}
240113f0:	e025      	b.n	2401143e <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF4) != 0U)
240113f2:	4b14      	ldr	r3, [pc, #80]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240113f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240113f6:	f003 0308 	and.w	r3, r3, #8
240113fa:	2b00      	cmp	r3, #0
240113fc:	d008      	beq.n	24011410 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x7c>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP4);
240113fe:	4b11      	ldr	r3, [pc, #68]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011400:	6a1b      	ldr	r3, [r3, #32]
24011402:	4a10      	ldr	r2, [pc, #64]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011404:	f043 0308 	orr.w	r3, r3, #8
24011408:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP4_Callback ();
2401140a:	f000 f832 	bl	24011472 <HAL_PWREx_WKUP4_Callback>
}
2401140e:	e016      	b.n	2401143e <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF5) != 0U)
24011410:	4b0c      	ldr	r3, [pc, #48]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011412:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011414:	f003 0310 	and.w	r3, r3, #16
24011418:	2b00      	cmp	r3, #0
2401141a:	d008      	beq.n	2401142e <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x9a>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP5);
2401141c:	4b09      	ldr	r3, [pc, #36]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2401141e:	6a1b      	ldr	r3, [r3, #32]
24011420:	4a08      	ldr	r2, [pc, #32]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011422:	f043 0310 	orr.w	r3, r3, #16
24011426:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP5_Callback ();
24011428:	f000 f82a 	bl	24011480 <HAL_PWREx_WKUP5_Callback>
}
2401142c:	e007      	b.n	2401143e <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);
2401142e:	4b05      	ldr	r3, [pc, #20]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011430:	6a1b      	ldr	r3, [r3, #32]
24011432:	4a04      	ldr	r2, [pc, #16]	; (24011444 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011434:	f043 0320 	orr.w	r3, r3, #32
24011438:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP6_Callback ();
2401143a:	f000 f828 	bl	2401148e <HAL_PWREx_WKUP6_Callback>
}
2401143e:	bf00      	nop
24011440:	bd80      	pop	{r7, pc}
24011442:	bf00      	nop
24011444:	58024800 	.word	0x58024800

24011448 <HAL_PWREx_WKUP1_Callback>:
/**
  * @brief PWR WKUP1 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP1_Callback (void)
{
24011448:	b480      	push	{r7}
2401144a:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP1Callback can be implemented in the user file
  */
}
2401144c:	bf00      	nop
2401144e:	46bd      	mov	sp, r7
24011450:	f85d 7b04 	ldr.w	r7, [sp], #4
24011454:	4770      	bx	lr

24011456 <HAL_PWREx_WKUP2_Callback>:
/**
  * @brief PWR WKUP2 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP2_Callback (void)
{
24011456:	b480      	push	{r7}
24011458:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP2Callback can be implemented in the user file
  */
}
2401145a:	bf00      	nop
2401145c:	46bd      	mov	sp, r7
2401145e:	f85d 7b04 	ldr.w	r7, [sp], #4
24011462:	4770      	bx	lr

24011464 <HAL_PWREx_WKUP3_Callback>:
/**
  * @brief PWR WKUP3 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP3_Callback (void)
{
24011464:	b480      	push	{r7}
24011466:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP3Callback can be implemented in the user file
  */
}
24011468:	bf00      	nop
2401146a:	46bd      	mov	sp, r7
2401146c:	f85d 7b04 	ldr.w	r7, [sp], #4
24011470:	4770      	bx	lr

24011472 <HAL_PWREx_WKUP4_Callback>:
/**
  * @brief PWR WKUP4 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP4_Callback (void)
{
24011472:	b480      	push	{r7}
24011474:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP4Callback can be implemented in the user file
  */
}
24011476:	bf00      	nop
24011478:	46bd      	mov	sp, r7
2401147a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401147e:	4770      	bx	lr

24011480 <HAL_PWREx_WKUP5_Callback>:
/**
  * @brief PWR WKUP5 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP5_Callback (void)
{
24011480:	b480      	push	{r7}
24011482:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP5Callback can be implemented in the user file
  */
}
24011484:	bf00      	nop
24011486:	46bd      	mov	sp, r7
24011488:	f85d 7b04 	ldr.w	r7, [sp], #4
2401148c:	4770      	bx	lr

2401148e <HAL_PWREx_WKUP6_Callback>:
/**
  * @brief PWR WKUP6 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP6_Callback (void)
{
2401148e:	b480      	push	{r7}
24011490:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP6Callback can be implemented in the user file
  */
}
24011492:	bf00      	nop
24011494:	46bd      	mov	sp, r7
24011496:	f85d 7b04 	ldr.w	r7, [sp], #4
2401149a:	4770      	bx	lr

2401149c <HAL_PWREx_EnableBkUpReg>:
/**
  * @brief Enable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg (void)
{
2401149c:	b580      	push	{r7, lr}
2401149e:	b082      	sub	sp, #8
240114a0:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the Backup regulator */
  SET_BIT (PWR->CR2, PWR_CR2_BREN);
240114a2:	4b10      	ldr	r3, [pc, #64]	; (240114e4 <HAL_PWREx_EnableBkUpReg+0x48>)
240114a4:	689b      	ldr	r3, [r3, #8]
240114a6:	4a0f      	ldr	r2, [pc, #60]	; (240114e4 <HAL_PWREx_EnableBkUpReg+0x48>)
240114a8:	f043 0301 	orr.w	r3, r3, #1
240114ac:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
240114ae:	f7f0 fdb5 	bl	2400201c <HAL_GetTick>
240114b2:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
240114b4:	e009      	b.n	240114ca <HAL_PWREx_EnableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
240114b6:	f7f0 fdb1 	bl	2400201c <HAL_GetTick>
240114ba:	4602      	mov	r2, r0
240114bc:	687b      	ldr	r3, [r7, #4]
240114be:	1ad3      	subs	r3, r2, r3
240114c0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
240114c4:	d901      	bls.n	240114ca <HAL_PWREx_EnableBkUpReg+0x2e>
    {
      return HAL_ERROR;
240114c6:	2301      	movs	r3, #1
240114c8:	e007      	b.n	240114da <HAL_PWREx_EnableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
240114ca:	4b06      	ldr	r3, [pc, #24]	; (240114e4 <HAL_PWREx_EnableBkUpReg+0x48>)
240114cc:	689b      	ldr	r3, [r3, #8]
240114ce:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240114d2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240114d6:	d1ee      	bne.n	240114b6 <HAL_PWREx_EnableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
240114d8:	2300      	movs	r3, #0
}
240114da:	4618      	mov	r0, r3
240114dc:	3708      	adds	r7, #8
240114de:	46bd      	mov	sp, r7
240114e0:	bd80      	pop	{r7, pc}
240114e2:	bf00      	nop
240114e4:	58024800 	.word	0x58024800

240114e8 <HAL_PWREx_DisableBkUpReg>:
/**
  * @brief Disable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg (void)
{
240114e8:	b580      	push	{r7, lr}
240114ea:	b082      	sub	sp, #8
240114ec:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the Backup regulator */
  CLEAR_BIT (PWR->CR2, PWR_CR2_BREN);
240114ee:	4b10      	ldr	r3, [pc, #64]	; (24011530 <HAL_PWREx_DisableBkUpReg+0x48>)
240114f0:	689b      	ldr	r3, [r3, #8]
240114f2:	4a0f      	ldr	r2, [pc, #60]	; (24011530 <HAL_PWREx_DisableBkUpReg+0x48>)
240114f4:	f023 0301 	bic.w	r3, r3, #1
240114f8:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
240114fa:	f7f0 fd8f 	bl	2400201c <HAL_GetTick>
240114fe:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is reset */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
24011500:	e009      	b.n	24011516 <HAL_PWREx_DisableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
24011502:	f7f0 fd8b 	bl	2400201c <HAL_GetTick>
24011506:	4602      	mov	r2, r0
24011508:	687b      	ldr	r3, [r7, #4]
2401150a:	1ad3      	subs	r3, r2, r3
2401150c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24011510:	d901      	bls.n	24011516 <HAL_PWREx_DisableBkUpReg+0x2e>
    {
      return HAL_ERROR;
24011512:	2301      	movs	r3, #1
24011514:	e007      	b.n	24011526 <HAL_PWREx_DisableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
24011516:	4b06      	ldr	r3, [pc, #24]	; (24011530 <HAL_PWREx_DisableBkUpReg+0x48>)
24011518:	689b      	ldr	r3, [r3, #8]
2401151a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401151e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24011522:	d0ee      	beq.n	24011502 <HAL_PWREx_DisableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
24011524:	2300      	movs	r3, #0
}
24011526:	4618      	mov	r0, r3
24011528:	3708      	adds	r7, #8
2401152a:	46bd      	mov	sp, r7
2401152c:	bd80      	pop	{r7, pc}
2401152e:	bf00      	nop
24011530:	58024800 	.word	0x58024800

24011534 <HAL_PWREx_EnableUSBReg>:
/**
  * @brief Enable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableUSBReg (void)
{
24011534:	b580      	push	{r7, lr}
24011536:	b082      	sub	sp, #8
24011538:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the USB regulator */
  SET_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2401153a:	4b10      	ldr	r3, [pc, #64]	; (2401157c <HAL_PWREx_EnableUSBReg+0x48>)
2401153c:	68db      	ldr	r3, [r3, #12]
2401153e:	4a0f      	ldr	r2, [pc, #60]	; (2401157c <HAL_PWREx_EnableUSBReg+0x48>)
24011540:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
24011544:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
24011546:	f7f0 fd69 	bl	2400201c <HAL_GetTick>
2401154a:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
2401154c:	e009      	b.n	24011562 <HAL_PWREx_EnableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2401154e:	f7f0 fd65 	bl	2400201c <HAL_GetTick>
24011552:	4602      	mov	r2, r0
24011554:	687b      	ldr	r3, [r7, #4]
24011556:	1ad3      	subs	r3, r2, r3
24011558:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2401155c:	d901      	bls.n	24011562 <HAL_PWREx_EnableUSBReg+0x2e>
    {
      return HAL_ERROR;
2401155e:	2301      	movs	r3, #1
24011560:	e007      	b.n	24011572 <HAL_PWREx_EnableUSBReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
24011562:	4b06      	ldr	r3, [pc, #24]	; (2401157c <HAL_PWREx_EnableUSBReg+0x48>)
24011564:	68db      	ldr	r3, [r3, #12]
24011566:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2401156a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2401156e:	d1ee      	bne.n	2401154e <HAL_PWREx_EnableUSBReg+0x1a>
    }
  }

  return HAL_OK;
24011570:	2300      	movs	r3, #0
}
24011572:	4618      	mov	r0, r3
24011574:	3708      	adds	r7, #8
24011576:	46bd      	mov	sp, r7
24011578:	bd80      	pop	{r7, pc}
2401157a:	bf00      	nop
2401157c:	58024800 	.word	0x58024800

24011580 <HAL_PWREx_DisableUSBReg>:
/**
  * @brief Disable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableUSBReg (void)
{
24011580:	b580      	push	{r7, lr}
24011582:	b082      	sub	sp, #8
24011584:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the USB regulator */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USBREGEN);
24011586:	4b10      	ldr	r3, [pc, #64]	; (240115c8 <HAL_PWREx_DisableUSBReg+0x48>)
24011588:	68db      	ldr	r3, [r3, #12]
2401158a:	4a0f      	ldr	r2, [pc, #60]	; (240115c8 <HAL_PWREx_DisableUSBReg+0x48>)
2401158c:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
24011590:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
24011592:	f7f0 fd43 	bl	2400201c <HAL_GetTick>
24011596:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is reset */
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
24011598:	e009      	b.n	240115ae <HAL_PWREx_DisableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2401159a:	f7f0 fd3f 	bl	2400201c <HAL_GetTick>
2401159e:	4602      	mov	r2, r0
240115a0:	687b      	ldr	r3, [r7, #4]
240115a2:	1ad3      	subs	r3, r2, r3
240115a4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
240115a8:	d901      	bls.n	240115ae <HAL_PWREx_DisableUSBReg+0x2e>
    {
      return HAL_ERROR;
240115aa:	2301      	movs	r3, #1
240115ac:	e007      	b.n	240115be <HAL_PWREx_DisableUSBReg+0x3e>
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
240115ae:	4b06      	ldr	r3, [pc, #24]	; (240115c8 <HAL_PWREx_DisableUSBReg+0x48>)
240115b0:	68db      	ldr	r3, [r3, #12]
240115b2:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
240115b6:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
240115ba:	d0ee      	beq.n	2401159a <HAL_PWREx_DisableUSBReg+0x1a>
    }
  }

  return HAL_OK;
240115bc:	2300      	movs	r3, #0
}
240115be:	4618      	mov	r0, r3
240115c0:	3708      	adds	r7, #8
240115c2:	46bd      	mov	sp, r7
240115c4:	bd80      	pop	{r7, pc}
240115c6:	bf00      	nop
240115c8:	58024800 	.word	0x58024800

240115cc <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
240115cc:	b480      	push	{r7}
240115ce:	af00      	add	r7, sp, #0
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
240115d0:	4b05      	ldr	r3, [pc, #20]	; (240115e8 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
240115d2:	68db      	ldr	r3, [r3, #12]
240115d4:	4a04      	ldr	r2, [pc, #16]	; (240115e8 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
240115d6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
240115da:	60d3      	str	r3, [r2, #12]
}
240115dc:	bf00      	nop
240115de:	46bd      	mov	sp, r7
240115e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240115e4:	4770      	bx	lr
240115e6:	bf00      	nop
240115e8:	58024800 	.word	0x58024800

240115ec <HAL_PWREx_DisableUSBVoltageDetector>:
/**
  * @brief Disable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
240115ec:	b480      	push	{r7}
240115ee:	af00      	add	r7, sp, #0
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
240115f0:	4b05      	ldr	r3, [pc, #20]	; (24011608 <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
240115f2:	68db      	ldr	r3, [r3, #12]
240115f4:	4a04      	ldr	r2, [pc, #16]	; (24011608 <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
240115f6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
240115fa:	60d3      	str	r3, [r2, #12]
}
240115fc:	bf00      	nop
240115fe:	46bd      	mov	sp, r7
24011600:	f85d 7b04 	ldr.w	r7, [sp], #4
24011604:	4770      	bx	lr
24011606:	bf00      	nop
24011608:	58024800 	.word	0x58024800

2401160c <HAL_PWREx_EnableBatteryCharging>:
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_5 : 5 KOhm resistor.
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_1_5 : 1.5 KOhm resistor.
  * @retval None.
  */
void HAL_PWREx_EnableBatteryCharging (uint32_t ResistorValue)
{
2401160c:	b480      	push	{r7}
2401160e:	b083      	sub	sp, #12
24011610:	af00      	add	r7, sp, #0
24011612:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_BATTERY_RESISTOR_SELECT (ResistorValue));

  /* Specify the charging resistor */
  MODIFY_REG (PWR->CR3, PWR_CR3_VBRS, ResistorValue);
24011614:	4b09      	ldr	r3, [pc, #36]	; (2401163c <HAL_PWREx_EnableBatteryCharging+0x30>)
24011616:	68db      	ldr	r3, [r3, #12]
24011618:	f423 7200 	bic.w	r2, r3, #512	; 0x200
2401161c:	4907      	ldr	r1, [pc, #28]	; (2401163c <HAL_PWREx_EnableBatteryCharging+0x30>)
2401161e:	687b      	ldr	r3, [r7, #4]
24011620:	4313      	orrs	r3, r2
24011622:	60cb      	str	r3, [r1, #12]

  /* Enable the Battery charging */
  SET_BIT (PWR->CR3, PWR_CR3_VBE);
24011624:	4b05      	ldr	r3, [pc, #20]	; (2401163c <HAL_PWREx_EnableBatteryCharging+0x30>)
24011626:	68db      	ldr	r3, [r3, #12]
24011628:	4a04      	ldr	r2, [pc, #16]	; (2401163c <HAL_PWREx_EnableBatteryCharging+0x30>)
2401162a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2401162e:	60d3      	str	r3, [r2, #12]
}
24011630:	bf00      	nop
24011632:	370c      	adds	r7, #12
24011634:	46bd      	mov	sp, r7
24011636:	f85d 7b04 	ldr.w	r7, [sp], #4
2401163a:	4770      	bx	lr
2401163c:	58024800 	.word	0x58024800

24011640 <HAL_PWREx_DisableBatteryCharging>:
/**
  * @brief Disable the Battery charging.
  * @retval None.
  */
void HAL_PWREx_DisableBatteryCharging (void)
{
24011640:	b480      	push	{r7}
24011642:	af00      	add	r7, sp, #0
  /* Disable the Battery charging */
  CLEAR_BIT (PWR->CR3, PWR_CR3_VBE);
24011644:	4b05      	ldr	r3, [pc, #20]	; (2401165c <HAL_PWREx_DisableBatteryCharging+0x1c>)
24011646:	68db      	ldr	r3, [r3, #12]
24011648:	4a04      	ldr	r2, [pc, #16]	; (2401165c <HAL_PWREx_DisableBatteryCharging+0x1c>)
2401164a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2401164e:	60d3      	str	r3, [r2, #12]
}
24011650:	bf00      	nop
24011652:	46bd      	mov	sp, r7
24011654:	f85d 7b04 	ldr.w	r7, [sp], #4
24011658:	4770      	bx	lr
2401165a:	bf00      	nop
2401165c:	58024800 	.word	0x58024800

24011660 <HAL_PWREx_EnableMonitoring>:
/**
  * @brief Enable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_EnableMonitoring (void)
{
24011660:	b480      	push	{r7}
24011662:	af00      	add	r7, sp, #0
  /* Enable the VBAT and Temperature monitoring */
  SET_BIT (PWR->CR2, PWR_CR2_MONEN);
24011664:	4b05      	ldr	r3, [pc, #20]	; (2401167c <HAL_PWREx_EnableMonitoring+0x1c>)
24011666:	689b      	ldr	r3, [r3, #8]
24011668:	4a04      	ldr	r2, [pc, #16]	; (2401167c <HAL_PWREx_EnableMonitoring+0x1c>)
2401166a:	f043 0310 	orr.w	r3, r3, #16
2401166e:	6093      	str	r3, [r2, #8]
}
24011670:	bf00      	nop
24011672:	46bd      	mov	sp, r7
24011674:	f85d 7b04 	ldr.w	r7, [sp], #4
24011678:	4770      	bx	lr
2401167a:	bf00      	nop
2401167c:	58024800 	.word	0x58024800

24011680 <HAL_PWREx_DisableMonitoring>:
/**
  * @brief Disable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_DisableMonitoring (void)
{
24011680:	b480      	push	{r7}
24011682:	af00      	add	r7, sp, #0
  /* Disable the VBAT and Temperature monitoring */
  CLEAR_BIT (PWR->CR2, PWR_CR2_MONEN);
24011684:	4b05      	ldr	r3, [pc, #20]	; (2401169c <HAL_PWREx_DisableMonitoring+0x1c>)
24011686:	689b      	ldr	r3, [r3, #8]
24011688:	4a04      	ldr	r2, [pc, #16]	; (2401169c <HAL_PWREx_DisableMonitoring+0x1c>)
2401168a:	f023 0310 	bic.w	r3, r3, #16
2401168e:	6093      	str	r3, [r2, #8]
}
24011690:	bf00      	nop
24011692:	46bd      	mov	sp, r7
24011694:	f85d 7b04 	ldr.w	r7, [sp], #4
24011698:	4770      	bx	lr
2401169a:	bf00      	nop
2401169c:	58024800 	.word	0x58024800

240116a0 <HAL_PWREx_GetTemperatureLevel>:
  * @brief Indicate whether the junction temperature is between, above or below
  *        the thresholds.
  * @retval Temperature level.
  */
uint32_t HAL_PWREx_GetTemperatureLevel (void)
{
240116a0:	b480      	push	{r7}
240116a2:	b083      	sub	sp, #12
240116a4:	af00      	add	r7, sp, #0
  uint32_t tempLevel, regValue;

  /* Read the temperature flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_TEMPH | PWR_CR2_TEMPL));
240116a6:	4b0f      	ldr	r3, [pc, #60]	; (240116e4 <HAL_PWREx_GetTemperatureLevel+0x44>)
240116a8:	689b      	ldr	r3, [r3, #8]
240116aa:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
240116ae:	603b      	str	r3, [r7, #0]

  /* Check if the temperature is below the threshold */
  if (regValue == PWR_CR2_TEMPL)
240116b0:	683b      	ldr	r3, [r7, #0]
240116b2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240116b6:	d103      	bne.n	240116c0 <HAL_PWREx_GetTemperatureLevel+0x20>
  {
    tempLevel = PWR_TEMP_BELOW_LOW_THRESHOLD;
240116b8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
240116bc:	607b      	str	r3, [r7, #4]
240116be:	e009      	b.n	240116d4 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* Check if the temperature is above the threshold */
  else if (regValue == PWR_CR2_TEMPH)
240116c0:	683b      	ldr	r3, [r7, #0]
240116c2:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
240116c6:	d103      	bne.n	240116d0 <HAL_PWREx_GetTemperatureLevel+0x30>
  {
    tempLevel = PWR_TEMP_ABOVE_HIGH_THRESHOLD;
240116c8:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
240116cc:	607b      	str	r3, [r7, #4]
240116ce:	e001      	b.n	240116d4 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* The temperature is between the thresholds */
  else
  {
    tempLevel = PWR_TEMP_BETWEEN_HIGH_LOW_THRESHOLD;
240116d0:	2300      	movs	r3, #0
240116d2:	607b      	str	r3, [r7, #4]
  }

  return tempLevel;
240116d4:	687b      	ldr	r3, [r7, #4]
}
240116d6:	4618      	mov	r0, r3
240116d8:	370c      	adds	r7, #12
240116da:	46bd      	mov	sp, r7
240116dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240116e0:	4770      	bx	lr
240116e2:	bf00      	nop
240116e4:	58024800 	.word	0x58024800

240116e8 <HAL_PWREx_GetVBATLevel>:
  * @brief Indicate whether the Battery voltage level is between, above or below
  *        the thresholds.
  * @retval VBAT level.
  */
uint32_t HAL_PWREx_GetVBATLevel (void)
{
240116e8:	b480      	push	{r7}
240116ea:	b083      	sub	sp, #12
240116ec:	af00      	add	r7, sp, #0
  uint32_t VBATLevel, regValue;

  /* Read the VBAT flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_VBATH | PWR_CR2_VBATL));
240116ee:	4b0f      	ldr	r3, [pc, #60]	; (2401172c <HAL_PWREx_GetVBATLevel+0x44>)
240116f0:	689b      	ldr	r3, [r3, #8]
240116f2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
240116f6:	603b      	str	r3, [r7, #0]

  /* Check if the VBAT is below the threshold */
  if (regValue == PWR_CR2_VBATL)
240116f8:	683b      	ldr	r3, [r7, #0]
240116fa:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
240116fe:	d103      	bne.n	24011708 <HAL_PWREx_GetVBATLevel+0x20>
  {
    VBATLevel = PWR_VBAT_BELOW_LOW_THRESHOLD;
24011700:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
24011704:	607b      	str	r3, [r7, #4]
24011706:	e009      	b.n	2401171c <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* Check if the VBAT is above the threshold */
  else if (regValue == PWR_CR2_VBATH)
24011708:	683b      	ldr	r3, [r7, #0]
2401170a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2401170e:	d103      	bne.n	24011718 <HAL_PWREx_GetVBATLevel+0x30>
  {
    VBATLevel = PWR_VBAT_ABOVE_HIGH_THRESHOLD;
24011710:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
24011714:	607b      	str	r3, [r7, #4]
24011716:	e001      	b.n	2401171c <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* The VBAT is between the thresholds */
  else
  {
    VBATLevel = PWR_VBAT_BETWEEN_HIGH_LOW_THRESHOLD;
24011718:	2300      	movs	r3, #0
2401171a:	607b      	str	r3, [r7, #4]
  }

  return VBATLevel;
2401171c:	687b      	ldr	r3, [r7, #4]
}
2401171e:	4618      	mov	r0, r3
24011720:	370c      	adds	r7, #12
24011722:	46bd      	mov	sp, r7
24011724:	f85d 7b04 	ldr.w	r7, [sp], #4
24011728:	4770      	bx	lr
2401172a:	bf00      	nop
2401172c:	58024800 	.word	0x58024800

24011730 <HAL_PWREx_ConfigAVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 and wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ConfigAVD (PWREx_AVDTypeDef *sConfigAVD)
{
24011730:	b480      	push	{r7}
24011732:	b083      	sub	sp, #12
24011734:	af00      	add	r7, sp, #0
24011736:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_AVD_LEVEL (sConfigAVD->AVDLevel));
  assert_param (IS_PWR_AVD_MODE (sConfigAVD->Mode));

  /* Set the ALS[18:17] bits according to AVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_ALS, sConfigAVD->AVDLevel);
24011738:	4b37      	ldr	r3, [pc, #220]	; (24011818 <HAL_PWREx_ConfigAVD+0xe8>)
2401173a:	681b      	ldr	r3, [r3, #0]
2401173c:	f423 22c0 	bic.w	r2, r3, #393216	; 0x60000
24011740:	687b      	ldr	r3, [r7, #4]
24011742:	681b      	ldr	r3, [r3, #0]
24011744:	4934      	ldr	r1, [pc, #208]	; (24011818 <HAL_PWREx_ConfigAVD+0xe8>)
24011746:	4313      	orrs	r3, r2
24011748:	600b      	str	r3, [r1, #0]

  /* Clear any previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_AVD_EXTI_DISABLE_EVENT ();
2401174a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401174e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24011752:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24011756:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401175a:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_AVD_EXTI_DISABLE_IT ();
2401175e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011762:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24011766:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401176a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401176e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_AVD_EXTI_DISABLE_RISING_EDGE ();
24011772:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011776:	681b      	ldr	r3, [r3, #0]
24011778:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401177c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011780:	6013      	str	r3, [r2, #0]
  __HAL_PWR_AVD_EXTI_DISABLE_FALLING_EDGE ();
24011782:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011786:	685b      	ldr	r3, [r3, #4]
24011788:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401178c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011790:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Configure the interrupt mode */
  if ((sConfigAVD->Mode & AVD_MODE_IT) == AVD_MODE_IT)
24011792:	687b      	ldr	r3, [r7, #4]
24011794:	685b      	ldr	r3, [r3, #4]
24011796:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401179a:	2b00      	cmp	r3, #0
2401179c:	d009      	beq.n	240117b2 <HAL_PWREx_ConfigAVD+0x82>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_IT ();
2401179e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240117a2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
240117a6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240117aa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240117ae:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Configure the event mode */
  if ((sConfigAVD->Mode & AVD_MODE_EVT) == AVD_MODE_EVT)
240117b2:	687b      	ldr	r3, [r7, #4]
240117b4:	685b      	ldr	r3, [r3, #4]
240117b6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240117ba:	2b00      	cmp	r3, #0
240117bc:	d009      	beq.n	240117d2 <HAL_PWREx_ConfigAVD+0xa2>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_EVENT ();
240117be:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240117c2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
240117c6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240117ca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240117ce:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigAVD->Mode & AVD_RISING_EDGE) == AVD_RISING_EDGE)
240117d2:	687b      	ldr	r3, [r7, #4]
240117d4:	685b      	ldr	r3, [r3, #4]
240117d6:	f003 0301 	and.w	r3, r3, #1
240117da:	2b00      	cmp	r3, #0
240117dc:	d007      	beq.n	240117ee <HAL_PWREx_ConfigAVD+0xbe>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_RISING_EDGE ();
240117de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240117e2:	681b      	ldr	r3, [r3, #0]
240117e4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240117e8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240117ec:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigAVD->Mode & AVD_FALLING_EDGE) == AVD_FALLING_EDGE)
240117ee:	687b      	ldr	r3, [r7, #4]
240117f0:	685b      	ldr	r3, [r3, #4]
240117f2:	f003 0302 	and.w	r3, r3, #2
240117f6:	2b00      	cmp	r3, #0
240117f8:	d007      	beq.n	2401180a <HAL_PWREx_ConfigAVD+0xda>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_FALLING_EDGE ();
240117fa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240117fe:	685b      	ldr	r3, [r3, #4]
24011800:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24011804:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011808:	6053      	str	r3, [r2, #4]
  }
}
2401180a:	bf00      	nop
2401180c:	370c      	adds	r7, #12
2401180e:	46bd      	mov	sp, r7
24011810:	f85d 7b04 	ldr.w	r7, [sp], #4
24011814:	4770      	bx	lr
24011816:	bf00      	nop
24011818:	58024800 	.word	0x58024800

2401181c <HAL_PWREx_EnableAVD>:
/**
  * @brief Enable the Analog Voltage Detector (AVD).
  * @retval None.
  */
void HAL_PWREx_EnableAVD (void)
{
2401181c:	b480      	push	{r7}
2401181e:	af00      	add	r7, sp, #0
  /* Enable the Analog Voltage Detector */
  SET_BIT (PWR->CR1, PWR_CR1_AVDEN);
24011820:	4b05      	ldr	r3, [pc, #20]	; (24011838 <HAL_PWREx_EnableAVD+0x1c>)
24011822:	681b      	ldr	r3, [r3, #0]
24011824:	4a04      	ldr	r2, [pc, #16]	; (24011838 <HAL_PWREx_EnableAVD+0x1c>)
24011826:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2401182a:	6013      	str	r3, [r2, #0]
}
2401182c:	bf00      	nop
2401182e:	46bd      	mov	sp, r7
24011830:	f85d 7b04 	ldr.w	r7, [sp], #4
24011834:	4770      	bx	lr
24011836:	bf00      	nop
24011838:	58024800 	.word	0x58024800

2401183c <HAL_PWREx_DisableAVD>:
/**
  * @brief Disable the Analog Voltage Detector(AVD).
  * @retval None.
  */
void HAL_PWREx_DisableAVD (void)
{
2401183c:	b480      	push	{r7}
2401183e:	af00      	add	r7, sp, #0
  /* Disable the Analog Voltage Detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_AVDEN);
24011840:	4b05      	ldr	r3, [pc, #20]	; (24011858 <HAL_PWREx_DisableAVD+0x1c>)
24011842:	681b      	ldr	r3, [r3, #0]
24011844:	4a04      	ldr	r2, [pc, #16]	; (24011858 <HAL_PWREx_DisableAVD+0x1c>)
24011846:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401184a:	6013      	str	r3, [r2, #0]
}
2401184c:	bf00      	nop
2401184e:	46bd      	mov	sp, r7
24011850:	f85d 7b04 	ldr.w	r7, [sp], #4
24011854:	4770      	bx	lr
24011856:	bf00      	nop
24011858:	58024800 	.word	0x58024800

2401185c <HAL_PWREx_PVD_AVD_IRQHandler>:
  * @brief  This function handles the PWR PVD/AVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None
  */
void HAL_PWREx_PVD_AVD_IRQHandler (void)
{
2401185c:	b580      	push	{r7, lr}
2401185e:	af00      	add	r7, sp, #0
  /* Check if the Programmable Voltage Detector is enabled (PVD) */
  if (READ_BIT (PWR->CR1, PWR_CR1_PVDEN) != 0U)
24011860:	4b1b      	ldr	r3, [pc, #108]	; (240118d0 <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
24011862:	681b      	ldr	r3, [r3, #0]
24011864:	f003 0310 	and.w	r3, r3, #16
24011868:	2b00      	cmp	r3, #0
2401186a:	d014      	beq.n	24011896 <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR D1/CD EXTI flag */
      if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
2401186c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011870:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24011874:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24011878:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401187c:	d10b      	bne.n	24011896 <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
      {
        /* PWR PVD interrupt user callback */
        HAL_PWR_PVDCallback ();
2401187e:	f7ff faf4 	bl	24010e6a <HAL_PWR_PVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
24011882:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011886:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2401188a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401188e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011892:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }
#endif /* defined (DUAL_CORE) */
  }

  /* Check if the Analog Voltage Detector is enabled (AVD) */
  if (READ_BIT (PWR->CR1, PWR_CR1_AVDEN) != 0U)
24011896:	4b0e      	ldr	r3, [pc, #56]	; (240118d0 <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
24011898:	681b      	ldr	r3, [r3, #0]
2401189a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401189e:	2b00      	cmp	r3, #0
240118a0:	d014      	beq.n	240118cc <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR EXTI D1/CD flag */
      if (__HAL_PWR_AVD_EXTI_GET_FLAG () != 0U)
240118a2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240118a6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
240118aa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240118ae:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240118b2:	d10b      	bne.n	240118cc <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
      {
        /* PWR AVD interrupt user callback */
        HAL_PWREx_AVDCallback ();
240118b4:	f000 f80e 	bl	240118d4 <HAL_PWREx_AVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_AVD_EXTI_CLEAR_FLAG ();
240118b8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240118bc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
240118c0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240118c4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240118c8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
        __HAL_PWR_AVD_EXTID2_CLEAR_FLAG ();
      }
    }
#endif /* defined (DUAL_CORE) */
  }
}
240118cc:	bf00      	nop
240118ce:	bd80      	pop	{r7, pc}
240118d0:	58024800 	.word	0x58024800

240118d4 <HAL_PWREx_AVDCallback>:
/**
  * @brief PWR AVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_AVDCallback (void)
{
240118d4:	b480      	push	{r7}
240118d6:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_AVDCallback can be implemented in the user file
  */
}
240118d8:	bf00      	nop
240118da:	46bd      	mov	sp, r7
240118dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240118e0:	4770      	bx	lr
	...

240118e4 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
240118e4:	b580      	push	{r7, lr}
240118e6:	b086      	sub	sp, #24
240118e8:	af02      	add	r7, sp, #8
240118ea:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240118ec:	f7f0 fb96 	bl	2400201c <HAL_GetTick>
240118f0:	60f8      	str	r0, [r7, #12]

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
240118f2:	687b      	ldr	r3, [r7, #4]
240118f4:	2b00      	cmp	r3, #0
240118f6:	d101      	bne.n	240118fc <HAL_QSPI_Init+0x18>
  {
    return HAL_ERROR;
240118f8:	2301      	movs	r3, #1
240118fa:	e05f      	b.n	240119bc <HAL_QSPI_Init+0xd8>
  if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }

  if(hqspi->State == HAL_QSPI_STATE_RESET)
240118fc:	687b      	ldr	r3, [r7, #4]
240118fe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011902:	b2db      	uxtb	r3, r3
24011904:	2b00      	cmp	r3, #0
24011906:	d107      	bne.n	24011918 <HAL_QSPI_Init+0x34>

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
24011908:	6878      	ldr	r0, [r7, #4]
2401190a:	f7ef fa31 	bl	24000d70 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
2401190e:	f241 3188 	movw	r1, #5000	; 0x1388
24011912:	6878      	ldr	r0, [r7, #4]
24011914:	f001 f98e 	bl	24012c34 <HAL_QSPI_SetTimeout>
  }

  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
24011918:	687b      	ldr	r3, [r7, #4]
2401191a:	681b      	ldr	r3, [r3, #0]
2401191c:	681b      	ldr	r3, [r3, #0]
2401191e:	f423 51f8 	bic.w	r1, r3, #7936	; 0x1f00
24011922:	687b      	ldr	r3, [r7, #4]
24011924:	689b      	ldr	r3, [r3, #8]
24011926:	3b01      	subs	r3, #1
24011928:	021a      	lsls	r2, r3, #8
2401192a:	687b      	ldr	r3, [r7, #4]
2401192c:	681b      	ldr	r3, [r3, #0]
2401192e:	430a      	orrs	r2, r1
24011930:	601a      	str	r2, [r3, #0]
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24011932:	687b      	ldr	r3, [r7, #4]
24011934:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24011936:	9300      	str	r3, [sp, #0]
24011938:	68fb      	ldr	r3, [r7, #12]
2401193a:	2200      	movs	r2, #0
2401193c:	2120      	movs	r1, #32
2401193e:	6878      	ldr	r0, [r7, #4]
24011940:	f001 fa87 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24011944:	4603      	mov	r3, r0
24011946:	72fb      	strb	r3, [r7, #11]

  if(status == HAL_OK)
24011948:	7afb      	ldrb	r3, [r7, #11]
2401194a:	2b00      	cmp	r3, #0
2401194c:	d135      	bne.n	240119ba <HAL_QSPI_Init+0xd6>
  {
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
2401194e:	687b      	ldr	r3, [r7, #4]
24011950:	681b      	ldr	r3, [r3, #0]
24011952:	681a      	ldr	r2, [r3, #0]
24011954:	4b1b      	ldr	r3, [pc, #108]	; (240119c4 <HAL_QSPI_Init+0xe0>)
24011956:	4013      	ands	r3, r2
24011958:	687a      	ldr	r2, [r7, #4]
2401195a:	6852      	ldr	r2, [r2, #4]
2401195c:	0611      	lsls	r1, r2, #24
2401195e:	687a      	ldr	r2, [r7, #4]
24011960:	68d2      	ldr	r2, [r2, #12]
24011962:	4311      	orrs	r1, r2
24011964:	687a      	ldr	r2, [r7, #4]
24011966:	69d2      	ldr	r2, [r2, #28]
24011968:	4311      	orrs	r1, r2
2401196a:	687a      	ldr	r2, [r7, #4]
2401196c:	6a12      	ldr	r2, [r2, #32]
2401196e:	4311      	orrs	r1, r2
24011970:	687a      	ldr	r2, [r7, #4]
24011972:	6812      	ldr	r2, [r2, #0]
24011974:	430b      	orrs	r3, r1
24011976:	6013      	str	r3, [r2, #0]
               ((hqspi->Init.ClockPrescaler << QUADSPI_CR_PRESCALER_Pos) |
                hqspi->Init.SampleShifting  | hqspi->Init.FlashID | hqspi->Init.DualFlash));

    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
24011978:	687b      	ldr	r3, [r7, #4]
2401197a:	681b      	ldr	r3, [r3, #0]
2401197c:	685a      	ldr	r2, [r3, #4]
2401197e:	4b12      	ldr	r3, [pc, #72]	; (240119c8 <HAL_QSPI_Init+0xe4>)
24011980:	4013      	ands	r3, r2
24011982:	687a      	ldr	r2, [r7, #4]
24011984:	6912      	ldr	r2, [r2, #16]
24011986:	0411      	lsls	r1, r2, #16
24011988:	687a      	ldr	r2, [r7, #4]
2401198a:	6952      	ldr	r2, [r2, #20]
2401198c:	4311      	orrs	r1, r2
2401198e:	687a      	ldr	r2, [r7, #4]
24011990:	6992      	ldr	r2, [r2, #24]
24011992:	4311      	orrs	r1, r2
24011994:	687a      	ldr	r2, [r7, #4]
24011996:	6812      	ldr	r2, [r2, #0]
24011998:	430b      	orrs	r3, r1
2401199a:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << QUADSPI_DCR_FSIZE_Pos) |
                hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));

    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
2401199c:	687b      	ldr	r3, [r7, #4]
2401199e:	681b      	ldr	r3, [r3, #0]
240119a0:	681a      	ldr	r2, [r3, #0]
240119a2:	687b      	ldr	r3, [r7, #4]
240119a4:	681b      	ldr	r3, [r3, #0]
240119a6:	f042 0201 	orr.w	r2, r2, #1
240119aa:	601a      	str	r2, [r3, #0]

    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240119ac:	687b      	ldr	r3, [r7, #4]
240119ae:	2200      	movs	r2, #0
240119b0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
240119b2:	687b      	ldr	r3, [r7, #4]
240119b4:	2201      	movs	r2, #1
240119b6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }

  /* Return function status */
  return status;
240119ba:	7afb      	ldrb	r3, [r7, #11]
}
240119bc:	4618      	mov	r0, r3
240119be:	3710      	adds	r7, #16
240119c0:	46bd      	mov	sp, r7
240119c2:	bd80      	pop	{r7, pc}
240119c4:	00ffff2f 	.word	0x00ffff2f
240119c8:	ffe0f8fe 	.word	0xffe0f8fe

240119cc <HAL_QSPI_DeInit>:
  * @brief De-Initialize the QSPI peripheral.
  * @param hqspi QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_DeInit(QSPI_HandleTypeDef *hqspi)
{
240119cc:	b580      	push	{r7, lr}
240119ce:	b082      	sub	sp, #8
240119d0:	af00      	add	r7, sp, #0
240119d2:	6078      	str	r0, [r7, #4]
  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
240119d4:	687b      	ldr	r3, [r7, #4]
240119d6:	2b00      	cmp	r3, #0
240119d8:	d101      	bne.n	240119de <HAL_QSPI_DeInit+0x12>
  {
    return HAL_ERROR;
240119da:	2301      	movs	r3, #1
240119dc:	e012      	b.n	24011a04 <HAL_QSPI_DeInit+0x38>
  }

  /* Disable the QSPI Peripheral Clock */
  __HAL_QSPI_DISABLE(hqspi);
240119de:	687b      	ldr	r3, [r7, #4]
240119e0:	681b      	ldr	r3, [r3, #0]
240119e2:	681a      	ldr	r2, [r3, #0]
240119e4:	687b      	ldr	r3, [r7, #4]
240119e6:	681b      	ldr	r3, [r3, #0]
240119e8:	f022 0201 	bic.w	r2, r2, #1
240119ec:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware */
  hqspi->MspDeInitCallback(hqspi);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_QSPI_MspDeInit(hqspi);
240119ee:	6878      	ldr	r0, [r7, #4]
240119f0:	f7ef fa74 	bl	24000edc <HAL_QSPI_MspDeInit>
#endif

  /* Set QSPI error code to none */
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240119f4:	687b      	ldr	r3, [r7, #4]
240119f6:	2200      	movs	r2, #0
240119f8:	645a      	str	r2, [r3, #68]	; 0x44

  /* Initialize the QSPI state */
  hqspi->State = HAL_QSPI_STATE_RESET;
240119fa:	687b      	ldr	r3, [r7, #4]
240119fc:	2200      	movs	r2, #0
240119fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  return HAL_OK;
24011a02:	2300      	movs	r3, #0
}
24011a04:	4618      	mov	r0, r3
24011a06:	3708      	adds	r7, #8
24011a08:	46bd      	mov	sp, r7
24011a0a:	bd80      	pop	{r7, pc}
  * @brief Initialize the QSPI MSP.
  * @param hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi)
{
24011a0c:	b480      	push	{r7}
24011a0e:	b083      	sub	sp, #12
24011a10:	af00      	add	r7, sp, #0
24011a12:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspInit can be implemented in the user file
   */
}
24011a14:	bf00      	nop
24011a16:	370c      	adds	r7, #12
24011a18:	46bd      	mov	sp, r7
24011a1a:	f85d 7b04 	ldr.w	r7, [sp], #4
24011a1e:	4770      	bx	lr
  * @brief DeInitialize the QSPI MSP.
  * @param hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
{
24011a20:	b480      	push	{r7}
24011a22:	b083      	sub	sp, #12
24011a24:	af00      	add	r7, sp, #0
24011a26:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspDeInit can be implemented in the user file
   */
}
24011a28:	bf00      	nop
24011a2a:	370c      	adds	r7, #12
24011a2c:	46bd      	mov	sp, r7
24011a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
24011a32:	4770      	bx	lr

24011a34 <HAL_QSPI_IRQHandler>:
  * @brief Handle QSPI interrupt request.
  * @param hqspi QSPI handle
  * @retval None
  */
void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
{
24011a34:	b580      	push	{r7, lr}
24011a36:	b086      	sub	sp, #24
24011a38:	af00      	add	r7, sp, #0
24011a3a:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg;
  uint32_t flag = READ_REG(hqspi->Instance->SR);
24011a3c:	687b      	ldr	r3, [r7, #4]
24011a3e:	681b      	ldr	r3, [r3, #0]
24011a40:	689b      	ldr	r3, [r3, #8]
24011a42:	617b      	str	r3, [r7, #20]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
24011a44:	687b      	ldr	r3, [r7, #4]
24011a46:	681b      	ldr	r3, [r3, #0]
24011a48:	681b      	ldr	r3, [r3, #0]
24011a4a:	613b      	str	r3, [r7, #16]

  /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
  if(((flag & QSPI_FLAG_FT) != 0U) && ((itsource & QSPI_IT_FT) != 0U))
24011a4c:	697b      	ldr	r3, [r7, #20]
24011a4e:	f003 0304 	and.w	r3, r3, #4
24011a52:	2b00      	cmp	r3, #0
24011a54:	d064      	beq.n	24011b20 <HAL_QSPI_IRQHandler+0xec>
24011a56:	693b      	ldr	r3, [r7, #16]
24011a58:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24011a5c:	2b00      	cmp	r3, #0
24011a5e:	d05f      	beq.n	24011b20 <HAL_QSPI_IRQHandler+0xec>
  {
    data_reg = &hqspi->Instance->DR;
24011a60:	687b      	ldr	r3, [r7, #4]
24011a62:	681b      	ldr	r3, [r3, #0]
24011a64:	3320      	adds	r3, #32
24011a66:	60fb      	str	r3, [r7, #12]

    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011a68:	687b      	ldr	r3, [r7, #4]
24011a6a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011a6e:	b2db      	uxtb	r3, r3
24011a70:	2b12      	cmp	r3, #18
24011a72:	d125      	bne.n	24011ac0 <HAL_QSPI_IRQHandler+0x8c>
    {
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24011a74:	e01c      	b.n	24011ab0 <HAL_QSPI_IRQHandler+0x7c>
      {
        if (hqspi->TxXferCount > 0U)
24011a76:	687b      	ldr	r3, [r7, #4]
24011a78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24011a7a:	2b00      	cmp	r3, #0
24011a7c:	d00f      	beq.n	24011a9e <HAL_QSPI_IRQHandler+0x6a>
        {
          /* Fill the FIFO until the threshold is reached */
          *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
24011a7e:	687b      	ldr	r3, [r7, #4]
24011a80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011a82:	781a      	ldrb	r2, [r3, #0]
24011a84:	68fb      	ldr	r3, [r7, #12]
24011a86:	701a      	strb	r2, [r3, #0]
          hqspi->pTxBuffPtr++;
24011a88:	687b      	ldr	r3, [r7, #4]
24011a8a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011a8c:	1c5a      	adds	r2, r3, #1
24011a8e:	687b      	ldr	r3, [r7, #4]
24011a90:	625a      	str	r2, [r3, #36]	; 0x24
          hqspi->TxXferCount--;
24011a92:	687b      	ldr	r3, [r7, #4]
24011a94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24011a96:	1e5a      	subs	r2, r3, #1
24011a98:	687b      	ldr	r3, [r7, #4]
24011a9a:	62da      	str	r2, [r3, #44]	; 0x2c
24011a9c:	e008      	b.n	24011ab0 <HAL_QSPI_IRQHandler+0x7c>
        }
        else
        {
          /* No more data available for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
24011a9e:	687b      	ldr	r3, [r7, #4]
24011aa0:	681b      	ldr	r3, [r3, #0]
24011aa2:	681a      	ldr	r2, [r3, #0]
24011aa4:	687b      	ldr	r3, [r7, #4]
24011aa6:	681b      	ldr	r3, [r3, #0]
24011aa8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
24011aac:	601a      	str	r2, [r3, #0]
          break;
24011aae:	e033      	b.n	24011b18 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24011ab0:	687b      	ldr	r3, [r7, #4]
24011ab2:	681b      	ldr	r3, [r3, #0]
24011ab4:	689b      	ldr	r3, [r3, #8]
24011ab6:	f003 0304 	and.w	r3, r3, #4
24011aba:	2b00      	cmp	r3, #0
24011abc:	d1db      	bne.n	24011a76 <HAL_QSPI_IRQHandler+0x42>
24011abe:	e02b      	b.n	24011b18 <HAL_QSPI_IRQHandler+0xe4>
        }
      }
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
24011ac0:	687b      	ldr	r3, [r7, #4]
24011ac2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011ac6:	b2db      	uxtb	r3, r3
24011ac8:	2b22      	cmp	r3, #34	; 0x22
24011aca:	d125      	bne.n	24011b18 <HAL_QSPI_IRQHandler+0xe4>
    {
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24011acc:	e01d      	b.n	24011b0a <HAL_QSPI_IRQHandler+0xd6>
      {
        if (hqspi->RxXferCount > 0U)
24011ace:	687b      	ldr	r3, [r7, #4]
24011ad0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24011ad2:	2b00      	cmp	r3, #0
24011ad4:	d010      	beq.n	24011af8 <HAL_QSPI_IRQHandler+0xc4>
        {
          /* Read the FIFO until the threshold is reached */
          *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24011ad6:	687b      	ldr	r3, [r7, #4]
24011ad8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011ada:	68fa      	ldr	r2, [r7, #12]
24011adc:	7812      	ldrb	r2, [r2, #0]
24011ade:	b2d2      	uxtb	r2, r2
24011ae0:	701a      	strb	r2, [r3, #0]
          hqspi->pRxBuffPtr++;
24011ae2:	687b      	ldr	r3, [r7, #4]
24011ae4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011ae6:	1c5a      	adds	r2, r3, #1
24011ae8:	687b      	ldr	r3, [r7, #4]
24011aea:	631a      	str	r2, [r3, #48]	; 0x30
          hqspi->RxXferCount--;
24011aec:	687b      	ldr	r3, [r7, #4]
24011aee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24011af0:	1e5a      	subs	r2, r3, #1
24011af2:	687b      	ldr	r3, [r7, #4]
24011af4:	639a      	str	r2, [r3, #56]	; 0x38
24011af6:	e008      	b.n	24011b0a <HAL_QSPI_IRQHandler+0xd6>
        }
        else
        {
          /* All data have been received for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
24011af8:	687b      	ldr	r3, [r7, #4]
24011afa:	681b      	ldr	r3, [r3, #0]
24011afc:	681a      	ldr	r2, [r3, #0]
24011afe:	687b      	ldr	r3, [r7, #4]
24011b00:	681b      	ldr	r3, [r3, #0]
24011b02:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
24011b06:	601a      	str	r2, [r3, #0]
          break;
24011b08:	e006      	b.n	24011b18 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24011b0a:	687b      	ldr	r3, [r7, #4]
24011b0c:	681b      	ldr	r3, [r3, #0]
24011b0e:	689b      	ldr	r3, [r3, #8]
24011b10:	f003 0304 	and.w	r3, r3, #4
24011b14:	2b00      	cmp	r3, #0
24011b16:	d1da      	bne.n	24011ace <HAL_QSPI_IRQHandler+0x9a>

    /* FIFO Threshold callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->FifoThresholdCallback(hqspi);
#else
    HAL_QSPI_FifoThresholdCallback(hqspi);
24011b18:	6878      	ldr	r0, [r7, #4]
24011b1a:	f000 ff72 	bl	24012a02 <HAL_QSPI_FifoThresholdCallback>
24011b1e:	e13c      	b.n	24011d9a <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Complete interrupt occurred -------------------------------*/
  else if(((flag & QSPI_FLAG_TC) != 0U) && ((itsource & QSPI_IT_TC) != 0U))
24011b20:	697b      	ldr	r3, [r7, #20]
24011b22:	f003 0302 	and.w	r3, r3, #2
24011b26:	2b00      	cmp	r3, #0
24011b28:	f000 80b0 	beq.w	24011c8c <HAL_QSPI_IRQHandler+0x258>
24011b2c:	693b      	ldr	r3, [r7, #16]
24011b2e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011b32:	2b00      	cmp	r3, #0
24011b34:	f000 80aa 	beq.w	24011c8c <HAL_QSPI_IRQHandler+0x258>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
24011b38:	687b      	ldr	r3, [r7, #4]
24011b3a:	681b      	ldr	r3, [r3, #0]
24011b3c:	2202      	movs	r2, #2
24011b3e:	60da      	str	r2, [r3, #12]

    /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
24011b40:	687b      	ldr	r3, [r7, #4]
24011b42:	681b      	ldr	r3, [r3, #0]
24011b44:	681a      	ldr	r2, [r3, #0]
24011b46:	687b      	ldr	r3, [r7, #4]
24011b48:	681b      	ldr	r3, [r3, #0]
24011b4a:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
24011b4e:	601a      	str	r2, [r3, #0]

    /* Transfer complete callback */
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011b50:	687b      	ldr	r3, [r7, #4]
24011b52:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011b56:	b2db      	uxtb	r3, r3
24011b58:	2b12      	cmp	r3, #18
24011b5a:	d120      	bne.n	24011b9e <HAL_QSPI_IRQHandler+0x16a>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011b5c:	687b      	ldr	r3, [r7, #4]
24011b5e:	681b      	ldr	r3, [r3, #0]
24011b60:	681b      	ldr	r3, [r3, #0]
24011b62:	f003 0304 	and.w	r3, r3, #4
24011b66:	2b00      	cmp	r3, #0
24011b68:	d011      	beq.n	24011b8e <HAL_QSPI_IRQHandler+0x15a>
      {
        /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
           but no impact on H7 HW and it minimize the cost in the footprint */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24011b6a:	687b      	ldr	r3, [r7, #4]
24011b6c:	681b      	ldr	r3, [r3, #0]
24011b6e:	681a      	ldr	r2, [r3, #0]
24011b70:	687b      	ldr	r3, [r7, #4]
24011b72:	681b      	ldr	r3, [r3, #0]
24011b74:	f022 0204 	bic.w	r2, r2, #4
24011b78:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
24011b7a:	687b      	ldr	r3, [r7, #4]
24011b7c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011b7e:	681b      	ldr	r3, [r3, #0]
24011b80:	68da      	ldr	r2, [r3, #12]
24011b82:	687b      	ldr	r3, [r7, #4]
24011b84:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011b86:	681b      	ldr	r3, [r3, #0]
24011b88:	f022 0201 	bic.w	r2, r2, #1
24011b8c:	60da      	str	r2, [r3, #12]
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011b8e:	687b      	ldr	r3, [r7, #4]
24011b90:	2201      	movs	r2, #1
24011b92:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* TX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->TxCpltCallback(hqspi);
#else
      HAL_QSPI_TxCpltCallback(hqspi);
24011b96:	6878      	ldr	r0, [r7, #4]
24011b98:	f000 ff29 	bl	240129ee <HAL_QSPI_TxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011b9c:	e0fa      	b.n	24011d94 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
24011b9e:	687b      	ldr	r3, [r7, #4]
24011ba0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011ba4:	b2db      	uxtb	r3, r3
24011ba6:	2b22      	cmp	r3, #34	; 0x22
24011ba8:	d143      	bne.n	24011c32 <HAL_QSPI_IRQHandler+0x1fe>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011baa:	687b      	ldr	r3, [r7, #4]
24011bac:	681b      	ldr	r3, [r3, #0]
24011bae:	681b      	ldr	r3, [r3, #0]
24011bb0:	f003 0304 	and.w	r3, r3, #4
24011bb4:	2b00      	cmp	r3, #0
24011bb6:	d012      	beq.n	24011bde <HAL_QSPI_IRQHandler+0x1aa>
      {
        /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
           but no impact on H7 HW and it minimize the cost in the footprint */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24011bb8:	687b      	ldr	r3, [r7, #4]
24011bba:	681b      	ldr	r3, [r3, #0]
24011bbc:	681a      	ldr	r2, [r3, #0]
24011bbe:	687b      	ldr	r3, [r7, #4]
24011bc0:	681b      	ldr	r3, [r3, #0]
24011bc2:	f022 0204 	bic.w	r2, r2, #4
24011bc6:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
24011bc8:	687b      	ldr	r3, [r7, #4]
24011bca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011bcc:	681b      	ldr	r3, [r3, #0]
24011bce:	68da      	ldr	r2, [r3, #12]
24011bd0:	687b      	ldr	r3, [r7, #4]
24011bd2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011bd4:	681b      	ldr	r3, [r3, #0]
24011bd6:	f022 0201 	bic.w	r2, r2, #1
24011bda:	60da      	str	r2, [r3, #12]
24011bdc:	e021      	b.n	24011c22 <HAL_QSPI_IRQHandler+0x1ee>
      }
      else
      {
        data_reg = &hqspi->Instance->DR;
24011bde:	687b      	ldr	r3, [r7, #4]
24011be0:	681b      	ldr	r3, [r3, #0]
24011be2:	3320      	adds	r3, #32
24011be4:	60fb      	str	r3, [r7, #12]
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
24011be6:	e013      	b.n	24011c10 <HAL_QSPI_IRQHandler+0x1dc>
        {
          if (hqspi->RxXferCount > 0U)
24011be8:	687b      	ldr	r3, [r7, #4]
24011bea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24011bec:	2b00      	cmp	r3, #0
24011bee:	d017      	beq.n	24011c20 <HAL_QSPI_IRQHandler+0x1ec>
          {
            /* Read the last data received in the FIFO until it is empty */
            *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24011bf0:	687b      	ldr	r3, [r7, #4]
24011bf2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011bf4:	68fa      	ldr	r2, [r7, #12]
24011bf6:	7812      	ldrb	r2, [r2, #0]
24011bf8:	b2d2      	uxtb	r2, r2
24011bfa:	701a      	strb	r2, [r3, #0]
            hqspi->pRxBuffPtr++;
24011bfc:	687b      	ldr	r3, [r7, #4]
24011bfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011c00:	1c5a      	adds	r2, r3, #1
24011c02:	687b      	ldr	r3, [r7, #4]
24011c04:	631a      	str	r2, [r3, #48]	; 0x30
            hqspi->RxXferCount--;
24011c06:	687b      	ldr	r3, [r7, #4]
24011c08:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24011c0a:	1e5a      	subs	r2, r3, #1
24011c0c:	687b      	ldr	r3, [r7, #4]
24011c0e:	639a      	str	r2, [r3, #56]	; 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
24011c10:	687b      	ldr	r3, [r7, #4]
24011c12:	681b      	ldr	r3, [r3, #0]
24011c14:	689b      	ldr	r3, [r3, #8]
24011c16:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
24011c1a:	2b00      	cmp	r3, #0
24011c1c:	d1e4      	bne.n	24011be8 <HAL_QSPI_IRQHandler+0x1b4>
24011c1e:	e000      	b.n	24011c22 <HAL_QSPI_IRQHandler+0x1ee>
          }
          else
          {
            /* All data have been received for the transfer */
            break;
24011c20:	bf00      	nop
        }
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011c22:	687b      	ldr	r3, [r7, #4]
24011c24:	2201      	movs	r2, #1
24011c26:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* RX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->RxCpltCallback(hqspi);
#else
      HAL_QSPI_RxCpltCallback(hqspi);
24011c2a:	6878      	ldr	r0, [r7, #4]
24011c2c:	f000 fed5 	bl	240129da <HAL_QSPI_RxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011c30:	e0b0      	b.n	24011d94 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
24011c32:	687b      	ldr	r3, [r7, #4]
24011c34:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011c38:	b2db      	uxtb	r3, r3
24011c3a:	2b02      	cmp	r3, #2
24011c3c:	d107      	bne.n	24011c4e <HAL_QSPI_IRQHandler+0x21a>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011c3e:	687b      	ldr	r3, [r7, #4]
24011c40:	2201      	movs	r2, #1
24011c42:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Command Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->CmdCpltCallback(hqspi);
#else
      HAL_QSPI_CmdCpltCallback(hqspi);
24011c46:	6878      	ldr	r0, [r7, #4]
24011c48:	f000 febd 	bl	240129c6 <HAL_QSPI_CmdCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011c4c:	e0a2      	b.n	24011d94 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
24011c4e:	687b      	ldr	r3, [r7, #4]
24011c50:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011c54:	b2db      	uxtb	r3, r3
24011c56:	2b08      	cmp	r3, #8
24011c58:	f040 809c 	bne.w	24011d94 <HAL_QSPI_IRQHandler+0x360>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
24011c5c:	687b      	ldr	r3, [r7, #4]
24011c5e:	681b      	ldr	r3, [r3, #0]
24011c60:	695a      	ldr	r2, [r3, #20]
24011c62:	687b      	ldr	r3, [r7, #4]
24011c64:	681b      	ldr	r3, [r3, #0]
24011c66:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24011c6a:	615a      	str	r2, [r3, #20]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011c6c:	687b      	ldr	r3, [r7, #4]
24011c6e:	2201      	movs	r2, #1
24011c70:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
24011c74:	687b      	ldr	r3, [r7, #4]
24011c76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011c78:	2b00      	cmp	r3, #0
24011c7a:	d103      	bne.n	24011c84 <HAL_QSPI_IRQHandler+0x250>

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
24011c7c:	6878      	ldr	r0, [r7, #4]
24011c7e:	f000 fe98 	bl	240129b2 <HAL_QSPI_AbortCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011c82:	e087      	b.n	24011d94 <HAL_QSPI_IRQHandler+0x360>

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
24011c84:	6878      	ldr	r0, [r7, #4]
24011c86:	f000 fe8a 	bl	2401299e <HAL_QSPI_ErrorCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011c8a:	e083      	b.n	24011d94 <HAL_QSPI_IRQHandler+0x360>
     /* Nothing to do */
    }
  }

  /* QSPI Status Match interrupt occurred ------------------------------------*/
  else if(((flag & QSPI_FLAG_SM) != 0U) && ((itsource & QSPI_IT_SM) != 0U))
24011c8c:	697b      	ldr	r3, [r7, #20]
24011c8e:	f003 0308 	and.w	r3, r3, #8
24011c92:	2b00      	cmp	r3, #0
24011c94:	d01f      	beq.n	24011cd6 <HAL_QSPI_IRQHandler+0x2a2>
24011c96:	693b      	ldr	r3, [r7, #16]
24011c98:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
24011c9c:	2b00      	cmp	r3, #0
24011c9e:	d01a      	beq.n	24011cd6 <HAL_QSPI_IRQHandler+0x2a2>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
24011ca0:	687b      	ldr	r3, [r7, #4]
24011ca2:	681b      	ldr	r3, [r3, #0]
24011ca4:	2208      	movs	r2, #8
24011ca6:	60da      	str	r2, [r3, #12]

    /* Check if the automatic poll mode stop is activated */
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0U)
24011ca8:	687b      	ldr	r3, [r7, #4]
24011caa:	681b      	ldr	r3, [r3, #0]
24011cac:	681b      	ldr	r3, [r3, #0]
24011cae:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
24011cb2:	2b00      	cmp	r3, #0
24011cb4:	d00b      	beq.n	24011cce <HAL_QSPI_IRQHandler+0x29a>
    {
      /* Disable the QSPI Transfer Error and Status Match Interrupts */
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
24011cb6:	687b      	ldr	r3, [r7, #4]
24011cb8:	681b      	ldr	r3, [r3, #0]
24011cba:	681a      	ldr	r2, [r3, #0]
24011cbc:	687b      	ldr	r3, [r7, #4]
24011cbe:	681b      	ldr	r3, [r3, #0]
24011cc0:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
24011cc4:	601a      	str	r2, [r3, #0]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011cc6:	687b      	ldr	r3, [r7, #4]
24011cc8:	2201      	movs	r2, #1
24011cca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Status match callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->StatusMatchCallback(hqspi);
#else
    HAL_QSPI_StatusMatchCallback(hqspi);
24011cce:	6878      	ldr	r0, [r7, #4]
24011cd0:	f000 fea1 	bl	24012a16 <HAL_QSPI_StatusMatchCallback>
24011cd4:	e061      	b.n	24011d9a <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Error interrupt occurred ----------------------------------*/
  else if(((flag & QSPI_FLAG_TE) != 0U) && ((itsource & QSPI_IT_TE) != 0U))
24011cd6:	697b      	ldr	r3, [r7, #20]
24011cd8:	f003 0301 	and.w	r3, r3, #1
24011cdc:	2b00      	cmp	r3, #0
24011cde:	d047      	beq.n	24011d70 <HAL_QSPI_IRQHandler+0x33c>
24011ce0:	693b      	ldr	r3, [r7, #16]
24011ce2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24011ce6:	2b00      	cmp	r3, #0
24011ce8:	d042      	beq.n	24011d70 <HAL_QSPI_IRQHandler+0x33c>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
24011cea:	687b      	ldr	r3, [r7, #4]
24011cec:	681b      	ldr	r3, [r3, #0]
24011cee:	2201      	movs	r2, #1
24011cf0:	60da      	str	r2, [r3, #12]

    /* Disable all the QSPI Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
24011cf2:	687b      	ldr	r3, [r7, #4]
24011cf4:	681b      	ldr	r3, [r3, #0]
24011cf6:	681a      	ldr	r2, [r3, #0]
24011cf8:	687b      	ldr	r3, [r7, #4]
24011cfa:	681b      	ldr	r3, [r3, #0]
24011cfc:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
24011d00:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
24011d02:	687b      	ldr	r3, [r7, #4]
24011d04:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011d06:	f043 0202 	orr.w	r2, r3, #2
24011d0a:	687b      	ldr	r3, [r7, #4]
24011d0c:	645a      	str	r2, [r3, #68]	; 0x44

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011d0e:	687b      	ldr	r3, [r7, #4]
24011d10:	681b      	ldr	r3, [r3, #0]
24011d12:	681b      	ldr	r3, [r3, #0]
24011d14:	f003 0304 	and.w	r3, r3, #4
24011d18:	2b00      	cmp	r3, #0
24011d1a:	d021      	beq.n	24011d60 <HAL_QSPI_IRQHandler+0x32c>
    {
      /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
         but no impact on H7 HW and it minimize the cost in the footprint */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24011d1c:	687b      	ldr	r3, [r7, #4]
24011d1e:	681b      	ldr	r3, [r3, #0]
24011d20:	681a      	ldr	r2, [r3, #0]
24011d22:	687b      	ldr	r3, [r7, #4]
24011d24:	681b      	ldr	r3, [r3, #0]
24011d26:	f022 0204 	bic.w	r2, r2, #4
24011d2a:	601a      	str	r2, [r3, #0]

      /* Disable the MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
24011d2c:	687b      	ldr	r3, [r7, #4]
24011d2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011d30:	4a1c      	ldr	r2, [pc, #112]	; (24011da4 <HAL_QSPI_IRQHandler+0x370>)
24011d32:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
24011d34:	687b      	ldr	r3, [r7, #4]
24011d36:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011d38:	4618      	mov	r0, r3
24011d3a:	f7fe fb34 	bl	240103a6 <HAL_MDMA_Abort_IT>
24011d3e:	4603      	mov	r3, r0
24011d40:	2b00      	cmp	r3, #0
24011d42:	d029      	beq.n	24011d98 <HAL_QSPI_IRQHandler+0x364>
      {
        /* Set error code to DMA */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24011d44:	687b      	ldr	r3, [r7, #4]
24011d46:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011d48:	f043 0204 	orr.w	r2, r3, #4
24011d4c:	687b      	ldr	r3, [r7, #4]
24011d4e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
24011d50:	687b      	ldr	r3, [r7, #4]
24011d52:	2201      	movs	r2, #1
24011d54:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
24011d58:	6878      	ldr	r0, [r7, #4]
24011d5a:	f000 fe20 	bl	2401299e <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011d5e:	e01b      	b.n	24011d98 <HAL_QSPI_IRQHandler+0x364>
      }
    }
    else
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011d60:	687b      	ldr	r3, [r7, #4]
24011d62:	2201      	movs	r2, #1
24011d64:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->ErrorCallback(hqspi);
#else
      HAL_QSPI_ErrorCallback(hqspi);
24011d68:	6878      	ldr	r0, [r7, #4]
24011d6a:	f000 fe18 	bl	2401299e <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011d6e:	e013      	b.n	24011d98 <HAL_QSPI_IRQHandler+0x364>
#endif
    }
  }

  /* QSPI Timeout interrupt occurred -----------------------------------------*/
  else if(((flag & QSPI_FLAG_TO) != 0U) && ((itsource & QSPI_IT_TO) != 0U))
24011d70:	697b      	ldr	r3, [r7, #20]
24011d72:	f003 0310 	and.w	r3, r3, #16
24011d76:	2b00      	cmp	r3, #0
24011d78:	d00f      	beq.n	24011d9a <HAL_QSPI_IRQHandler+0x366>
24011d7a:	693b      	ldr	r3, [r7, #16]
24011d7c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
24011d80:	2b00      	cmp	r3, #0
24011d82:	d00a      	beq.n	24011d9a <HAL_QSPI_IRQHandler+0x366>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
24011d84:	687b      	ldr	r3, [r7, #4]
24011d86:	681b      	ldr	r3, [r3, #0]
24011d88:	2210      	movs	r2, #16
24011d8a:	60da      	str	r2, [r3, #12]

    /* Timeout callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->TimeOutCallback(hqspi);
#else
    HAL_QSPI_TimeOutCallback(hqspi);
24011d8c:	6878      	ldr	r0, [r7, #4]
24011d8e:	f000 fe4c 	bl	24012a2a <HAL_QSPI_TimeOutCallback>

   else
  {
   /* Nothing to do */
  }
}
24011d92:	e002      	b.n	24011d9a <HAL_QSPI_IRQHandler+0x366>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011d94:	bf00      	nop
24011d96:	e000      	b.n	24011d9a <HAL_QSPI_IRQHandler+0x366>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011d98:	bf00      	nop
}
24011d9a:	bf00      	nop
24011d9c:	3718      	adds	r7, #24
24011d9e:	46bd      	mov	sp, r7
24011da0:	bd80      	pop	{r7, pc}
24011da2:	bf00      	nop
24011da4:	24012ded 	.word	0x24012ded

24011da8 <HAL_QSPI_Command>:
  * @param Timeout Timeout duration
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout)
{
24011da8:	b580      	push	{r7, lr}
24011daa:	b088      	sub	sp, #32
24011dac:	af02      	add	r7, sp, #8
24011dae:	60f8      	str	r0, [r7, #12]
24011db0:	60b9      	str	r1, [r7, #8]
24011db2:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
24011db4:	f7f0 f932 	bl	2400201c <HAL_GetTick>
24011db8:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
24011dba:	68fb      	ldr	r3, [r7, #12]
24011dbc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011dc0:	b2db      	uxtb	r3, r3
24011dc2:	2b01      	cmp	r3, #1
24011dc4:	d101      	bne.n	24011dca <HAL_QSPI_Command+0x22>
24011dc6:	2302      	movs	r3, #2
24011dc8:	e048      	b.n	24011e5c <HAL_QSPI_Command+0xb4>
24011dca:	68fb      	ldr	r3, [r7, #12]
24011dcc:	2201      	movs	r2, #1
24011dce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011dd2:	68fb      	ldr	r3, [r7, #12]
24011dd4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011dd8:	b2db      	uxtb	r3, r3
24011dda:	2b01      	cmp	r3, #1
24011ddc:	d137      	bne.n	24011e4e <HAL_QSPI_Command+0xa6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011dde:	68fb      	ldr	r3, [r7, #12]
24011de0:	2200      	movs	r2, #0
24011de2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
24011de4:	68fb      	ldr	r3, [r7, #12]
24011de6:	2202      	movs	r2, #2
24011de8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
24011dec:	687b      	ldr	r3, [r7, #4]
24011dee:	9300      	str	r3, [sp, #0]
24011df0:	693b      	ldr	r3, [r7, #16]
24011df2:	2200      	movs	r2, #0
24011df4:	2120      	movs	r1, #32
24011df6:	68f8      	ldr	r0, [r7, #12]
24011df8:	f001 f82b 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24011dfc:	4603      	mov	r3, r0
24011dfe:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
24011e00:	7dfb      	ldrb	r3, [r7, #23]
24011e02:	2b00      	cmp	r3, #0
24011e04:	d125      	bne.n	24011e52 <HAL_QSPI_Command+0xaa>
    {
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24011e06:	2200      	movs	r2, #0
24011e08:	68b9      	ldr	r1, [r7, #8]
24011e0a:	68f8      	ldr	r0, [r7, #12]
24011e0c:	f001 f858 	bl	24012ec0 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
24011e10:	68bb      	ldr	r3, [r7, #8]
24011e12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011e14:	2b00      	cmp	r3, #0
24011e16:	d115      	bne.n	24011e44 <HAL_QSPI_Command+0x9c>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24011e18:	687b      	ldr	r3, [r7, #4]
24011e1a:	9300      	str	r3, [sp, #0]
24011e1c:	693b      	ldr	r3, [r7, #16]
24011e1e:	2201      	movs	r2, #1
24011e20:	2102      	movs	r1, #2
24011e22:	68f8      	ldr	r0, [r7, #12]
24011e24:	f001 f815 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24011e28:	4603      	mov	r3, r0
24011e2a:	75fb      	strb	r3, [r7, #23]

        if (status == HAL_OK)
24011e2c:	7dfb      	ldrb	r3, [r7, #23]
24011e2e:	2b00      	cmp	r3, #0
24011e30:	d10f      	bne.n	24011e52 <HAL_QSPI_Command+0xaa>
        {
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24011e32:	68fb      	ldr	r3, [r7, #12]
24011e34:	681b      	ldr	r3, [r3, #0]
24011e36:	2202      	movs	r2, #2
24011e38:	60da      	str	r2, [r3, #12]

          /* Update QSPI state */
          hqspi->State = HAL_QSPI_STATE_READY;
24011e3a:	68fb      	ldr	r3, [r7, #12]
24011e3c:	2201      	movs	r2, #1
24011e3e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24011e42:	e006      	b.n	24011e52 <HAL_QSPI_Command+0xaa>
        }
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
24011e44:	68fb      	ldr	r3, [r7, #12]
24011e46:	2201      	movs	r2, #1
24011e48:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24011e4c:	e001      	b.n	24011e52 <HAL_QSPI_Command+0xaa>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
24011e4e:	2302      	movs	r3, #2
24011e50:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24011e52:	68fb      	ldr	r3, [r7, #12]
24011e54:	2200      	movs	r2, #0
24011e56:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24011e5a:	7dfb      	ldrb	r3, [r7, #23]
}
24011e5c:	4618      	mov	r0, r3
24011e5e:	3718      	adds	r7, #24
24011e60:	46bd      	mov	sp, r7
24011e62:	bd80      	pop	{r7, pc}

24011e64 <HAL_QSPI_Command_IT>:
  * @param cmd structure that contains the command configuration information
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd)
{
24011e64:	b580      	push	{r7, lr}
24011e66:	b086      	sub	sp, #24
24011e68:	af02      	add	r7, sp, #8
24011e6a:	6078      	str	r0, [r7, #4]
24011e6c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
24011e6e:	f7f0 f8d5 	bl	2400201c <HAL_GetTick>
24011e72:	60b8      	str	r0, [r7, #8]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
24011e74:	687b      	ldr	r3, [r7, #4]
24011e76:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011e7a:	b2db      	uxtb	r3, r3
24011e7c:	2b01      	cmp	r3, #1
24011e7e:	d101      	bne.n	24011e84 <HAL_QSPI_Command_IT+0x20>
24011e80:	2302      	movs	r3, #2
24011e82:	e051      	b.n	24011f28 <HAL_QSPI_Command_IT+0xc4>
24011e84:	687b      	ldr	r3, [r7, #4]
24011e86:	2201      	movs	r2, #1
24011e88:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011e8c:	687b      	ldr	r3, [r7, #4]
24011e8e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011e92:	b2db      	uxtb	r3, r3
24011e94:	2b01      	cmp	r3, #1
24011e96:	d140      	bne.n	24011f1a <HAL_QSPI_Command_IT+0xb6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011e98:	687b      	ldr	r3, [r7, #4]
24011e9a:	2200      	movs	r2, #0
24011e9c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
24011e9e:	687b      	ldr	r3, [r7, #4]
24011ea0:	2202      	movs	r2, #2
24011ea2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24011ea6:	687b      	ldr	r3, [r7, #4]
24011ea8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24011eaa:	9300      	str	r3, [sp, #0]
24011eac:	68bb      	ldr	r3, [r7, #8]
24011eae:	2200      	movs	r2, #0
24011eb0:	2120      	movs	r1, #32
24011eb2:	6878      	ldr	r0, [r7, #4]
24011eb4:	f000 ffcd 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24011eb8:	4603      	mov	r3, r0
24011eba:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
24011ebc:	7bfb      	ldrb	r3, [r7, #15]
24011ebe:	2b00      	cmp	r3, #0
24011ec0:	d126      	bne.n	24011f10 <HAL_QSPI_Command_IT+0xac>
    {
      if (cmd->DataMode == QSPI_DATA_NONE)
24011ec2:	683b      	ldr	r3, [r7, #0]
24011ec4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011ec6:	2b00      	cmp	r3, #0
24011ec8:	d103      	bne.n	24011ed2 <HAL_QSPI_Command_IT+0x6e>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24011eca:	687b      	ldr	r3, [r7, #4]
24011ecc:	681b      	ldr	r3, [r3, #0]
24011ece:	2203      	movs	r2, #3
24011ed0:	60da      	str	r2, [r3, #12]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24011ed2:	2200      	movs	r2, #0
24011ed4:	6839      	ldr	r1, [r7, #0]
24011ed6:	6878      	ldr	r0, [r7, #4]
24011ed8:	f000 fff2 	bl	24012ec0 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
24011edc:	683b      	ldr	r3, [r7, #0]
24011ede:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011ee0:	2b00      	cmp	r3, #0
24011ee2:	d10c      	bne.n	24011efe <HAL_QSPI_Command_IT+0x9a>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so activate TC and TE interrupts */
        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
24011ee4:	687b      	ldr	r3, [r7, #4]
24011ee6:	2200      	movs	r2, #0
24011ee8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Enable the QSPI Transfer Error Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
24011eec:	687b      	ldr	r3, [r7, #4]
24011eee:	681b      	ldr	r3, [r3, #0]
24011ef0:	681a      	ldr	r2, [r3, #0]
24011ef2:	687b      	ldr	r3, [r7, #4]
24011ef4:	681b      	ldr	r3, [r3, #0]
24011ef6:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
24011efa:	601a      	str	r2, [r3, #0]
24011efc:	e013      	b.n	24011f26 <HAL_QSPI_Command_IT+0xc2>
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
24011efe:	687b      	ldr	r3, [r7, #4]
24011f00:	2201      	movs	r2, #1
24011f02:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
24011f06:	687b      	ldr	r3, [r7, #4]
24011f08:	2200      	movs	r2, #0
24011f0a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011f0e:	e00a      	b.n	24011f26 <HAL_QSPI_Command_IT+0xc2>
      }
    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011f10:	687b      	ldr	r3, [r7, #4]
24011f12:	2200      	movs	r2, #0
24011f14:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011f18:	e005      	b.n	24011f26 <HAL_QSPI_Command_IT+0xc2>
    }
  }
  else
  {
    status = HAL_BUSY;
24011f1a:	2302      	movs	r3, #2
24011f1c:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24011f1e:	687b      	ldr	r3, [r7, #4]
24011f20:	2200      	movs	r2, #0
24011f22:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
24011f26:	7bfb      	ldrb	r3, [r7, #15]
}
24011f28:	4618      	mov	r0, r3
24011f2a:	3710      	adds	r7, #16
24011f2c:	46bd      	mov	sp, r7
24011f2e:	bd80      	pop	{r7, pc}

24011f30 <HAL_QSPI_Transmit>:
  * @param Timeout Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
24011f30:	b580      	push	{r7, lr}
24011f32:	b08a      	sub	sp, #40	; 0x28
24011f34:	af02      	add	r7, sp, #8
24011f36:	60f8      	str	r0, [r7, #12]
24011f38:	60b9      	str	r1, [r7, #8]
24011f3a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24011f3c:	2300      	movs	r3, #0
24011f3e:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
24011f40:	f7f0 f86c 	bl	2400201c <HAL_GetTick>
24011f44:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
24011f46:	68fb      	ldr	r3, [r7, #12]
24011f48:	681b      	ldr	r3, [r3, #0]
24011f4a:	3320      	adds	r3, #32
24011f4c:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hqspi);
24011f4e:	68fb      	ldr	r3, [r7, #12]
24011f50:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011f54:	b2db      	uxtb	r3, r3
24011f56:	2b01      	cmp	r3, #1
24011f58:	d101      	bne.n	24011f5e <HAL_QSPI_Transmit+0x2e>
24011f5a:	2302      	movs	r3, #2
24011f5c:	e076      	b.n	2401204c <HAL_QSPI_Transmit+0x11c>
24011f5e:	68fb      	ldr	r3, [r7, #12]
24011f60:	2201      	movs	r2, #1
24011f62:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011f66:	68fb      	ldr	r3, [r7, #12]
24011f68:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011f6c:	b2db      	uxtb	r3, r3
24011f6e:	2b01      	cmp	r3, #1
24011f70:	d165      	bne.n	2401203e <HAL_QSPI_Transmit+0x10e>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011f72:	68fb      	ldr	r3, [r7, #12]
24011f74:	2200      	movs	r2, #0
24011f76:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24011f78:	68bb      	ldr	r3, [r7, #8]
24011f7a:	2b00      	cmp	r3, #0
24011f7c:	d056      	beq.n	2401202c <HAL_QSPI_Transmit+0xfc>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24011f7e:	68fb      	ldr	r3, [r7, #12]
24011f80:	2212      	movs	r2, #18
24011f82:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24011f86:	68fb      	ldr	r3, [r7, #12]
24011f88:	681b      	ldr	r3, [r3, #0]
24011f8a:	691b      	ldr	r3, [r3, #16]
24011f8c:	1c5a      	adds	r2, r3, #1
24011f8e:	68fb      	ldr	r3, [r7, #12]
24011f90:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24011f92:	68fb      	ldr	r3, [r7, #12]
24011f94:	681b      	ldr	r3, [r3, #0]
24011f96:	691b      	ldr	r3, [r3, #16]
24011f98:	1c5a      	adds	r2, r3, #1
24011f9a:	68fb      	ldr	r3, [r7, #12]
24011f9c:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
24011f9e:	68fb      	ldr	r3, [r7, #12]
24011fa0:	68ba      	ldr	r2, [r7, #8]
24011fa2:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24011fa4:	68fb      	ldr	r3, [r7, #12]
24011fa6:	681b      	ldr	r3, [r3, #0]
24011fa8:	695a      	ldr	r2, [r3, #20]
24011faa:	68fb      	ldr	r3, [r7, #12]
24011fac:	681b      	ldr	r3, [r3, #0]
24011fae:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24011fb2:	615a      	str	r2, [r3, #20]

      while(hqspi->TxXferCount > 0U)
24011fb4:	e01b      	b.n	24011fee <HAL_QSPI_Transmit+0xbe>
      {
        /* Wait until FT flag is set to send data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
24011fb6:	687b      	ldr	r3, [r7, #4]
24011fb8:	9300      	str	r3, [sp, #0]
24011fba:	69bb      	ldr	r3, [r7, #24]
24011fbc:	2201      	movs	r2, #1
24011fbe:	2104      	movs	r1, #4
24011fc0:	68f8      	ldr	r0, [r7, #12]
24011fc2:	f000 ff46 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24011fc6:	4603      	mov	r3, r0
24011fc8:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
24011fca:	7ffb      	ldrb	r3, [r7, #31]
24011fcc:	2b00      	cmp	r3, #0
24011fce:	d113      	bne.n	24011ff8 <HAL_QSPI_Transmit+0xc8>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
24011fd0:	68fb      	ldr	r3, [r7, #12]
24011fd2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011fd4:	781a      	ldrb	r2, [r3, #0]
24011fd6:	697b      	ldr	r3, [r7, #20]
24011fd8:	701a      	strb	r2, [r3, #0]
        hqspi->pTxBuffPtr++;
24011fda:	68fb      	ldr	r3, [r7, #12]
24011fdc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011fde:	1c5a      	adds	r2, r3, #1
24011fe0:	68fb      	ldr	r3, [r7, #12]
24011fe2:	625a      	str	r2, [r3, #36]	; 0x24
        hqspi->TxXferCount--;
24011fe4:	68fb      	ldr	r3, [r7, #12]
24011fe6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24011fe8:	1e5a      	subs	r2, r3, #1
24011fea:	68fb      	ldr	r3, [r7, #12]
24011fec:	62da      	str	r2, [r3, #44]	; 0x2c
      while(hqspi->TxXferCount > 0U)
24011fee:	68fb      	ldr	r3, [r7, #12]
24011ff0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24011ff2:	2b00      	cmp	r3, #0
24011ff4:	d1df      	bne.n	24011fb6 <HAL_QSPI_Transmit+0x86>
24011ff6:	e000      	b.n	24011ffa <HAL_QSPI_Transmit+0xca>
          break;
24011ff8:	bf00      	nop
      }

      if (status == HAL_OK)
24011ffa:	7ffb      	ldrb	r3, [r7, #31]
24011ffc:	2b00      	cmp	r3, #0
24011ffe:	d110      	bne.n	24012022 <HAL_QSPI_Transmit+0xf2>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24012000:	687b      	ldr	r3, [r7, #4]
24012002:	9300      	str	r3, [sp, #0]
24012004:	69bb      	ldr	r3, [r7, #24]
24012006:	2201      	movs	r2, #1
24012008:	2102      	movs	r1, #2
2401200a:	68f8      	ldr	r0, [r7, #12]
2401200c:	f000 ff21 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24012010:	4603      	mov	r3, r0
24012012:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
24012014:	7ffb      	ldrb	r3, [r7, #31]
24012016:	2b00      	cmp	r3, #0
24012018:	d103      	bne.n	24012022 <HAL_QSPI_Transmit+0xf2>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2401201a:	68fb      	ldr	r3, [r7, #12]
2401201c:	681b      	ldr	r3, [r3, #0]
2401201e:	2202      	movs	r2, #2
24012020:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
24012022:	68fb      	ldr	r3, [r7, #12]
24012024:	2201      	movs	r2, #1
24012026:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401202a:	e00a      	b.n	24012042 <HAL_QSPI_Transmit+0x112>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2401202c:	68fb      	ldr	r3, [r7, #12]
2401202e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012030:	f043 0208 	orr.w	r2, r3, #8
24012034:	68fb      	ldr	r3, [r7, #12]
24012036:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24012038:	2301      	movs	r3, #1
2401203a:	77fb      	strb	r3, [r7, #31]
2401203c:	e001      	b.n	24012042 <HAL_QSPI_Transmit+0x112>
    }
  }
  else
  {
    status = HAL_BUSY;
2401203e:	2302      	movs	r3, #2
24012040:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24012042:	68fb      	ldr	r3, [r7, #12]
24012044:	2200      	movs	r2, #0
24012046:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
2401204a:	7ffb      	ldrb	r3, [r7, #31]
}
2401204c:	4618      	mov	r0, r3
2401204e:	3720      	adds	r7, #32
24012050:	46bd      	mov	sp, r7
24012052:	bd80      	pop	{r7, pc}

24012054 <HAL_QSPI_Receive>:
  * @param Timeout Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
24012054:	b580      	push	{r7, lr}
24012056:	b08a      	sub	sp, #40	; 0x28
24012058:	af02      	add	r7, sp, #8
2401205a:	60f8      	str	r0, [r7, #12]
2401205c:	60b9      	str	r1, [r7, #8]
2401205e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24012060:	2300      	movs	r3, #0
24012062:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
24012064:	f7ef ffda 	bl	2400201c <HAL_GetTick>
24012068:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
2401206a:	68fb      	ldr	r3, [r7, #12]
2401206c:	681b      	ldr	r3, [r3, #0]
2401206e:	699b      	ldr	r3, [r3, #24]
24012070:	617b      	str	r3, [r7, #20]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
24012072:	68fb      	ldr	r3, [r7, #12]
24012074:	681b      	ldr	r3, [r3, #0]
24012076:	3320      	adds	r3, #32
24012078:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hqspi);
2401207a:	68fb      	ldr	r3, [r7, #12]
2401207c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012080:	b2db      	uxtb	r3, r3
24012082:	2b01      	cmp	r3, #1
24012084:	d101      	bne.n	2401208a <HAL_QSPI_Receive+0x36>
24012086:	2302      	movs	r3, #2
24012088:	e07d      	b.n	24012186 <HAL_QSPI_Receive+0x132>
2401208a:	68fb      	ldr	r3, [r7, #12]
2401208c:	2201      	movs	r2, #1
2401208e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012092:	68fb      	ldr	r3, [r7, #12]
24012094:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012098:	b2db      	uxtb	r3, r3
2401209a:	2b01      	cmp	r3, #1
2401209c:	d16c      	bne.n	24012178 <HAL_QSPI_Receive+0x124>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2401209e:	68fb      	ldr	r3, [r7, #12]
240120a0:	2200      	movs	r2, #0
240120a2:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
240120a4:	68bb      	ldr	r3, [r7, #8]
240120a6:	2b00      	cmp	r3, #0
240120a8:	d05d      	beq.n	24012166 <HAL_QSPI_Receive+0x112>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
240120aa:	68fb      	ldr	r3, [r7, #12]
240120ac:	2222      	movs	r2, #34	; 0x22
240120ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
240120b2:	68fb      	ldr	r3, [r7, #12]
240120b4:	681b      	ldr	r3, [r3, #0]
240120b6:	691b      	ldr	r3, [r3, #16]
240120b8:	1c5a      	adds	r2, r3, #1
240120ba:	68fb      	ldr	r3, [r7, #12]
240120bc:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
240120be:	68fb      	ldr	r3, [r7, #12]
240120c0:	681b      	ldr	r3, [r3, #0]
240120c2:	691b      	ldr	r3, [r3, #16]
240120c4:	1c5a      	adds	r2, r3, #1
240120c6:	68fb      	ldr	r3, [r7, #12]
240120c8:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
240120ca:	68fb      	ldr	r3, [r7, #12]
240120cc:	68ba      	ldr	r2, [r7, #8]
240120ce:	631a      	str	r2, [r3, #48]	; 0x30

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
240120d0:	68fb      	ldr	r3, [r7, #12]
240120d2:	681b      	ldr	r3, [r3, #0]
240120d4:	695b      	ldr	r3, [r3, #20]
240120d6:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
240120da:	68fb      	ldr	r3, [r7, #12]
240120dc:	681b      	ldr	r3, [r3, #0]
240120de:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
240120e2:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
240120e4:	68fb      	ldr	r3, [r7, #12]
240120e6:	681b      	ldr	r3, [r3, #0]
240120e8:	697a      	ldr	r2, [r7, #20]
240120ea:	619a      	str	r2, [r3, #24]

      while(hqspi->RxXferCount > 0U)
240120ec:	e01c      	b.n	24012128 <HAL_QSPI_Receive+0xd4>
      {
        /* Wait until FT or TC flag is set to read received data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
240120ee:	687b      	ldr	r3, [r7, #4]
240120f0:	9300      	str	r3, [sp, #0]
240120f2:	69bb      	ldr	r3, [r7, #24]
240120f4:	2201      	movs	r2, #1
240120f6:	2106      	movs	r1, #6
240120f8:	68f8      	ldr	r0, [r7, #12]
240120fa:	f000 feaa 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
240120fe:	4603      	mov	r3, r0
24012100:	77fb      	strb	r3, [r7, #31]

        if  (status != HAL_OK)
24012102:	7ffb      	ldrb	r3, [r7, #31]
24012104:	2b00      	cmp	r3, #0
24012106:	d114      	bne.n	24012132 <HAL_QSPI_Receive+0xde>
        {
          break;
        }

        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24012108:	68fb      	ldr	r3, [r7, #12]
2401210a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401210c:	693a      	ldr	r2, [r7, #16]
2401210e:	7812      	ldrb	r2, [r2, #0]
24012110:	b2d2      	uxtb	r2, r2
24012112:	701a      	strb	r2, [r3, #0]
        hqspi->pRxBuffPtr++;
24012114:	68fb      	ldr	r3, [r7, #12]
24012116:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012118:	1c5a      	adds	r2, r3, #1
2401211a:	68fb      	ldr	r3, [r7, #12]
2401211c:	631a      	str	r2, [r3, #48]	; 0x30
        hqspi->RxXferCount--;
2401211e:	68fb      	ldr	r3, [r7, #12]
24012120:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24012122:	1e5a      	subs	r2, r3, #1
24012124:	68fb      	ldr	r3, [r7, #12]
24012126:	639a      	str	r2, [r3, #56]	; 0x38
      while(hqspi->RxXferCount > 0U)
24012128:	68fb      	ldr	r3, [r7, #12]
2401212a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401212c:	2b00      	cmp	r3, #0
2401212e:	d1de      	bne.n	240120ee <HAL_QSPI_Receive+0x9a>
24012130:	e000      	b.n	24012134 <HAL_QSPI_Receive+0xe0>
          break;
24012132:	bf00      	nop
      }

      if (status == HAL_OK)
24012134:	7ffb      	ldrb	r3, [r7, #31]
24012136:	2b00      	cmp	r3, #0
24012138:	d110      	bne.n	2401215c <HAL_QSPI_Receive+0x108>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
2401213a:	687b      	ldr	r3, [r7, #4]
2401213c:	9300      	str	r3, [sp, #0]
2401213e:	69bb      	ldr	r3, [r7, #24]
24012140:	2201      	movs	r2, #1
24012142:	2102      	movs	r1, #2
24012144:	68f8      	ldr	r0, [r7, #12]
24012146:	f000 fe84 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
2401214a:	4603      	mov	r3, r0
2401214c:	77fb      	strb	r3, [r7, #31]

        if  (status == HAL_OK)
2401214e:	7ffb      	ldrb	r3, [r7, #31]
24012150:	2b00      	cmp	r3, #0
24012152:	d103      	bne.n	2401215c <HAL_QSPI_Receive+0x108>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24012154:	68fb      	ldr	r3, [r7, #12]
24012156:	681b      	ldr	r3, [r3, #0]
24012158:	2202      	movs	r2, #2
2401215a:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
2401215c:	68fb      	ldr	r3, [r7, #12]
2401215e:	2201      	movs	r2, #1
24012160:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24012164:	e00a      	b.n	2401217c <HAL_QSPI_Receive+0x128>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24012166:	68fb      	ldr	r3, [r7, #12]
24012168:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401216a:	f043 0208 	orr.w	r2, r3, #8
2401216e:	68fb      	ldr	r3, [r7, #12]
24012170:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24012172:	2301      	movs	r3, #1
24012174:	77fb      	strb	r3, [r7, #31]
24012176:	e001      	b.n	2401217c <HAL_QSPI_Receive+0x128>
    }
  }
  else
  {
    status = HAL_BUSY;
24012178:	2302      	movs	r3, #2
2401217a:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2401217c:	68fb      	ldr	r3, [r7, #12]
2401217e:	2200      	movs	r2, #0
24012180:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
24012184:	7ffb      	ldrb	r3, [r7, #31]
}
24012186:	4618      	mov	r0, r3
24012188:	3720      	adds	r7, #32
2401218a:	46bd      	mov	sp, r7
2401218c:	bd80      	pop	{r7, pc}

2401218e <HAL_QSPI_Transmit_IT>:
  * @param  pData pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
2401218e:	b480      	push	{r7}
24012190:	b085      	sub	sp, #20
24012192:	af00      	add	r7, sp, #0
24012194:	6078      	str	r0, [r7, #4]
24012196:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24012198:	2300      	movs	r3, #0
2401219a:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
2401219c:	687b      	ldr	r3, [r7, #4]
2401219e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240121a2:	b2db      	uxtb	r3, r3
240121a4:	2b01      	cmp	r3, #1
240121a6:	d101      	bne.n	240121ac <HAL_QSPI_Transmit_IT+0x1e>
240121a8:	2302      	movs	r3, #2
240121aa:	e04f      	b.n	2401224c <HAL_QSPI_Transmit_IT+0xbe>
240121ac:	687b      	ldr	r3, [r7, #4]
240121ae:	2201      	movs	r2, #1
240121b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240121b4:	687b      	ldr	r3, [r7, #4]
240121b6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240121ba:	b2db      	uxtb	r3, r3
240121bc:	2b01      	cmp	r3, #1
240121be:	d13e      	bne.n	2401223e <HAL_QSPI_Transmit_IT+0xb0>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240121c0:	687b      	ldr	r3, [r7, #4]
240121c2:	2200      	movs	r2, #0
240121c4:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
240121c6:	683b      	ldr	r3, [r7, #0]
240121c8:	2b00      	cmp	r3, #0
240121ca:	d02b      	beq.n	24012224 <HAL_QSPI_Transmit_IT+0x96>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
240121cc:	687b      	ldr	r3, [r7, #4]
240121ce:	2212      	movs	r2, #18
240121d0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
240121d4:	687b      	ldr	r3, [r7, #4]
240121d6:	681b      	ldr	r3, [r3, #0]
240121d8:	691b      	ldr	r3, [r3, #16]
240121da:	1c5a      	adds	r2, r3, #1
240121dc:	687b      	ldr	r3, [r7, #4]
240121de:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
240121e0:	687b      	ldr	r3, [r7, #4]
240121e2:	681b      	ldr	r3, [r3, #0]
240121e4:	691b      	ldr	r3, [r3, #16]
240121e6:	1c5a      	adds	r2, r3, #1
240121e8:	687b      	ldr	r3, [r7, #4]
240121ea:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
240121ec:	687b      	ldr	r3, [r7, #4]
240121ee:	683a      	ldr	r2, [r7, #0]
240121f0:	625a      	str	r2, [r3, #36]	; 0x24

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
240121f2:	687b      	ldr	r3, [r7, #4]
240121f4:	681b      	ldr	r3, [r3, #0]
240121f6:	2203      	movs	r2, #3
240121f8:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
240121fa:	687b      	ldr	r3, [r7, #4]
240121fc:	681b      	ldr	r3, [r3, #0]
240121fe:	695a      	ldr	r2, [r3, #20]
24012200:	687b      	ldr	r3, [r7, #4]
24012202:	681b      	ldr	r3, [r3, #0]
24012204:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24012208:	615a      	str	r2, [r3, #20]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2401220a:	687b      	ldr	r3, [r7, #4]
2401220c:	2200      	movs	r2, #0
2401220e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24012212:	687b      	ldr	r3, [r7, #4]
24012214:	681b      	ldr	r3, [r3, #0]
24012216:	681a      	ldr	r2, [r3, #0]
24012218:	687b      	ldr	r3, [r7, #4]
2401221a:	681b      	ldr	r3, [r3, #0]
2401221c:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
24012220:	601a      	str	r2, [r3, #0]
24012222:	e012      	b.n	2401224a <HAL_QSPI_Transmit_IT+0xbc>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24012224:	687b      	ldr	r3, [r7, #4]
24012226:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012228:	f043 0208 	orr.w	r2, r3, #8
2401222c:	687b      	ldr	r3, [r7, #4]
2401222e:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24012230:	2301      	movs	r3, #1
24012232:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24012234:	687b      	ldr	r3, [r7, #4]
24012236:	2200      	movs	r2, #0
24012238:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401223c:	e005      	b.n	2401224a <HAL_QSPI_Transmit_IT+0xbc>
    }
  }
  else
  {
    status = HAL_BUSY;
2401223e:	2302      	movs	r3, #2
24012240:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24012242:	687b      	ldr	r3, [r7, #4]
24012244:	2200      	movs	r2, #0
24012246:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
2401224a:	7bfb      	ldrb	r3, [r7, #15]
}
2401224c:	4618      	mov	r0, r3
2401224e:	3714      	adds	r7, #20
24012250:	46bd      	mov	sp, r7
24012252:	f85d 7b04 	ldr.w	r7, [sp], #4
24012256:	4770      	bx	lr

24012258 <HAL_QSPI_Receive_IT>:
  * @param  pData pointer to data buffer
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24012258:	b480      	push	{r7}
2401225a:	b085      	sub	sp, #20
2401225c:	af00      	add	r7, sp, #0
2401225e:	6078      	str	r0, [r7, #4]
24012260:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24012262:	2300      	movs	r3, #0
24012264:	73fb      	strb	r3, [r7, #15]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24012266:	687b      	ldr	r3, [r7, #4]
24012268:	681b      	ldr	r3, [r3, #0]
2401226a:	699b      	ldr	r3, [r3, #24]
2401226c:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
2401226e:	687b      	ldr	r3, [r7, #4]
24012270:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012274:	b2db      	uxtb	r3, r3
24012276:	2b01      	cmp	r3, #1
24012278:	d101      	bne.n	2401227e <HAL_QSPI_Receive_IT+0x26>
2401227a:	2302      	movs	r3, #2
2401227c:	e055      	b.n	2401232a <HAL_QSPI_Receive_IT+0xd2>
2401227e:	687b      	ldr	r3, [r7, #4]
24012280:	2201      	movs	r2, #1
24012282:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012286:	687b      	ldr	r3, [r7, #4]
24012288:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401228c:	b2db      	uxtb	r3, r3
2401228e:	2b01      	cmp	r3, #1
24012290:	d144      	bne.n	2401231c <HAL_QSPI_Receive_IT+0xc4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24012292:	687b      	ldr	r3, [r7, #4]
24012294:	2200      	movs	r2, #0
24012296:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24012298:	683b      	ldr	r3, [r7, #0]
2401229a:	2b00      	cmp	r3, #0
2401229c:	d031      	beq.n	24012302 <HAL_QSPI_Receive_IT+0xaa>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
2401229e:	687b      	ldr	r3, [r7, #4]
240122a0:	2222      	movs	r2, #34	; 0x22
240122a2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
240122a6:	687b      	ldr	r3, [r7, #4]
240122a8:	681b      	ldr	r3, [r3, #0]
240122aa:	691b      	ldr	r3, [r3, #16]
240122ac:	1c5a      	adds	r2, r3, #1
240122ae:	687b      	ldr	r3, [r7, #4]
240122b0:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
240122b2:	687b      	ldr	r3, [r7, #4]
240122b4:	681b      	ldr	r3, [r3, #0]
240122b6:	691b      	ldr	r3, [r3, #16]
240122b8:	1c5a      	adds	r2, r3, #1
240122ba:	687b      	ldr	r3, [r7, #4]
240122bc:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
240122be:	687b      	ldr	r3, [r7, #4]
240122c0:	683a      	ldr	r2, [r7, #0]
240122c2:	631a      	str	r2, [r3, #48]	; 0x30

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
240122c4:	687b      	ldr	r3, [r7, #4]
240122c6:	681b      	ldr	r3, [r3, #0]
240122c8:	2203      	movs	r2, #3
240122ca:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
240122cc:	687b      	ldr	r3, [r7, #4]
240122ce:	681b      	ldr	r3, [r3, #0]
240122d0:	695b      	ldr	r3, [r3, #20]
240122d2:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
240122d6:	687b      	ldr	r3, [r7, #4]
240122d8:	681b      	ldr	r3, [r3, #0]
240122da:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
240122de:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
240122e0:	687b      	ldr	r3, [r7, #4]
240122e2:	681b      	ldr	r3, [r3, #0]
240122e4:	68ba      	ldr	r2, [r7, #8]
240122e6:	619a      	str	r2, [r3, #24]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240122e8:	687b      	ldr	r3, [r7, #4]
240122ea:	2200      	movs	r2, #0
240122ec:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
240122f0:	687b      	ldr	r3, [r7, #4]
240122f2:	681b      	ldr	r3, [r3, #0]
240122f4:	681a      	ldr	r2, [r3, #0]
240122f6:	687b      	ldr	r3, [r7, #4]
240122f8:	681b      	ldr	r3, [r3, #0]
240122fa:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
240122fe:	601a      	str	r2, [r3, #0]
24012300:	e012      	b.n	24012328 <HAL_QSPI_Receive_IT+0xd0>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24012302:	687b      	ldr	r3, [r7, #4]
24012304:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012306:	f043 0208 	orr.w	r2, r3, #8
2401230a:	687b      	ldr	r3, [r7, #4]
2401230c:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2401230e:	2301      	movs	r3, #1
24012310:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24012312:	687b      	ldr	r3, [r7, #4]
24012314:	2200      	movs	r2, #0
24012316:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401231a:	e005      	b.n	24012328 <HAL_QSPI_Receive_IT+0xd0>
    }
  }
  else
  {
    status = HAL_BUSY;
2401231c:	2302      	movs	r3, #2
2401231e:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24012320:	687b      	ldr	r3, [r7, #4]
24012322:	2200      	movs	r2, #0
24012324:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24012328:	7bfb      	ldrb	r3, [r7, #15]
}
2401232a:	4618      	mov	r0, r3
2401232c:	3714      	adds	r7, #20
2401232e:	46bd      	mov	sp, r7
24012330:	f85d 7b04 	ldr.w	r7, [sp], #4
24012334:	4770      	bx	lr
	...

24012338 <HAL_QSPI_Transmit_DMA>:
  * @param  pData pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24012338:	b590      	push	{r4, r7, lr}
2401233a:	b087      	sub	sp, #28
2401233c:	af02      	add	r7, sp, #8
2401233e:	6078      	str	r0, [r7, #4]
24012340:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24012342:	2300      	movs	r3, #0
24012344:	73fb      	strb	r3, [r7, #15]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24012346:	687b      	ldr	r3, [r7, #4]
24012348:	681b      	ldr	r3, [r3, #0]
2401234a:	691b      	ldr	r3, [r3, #16]
2401234c:	3301      	adds	r3, #1
2401234e:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
24012350:	687b      	ldr	r3, [r7, #4]
24012352:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012356:	b2db      	uxtb	r3, r3
24012358:	2b01      	cmp	r3, #1
2401235a:	d101      	bne.n	24012360 <HAL_QSPI_Transmit_DMA+0x28>
2401235c:	2302      	movs	r3, #2
2401235e:	e0cb      	b.n	240124f8 <HAL_QSPI_Transmit_DMA+0x1c0>
24012360:	687b      	ldr	r3, [r7, #4]
24012362:	2201      	movs	r2, #1
24012364:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012368:	687b      	ldr	r3, [r7, #4]
2401236a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401236e:	b2db      	uxtb	r3, r3
24012370:	2b01      	cmp	r3, #1
24012372:	f040 80ba 	bne.w	240124ea <HAL_QSPI_Transmit_DMA+0x1b2>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24012376:	687b      	ldr	r3, [r7, #4]
24012378:	2200      	movs	r2, #0
2401237a:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
2401237c:	683b      	ldr	r3, [r7, #0]
2401237e:	2b00      	cmp	r3, #0
24012380:	f000 80a6 	beq.w	240124d0 <HAL_QSPI_Transmit_DMA+0x198>
    {
      /* Configure counters of the handle */
      hqspi->TxXferCount = data_size;
24012384:	687b      	ldr	r3, [r7, #4]
24012386:	68ba      	ldr	r2, [r7, #8]
24012388:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
2401238a:	687b      	ldr	r3, [r7, #4]
2401238c:	2212      	movs	r2, #18
2401238e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24012392:	687b      	ldr	r3, [r7, #4]
24012394:	681b      	ldr	r3, [r3, #0]
24012396:	2203      	movs	r2, #3
24012398:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->TxXferSize = hqspi->TxXferCount;
2401239a:	687b      	ldr	r3, [r7, #4]
2401239c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2401239e:	687b      	ldr	r3, [r7, #4]
240123a0:	629a      	str	r2, [r3, #40]	; 0x28
        hqspi->pTxBuffPtr = pData;
240123a2:	687b      	ldr	r3, [r7, #4]
240123a4:	683a      	ldr	r2, [r7, #0]
240123a6:	625a      	str	r2, [r3, #36]	; 0x24

        /* Configure QSPI: CCR register with functional mode as indirect write */
        MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
240123a8:	687b      	ldr	r3, [r7, #4]
240123aa:	681b      	ldr	r3, [r3, #0]
240123ac:	695a      	ldr	r2, [r3, #20]
240123ae:	687b      	ldr	r3, [r7, #4]
240123b0:	681b      	ldr	r3, [r3, #0]
240123b2:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
240123b6:	615a      	str	r2, [r3, #20]

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMATxCplt;
240123b8:	687b      	ldr	r3, [r7, #4]
240123ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123bc:	4a50      	ldr	r2, [pc, #320]	; (24012500 <HAL_QSPI_Transmit_DMA+0x1c8>)
240123be:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
240123c0:	687b      	ldr	r3, [r7, #4]
240123c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123c4:	4a4f      	ldr	r2, [pc, #316]	; (24012504 <HAL_QSPI_Transmit_DMA+0x1cc>)
240123c6:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
240123c8:	687b      	ldr	r3, [r7, #4]
240123ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123cc:	2200      	movs	r2, #0
240123ce:	659a      	str	r2, [r3, #88]	; 0x58

        /* In Transmit mode , the MDMA destination is the QSPI DR register : Force the MDMA Destination Increment to disable */
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) ,MDMA_DEST_INC_DISABLE);
240123d0:	687b      	ldr	r3, [r7, #4]
240123d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123d4:	681b      	ldr	r3, [r3, #0]
240123d6:	6919      	ldr	r1, [r3, #16]
240123d8:	687b      	ldr	r3, [r7, #4]
240123da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123dc:	681a      	ldr	r2, [r3, #0]
240123de:	4b4a      	ldr	r3, [pc, #296]	; (24012508 <HAL_QSPI_Transmit_DMA+0x1d0>)
240123e0:	400b      	ands	r3, r1
240123e2:	6113      	str	r3, [r2, #16]

        /* Update MDMA configuration with the correct SourceInc field for Write operation */
        if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_BYTE)
240123e4:	687b      	ldr	r3, [r7, #4]
240123e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123e8:	69db      	ldr	r3, [r3, #28]
240123ea:	2b00      	cmp	r3, #0
240123ec:	d10c      	bne.n	24012408 <HAL_QSPI_Transmit_DMA+0xd0>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_BYTE);
240123ee:	687b      	ldr	r3, [r7, #4]
240123f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123f2:	681b      	ldr	r3, [r3, #0]
240123f4:	691a      	ldr	r2, [r3, #16]
240123f6:	4b45      	ldr	r3, [pc, #276]	; (2401250c <HAL_QSPI_Transmit_DMA+0x1d4>)
240123f8:	4013      	ands	r3, r2
240123fa:	687a      	ldr	r2, [r7, #4]
240123fc:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
240123fe:	6812      	ldr	r2, [r2, #0]
24012400:	f043 0302 	orr.w	r3, r3, #2
24012404:	6113      	str	r3, [r2, #16]
24012406:	e02c      	b.n	24012462 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_HALFWORD)
24012408:	687b      	ldr	r3, [r7, #4]
2401240a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401240c:	69db      	ldr	r3, [r3, #28]
2401240e:	2b10      	cmp	r3, #16
24012410:	d10c      	bne.n	2401242c <HAL_QSPI_Transmit_DMA+0xf4>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_HALFWORD);
24012412:	687b      	ldr	r3, [r7, #4]
24012414:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012416:	681b      	ldr	r3, [r3, #0]
24012418:	691a      	ldr	r2, [r3, #16]
2401241a:	4b3c      	ldr	r3, [pc, #240]	; (2401250c <HAL_QSPI_Transmit_DMA+0x1d4>)
2401241c:	4013      	ands	r3, r2
2401241e:	687a      	ldr	r2, [r7, #4]
24012420:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24012422:	6812      	ldr	r2, [r2, #0]
24012424:	f443 7381 	orr.w	r3, r3, #258	; 0x102
24012428:	6113      	str	r3, [r2, #16]
2401242a:	e01a      	b.n	24012462 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_WORD)
2401242c:	687b      	ldr	r3, [r7, #4]
2401242e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012430:	69db      	ldr	r3, [r3, #28]
24012432:	2b20      	cmp	r3, #32
24012434:	d10d      	bne.n	24012452 <HAL_QSPI_Transmit_DMA+0x11a>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_WORD);
24012436:	687b      	ldr	r3, [r7, #4]
24012438:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401243a:	681b      	ldr	r3, [r3, #0]
2401243c:	691b      	ldr	r3, [r3, #16]
2401243e:	4a33      	ldr	r2, [pc, #204]	; (2401250c <HAL_QSPI_Transmit_DMA+0x1d4>)
24012440:	401a      	ands	r2, r3
24012442:	687b      	ldr	r3, [r7, #4]
24012444:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012446:	6819      	ldr	r1, [r3, #0]
24012448:	f240 2302 	movw	r3, #514	; 0x202
2401244c:	4313      	orrs	r3, r2
2401244e:	610b      	str	r3, [r1, #16]
24012450:	e007      	b.n	24012462 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else
        {
          /* in case of incorrect source data size */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24012452:	687b      	ldr	r3, [r7, #4]
24012454:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012456:	f043 0204 	orr.w	r2, r3, #4
2401245a:	687b      	ldr	r3, [r7, #4]
2401245c:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
2401245e:	2301      	movs	r3, #1
24012460:	73fb      	strb	r3, [r7, #15]
        }

        /* Enable the QSPI transmit MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)pData, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize, 1) == HAL_OK)
24012462:	687b      	ldr	r3, [r7, #4]
24012464:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24012466:	6839      	ldr	r1, [r7, #0]
24012468:	687b      	ldr	r3, [r7, #4]
2401246a:	681b      	ldr	r3, [r3, #0]
2401246c:	3320      	adds	r3, #32
2401246e:	461c      	mov	r4, r3
24012470:	687b      	ldr	r3, [r7, #4]
24012472:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012474:	2201      	movs	r2, #1
24012476:	9200      	str	r2, [sp, #0]
24012478:	4622      	mov	r2, r4
2401247a:	f7fd feb8 	bl	240101ee <HAL_MDMA_Start_IT>
2401247e:	4603      	mov	r3, r0
24012480:	2b00      	cmp	r3, #0
24012482:	d114      	bne.n	240124ae <HAL_QSPI_Transmit_DMA+0x176>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24012484:	687b      	ldr	r3, [r7, #4]
24012486:	2200      	movs	r2, #0
24012488:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
2401248c:	687b      	ldr	r3, [r7, #4]
2401248e:	681b      	ldr	r3, [r3, #0]
24012490:	681a      	ldr	r2, [r3, #0]
24012492:	687b      	ldr	r3, [r7, #4]
24012494:	681b      	ldr	r3, [r3, #0]
24012496:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2401249a:	601a      	str	r2, [r3, #0]

          /* Enable using MDMA by setting DMAEN, note that DMAEN bit is "reserved"
             but no impact on H7 HW and it minimize the cost in the footprint */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401249c:	687b      	ldr	r3, [r7, #4]
2401249e:	681b      	ldr	r3, [r3, #0]
240124a0:	681a      	ldr	r2, [r3, #0]
240124a2:	687b      	ldr	r3, [r7, #4]
240124a4:	681b      	ldr	r3, [r3, #0]
240124a6:	f042 0204 	orr.w	r2, r2, #4
240124aa:	601a      	str	r2, [r3, #0]
240124ac:	e023      	b.n	240124f6 <HAL_QSPI_Transmit_DMA+0x1be>
        }
        else
        {
          status = HAL_ERROR;
240124ae:	2301      	movs	r3, #1
240124b0:	73fb      	strb	r3, [r7, #15]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
240124b2:	687b      	ldr	r3, [r7, #4]
240124b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240124b6:	f043 0204 	orr.w	r2, r3, #4
240124ba:	687b      	ldr	r3, [r7, #4]
240124bc:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
240124be:	687b      	ldr	r3, [r7, #4]
240124c0:	2201      	movs	r2, #1
240124c2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
240124c6:	687b      	ldr	r3, [r7, #4]
240124c8:	2200      	movs	r2, #0
240124ca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240124ce:	e012      	b.n	240124f6 <HAL_QSPI_Transmit_DMA+0x1be>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
240124d0:	687b      	ldr	r3, [r7, #4]
240124d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240124d4:	f043 0208 	orr.w	r2, r3, #8
240124d8:	687b      	ldr	r3, [r7, #4]
240124da:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
240124dc:	2301      	movs	r3, #1
240124de:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240124e0:	687b      	ldr	r3, [r7, #4]
240124e2:	2200      	movs	r2, #0
240124e4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240124e8:	e005      	b.n	240124f6 <HAL_QSPI_Transmit_DMA+0x1be>
    }
  }
  else
  {
    status = HAL_BUSY;
240124ea:	2302      	movs	r3, #2
240124ec:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
240124ee:	687b      	ldr	r3, [r7, #4]
240124f0:	2200      	movs	r2, #0
240124f2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
240124f6:	7bfb      	ldrb	r3, [r7, #15]
}
240124f8:	4618      	mov	r0, r3
240124fa:	3714      	adds	r7, #20
240124fc:	46bd      	mov	sp, r7
240124fe:	bd90      	pop	{r4, r7, pc}
24012500:	24012d79 	.word	0x24012d79
24012504:	24012da9 	.word	0x24012da9
24012508:	fffff3f3 	.word	0xfffff3f3
2401250c:	fffffcfc 	.word	0xfffffcfc

24012510 <HAL_QSPI_Receive_DMA>:
  * @param  pData pointer to data buffer.
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24012510:	b590      	push	{r4, r7, lr}
24012512:	b089      	sub	sp, #36	; 0x24
24012514:	af02      	add	r7, sp, #8
24012516:	6078      	str	r0, [r7, #4]
24012518:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401251a:	2300      	movs	r3, #0
2401251c:	75fb      	strb	r3, [r7, #23]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
2401251e:	687b      	ldr	r3, [r7, #4]
24012520:	681b      	ldr	r3, [r3, #0]
24012522:	699b      	ldr	r3, [r3, #24]
24012524:	613b      	str	r3, [r7, #16]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24012526:	687b      	ldr	r3, [r7, #4]
24012528:	681b      	ldr	r3, [r3, #0]
2401252a:	691b      	ldr	r3, [r3, #16]
2401252c:	3301      	adds	r3, #1
2401252e:	60fb      	str	r3, [r7, #12]

  /* Process locked */
  __HAL_LOCK(hqspi);
24012530:	687b      	ldr	r3, [r7, #4]
24012532:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012536:	b2db      	uxtb	r3, r3
24012538:	2b01      	cmp	r3, #1
2401253a:	d101      	bne.n	24012540 <HAL_QSPI_Receive_DMA+0x30>
2401253c:	2302      	movs	r3, #2
2401253e:	e0d1      	b.n	240126e4 <HAL_QSPI_Receive_DMA+0x1d4>
24012540:	687b      	ldr	r3, [r7, #4]
24012542:	2201      	movs	r2, #1
24012544:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012548:	687b      	ldr	r3, [r7, #4]
2401254a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401254e:	b2db      	uxtb	r3, r3
24012550:	2b01      	cmp	r3, #1
24012552:	f040 80c0 	bne.w	240126d6 <HAL_QSPI_Receive_DMA+0x1c6>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24012556:	687b      	ldr	r3, [r7, #4]
24012558:	2200      	movs	r2, #0
2401255a:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
2401255c:	683b      	ldr	r3, [r7, #0]
2401255e:	2b00      	cmp	r3, #0
24012560:	f000 80ac 	beq.w	240126bc <HAL_QSPI_Receive_DMA+0x1ac>
    {
      /* Configure counters of the handle */
      hqspi->RxXferCount = data_size;
24012564:	687b      	ldr	r3, [r7, #4]
24012566:	68fa      	ldr	r2, [r7, #12]
24012568:	639a      	str	r2, [r3, #56]	; 0x38
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
2401256a:	687b      	ldr	r3, [r7, #4]
2401256c:	2222      	movs	r2, #34	; 0x22
2401256e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24012572:	687b      	ldr	r3, [r7, #4]
24012574:	681b      	ldr	r3, [r3, #0]
24012576:	2203      	movs	r2, #3
24012578:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->RxXferSize = hqspi->RxXferCount;
2401257a:	687b      	ldr	r3, [r7, #4]
2401257c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
2401257e:	687b      	ldr	r3, [r7, #4]
24012580:	635a      	str	r2, [r3, #52]	; 0x34
        hqspi->pRxBuffPtr = pData;
24012582:	687b      	ldr	r3, [r7, #4]
24012584:	683a      	ldr	r2, [r7, #0]
24012586:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMARxCplt;
24012588:	687b      	ldr	r3, [r7, #4]
2401258a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401258c:	4a57      	ldr	r2, [pc, #348]	; (240126ec <HAL_QSPI_Receive_DMA+0x1dc>)
2401258e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24012590:	687b      	ldr	r3, [r7, #4]
24012592:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012594:	4a56      	ldr	r2, [pc, #344]	; (240126f0 <HAL_QSPI_Receive_DMA+0x1e0>)
24012596:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
24012598:	687b      	ldr	r3, [r7, #4]
2401259a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401259c:	2200      	movs	r2, #0
2401259e:	659a      	str	r2, [r3, #88]	; 0x58

      /* In Receive mode , the MDMA source is the QSPI DR register : Force the MDMA Source Increment to disable */
      MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_DISABLE);
240125a0:	687b      	ldr	r3, [r7, #4]
240125a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240125a4:	681b      	ldr	r3, [r3, #0]
240125a6:	6919      	ldr	r1, [r3, #16]
240125a8:	687b      	ldr	r3, [r7, #4]
240125aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240125ac:	681a      	ldr	r2, [r3, #0]
240125ae:	4b51      	ldr	r3, [pc, #324]	; (240126f4 <HAL_QSPI_Receive_DMA+0x1e4>)
240125b0:	400b      	ands	r3, r1
240125b2:	6113      	str	r3, [r2, #16]

      /* Update MDMA configuration with the correct DestinationInc field for read operation */
      if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_BYTE)
240125b4:	687b      	ldr	r3, [r7, #4]
240125b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240125b8:	6a1b      	ldr	r3, [r3, #32]
240125ba:	2b00      	cmp	r3, #0
240125bc:	d10c      	bne.n	240125d8 <HAL_QSPI_Receive_DMA+0xc8>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_BYTE);
240125be:	687b      	ldr	r3, [r7, #4]
240125c0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240125c2:	681b      	ldr	r3, [r3, #0]
240125c4:	691a      	ldr	r2, [r3, #16]
240125c6:	4b4c      	ldr	r3, [pc, #304]	; (240126f8 <HAL_QSPI_Receive_DMA+0x1e8>)
240125c8:	4013      	ands	r3, r2
240125ca:	687a      	ldr	r2, [r7, #4]
240125cc:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
240125ce:	6812      	ldr	r2, [r2, #0]
240125d0:	f043 0308 	orr.w	r3, r3, #8
240125d4:	6113      	str	r3, [r2, #16]
240125d6:	e02c      	b.n	24012632 <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_HALFWORD)
240125d8:	687b      	ldr	r3, [r7, #4]
240125da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240125dc:	6a1b      	ldr	r3, [r3, #32]
240125de:	2b40      	cmp	r3, #64	; 0x40
240125e0:	d10c      	bne.n	240125fc <HAL_QSPI_Receive_DMA+0xec>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_HALFWORD);
240125e2:	687b      	ldr	r3, [r7, #4]
240125e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240125e6:	681b      	ldr	r3, [r3, #0]
240125e8:	691a      	ldr	r2, [r3, #16]
240125ea:	4b43      	ldr	r3, [pc, #268]	; (240126f8 <HAL_QSPI_Receive_DMA+0x1e8>)
240125ec:	4013      	ands	r3, r2
240125ee:	687a      	ldr	r2, [r7, #4]
240125f0:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
240125f2:	6812      	ldr	r2, [r2, #0]
240125f4:	f443 6381 	orr.w	r3, r3, #1032	; 0x408
240125f8:	6113      	str	r3, [r2, #16]
240125fa:	e01a      	b.n	24012632 <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_WORD)
240125fc:	687b      	ldr	r3, [r7, #4]
240125fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012600:	6a1b      	ldr	r3, [r3, #32]
24012602:	2b80      	cmp	r3, #128	; 0x80
24012604:	d10d      	bne.n	24012622 <HAL_QSPI_Receive_DMA+0x112>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_WORD);
24012606:	687b      	ldr	r3, [r7, #4]
24012608:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401260a:	681b      	ldr	r3, [r3, #0]
2401260c:	691b      	ldr	r3, [r3, #16]
2401260e:	4a3a      	ldr	r2, [pc, #232]	; (240126f8 <HAL_QSPI_Receive_DMA+0x1e8>)
24012610:	401a      	ands	r2, r3
24012612:	687b      	ldr	r3, [r7, #4]
24012614:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012616:	6819      	ldr	r1, [r3, #0]
24012618:	f640 0308 	movw	r3, #2056	; 0x808
2401261c:	4313      	orrs	r3, r2
2401261e:	610b      	str	r3, [r1, #16]
24012620:	e007      	b.n	24012632 <HAL_QSPI_Receive_DMA+0x122>
      }
      else
      {
       /* in case of incorrect destination data size */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24012622:	687b      	ldr	r3, [r7, #4]
24012624:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012626:	f043 0204 	orr.w	r2, r3, #4
2401262a:	687b      	ldr	r3, [r7, #4]
2401262c:	645a      	str	r2, [r3, #68]	; 0x44
        status = HAL_ERROR;
2401262e:	2301      	movs	r3, #1
24012630:	75fb      	strb	r3, [r7, #23]
      }
          /* Configure QSPI: CCR register with functional as indirect read */
          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24012632:	687b      	ldr	r3, [r7, #4]
24012634:	681b      	ldr	r3, [r3, #0]
24012636:	695b      	ldr	r3, [r3, #20]
24012638:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
2401263c:	687b      	ldr	r3, [r7, #4]
2401263e:	681b      	ldr	r3, [r3, #0]
24012640:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24012644:	615a      	str	r2, [r3, #20]

          /* Start the transfer by re-writing the address in AR register */
          WRITE_REG(hqspi->Instance->AR, addr_reg);
24012646:	687b      	ldr	r3, [r7, #4]
24012648:	681b      	ldr	r3, [r3, #0]
2401264a:	693a      	ldr	r2, [r7, #16]
2401264c:	619a      	str	r2, [r3, #24]

        /* Enable the MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)&hqspi->Instance->DR, (uint32_t)pData, hqspi->RxXferSize, 1) == HAL_OK)
2401264e:	687b      	ldr	r3, [r7, #4]
24012650:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24012652:	687b      	ldr	r3, [r7, #4]
24012654:	681b      	ldr	r3, [r3, #0]
24012656:	3320      	adds	r3, #32
24012658:	461c      	mov	r4, r3
2401265a:	683a      	ldr	r2, [r7, #0]
2401265c:	687b      	ldr	r3, [r7, #4]
2401265e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012660:	2101      	movs	r1, #1
24012662:	9100      	str	r1, [sp, #0]
24012664:	4621      	mov	r1, r4
24012666:	f7fd fdc2 	bl	240101ee <HAL_MDMA_Start_IT>
2401266a:	4603      	mov	r3, r0
2401266c:	2b00      	cmp	r3, #0
2401266e:	d114      	bne.n	2401269a <HAL_QSPI_Receive_DMA+0x18a>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24012670:	687b      	ldr	r3, [r7, #4]
24012672:	2200      	movs	r2, #0
24012674:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
24012678:	687b      	ldr	r3, [r7, #4]
2401267a:	681b      	ldr	r3, [r3, #0]
2401267c:	681a      	ldr	r2, [r3, #0]
2401267e:	687b      	ldr	r3, [r7, #4]
24012680:	681b      	ldr	r3, [r3, #0]
24012682:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24012686:	601a      	str	r2, [r3, #0]

          /* Enable using MDMA by setting DMAEN, note that DMAEN bit is "reserved"
             but no impact on H7 HW and it minimize the cost in the footprint */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24012688:	687b      	ldr	r3, [r7, #4]
2401268a:	681b      	ldr	r3, [r3, #0]
2401268c:	681a      	ldr	r2, [r3, #0]
2401268e:	687b      	ldr	r3, [r7, #4]
24012690:	681b      	ldr	r3, [r3, #0]
24012692:	f042 0204 	orr.w	r2, r2, #4
24012696:	601a      	str	r2, [r3, #0]
24012698:	e023      	b.n	240126e2 <HAL_QSPI_Receive_DMA+0x1d2>
        }
        else
        {
          status = HAL_ERROR;
2401269a:	2301      	movs	r3, #1
2401269c:	75fb      	strb	r3, [r7, #23]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
2401269e:	687b      	ldr	r3, [r7, #4]
240126a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240126a2:	f043 0204 	orr.w	r2, r3, #4
240126a6:	687b      	ldr	r3, [r7, #4]
240126a8:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
240126aa:	687b      	ldr	r3, [r7, #4]
240126ac:	2201      	movs	r2, #1
240126ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
240126b2:	687b      	ldr	r3, [r7, #4]
240126b4:	2200      	movs	r2, #0
240126b6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240126ba:	e012      	b.n	240126e2 <HAL_QSPI_Receive_DMA+0x1d2>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
240126bc:	687b      	ldr	r3, [r7, #4]
240126be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240126c0:	f043 0208 	orr.w	r2, r3, #8
240126c4:	687b      	ldr	r3, [r7, #4]
240126c6:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
240126c8:	2301      	movs	r3, #1
240126ca:	75fb      	strb	r3, [r7, #23]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240126cc:	687b      	ldr	r3, [r7, #4]
240126ce:	2200      	movs	r2, #0
240126d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240126d4:	e005      	b.n	240126e2 <HAL_QSPI_Receive_DMA+0x1d2>
    }
  }
  else
  {
    status = HAL_BUSY;
240126d6:	2302      	movs	r3, #2
240126d8:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
240126da:	687b      	ldr	r3, [r7, #4]
240126dc:	2200      	movs	r2, #0
240126de:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
240126e2:	7dfb      	ldrb	r3, [r7, #23]
}
240126e4:	4618      	mov	r0, r3
240126e6:	371c      	adds	r7, #28
240126e8:	46bd      	mov	sp, r7
240126ea:	bd90      	pop	{r4, r7, pc}
240126ec:	24012d49 	.word	0x24012d49
240126f0:	24012da9 	.word	0x24012da9
240126f4:	fffffcfc 	.word	0xfffffcfc
240126f8:	fffff3f3 	.word	0xfffff3f3

240126fc <HAL_QSPI_AutoPolling>:
  * @param  Timeout Timeout duration
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
240126fc:	b580      	push	{r7, lr}
240126fe:	b088      	sub	sp, #32
24012700:	af02      	add	r7, sp, #8
24012702:	60f8      	str	r0, [r7, #12]
24012704:	60b9      	str	r1, [r7, #8]
24012706:	607a      	str	r2, [r7, #4]
24012708:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
2401270a:	f7ef fc87 	bl	2400201c <HAL_GetTick>
2401270e:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_INTERVAL(cfg->Interval));
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
24012710:	68fb      	ldr	r3, [r7, #12]
24012712:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012716:	b2db      	uxtb	r3, r3
24012718:	2b01      	cmp	r3, #1
2401271a:	d101      	bne.n	24012720 <HAL_QSPI_AutoPolling+0x24>
2401271c:	2302      	movs	r3, #2
2401271e:	e060      	b.n	240127e2 <HAL_QSPI_AutoPolling+0xe6>
24012720:	68fb      	ldr	r3, [r7, #12]
24012722:	2201      	movs	r2, #1
24012724:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012728:	68fb      	ldr	r3, [r7, #12]
2401272a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401272e:	b2db      	uxtb	r3, r3
24012730:	2b01      	cmp	r3, #1
24012732:	d14f      	bne.n	240127d4 <HAL_QSPI_AutoPolling+0xd8>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24012734:	68fb      	ldr	r3, [r7, #12]
24012736:	2200      	movs	r2, #0
24012738:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
2401273a:	68fb      	ldr	r3, [r7, #12]
2401273c:	2242      	movs	r2, #66	; 0x42
2401273e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
24012742:	683b      	ldr	r3, [r7, #0]
24012744:	9300      	str	r3, [sp, #0]
24012746:	693b      	ldr	r3, [r7, #16]
24012748:	2200      	movs	r2, #0
2401274a:	2120      	movs	r1, #32
2401274c:	68f8      	ldr	r0, [r7, #12]
2401274e:	f000 fb80 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24012752:	4603      	mov	r3, r0
24012754:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
24012756:	7dfb      	ldrb	r3, [r7, #23]
24012758:	2b00      	cmp	r3, #0
2401275a:	d13d      	bne.n	240127d8 <HAL_QSPI_AutoPolling+0xdc>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
2401275c:	68fb      	ldr	r3, [r7, #12]
2401275e:	681b      	ldr	r3, [r3, #0]
24012760:	687a      	ldr	r2, [r7, #4]
24012762:	6812      	ldr	r2, [r2, #0]
24012764:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
24012766:	68fb      	ldr	r3, [r7, #12]
24012768:	681b      	ldr	r3, [r3, #0]
2401276a:	687a      	ldr	r2, [r7, #4]
2401276c:	6852      	ldr	r2, [r2, #4]
2401276e:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24012770:	68fb      	ldr	r3, [r7, #12]
24012772:	681b      	ldr	r3, [r3, #0]
24012774:	687a      	ldr	r2, [r7, #4]
24012776:	6892      	ldr	r2, [r2, #8]
24012778:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop enabled
      (otherwise there will be an infinite loop in blocking mode) */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
2401277a:	68fb      	ldr	r3, [r7, #12]
2401277c:	681b      	ldr	r3, [r3, #0]
2401277e:	681b      	ldr	r3, [r3, #0]
24012780:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
24012784:	687b      	ldr	r3, [r7, #4]
24012786:	691b      	ldr	r3, [r3, #16]
24012788:	431a      	orrs	r2, r3
2401278a:	68fb      	ldr	r3, [r7, #12]
2401278c:	681b      	ldr	r3, [r3, #0]
2401278e:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
24012792:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | QSPI_AUTOMATIC_STOP_ENABLE));

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
24012794:	687b      	ldr	r3, [r7, #4]
24012796:	68da      	ldr	r2, [r3, #12]
24012798:	68bb      	ldr	r3, [r7, #8]
2401279a:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
2401279c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
240127a0:	68b9      	ldr	r1, [r7, #8]
240127a2:	68f8      	ldr	r0, [r7, #12]
240127a4:	f000 fb8c 	bl	24012ec0 <QSPI_Config>

      /* Wait until SM flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
240127a8:	683b      	ldr	r3, [r7, #0]
240127aa:	9300      	str	r3, [sp, #0]
240127ac:	693b      	ldr	r3, [r7, #16]
240127ae:	2201      	movs	r2, #1
240127b0:	2108      	movs	r1, #8
240127b2:	68f8      	ldr	r0, [r7, #12]
240127b4:	f000 fb4d 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
240127b8:	4603      	mov	r3, r0
240127ba:	75fb      	strb	r3, [r7, #23]

      if (status == HAL_OK)
240127bc:	7dfb      	ldrb	r3, [r7, #23]
240127be:	2b00      	cmp	r3, #0
240127c0:	d10a      	bne.n	240127d8 <HAL_QSPI_AutoPolling+0xdc>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
240127c2:	68fb      	ldr	r3, [r7, #12]
240127c4:	681b      	ldr	r3, [r3, #0]
240127c6:	2208      	movs	r2, #8
240127c8:	60da      	str	r2, [r3, #12]

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
240127ca:	68fb      	ldr	r3, [r7, #12]
240127cc:	2201      	movs	r2, #1
240127ce:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
240127d2:	e001      	b.n	240127d8 <HAL_QSPI_AutoPolling+0xdc>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
240127d4:	2302      	movs	r3, #2
240127d6:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
240127d8:	68fb      	ldr	r3, [r7, #12]
240127da:	2200      	movs	r2, #0
240127dc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
240127e0:	7dfb      	ldrb	r3, [r7, #23]
}
240127e2:	4618      	mov	r0, r3
240127e4:	3718      	adds	r7, #24
240127e6:	46bd      	mov	sp, r7
240127e8:	bd80      	pop	{r7, pc}

240127ea <HAL_QSPI_AutoPolling_IT>:
  * @param  cfg structure that contains the polling configuration information.
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg)
{
240127ea:	b580      	push	{r7, lr}
240127ec:	b088      	sub	sp, #32
240127ee:	af02      	add	r7, sp, #8
240127f0:	60f8      	str	r0, [r7, #12]
240127f2:	60b9      	str	r1, [r7, #8]
240127f4:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240127f6:	f7ef fc11 	bl	2400201c <HAL_GetTick>
240127fa:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
  assert_param(IS_QSPI_AUTOMATIC_STOP(cfg->AutomaticStop));

  /* Process locked */
  __HAL_LOCK(hqspi);
240127fc:	68fb      	ldr	r3, [r7, #12]
240127fe:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012802:	b2db      	uxtb	r3, r3
24012804:	2b01      	cmp	r3, #1
24012806:	d101      	bne.n	2401280c <HAL_QSPI_AutoPolling_IT+0x22>
24012808:	2302      	movs	r3, #2
2401280a:	e062      	b.n	240128d2 <HAL_QSPI_AutoPolling_IT+0xe8>
2401280c:	68fb      	ldr	r3, [r7, #12]
2401280e:	2201      	movs	r2, #1
24012810:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012814:	68fb      	ldr	r3, [r7, #12]
24012816:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401281a:	b2db      	uxtb	r3, r3
2401281c:	2b01      	cmp	r3, #1
2401281e:	d151      	bne.n	240128c4 <HAL_QSPI_AutoPolling_IT+0xda>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24012820:	68fb      	ldr	r3, [r7, #12]
24012822:	2200      	movs	r2, #0
24012824:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
24012826:	68fb      	ldr	r3, [r7, #12]
24012828:	2242      	movs	r2, #66	; 0x42
2401282a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2401282e:	68fb      	ldr	r3, [r7, #12]
24012830:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24012832:	9300      	str	r3, [sp, #0]
24012834:	693b      	ldr	r3, [r7, #16]
24012836:	2200      	movs	r2, #0
24012838:	2120      	movs	r1, #32
2401283a:	68f8      	ldr	r0, [r7, #12]
2401283c:	f000 fb09 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24012840:	4603      	mov	r3, r0
24012842:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
24012844:	7dfb      	ldrb	r3, [r7, #23]
24012846:	2b00      	cmp	r3, #0
24012848:	d137      	bne.n	240128ba <HAL_QSPI_AutoPolling_IT+0xd0>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
2401284a:	68fb      	ldr	r3, [r7, #12]
2401284c:	681b      	ldr	r3, [r3, #0]
2401284e:	687a      	ldr	r2, [r7, #4]
24012850:	6812      	ldr	r2, [r2, #0]
24012852:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
24012854:	68fb      	ldr	r3, [r7, #12]
24012856:	681b      	ldr	r3, [r3, #0]
24012858:	687a      	ldr	r2, [r7, #4]
2401285a:	6852      	ldr	r2, [r2, #4]
2401285c:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
2401285e:	68fb      	ldr	r3, [r7, #12]
24012860:	681b      	ldr	r3, [r3, #0]
24012862:	687a      	ldr	r2, [r7, #4]
24012864:	6892      	ldr	r2, [r2, #8]
24012866:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop mode */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24012868:	68fb      	ldr	r3, [r7, #12]
2401286a:	681b      	ldr	r3, [r3, #0]
2401286c:	681b      	ldr	r3, [r3, #0]
2401286e:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
24012872:	687b      	ldr	r3, [r7, #4]
24012874:	691a      	ldr	r2, [r3, #16]
24012876:	687b      	ldr	r3, [r7, #4]
24012878:	695b      	ldr	r3, [r3, #20]
2401287a:	431a      	orrs	r2, r3
2401287c:	68fb      	ldr	r3, [r7, #12]
2401287e:	681b      	ldr	r3, [r3, #0]
24012880:	430a      	orrs	r2, r1
24012882:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | cfg->AutomaticStop));

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
24012884:	68fb      	ldr	r3, [r7, #12]
24012886:	681b      	ldr	r3, [r3, #0]
24012888:	2209      	movs	r2, #9
2401288a:	60da      	str	r2, [r3, #12]

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
2401288c:	687b      	ldr	r3, [r7, #4]
2401288e:	68da      	ldr	r2, [r3, #12]
24012890:	68bb      	ldr	r3, [r7, #8]
24012892:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24012894:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
24012898:	68b9      	ldr	r1, [r7, #8]
2401289a:	68f8      	ldr	r0, [r7, #12]
2401289c:	f000 fb10 	bl	24012ec0 <QSPI_Config>

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240128a0:	68fb      	ldr	r3, [r7, #12]
240128a2:	2200      	movs	r2, #0
240128a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI Transfer Error and status match Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
240128a8:	68fb      	ldr	r3, [r7, #12]
240128aa:	681b      	ldr	r3, [r3, #0]
240128ac:	681a      	ldr	r2, [r3, #0]
240128ae:	68fb      	ldr	r3, [r7, #12]
240128b0:	681b      	ldr	r3, [r3, #0]
240128b2:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
240128b6:	601a      	str	r2, [r3, #0]
240128b8:	e00a      	b.n	240128d0 <HAL_QSPI_AutoPolling_IT+0xe6>

    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240128ba:	68fb      	ldr	r3, [r7, #12]
240128bc:	2200      	movs	r2, #0
240128be:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240128c2:	e005      	b.n	240128d0 <HAL_QSPI_AutoPolling_IT+0xe6>
    }
  }
  else
  {
    status = HAL_BUSY;
240128c4:	2302      	movs	r3, #2
240128c6:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
240128c8:	68fb      	ldr	r3, [r7, #12]
240128ca:	2200      	movs	r2, #0
240128cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
240128d0:	7dfb      	ldrb	r3, [r7, #23]
}
240128d2:	4618      	mov	r0, r3
240128d4:	3718      	adds	r7, #24
240128d6:	46bd      	mov	sp, r7
240128d8:	bd80      	pop	{r7, pc}

240128da <HAL_QSPI_MemoryMapped>:
  * @param  cfg structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg)
{
240128da:	b580      	push	{r7, lr}
240128dc:	b088      	sub	sp, #32
240128de:	af02      	add	r7, sp, #8
240128e0:	60f8      	str	r0, [r7, #12]
240128e2:	60b9      	str	r1, [r7, #8]
240128e4:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240128e6:	f7ef fb99 	bl	2400201c <HAL_GetTick>
240128ea:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  assert_param(IS_QSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Process locked */
  __HAL_LOCK(hqspi);
240128ec:	68fb      	ldr	r3, [r7, #12]
240128ee:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240128f2:	b2db      	uxtb	r3, r3
240128f4:	2b01      	cmp	r3, #1
240128f6:	d101      	bne.n	240128fc <HAL_QSPI_MemoryMapped+0x22>
240128f8:	2302      	movs	r3, #2
240128fa:	e04c      	b.n	24012996 <HAL_QSPI_MemoryMapped+0xbc>
240128fc:	68fb      	ldr	r3, [r7, #12]
240128fe:	2201      	movs	r2, #1
24012900:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012904:	68fb      	ldr	r3, [r7, #12]
24012906:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401290a:	b2db      	uxtb	r3, r3
2401290c:	2b01      	cmp	r3, #1
2401290e:	d13b      	bne.n	24012988 <HAL_QSPI_MemoryMapped+0xae>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24012910:	68fb      	ldr	r3, [r7, #12]
24012912:	2200      	movs	r2, #0
24012914:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
24012916:	68fb      	ldr	r3, [r7, #12]
24012918:	2282      	movs	r2, #130	; 0x82
2401291a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2401291e:	68fb      	ldr	r3, [r7, #12]
24012920:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24012922:	9300      	str	r3, [sp, #0]
24012924:	693b      	ldr	r3, [r7, #16]
24012926:	2200      	movs	r2, #0
24012928:	2120      	movs	r1, #32
2401292a:	68f8      	ldr	r0, [r7, #12]
2401292c:	f000 fa91 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24012930:	4603      	mov	r3, r0
24012932:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
24012934:	7dfb      	ldrb	r3, [r7, #23]
24012936:	2b00      	cmp	r3, #0
24012938:	d128      	bne.n	2401298c <HAL_QSPI_MemoryMapped+0xb2>
    {
      /* Configure QSPI: CR register with timeout counter enable */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
2401293a:	68fb      	ldr	r3, [r7, #12]
2401293c:	681b      	ldr	r3, [r3, #0]
2401293e:	681b      	ldr	r3, [r3, #0]
24012940:	f023 0108 	bic.w	r1, r3, #8
24012944:	687b      	ldr	r3, [r7, #4]
24012946:	685a      	ldr	r2, [r3, #4]
24012948:	68fb      	ldr	r3, [r7, #12]
2401294a:	681b      	ldr	r3, [r3, #0]
2401294c:	430a      	orrs	r2, r1
2401294e:	601a      	str	r2, [r3, #0]

    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
24012950:	687b      	ldr	r3, [r7, #4]
24012952:	685b      	ldr	r3, [r3, #4]
24012954:	2b08      	cmp	r3, #8
24012956:	d110      	bne.n	2401297a <HAL_QSPI_MemoryMapped+0xa0>
      {
        assert_param(IS_QSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));

        /* Configure QSPI: LPTR register with the low-power timeout value */
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
24012958:	68fb      	ldr	r3, [r7, #12]
2401295a:	681b      	ldr	r3, [r3, #0]
2401295c:	687a      	ldr	r2, [r7, #4]
2401295e:	6812      	ldr	r2, [r2, #0]
24012960:	631a      	str	r2, [r3, #48]	; 0x30

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
24012962:	68fb      	ldr	r3, [r7, #12]
24012964:	681b      	ldr	r3, [r3, #0]
24012966:	2210      	movs	r2, #16
24012968:	60da      	str	r2, [r3, #12]

        /* Enable the QSPI TimeOut Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
2401296a:	68fb      	ldr	r3, [r7, #12]
2401296c:	681b      	ldr	r3, [r3, #0]
2401296e:	681a      	ldr	r2, [r3, #0]
24012970:	68fb      	ldr	r3, [r7, #12]
24012972:	681b      	ldr	r3, [r3, #0]
24012974:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
24012978:	601a      	str	r2, [r3, #0]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
2401297a:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
2401297e:	68b9      	ldr	r1, [r7, #8]
24012980:	68f8      	ldr	r0, [r7, #12]
24012982:	f000 fa9d 	bl	24012ec0 <QSPI_Config>
24012986:	e001      	b.n	2401298c <HAL_QSPI_MemoryMapped+0xb2>
    }
  }
  else
  {
    status = HAL_BUSY;
24012988:	2302      	movs	r3, #2
2401298a:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2401298c:	68fb      	ldr	r3, [r7, #12]
2401298e:	2200      	movs	r2, #0
24012990:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24012994:	7dfb      	ldrb	r3, [r7, #23]
}
24012996:	4618      	mov	r0, r3
24012998:	3718      	adds	r7, #24
2401299a:	46bd      	mov	sp, r7
2401299c:	bd80      	pop	{r7, pc}

2401299e <HAL_QSPI_ErrorCallback>:
  * @brief  Transfer Error callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
{
2401299e:	b480      	push	{r7}
240129a0:	b083      	sub	sp, #12
240129a2:	af00      	add	r7, sp, #0
240129a4:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_ErrorCallback could be implemented in the user file
   */
}
240129a6:	bf00      	nop
240129a8:	370c      	adds	r7, #12
240129aa:	46bd      	mov	sp, r7
240129ac:	f85d 7b04 	ldr.w	r7, [sp], #4
240129b0:	4770      	bx	lr

240129b2 <HAL_QSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240129b2:	b480      	push	{r7}
240129b4:	b083      	sub	sp, #12
240129b6:	af00      	add	r7, sp, #0
240129b8:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_AbortCpltCallback could be implemented in the user file
   */
}
240129ba:	bf00      	nop
240129bc:	370c      	adds	r7, #12
240129be:	46bd      	mov	sp, r7
240129c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240129c4:	4770      	bx	lr

240129c6 <HAL_QSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240129c6:	b480      	push	{r7}
240129c8:	b083      	sub	sp, #12
240129ca:	af00      	add	r7, sp, #0
240129cc:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_CmdCpltCallback could be implemented in the user file
   */
}
240129ce:	bf00      	nop
240129d0:	370c      	adds	r7, #12
240129d2:	46bd      	mov	sp, r7
240129d4:	f85d 7b04 	ldr.w	r7, [sp], #4
240129d8:	4770      	bx	lr

240129da <HAL_QSPI_RxCpltCallback>:
  * @brief  Rx Transfer completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240129da:	b480      	push	{r7}
240129dc:	b083      	sub	sp, #12
240129de:	af00      	add	r7, sp, #0
240129e0:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_RxCpltCallback could be implemented in the user file
   */
}
240129e2:	bf00      	nop
240129e4:	370c      	adds	r7, #12
240129e6:	46bd      	mov	sp, r7
240129e8:	f85d 7b04 	ldr.w	r7, [sp], #4
240129ec:	4770      	bx	lr

240129ee <HAL_QSPI_TxCpltCallback>:
  * @brief  Tx Transfer completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240129ee:	b480      	push	{r7}
240129f0:	b083      	sub	sp, #12
240129f2:	af00      	add	r7, sp, #0
240129f4:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_TxCpltCallback could be implemented in the user file
   */
}
240129f6:	bf00      	nop
240129f8:	370c      	adds	r7, #12
240129fa:	46bd      	mov	sp, r7
240129fc:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a00:	4770      	bx	lr

24012a02 <HAL_QSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
{
24012a02:	b480      	push	{r7}
24012a04:	b083      	sub	sp, #12
24012a06:	af00      	add	r7, sp, #0
24012a08:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
24012a0a:	bf00      	nop
24012a0c:	370c      	adds	r7, #12
24012a0e:	46bd      	mov	sp, r7
24012a10:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a14:	4770      	bx	lr

24012a16 <HAL_QSPI_StatusMatchCallback>:
  * @brief  Status Match callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
{
24012a16:	b480      	push	{r7}
24012a18:	b083      	sub	sp, #12
24012a1a:	af00      	add	r7, sp, #0
24012a1c:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_StatusMatchCallback could be implemented in the user file
   */
}
24012a1e:	bf00      	nop
24012a20:	370c      	adds	r7, #12
24012a22:	46bd      	mov	sp, r7
24012a24:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a28:	4770      	bx	lr

24012a2a <HAL_QSPI_TimeOutCallback>:
  * @brief  Timeout callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
{
24012a2a:	b480      	push	{r7}
24012a2c:	b083      	sub	sp, #12
24012a2e:	af00      	add	r7, sp, #0
24012a30:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_TimeOutCallback could be implemented in the user file
   */
}
24012a32:	bf00      	nop
24012a34:	370c      	adds	r7, #12
24012a36:	46bd      	mov	sp, r7
24012a38:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a3c:	4770      	bx	lr

24012a3e <HAL_QSPI_GetState>:
  * @brief  Return the QSPI handle state.
  * @param  hqspi QSPI handle
  * @retval HAL state
  */
HAL_QSPI_StateTypeDef HAL_QSPI_GetState(QSPI_HandleTypeDef *hqspi)
{
24012a3e:	b480      	push	{r7}
24012a40:	b083      	sub	sp, #12
24012a42:	af00      	add	r7, sp, #0
24012a44:	6078      	str	r0, [r7, #4]
  /* Return QSPI handle state */
  return hqspi->State;
24012a46:	687b      	ldr	r3, [r7, #4]
24012a48:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012a4c:	b2db      	uxtb	r3, r3
}
24012a4e:	4618      	mov	r0, r3
24012a50:	370c      	adds	r7, #12
24012a52:	46bd      	mov	sp, r7
24012a54:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a58:	4770      	bx	lr

24012a5a <HAL_QSPI_GetError>:
* @brief  Return the QSPI error code.
* @param  hqspi QSPI handle
* @retval QSPI Error Code
*/
uint32_t HAL_QSPI_GetError(QSPI_HandleTypeDef *hqspi)
{
24012a5a:	b480      	push	{r7}
24012a5c:	b083      	sub	sp, #12
24012a5e:	af00      	add	r7, sp, #0
24012a60:	6078      	str	r0, [r7, #4]
  return hqspi->ErrorCode;
24012a62:	687b      	ldr	r3, [r7, #4]
24012a64:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
24012a66:	4618      	mov	r0, r3
24012a68:	370c      	adds	r7, #12
24012a6a:	46bd      	mov	sp, r7
24012a6c:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a70:	4770      	bx	lr

24012a72 <HAL_QSPI_Abort>:
* @brief  Abort the current transmission.
* @param  hqspi QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort(QSPI_HandleTypeDef *hqspi)
{
24012a72:	b580      	push	{r7, lr}
24012a74:	b086      	sub	sp, #24
24012a76:	af02      	add	r7, sp, #8
24012a78:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24012a7a:	2300      	movs	r3, #0
24012a7c:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
24012a7e:	f7ef facd 	bl	2400201c <HAL_GetTick>
24012a82:	60b8      	str	r0, [r7, #8]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
24012a84:	687b      	ldr	r3, [r7, #4]
24012a86:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012a8a:	b2db      	uxtb	r3, r3
24012a8c:	f003 0302 	and.w	r3, r3, #2
24012a90:	2b00      	cmp	r3, #0
24012a92:	d062      	beq.n	24012b5a <HAL_QSPI_Abort+0xe8>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24012a94:	687b      	ldr	r3, [r7, #4]
24012a96:	2200      	movs	r2, #0
24012a98:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24012a9c:	687b      	ldr	r3, [r7, #4]
24012a9e:	681b      	ldr	r3, [r3, #0]
24012aa0:	681b      	ldr	r3, [r3, #0]
24012aa2:	f003 0304 	and.w	r3, r3, #4
24012aa6:	2b00      	cmp	r3, #0
24012aa8:	d017      	beq.n	24012ada <HAL_QSPI_Abort+0x68>
    {
      /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
         but no impact on H7 HW and it minimize the cost in the footprint */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24012aaa:	687b      	ldr	r3, [r7, #4]
24012aac:	681b      	ldr	r3, [r3, #0]
24012aae:	681a      	ldr	r2, [r3, #0]
24012ab0:	687b      	ldr	r3, [r7, #4]
24012ab2:	681b      	ldr	r3, [r3, #0]
24012ab4:	f022 0204 	bic.w	r2, r2, #4
24012ab8:	601a      	str	r2, [r3, #0]

      /* Abort MDMA */
      status = HAL_MDMA_Abort(hqspi->hmdma);
24012aba:	687b      	ldr	r3, [r7, #4]
24012abc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012abe:	4618      	mov	r0, r3
24012ac0:	f7fd fc16 	bl	240102f0 <HAL_MDMA_Abort>
24012ac4:	4603      	mov	r3, r0
24012ac6:	73fb      	strb	r3, [r7, #15]
      if(status != HAL_OK)
24012ac8:	7bfb      	ldrb	r3, [r7, #15]
24012aca:	2b00      	cmp	r3, #0
24012acc:	d005      	beq.n	24012ada <HAL_QSPI_Abort+0x68>
      {
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24012ace:	687b      	ldr	r3, [r7, #4]
24012ad0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012ad2:	f043 0204 	orr.w	r2, r3, #4
24012ad6:	687b      	ldr	r3, [r7, #4]
24012ad8:	645a      	str	r2, [r3, #68]	; 0x44
      }
    }

    if (__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_BUSY) != RESET)
24012ada:	687b      	ldr	r3, [r7, #4]
24012adc:	681b      	ldr	r3, [r3, #0]
24012ade:	689b      	ldr	r3, [r3, #8]
24012ae0:	f003 0320 	and.w	r3, r3, #32
24012ae4:	2b00      	cmp	r3, #0
24012ae6:	d034      	beq.n	24012b52 <HAL_QSPI_Abort+0xe0>
    {
      /* Configure QSPI: CR register with Abort request */
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
24012ae8:	687b      	ldr	r3, [r7, #4]
24012aea:	681b      	ldr	r3, [r3, #0]
24012aec:	681a      	ldr	r2, [r3, #0]
24012aee:	687b      	ldr	r3, [r7, #4]
24012af0:	681b      	ldr	r3, [r3, #0]
24012af2:	f042 0202 	orr.w	r2, r2, #2
24012af6:	601a      	str	r2, [r3, #0]
      
      /* Wait until TC flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
24012af8:	687b      	ldr	r3, [r7, #4]
24012afa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24012afc:	9300      	str	r3, [sp, #0]
24012afe:	68bb      	ldr	r3, [r7, #8]
24012b00:	2201      	movs	r2, #1
24012b02:	2102      	movs	r1, #2
24012b04:	6878      	ldr	r0, [r7, #4]
24012b06:	f000 f9a4 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24012b0a:	4603      	mov	r3, r0
24012b0c:	73fb      	strb	r3, [r7, #15]
      
      if (status == HAL_OK)
24012b0e:	7bfb      	ldrb	r3, [r7, #15]
24012b10:	2b00      	cmp	r3, #0
24012b12:	d10e      	bne.n	24012b32 <HAL_QSPI_Abort+0xc0>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24012b14:	687b      	ldr	r3, [r7, #4]
24012b16:	681b      	ldr	r3, [r3, #0]
24012b18:	2202      	movs	r2, #2
24012b1a:	60da      	str	r2, [r3, #12]
        
        /* Wait until BUSY flag is reset */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24012b1c:	687b      	ldr	r3, [r7, #4]
24012b1e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24012b20:	9300      	str	r3, [sp, #0]
24012b22:	68bb      	ldr	r3, [r7, #8]
24012b24:	2200      	movs	r2, #0
24012b26:	2120      	movs	r1, #32
24012b28:	6878      	ldr	r0, [r7, #4]
24012b2a:	f000 f992 	bl	24012e52 <QSPI_WaitFlagStateUntilTimeout>
24012b2e:	4603      	mov	r3, r0
24012b30:	73fb      	strb	r3, [r7, #15]
      }

      if (status == HAL_OK)
24012b32:	7bfb      	ldrb	r3, [r7, #15]
24012b34:	2b00      	cmp	r3, #0
24012b36:	d110      	bne.n	24012b5a <HAL_QSPI_Abort+0xe8>
      {
        /* Reset functional mode configuration to indirect write mode by default */
        CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
24012b38:	687b      	ldr	r3, [r7, #4]
24012b3a:	681b      	ldr	r3, [r3, #0]
24012b3c:	695a      	ldr	r2, [r3, #20]
24012b3e:	687b      	ldr	r3, [r7, #4]
24012b40:	681b      	ldr	r3, [r3, #0]
24012b42:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24012b46:	615a      	str	r2, [r3, #20]
        
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
24012b48:	687b      	ldr	r3, [r7, #4]
24012b4a:	2201      	movs	r2, #1
24012b4c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24012b50:	e003      	b.n	24012b5a <HAL_QSPI_Abort+0xe8>
      }
    }
    else
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_READY;
24012b52:	687b      	ldr	r3, [r7, #4]
24012b54:	2201      	movs	r2, #1
24012b56:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
  }

  return status;
24012b5a:	7bfb      	ldrb	r3, [r7, #15]
}
24012b5c:	4618      	mov	r0, r3
24012b5e:	3710      	adds	r7, #16
24012b60:	46bd      	mov	sp, r7
24012b62:	bd80      	pop	{r7, pc}

24012b64 <HAL_QSPI_Abort_IT>:
* @brief  Abort the current transmission (non-blocking function)
* @param  hqspi QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort_IT(QSPI_HandleTypeDef *hqspi)
{
24012b64:	b580      	push	{r7, lr}
24012b66:	b084      	sub	sp, #16
24012b68:	af00      	add	r7, sp, #0
24012b6a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24012b6c:	2300      	movs	r3, #0
24012b6e:	73fb      	strb	r3, [r7, #15]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
24012b70:	687b      	ldr	r3, [r7, #4]
24012b72:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012b76:	b2db      	uxtb	r3, r3
24012b78:	f003 0302 	and.w	r3, r3, #2
24012b7c:	2b00      	cmp	r3, #0
24012b7e:	d052      	beq.n	24012c26 <HAL_QSPI_Abort_IT+0xc2>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24012b80:	687b      	ldr	r3, [r7, #4]
24012b82:	2200      	movs	r2, #0
24012b84:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_ABORT;
24012b88:	687b      	ldr	r3, [r7, #4]
24012b8a:	2208      	movs	r2, #8
24012b8c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable all interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
24012b90:	687b      	ldr	r3, [r7, #4]
24012b92:	681b      	ldr	r3, [r3, #0]
24012b94:	681a      	ldr	r2, [r3, #0]
24012b96:	687b      	ldr	r3, [r7, #4]
24012b98:	681b      	ldr	r3, [r3, #0]
24012b9a:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
24012b9e:	601a      	str	r2, [r3, #0]

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24012ba0:	687b      	ldr	r3, [r7, #4]
24012ba2:	681b      	ldr	r3, [r3, #0]
24012ba4:	681b      	ldr	r3, [r3, #0]
24012ba6:	f003 0304 	and.w	r3, r3, #4
24012baa:	2b00      	cmp	r3, #0
24012bac:	d01b      	beq.n	24012be6 <HAL_QSPI_Abort_IT+0x82>
    {
      /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
         but no impact on H7 HW and it minimize the cost in the footprint */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24012bae:	687b      	ldr	r3, [r7, #4]
24012bb0:	681b      	ldr	r3, [r3, #0]
24012bb2:	681a      	ldr	r2, [r3, #0]
24012bb4:	687b      	ldr	r3, [r7, #4]
24012bb6:	681b      	ldr	r3, [r3, #0]
24012bb8:	f022 0204 	bic.w	r2, r2, #4
24012bbc:	601a      	str	r2, [r3, #0]

      /* Abort MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
24012bbe:	687b      	ldr	r3, [r7, #4]
24012bc0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012bc2:	4a1b      	ldr	r2, [pc, #108]	; (24012c30 <HAL_QSPI_Abort_IT+0xcc>)
24012bc4:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
24012bc6:	687b      	ldr	r3, [r7, #4]
24012bc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012bca:	4618      	mov	r0, r3
24012bcc:	f7fd fbeb 	bl	240103a6 <HAL_MDMA_Abort_IT>
24012bd0:	4603      	mov	r3, r0
24012bd2:	2b00      	cmp	r3, #0
24012bd4:	d027      	beq.n	24012c26 <HAL_QSPI_Abort_IT+0xc2>
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
24012bd6:	687b      	ldr	r3, [r7, #4]
24012bd8:	2201      	movs	r2, #1
24012bda:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
24012bde:	6878      	ldr	r0, [r7, #4]
24012be0:	f7ff fee7 	bl	240129b2 <HAL_QSPI_AbortCpltCallback>
24012be4:	e01f      	b.n	24012c26 <HAL_QSPI_Abort_IT+0xc2>
#endif
      }
    }
    else
    {
      if (__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_BUSY) != RESET)
24012be6:	687b      	ldr	r3, [r7, #4]
24012be8:	681b      	ldr	r3, [r3, #0]
24012bea:	689b      	ldr	r3, [r3, #8]
24012bec:	f003 0320 	and.w	r3, r3, #32
24012bf0:	2b00      	cmp	r3, #0
24012bf2:	d014      	beq.n	24012c1e <HAL_QSPI_Abort_IT+0xba>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24012bf4:	687b      	ldr	r3, [r7, #4]
24012bf6:	681b      	ldr	r3, [r3, #0]
24012bf8:	2202      	movs	r2, #2
24012bfa:	60da      	str	r2, [r3, #12]
        
        /* Enable the QSPI Transfer Complete Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24012bfc:	687b      	ldr	r3, [r7, #4]
24012bfe:	681b      	ldr	r3, [r3, #0]
24012c00:	681a      	ldr	r2, [r3, #0]
24012c02:	687b      	ldr	r3, [r7, #4]
24012c04:	681b      	ldr	r3, [r3, #0]
24012c06:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24012c0a:	601a      	str	r2, [r3, #0]
        
        /* Configure QSPI: CR register with Abort request */
        SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
24012c0c:	687b      	ldr	r3, [r7, #4]
24012c0e:	681b      	ldr	r3, [r3, #0]
24012c10:	681a      	ldr	r2, [r3, #0]
24012c12:	687b      	ldr	r3, [r7, #4]
24012c14:	681b      	ldr	r3, [r3, #0]
24012c16:	f042 0202 	orr.w	r2, r2, #2
24012c1a:	601a      	str	r2, [r3, #0]
24012c1c:	e003      	b.n	24012c26 <HAL_QSPI_Abort_IT+0xc2>
      }    
      else
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
24012c1e:	687b      	ldr	r3, [r7, #4]
24012c20:	2201      	movs	r2, #1
24012c22:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      }
    }
  }
  return status;
24012c26:	7bfb      	ldrb	r3, [r7, #15]
}
24012c28:	4618      	mov	r0, r3
24012c2a:	3710      	adds	r7, #16
24012c2c:	46bd      	mov	sp, r7
24012c2e:	bd80      	pop	{r7, pc}
24012c30:	24012ded 	.word	0x24012ded

24012c34 <HAL_QSPI_SetTimeout>:
  * @param  hqspi QSPI handle.
  * @param  Timeout Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
24012c34:	b480      	push	{r7}
24012c36:	b083      	sub	sp, #12
24012c38:	af00      	add	r7, sp, #0
24012c3a:	6078      	str	r0, [r7, #4]
24012c3c:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
24012c3e:	687b      	ldr	r3, [r7, #4]
24012c40:	683a      	ldr	r2, [r7, #0]
24012c42:	649a      	str	r2, [r3, #72]	; 0x48
}
24012c44:	bf00      	nop
24012c46:	370c      	adds	r7, #12
24012c48:	46bd      	mov	sp, r7
24012c4a:	f85d 7b04 	ldr.w	r7, [sp], #4
24012c4e:	4770      	bx	lr

24012c50 <HAL_QSPI_SetFifoThreshold>:
  * @param  hqspi QSPI handle.
  * @param  Threshold Threshold of the Fifo (value between 1 and 16).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold)
{
24012c50:	b480      	push	{r7}
24012c52:	b085      	sub	sp, #20
24012c54:	af00      	add	r7, sp, #0
24012c56:	6078      	str	r0, [r7, #4]
24012c58:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24012c5a:	2300      	movs	r3, #0
24012c5c:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
24012c5e:	687b      	ldr	r3, [r7, #4]
24012c60:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012c64:	b2db      	uxtb	r3, r3
24012c66:	2b01      	cmp	r3, #1
24012c68:	d101      	bne.n	24012c6e <HAL_QSPI_SetFifoThreshold+0x1e>
24012c6a:	2302      	movs	r3, #2
24012c6c:	e021      	b.n	24012cb2 <HAL_QSPI_SetFifoThreshold+0x62>
24012c6e:	687b      	ldr	r3, [r7, #4]
24012c70:	2201      	movs	r2, #1
24012c72:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012c76:	687b      	ldr	r3, [r7, #4]
24012c78:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012c7c:	b2db      	uxtb	r3, r3
24012c7e:	2b01      	cmp	r3, #1
24012c80:	d110      	bne.n	24012ca4 <HAL_QSPI_SetFifoThreshold+0x54>
  {
    /* Synchronize init structure with new FIFO threshold value */
    hqspi->Init.FifoThreshold = Threshold;
24012c82:	687b      	ldr	r3, [r7, #4]
24012c84:	683a      	ldr	r2, [r7, #0]
24012c86:	609a      	str	r2, [r3, #8]

    /* Configure QSPI FIFO Threshold */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
24012c88:	687b      	ldr	r3, [r7, #4]
24012c8a:	681b      	ldr	r3, [r3, #0]
24012c8c:	681b      	ldr	r3, [r3, #0]
24012c8e:	f423 51f8 	bic.w	r1, r3, #7936	; 0x1f00
24012c92:	687b      	ldr	r3, [r7, #4]
24012c94:	689b      	ldr	r3, [r3, #8]
24012c96:	3b01      	subs	r3, #1
24012c98:	021a      	lsls	r2, r3, #8
24012c9a:	687b      	ldr	r3, [r7, #4]
24012c9c:	681b      	ldr	r3, [r3, #0]
24012c9e:	430a      	orrs	r2, r1
24012ca0:	601a      	str	r2, [r3, #0]
24012ca2:	e001      	b.n	24012ca8 <HAL_QSPI_SetFifoThreshold+0x58>
               ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));
  }
  else
  {
    status = HAL_BUSY;
24012ca4:	2302      	movs	r3, #2
24012ca6:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24012ca8:	687b      	ldr	r3, [r7, #4]
24012caa:	2200      	movs	r2, #0
24012cac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24012cb0:	7bfb      	ldrb	r3, [r7, #15]
}
24012cb2:	4618      	mov	r0, r3
24012cb4:	3714      	adds	r7, #20
24012cb6:	46bd      	mov	sp, r7
24012cb8:	f85d 7b04 	ldr.w	r7, [sp], #4
24012cbc:	4770      	bx	lr

24012cbe <HAL_QSPI_GetFifoThreshold>:
/** @brief Get QSPI Fifo threshold.
  * @param  hqspi QSPI handle.
  * @retval Fifo threshold (value between 1 and 16)
  */
uint32_t HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi)
{
24012cbe:	b480      	push	{r7}
24012cc0:	b083      	sub	sp, #12
24012cc2:	af00      	add	r7, sp, #0
24012cc4:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> QUADSPI_CR_FTHRES_Pos) + 1U);
24012cc6:	687b      	ldr	r3, [r7, #4]
24012cc8:	681b      	ldr	r3, [r3, #0]
24012cca:	681b      	ldr	r3, [r3, #0]
24012ccc:	0a1b      	lsrs	r3, r3, #8
24012cce:	f003 031f 	and.w	r3, r3, #31
24012cd2:	3301      	adds	r3, #1
}
24012cd4:	4618      	mov	r0, r3
24012cd6:	370c      	adds	r7, #12
24012cd8:	46bd      	mov	sp, r7
24012cda:	f85d 7b04 	ldr.w	r7, [sp], #4
24012cde:	4770      	bx	lr

24012ce0 <HAL_QSPI_SetFlashID>:
  *                   This parameter can be a value of @ref QSPI_Flash_Select.
  * @note   The FlashID is ignored when dual flash mode is enabled.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFlashID(QSPI_HandleTypeDef *hqspi, uint32_t FlashID)
{
24012ce0:	b480      	push	{r7}
24012ce2:	b085      	sub	sp, #20
24012ce4:	af00      	add	r7, sp, #0
24012ce6:	6078      	str	r0, [r7, #4]
24012ce8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24012cea:	2300      	movs	r3, #0
24012cec:	73fb      	strb	r3, [r7, #15]

  /* Check the parameter */
  assert_param(IS_QSPI_FLASH_ID(FlashID));

  /* Process locked */
  __HAL_LOCK(hqspi);
24012cee:	687b      	ldr	r3, [r7, #4]
24012cf0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012cf4:	b2db      	uxtb	r3, r3
24012cf6:	2b01      	cmp	r3, #1
24012cf8:	d101      	bne.n	24012cfe <HAL_QSPI_SetFlashID+0x1e>
24012cfa:	2302      	movs	r3, #2
24012cfc:	e01e      	b.n	24012d3c <HAL_QSPI_SetFlashID+0x5c>
24012cfe:	687b      	ldr	r3, [r7, #4]
24012d00:	2201      	movs	r2, #1
24012d02:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24012d06:	687b      	ldr	r3, [r7, #4]
24012d08:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012d0c:	b2db      	uxtb	r3, r3
24012d0e:	2b01      	cmp	r3, #1
24012d10:	d10d      	bne.n	24012d2e <HAL_QSPI_SetFlashID+0x4e>
  {
    /* Synchronize init structure with new FlashID value */
    hqspi->Init.FlashID = FlashID;
24012d12:	687b      	ldr	r3, [r7, #4]
24012d14:	683a      	ldr	r2, [r7, #0]
24012d16:	61da      	str	r2, [r3, #28]

    /* Configure QSPI FlashID */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FSEL, FlashID);
24012d18:	687b      	ldr	r3, [r7, #4]
24012d1a:	681b      	ldr	r3, [r3, #0]
24012d1c:	681b      	ldr	r3, [r3, #0]
24012d1e:	f023 0180 	bic.w	r1, r3, #128	; 0x80
24012d22:	687b      	ldr	r3, [r7, #4]
24012d24:	681b      	ldr	r3, [r3, #0]
24012d26:	683a      	ldr	r2, [r7, #0]
24012d28:	430a      	orrs	r2, r1
24012d2a:	601a      	str	r2, [r3, #0]
24012d2c:	e001      	b.n	24012d32 <HAL_QSPI_SetFlashID+0x52>
  }
  else
  {
    status = HAL_BUSY;
24012d2e:	2302      	movs	r3, #2
24012d30:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24012d32:	687b      	ldr	r3, [r7, #4]
24012d34:	2200      	movs	r2, #0
24012d36:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24012d3a:	7bfb      	ldrb	r3, [r7, #15]
}
24012d3c:	4618      	mov	r0, r3
24012d3e:	3714      	adds	r7, #20
24012d40:	46bd      	mov	sp, r7
24012d42:	f85d 7b04 	ldr.w	r7, [sp], #4
24012d46:	4770      	bx	lr

24012d48 <QSPI_DMARxCplt>:
  * @brief  DMA QSPI receive process complete callback.
  * @param  hmdma MDMA handle
  * @retval None
  */
static void QSPI_DMARxCplt(MDMA_HandleTypeDef *hmdma)
{
24012d48:	b480      	push	{r7}
24012d4a:	b085      	sub	sp, #20
24012d4c:	af00      	add	r7, sp, #0
24012d4e:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
24012d50:	687b      	ldr	r3, [r7, #4]
24012d52:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012d54:	60fb      	str	r3, [r7, #12]
  hqspi->RxXferCount = 0U;
24012d56:	68fb      	ldr	r3, [r7, #12]
24012d58:	2200      	movs	r2, #0
24012d5a:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24012d5c:	68fb      	ldr	r3, [r7, #12]
24012d5e:	681b      	ldr	r3, [r3, #0]
24012d60:	681a      	ldr	r2, [r3, #0]
24012d62:	68fb      	ldr	r3, [r7, #12]
24012d64:	681b      	ldr	r3, [r3, #0]
24012d66:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24012d6a:	601a      	str	r2, [r3, #0]
}
24012d6c:	bf00      	nop
24012d6e:	3714      	adds	r7, #20
24012d70:	46bd      	mov	sp, r7
24012d72:	f85d 7b04 	ldr.w	r7, [sp], #4
24012d76:	4770      	bx	lr

24012d78 <QSPI_DMATxCplt>:
  * @brief  DMA QSPI transmit process complete callback.
  * @param  hmdma MDMA handle
  * @retval None
  */
static void QSPI_DMATxCplt(MDMA_HandleTypeDef *hmdma)
{
24012d78:	b480      	push	{r7}
24012d7a:	b085      	sub	sp, #20
24012d7c:	af00      	add	r7, sp, #0
24012d7e:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
24012d80:	687b      	ldr	r3, [r7, #4]
24012d82:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012d84:	60fb      	str	r3, [r7, #12]
  hqspi->TxXferCount = 0U;
24012d86:	68fb      	ldr	r3, [r7, #12]
24012d88:	2200      	movs	r2, #0
24012d8a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24012d8c:	68fb      	ldr	r3, [r7, #12]
24012d8e:	681b      	ldr	r3, [r3, #0]
24012d90:	681a      	ldr	r2, [r3, #0]
24012d92:	68fb      	ldr	r3, [r7, #12]
24012d94:	681b      	ldr	r3, [r3, #0]
24012d96:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24012d9a:	601a      	str	r2, [r3, #0]
}
24012d9c:	bf00      	nop
24012d9e:	3714      	adds	r7, #20
24012da0:	46bd      	mov	sp, r7
24012da2:	f85d 7b04 	ldr.w	r7, [sp], #4
24012da6:	4770      	bx	lr

24012da8 <QSPI_DMAError>:
  * @brief  DMA QSPI communication error callback.
  * @param  hmdma MDMA handle
  * @retval None
  */
static void QSPI_DMAError(MDMA_HandleTypeDef *hmdma)
{
24012da8:	b580      	push	{r7, lr}
24012daa:	b084      	sub	sp, #16
24012dac:	af00      	add	r7, sp, #0
24012dae:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24012db0:	687b      	ldr	r3, [r7, #4]
24012db2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012db4:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
24012db6:	68fb      	ldr	r3, [r7, #12]
24012db8:	2200      	movs	r2, #0
24012dba:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
24012dbc:	68fb      	ldr	r3, [r7, #12]
24012dbe:	2200      	movs	r2, #0
24012dc0:	62da      	str	r2, [r3, #44]	; 0x2c
  hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
24012dc2:	68fb      	ldr	r3, [r7, #12]
24012dc4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012dc6:	f043 0204 	orr.w	r2, r3, #4
24012dca:	68fb      	ldr	r3, [r7, #12]
24012dcc:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
     but no impact on H7 HW and it minimize the cost in the footprint */
  CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24012dce:	68fb      	ldr	r3, [r7, #12]
24012dd0:	681b      	ldr	r3, [r3, #0]
24012dd2:	681a      	ldr	r2, [r3, #0]
24012dd4:	68fb      	ldr	r3, [r7, #12]
24012dd6:	681b      	ldr	r3, [r3, #0]
24012dd8:	f022 0204 	bic.w	r2, r2, #4
24012ddc:	601a      	str	r2, [r3, #0]

  /* Abort the QSPI */
  (void)HAL_QSPI_Abort_IT(hqspi);
24012dde:	68f8      	ldr	r0, [r7, #12]
24012de0:	f7ff fec0 	bl	24012b64 <HAL_QSPI_Abort_IT>

}
24012de4:	bf00      	nop
24012de6:	3710      	adds	r7, #16
24012de8:	46bd      	mov	sp, r7
24012dea:	bd80      	pop	{r7, pc}

24012dec <QSPI_DMAAbortCplt>:
  * @brief  MDMA QSPI abort complete callback.
  * @param  hmdma MDMA handle
  * @retval None
  */
static void QSPI_DMAAbortCplt(MDMA_HandleTypeDef *hmdma)
{
24012dec:	b580      	push	{r7, lr}
24012dee:	b084      	sub	sp, #16
24012df0:	af00      	add	r7, sp, #0
24012df2:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24012df4:	687b      	ldr	r3, [r7, #4]
24012df6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012df8:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
24012dfa:	68fb      	ldr	r3, [r7, #12]
24012dfc:	2200      	movs	r2, #0
24012dfe:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
24012e00:	68fb      	ldr	r3, [r7, #12]
24012e02:	2200      	movs	r2, #0
24012e04:	62da      	str	r2, [r3, #44]	; 0x2c

  if(hqspi->State == HAL_QSPI_STATE_ABORT)
24012e06:	68fb      	ldr	r3, [r7, #12]
24012e08:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012e0c:	b2db      	uxtb	r3, r3
24012e0e:	2b08      	cmp	r3, #8
24012e10:	d114      	bne.n	24012e3c <QSPI_DMAAbortCplt+0x50>
  {
    /* MDMA Abort called by QSPI abort */
    /* Clear interrupt */
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24012e12:	68fb      	ldr	r3, [r7, #12]
24012e14:	681b      	ldr	r3, [r3, #0]
24012e16:	2202      	movs	r2, #2
24012e18:	60da      	str	r2, [r3, #12]

    /* Enable the QSPI Transfer Complete Interrupt */
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24012e1a:	68fb      	ldr	r3, [r7, #12]
24012e1c:	681b      	ldr	r3, [r3, #0]
24012e1e:	681a      	ldr	r2, [r3, #0]
24012e20:	68fb      	ldr	r3, [r7, #12]
24012e22:	681b      	ldr	r3, [r3, #0]
24012e24:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24012e28:	601a      	str	r2, [r3, #0]

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
24012e2a:	68fb      	ldr	r3, [r7, #12]
24012e2c:	681b      	ldr	r3, [r3, #0]
24012e2e:	681a      	ldr	r2, [r3, #0]
24012e30:	68fb      	ldr	r3, [r7, #12]
24012e32:	681b      	ldr	r3, [r3, #0]
24012e34:	f042 0202 	orr.w	r2, r2, #2
24012e38:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCallback(hqspi);
#else
    HAL_QSPI_ErrorCallback(hqspi);
#endif
  }
}
24012e3a:	e006      	b.n	24012e4a <QSPI_DMAAbortCplt+0x5e>
    hqspi->State = HAL_QSPI_STATE_READY;
24012e3c:	68fb      	ldr	r3, [r7, #12]
24012e3e:	2201      	movs	r2, #1
24012e40:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    HAL_QSPI_ErrorCallback(hqspi);
24012e44:	68f8      	ldr	r0, [r7, #12]
24012e46:	f7ff fdaa 	bl	2401299e <HAL_QSPI_ErrorCallback>
}
24012e4a:	bf00      	nop
24012e4c:	3710      	adds	r7, #16
24012e4e:	46bd      	mov	sp, r7
24012e50:	bd80      	pop	{r7, pc}

24012e52 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
24012e52:	b580      	push	{r7, lr}
24012e54:	b084      	sub	sp, #16
24012e56:	af00      	add	r7, sp, #0
24012e58:	60f8      	str	r0, [r7, #12]
24012e5a:	60b9      	str	r1, [r7, #8]
24012e5c:	603b      	str	r3, [r7, #0]
24012e5e:	4613      	mov	r3, r2
24012e60:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
24012e62:	e01a      	b.n	24012e9a <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
24012e64:	69bb      	ldr	r3, [r7, #24]
24012e66:	f1b3 3fff 	cmp.w	r3, #4294967295
24012e6a:	d016      	beq.n	24012e9a <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
24012e6c:	f7ef f8d6 	bl	2400201c <HAL_GetTick>
24012e70:	4602      	mov	r2, r0
24012e72:	683b      	ldr	r3, [r7, #0]
24012e74:	1ad3      	subs	r3, r2, r3
24012e76:	69ba      	ldr	r2, [r7, #24]
24012e78:	429a      	cmp	r2, r3
24012e7a:	d302      	bcc.n	24012e82 <QSPI_WaitFlagStateUntilTimeout+0x30>
24012e7c:	69bb      	ldr	r3, [r7, #24]
24012e7e:	2b00      	cmp	r3, #0
24012e80:	d10b      	bne.n	24012e9a <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
24012e82:	68fb      	ldr	r3, [r7, #12]
24012e84:	2204      	movs	r2, #4
24012e86:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
24012e8a:	68fb      	ldr	r3, [r7, #12]
24012e8c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012e8e:	f043 0201 	orr.w	r2, r3, #1
24012e92:	68fb      	ldr	r3, [r7, #12]
24012e94:	645a      	str	r2, [r3, #68]	; 0x44

        return HAL_ERROR;
24012e96:	2301      	movs	r3, #1
24012e98:	e00e      	b.n	24012eb8 <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
24012e9a:	68fb      	ldr	r3, [r7, #12]
24012e9c:	681b      	ldr	r3, [r3, #0]
24012e9e:	689a      	ldr	r2, [r3, #8]
24012ea0:	68bb      	ldr	r3, [r7, #8]
24012ea2:	4013      	ands	r3, r2
24012ea4:	2b00      	cmp	r3, #0
24012ea6:	bf14      	ite	ne
24012ea8:	2301      	movne	r3, #1
24012eaa:	2300      	moveq	r3, #0
24012eac:	b2db      	uxtb	r3, r3
24012eae:	461a      	mov	r2, r3
24012eb0:	79fb      	ldrb	r3, [r7, #7]
24012eb2:	429a      	cmp	r2, r3
24012eb4:	d1d6      	bne.n	24012e64 <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
24012eb6:	2300      	movs	r3, #0
}
24012eb8:	4618      	mov	r0, r3
24012eba:	3710      	adds	r7, #16
24012ebc:	46bd      	mov	sp, r7
24012ebe:	bd80      	pop	{r7, pc}

24012ec0 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
24012ec0:	b480      	push	{r7}
24012ec2:	b085      	sub	sp, #20
24012ec4:	af00      	add	r7, sp, #0
24012ec6:	60f8      	str	r0, [r7, #12]
24012ec8:	60b9      	str	r1, [r7, #8]
24012eca:	607a      	str	r2, [r7, #4]
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
24012ecc:	68bb      	ldr	r3, [r7, #8]
24012ece:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012ed0:	2b00      	cmp	r3, #0
24012ed2:	d009      	beq.n	24012ee8 <QSPI_Config+0x28>
24012ed4:	687b      	ldr	r3, [r7, #4]
24012ed6:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24012eda:	d005      	beq.n	24012ee8 <QSPI_Config+0x28>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
24012edc:	68bb      	ldr	r3, [r7, #8]
24012ede:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24012ee0:	68fb      	ldr	r3, [r7, #12]
24012ee2:	681b      	ldr	r3, [r3, #0]
24012ee4:	3a01      	subs	r2, #1
24012ee6:	611a      	str	r2, [r3, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
24012ee8:	68bb      	ldr	r3, [r7, #8]
24012eea:	699b      	ldr	r3, [r3, #24]
24012eec:	2b00      	cmp	r3, #0
24012eee:	f000 80b9 	beq.w	24013064 <QSPI_Config+0x1a4>
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
24012ef2:	68bb      	ldr	r3, [r7, #8]
24012ef4:	6a1b      	ldr	r3, [r3, #32]
24012ef6:	2b00      	cmp	r3, #0
24012ef8:	d05f      	beq.n	24012fba <QSPI_Config+0xfa>
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24012efa:	68fb      	ldr	r3, [r7, #12]
24012efc:	681b      	ldr	r3, [r3, #0]
24012efe:	68ba      	ldr	r2, [r7, #8]
24012f00:	6892      	ldr	r2, [r2, #8]
24012f02:	61da      	str	r2, [r3, #28]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24012f04:	68bb      	ldr	r3, [r7, #8]
24012f06:	69db      	ldr	r3, [r3, #28]
24012f08:	2b00      	cmp	r3, #0
24012f0a:	d031      	beq.n	24012f70 <QSPI_Config+0xb0>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012f0c:	68bb      	ldr	r3, [r7, #8]
24012f0e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012f10:	68bb      	ldr	r3, [r7, #8]
24012f12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012f14:	431a      	orrs	r2, r3
24012f16:	68bb      	ldr	r3, [r7, #8]
24012f18:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012f1a:	431a      	orrs	r2, r3
24012f1c:	68bb      	ldr	r3, [r7, #8]
24012f1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012f20:	431a      	orrs	r2, r3
24012f22:	68bb      	ldr	r3, [r7, #8]
24012f24:	695b      	ldr	r3, [r3, #20]
24012f26:	049b      	lsls	r3, r3, #18
24012f28:	431a      	orrs	r2, r3
24012f2a:	68bb      	ldr	r3, [r7, #8]
24012f2c:	691b      	ldr	r3, [r3, #16]
24012f2e:	431a      	orrs	r2, r3
24012f30:	68bb      	ldr	r3, [r7, #8]
24012f32:	6a1b      	ldr	r3, [r3, #32]
24012f34:	431a      	orrs	r2, r3
24012f36:	68bb      	ldr	r3, [r7, #8]
24012f38:	68db      	ldr	r3, [r3, #12]
24012f3a:	431a      	orrs	r2, r3
24012f3c:	68bb      	ldr	r3, [r7, #8]
24012f3e:	69db      	ldr	r3, [r3, #28]
24012f40:	431a      	orrs	r2, r3
24012f42:	68bb      	ldr	r3, [r7, #8]
24012f44:	699b      	ldr	r3, [r3, #24]
24012f46:	431a      	orrs	r2, r3
24012f48:	68bb      	ldr	r3, [r7, #8]
24012f4a:	681b      	ldr	r3, [r3, #0]
24012f4c:	ea42 0103 	orr.w	r1, r2, r3
24012f50:	68fb      	ldr	r3, [r7, #12]
24012f52:	681b      	ldr	r3, [r3, #0]
24012f54:	687a      	ldr	r2, [r7, #4]
24012f56:	430a      	orrs	r2, r1
24012f58:	615a      	str	r2, [r3, #20]
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateBytesSize | cmd->AlternateByteMode |
                                         cmd->AddressSize | cmd->AddressMode | cmd->InstructionMode |
                                         cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24012f5a:	687b      	ldr	r3, [r7, #4]
24012f5c:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24012f60:	f000 812e 	beq.w	240131c0 <QSPI_Config+0x300>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24012f64:	68fb      	ldr	r3, [r7, #12]
24012f66:	681b      	ldr	r3, [r3, #0]
24012f68:	68ba      	ldr	r2, [r7, #8]
24012f6a:	6852      	ldr	r2, [r2, #4]
24012f6c:	619a      	str	r2, [r3, #24]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
24012f6e:	e127      	b.n	240131c0 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012f70:	68bb      	ldr	r3, [r7, #8]
24012f72:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012f74:	68bb      	ldr	r3, [r7, #8]
24012f76:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012f78:	431a      	orrs	r2, r3
24012f7a:	68bb      	ldr	r3, [r7, #8]
24012f7c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012f7e:	431a      	orrs	r2, r3
24012f80:	68bb      	ldr	r3, [r7, #8]
24012f82:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012f84:	431a      	orrs	r2, r3
24012f86:	68bb      	ldr	r3, [r7, #8]
24012f88:	695b      	ldr	r3, [r3, #20]
24012f8a:	049b      	lsls	r3, r3, #18
24012f8c:	431a      	orrs	r2, r3
24012f8e:	68bb      	ldr	r3, [r7, #8]
24012f90:	691b      	ldr	r3, [r3, #16]
24012f92:	431a      	orrs	r2, r3
24012f94:	68bb      	ldr	r3, [r7, #8]
24012f96:	6a1b      	ldr	r3, [r3, #32]
24012f98:	431a      	orrs	r2, r3
24012f9a:	68bb      	ldr	r3, [r7, #8]
24012f9c:	69db      	ldr	r3, [r3, #28]
24012f9e:	431a      	orrs	r2, r3
24012fa0:	68bb      	ldr	r3, [r7, #8]
24012fa2:	699b      	ldr	r3, [r3, #24]
24012fa4:	431a      	orrs	r2, r3
24012fa6:	68bb      	ldr	r3, [r7, #8]
24012fa8:	681b      	ldr	r3, [r3, #0]
24012faa:	ea42 0103 	orr.w	r1, r2, r3
24012fae:	68fb      	ldr	r3, [r7, #12]
24012fb0:	681b      	ldr	r3, [r3, #0]
24012fb2:	687a      	ldr	r2, [r7, #4]
24012fb4:	430a      	orrs	r2, r1
24012fb6:	615a      	str	r2, [r3, #20]
}
24012fb8:	e102      	b.n	240131c0 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24012fba:	68bb      	ldr	r3, [r7, #8]
24012fbc:	69db      	ldr	r3, [r3, #28]
24012fbe:	2b00      	cmp	r3, #0
24012fc0:	d02e      	beq.n	24013020 <QSPI_Config+0x160>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012fc2:	68bb      	ldr	r3, [r7, #8]
24012fc4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012fc6:	68bb      	ldr	r3, [r7, #8]
24012fc8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012fca:	431a      	orrs	r2, r3
24012fcc:	68bb      	ldr	r3, [r7, #8]
24012fce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012fd0:	431a      	orrs	r2, r3
24012fd2:	68bb      	ldr	r3, [r7, #8]
24012fd4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012fd6:	431a      	orrs	r2, r3
24012fd8:	68bb      	ldr	r3, [r7, #8]
24012fda:	695b      	ldr	r3, [r3, #20]
24012fdc:	049b      	lsls	r3, r3, #18
24012fde:	431a      	orrs	r2, r3
24012fe0:	68bb      	ldr	r3, [r7, #8]
24012fe2:	6a1b      	ldr	r3, [r3, #32]
24012fe4:	431a      	orrs	r2, r3
24012fe6:	68bb      	ldr	r3, [r7, #8]
24012fe8:	68db      	ldr	r3, [r3, #12]
24012fea:	431a      	orrs	r2, r3
24012fec:	68bb      	ldr	r3, [r7, #8]
24012fee:	69db      	ldr	r3, [r3, #28]
24012ff0:	431a      	orrs	r2, r3
24012ff2:	68bb      	ldr	r3, [r7, #8]
24012ff4:	699b      	ldr	r3, [r3, #24]
24012ff6:	431a      	orrs	r2, r3
24012ff8:	68bb      	ldr	r3, [r7, #8]
24012ffa:	681b      	ldr	r3, [r3, #0]
24012ffc:	ea42 0103 	orr.w	r1, r2, r3
24013000:	68fb      	ldr	r3, [r7, #12]
24013002:	681b      	ldr	r3, [r3, #0]
24013004:	687a      	ldr	r2, [r7, #4]
24013006:	430a      	orrs	r2, r1
24013008:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2401300a:	687b      	ldr	r3, [r7, #4]
2401300c:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24013010:	f000 80d6 	beq.w	240131c0 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24013014:	68fb      	ldr	r3, [r7, #12]
24013016:	681b      	ldr	r3, [r3, #0]
24013018:	68ba      	ldr	r2, [r7, #8]
2401301a:	6852      	ldr	r2, [r2, #4]
2401301c:	619a      	str	r2, [r3, #24]
}
2401301e:	e0cf      	b.n	240131c0 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24013020:	68bb      	ldr	r3, [r7, #8]
24013022:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24013024:	68bb      	ldr	r3, [r7, #8]
24013026:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013028:	431a      	orrs	r2, r3
2401302a:	68bb      	ldr	r3, [r7, #8]
2401302c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401302e:	431a      	orrs	r2, r3
24013030:	68bb      	ldr	r3, [r7, #8]
24013032:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24013034:	431a      	orrs	r2, r3
24013036:	68bb      	ldr	r3, [r7, #8]
24013038:	695b      	ldr	r3, [r3, #20]
2401303a:	049b      	lsls	r3, r3, #18
2401303c:	431a      	orrs	r2, r3
2401303e:	68bb      	ldr	r3, [r7, #8]
24013040:	6a1b      	ldr	r3, [r3, #32]
24013042:	431a      	orrs	r2, r3
24013044:	68bb      	ldr	r3, [r7, #8]
24013046:	69db      	ldr	r3, [r3, #28]
24013048:	431a      	orrs	r2, r3
2401304a:	68bb      	ldr	r3, [r7, #8]
2401304c:	699b      	ldr	r3, [r3, #24]
2401304e:	431a      	orrs	r2, r3
24013050:	68bb      	ldr	r3, [r7, #8]
24013052:	681b      	ldr	r3, [r3, #0]
24013054:	ea42 0103 	orr.w	r1, r2, r3
24013058:	68fb      	ldr	r3, [r7, #12]
2401305a:	681b      	ldr	r3, [r3, #0]
2401305c:	687a      	ldr	r2, [r7, #4]
2401305e:	430a      	orrs	r2, r1
24013060:	615a      	str	r2, [r3, #20]
}
24013062:	e0ad      	b.n	240131c0 <QSPI_Config+0x300>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
24013064:	68bb      	ldr	r3, [r7, #8]
24013066:	6a1b      	ldr	r3, [r3, #32]
24013068:	2b00      	cmp	r3, #0
2401306a:	d058      	beq.n	2401311e <QSPI_Config+0x25e>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
2401306c:	68fb      	ldr	r3, [r7, #12]
2401306e:	681b      	ldr	r3, [r3, #0]
24013070:	68ba      	ldr	r2, [r7, #8]
24013072:	6892      	ldr	r2, [r2, #8]
24013074:	61da      	str	r2, [r3, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24013076:	68bb      	ldr	r3, [r7, #8]
24013078:	69db      	ldr	r3, [r3, #28]
2401307a:	2b00      	cmp	r3, #0
2401307c:	d02d      	beq.n	240130da <QSPI_Config+0x21a>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2401307e:	68bb      	ldr	r3, [r7, #8]
24013080:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24013082:	68bb      	ldr	r3, [r7, #8]
24013084:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013086:	431a      	orrs	r2, r3
24013088:	68bb      	ldr	r3, [r7, #8]
2401308a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401308c:	431a      	orrs	r2, r3
2401308e:	68bb      	ldr	r3, [r7, #8]
24013090:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24013092:	431a      	orrs	r2, r3
24013094:	68bb      	ldr	r3, [r7, #8]
24013096:	695b      	ldr	r3, [r3, #20]
24013098:	049b      	lsls	r3, r3, #18
2401309a:	431a      	orrs	r2, r3
2401309c:	68bb      	ldr	r3, [r7, #8]
2401309e:	691b      	ldr	r3, [r3, #16]
240130a0:	431a      	orrs	r2, r3
240130a2:	68bb      	ldr	r3, [r7, #8]
240130a4:	6a1b      	ldr	r3, [r3, #32]
240130a6:	431a      	orrs	r2, r3
240130a8:	68bb      	ldr	r3, [r7, #8]
240130aa:	68db      	ldr	r3, [r3, #12]
240130ac:	431a      	orrs	r2, r3
240130ae:	68bb      	ldr	r3, [r7, #8]
240130b0:	69db      	ldr	r3, [r3, #28]
240130b2:	431a      	orrs	r2, r3
240130b4:	68bb      	ldr	r3, [r7, #8]
240130b6:	699b      	ldr	r3, [r3, #24]
240130b8:	ea42 0103 	orr.w	r1, r2, r3
240130bc:	68fb      	ldr	r3, [r7, #12]
240130be:	681b      	ldr	r3, [r3, #0]
240130c0:	687a      	ldr	r2, [r7, #4]
240130c2:	430a      	orrs	r2, r1
240130c4:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
240130c6:	687b      	ldr	r3, [r7, #4]
240130c8:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
240130cc:	d078      	beq.n	240131c0 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
240130ce:	68fb      	ldr	r3, [r7, #12]
240130d0:	681b      	ldr	r3, [r3, #0]
240130d2:	68ba      	ldr	r2, [r7, #8]
240130d4:	6852      	ldr	r2, [r2, #4]
240130d6:	619a      	str	r2, [r3, #24]
}
240130d8:	e072      	b.n	240131c0 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240130da:	68bb      	ldr	r3, [r7, #8]
240130dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
240130de:	68bb      	ldr	r3, [r7, #8]
240130e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240130e2:	431a      	orrs	r2, r3
240130e4:	68bb      	ldr	r3, [r7, #8]
240130e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240130e8:	431a      	orrs	r2, r3
240130ea:	68bb      	ldr	r3, [r7, #8]
240130ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240130ee:	431a      	orrs	r2, r3
240130f0:	68bb      	ldr	r3, [r7, #8]
240130f2:	695b      	ldr	r3, [r3, #20]
240130f4:	049b      	lsls	r3, r3, #18
240130f6:	431a      	orrs	r2, r3
240130f8:	68bb      	ldr	r3, [r7, #8]
240130fa:	691b      	ldr	r3, [r3, #16]
240130fc:	431a      	orrs	r2, r3
240130fe:	68bb      	ldr	r3, [r7, #8]
24013100:	6a1b      	ldr	r3, [r3, #32]
24013102:	431a      	orrs	r2, r3
24013104:	68bb      	ldr	r3, [r7, #8]
24013106:	69db      	ldr	r3, [r3, #28]
24013108:	431a      	orrs	r2, r3
2401310a:	68bb      	ldr	r3, [r7, #8]
2401310c:	699b      	ldr	r3, [r3, #24]
2401310e:	ea42 0103 	orr.w	r1, r2, r3
24013112:	68fb      	ldr	r3, [r7, #12]
24013114:	681b      	ldr	r3, [r3, #0]
24013116:	687a      	ldr	r2, [r7, #4]
24013118:	430a      	orrs	r2, r1
2401311a:	615a      	str	r2, [r3, #20]
}
2401311c:	e050      	b.n	240131c0 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2401311e:	68bb      	ldr	r3, [r7, #8]
24013120:	69db      	ldr	r3, [r3, #28]
24013122:	2b00      	cmp	r3, #0
24013124:	d02a      	beq.n	2401317c <QSPI_Config+0x2bc>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24013126:	68bb      	ldr	r3, [r7, #8]
24013128:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2401312a:	68bb      	ldr	r3, [r7, #8]
2401312c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401312e:	431a      	orrs	r2, r3
24013130:	68bb      	ldr	r3, [r7, #8]
24013132:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24013134:	431a      	orrs	r2, r3
24013136:	68bb      	ldr	r3, [r7, #8]
24013138:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401313a:	431a      	orrs	r2, r3
2401313c:	68bb      	ldr	r3, [r7, #8]
2401313e:	695b      	ldr	r3, [r3, #20]
24013140:	049b      	lsls	r3, r3, #18
24013142:	431a      	orrs	r2, r3
24013144:	68bb      	ldr	r3, [r7, #8]
24013146:	6a1b      	ldr	r3, [r3, #32]
24013148:	431a      	orrs	r2, r3
2401314a:	68bb      	ldr	r3, [r7, #8]
2401314c:	68db      	ldr	r3, [r3, #12]
2401314e:	431a      	orrs	r2, r3
24013150:	68bb      	ldr	r3, [r7, #8]
24013152:	69db      	ldr	r3, [r3, #28]
24013154:	431a      	orrs	r2, r3
24013156:	68bb      	ldr	r3, [r7, #8]
24013158:	699b      	ldr	r3, [r3, #24]
2401315a:	ea42 0103 	orr.w	r1, r2, r3
2401315e:	68fb      	ldr	r3, [r7, #12]
24013160:	681b      	ldr	r3, [r3, #0]
24013162:	687a      	ldr	r2, [r7, #4]
24013164:	430a      	orrs	r2, r1
24013166:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24013168:	687b      	ldr	r3, [r7, #4]
2401316a:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2401316e:	d027      	beq.n	240131c0 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24013170:	68fb      	ldr	r3, [r7, #12]
24013172:	681b      	ldr	r3, [r3, #0]
24013174:	68ba      	ldr	r2, [r7, #8]
24013176:	6852      	ldr	r2, [r2, #4]
24013178:	619a      	str	r2, [r3, #24]
}
2401317a:	e021      	b.n	240131c0 <QSPI_Config+0x300>
        if (cmd->DataMode != QSPI_DATA_NONE)
2401317c:	68bb      	ldr	r3, [r7, #8]
2401317e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24013180:	2b00      	cmp	r3, #0
24013182:	d01d      	beq.n	240131c0 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24013184:	68bb      	ldr	r3, [r7, #8]
24013186:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24013188:	68bb      	ldr	r3, [r7, #8]
2401318a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401318c:	431a      	orrs	r2, r3
2401318e:	68bb      	ldr	r3, [r7, #8]
24013190:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24013192:	431a      	orrs	r2, r3
24013194:	68bb      	ldr	r3, [r7, #8]
24013196:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24013198:	431a      	orrs	r2, r3
2401319a:	68bb      	ldr	r3, [r7, #8]
2401319c:	695b      	ldr	r3, [r3, #20]
2401319e:	049b      	lsls	r3, r3, #18
240131a0:	431a      	orrs	r2, r3
240131a2:	68bb      	ldr	r3, [r7, #8]
240131a4:	6a1b      	ldr	r3, [r3, #32]
240131a6:	431a      	orrs	r2, r3
240131a8:	68bb      	ldr	r3, [r7, #8]
240131aa:	69db      	ldr	r3, [r3, #28]
240131ac:	431a      	orrs	r2, r3
240131ae:	68bb      	ldr	r3, [r7, #8]
240131b0:	699b      	ldr	r3, [r3, #24]
240131b2:	ea42 0103 	orr.w	r1, r2, r3
240131b6:	68fb      	ldr	r3, [r7, #12]
240131b8:	681b      	ldr	r3, [r3, #0]
240131ba:	687a      	ldr	r2, [r7, #4]
240131bc:	430a      	orrs	r2, r1
240131be:	615a      	str	r2, [r3, #20]
}
240131c0:	bf00      	nop
240131c2:	3714      	adds	r7, #20
240131c4:	46bd      	mov	sp, r7
240131c6:	f85d 7b04 	ldr.w	r7, [sp], #4
240131ca:	4770      	bx	lr

240131cc <HAL_RCC_DeInit>:
  *            - Peripheral clocks
  *            - LSI, LSE and RTC clocks
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
240131cc:	b580      	push	{r7, lr}
240131ce:	b082      	sub	sp, #8
240131d0:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Increasing the CPU frequency */
  if (FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
240131d2:	4b89      	ldr	r3, [pc, #548]	; (240133f8 <HAL_RCC_DeInit+0x22c>)
240131d4:	681b      	ldr	r3, [r3, #0]
240131d6:	f003 030f 	and.w	r3, r3, #15
240131da:	2b06      	cmp	r3, #6
240131dc:	d80f      	bhi.n	240131fe <HAL_RCC_DeInit+0x32>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
240131de:	4b86      	ldr	r3, [pc, #536]	; (240133f8 <HAL_RCC_DeInit+0x22c>)
240131e0:	681b      	ldr	r3, [r3, #0]
240131e2:	f023 030f 	bic.w	r3, r3, #15
240131e6:	4a84      	ldr	r2, [pc, #528]	; (240133f8 <HAL_RCC_DeInit+0x22c>)
240131e8:	f043 0307 	orr.w	r3, r3, #7
240131ec:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
240131ee:	4b82      	ldr	r3, [pc, #520]	; (240133f8 <HAL_RCC_DeInit+0x22c>)
240131f0:	681b      	ldr	r3, [r3, #0]
240131f2:	f003 030f 	and.w	r3, r3, #15
240131f6:	2b07      	cmp	r3, #7
240131f8:	d001      	beq.n	240131fe <HAL_RCC_DeInit+0x32>
    {
      return HAL_ERROR;
240131fa:	2301      	movs	r3, #1
240131fc:	e0f7      	b.n	240133ee <HAL_RCC_DeInit+0x222>

  }


  /* Get Start Tick */
  tickstart = HAL_GetTick();
240131fe:	f7ee ff0d 	bl	2400201c <HAL_GetTick>
24013202:	6078      	str	r0, [r7, #4]

  /* Set HSION bit */
  SET_BIT(RCC->CR, RCC_CR_HSION);
24013204:	4b7d      	ldr	r3, [pc, #500]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013206:	681b      	ldr	r3, [r3, #0]
24013208:	4a7c      	ldr	r2, [pc, #496]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401320a:	f043 0301 	orr.w	r3, r3, #1
2401320e:	6013      	str	r3, [r2, #0]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
24013210:	e008      	b.n	24013224 <HAL_RCC_DeInit+0x58>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
24013212:	f7ee ff03 	bl	2400201c <HAL_GetTick>
24013216:	4602      	mov	r2, r0
24013218:	687b      	ldr	r3, [r7, #4]
2401321a:	1ad3      	subs	r3, r2, r3
2401321c:	2b02      	cmp	r3, #2
2401321e:	d901      	bls.n	24013224 <HAL_RCC_DeInit+0x58>
    {
      return HAL_TIMEOUT;
24013220:	2303      	movs	r3, #3
24013222:	e0e4      	b.n	240133ee <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
24013224:	4b75      	ldr	r3, [pc, #468]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013226:	681b      	ldr	r3, [r3, #0]
24013228:	f003 0304 	and.w	r3, r3, #4
2401322c:	2b00      	cmp	r3, #0
2401322e:	d0f0      	beq.n	24013212 <HAL_RCC_DeInit+0x46>
    }
  }

  /* Set HSITRIM[6:0] bits to the reset value */
  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
24013230:	4b72      	ldr	r3, [pc, #456]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013232:	685b      	ldr	r3, [r3, #4]
24013234:	4a71      	ldr	r2, [pc, #452]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013236:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
2401323a:	6053      	str	r3, [r2, #4]

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);
2401323c:	4b6f      	ldr	r3, [pc, #444]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401323e:	2200      	movs	r2, #0
24013240:	611a      	str	r2, [r3, #16]

  /* Update the SystemCoreClock and SystemD2Clock global variables */
  SystemCoreClock = HSI_VALUE;
24013242:	4b6f      	ldr	r3, [pc, #444]	; (24013400 <HAL_RCC_DeInit+0x234>)
24013244:	4a6f      	ldr	r2, [pc, #444]	; (24013404 <HAL_RCC_DeInit+0x238>)
24013246:	601a      	str	r2, [r3, #0]
  SystemD2Clock = HSI_VALUE;
24013248:	4b6f      	ldr	r3, [pc, #444]	; (24013408 <HAL_RCC_DeInit+0x23c>)
2401324a:	4a6e      	ldr	r2, [pc, #440]	; (24013404 <HAL_RCC_DeInit+0x238>)
2401324c:	601a      	str	r2, [r3, #0]

  /* Adapt Systick interrupt period */
  if (HAL_InitTick(uwTickPrio) != HAL_OK)
2401324e:	4b6f      	ldr	r3, [pc, #444]	; (2401340c <HAL_RCC_DeInit+0x240>)
24013250:	681b      	ldr	r3, [r3, #0]
24013252:	4618      	mov	r0, r3
24013254:	f7ee f996 	bl	24001584 <HAL_InitTick>
24013258:	4603      	mov	r3, r0
2401325a:	2b00      	cmp	r3, #0
2401325c:	d001      	beq.n	24013262 <HAL_RCC_DeInit+0x96>
  {
    return HAL_ERROR;
2401325e:	2301      	movs	r3, #1
24013260:	e0c5      	b.n	240133ee <HAL_RCC_DeInit+0x222>
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24013262:	f7ee fedb 	bl	2400201c <HAL_GetTick>
24013266:	6078      	str	r0, [r7, #4]

  /* Wait till clock switch is ready */
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24013268:	e00a      	b.n	24013280 <HAL_RCC_DeInit+0xb4>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2401326a:	f7ee fed7 	bl	2400201c <HAL_GetTick>
2401326e:	4602      	mov	r2, r0
24013270:	687b      	ldr	r3, [r7, #4]
24013272:	1ad3      	subs	r3, r2, r3
24013274:	f241 3288 	movw	r2, #5000	; 0x1388
24013278:	4293      	cmp	r3, r2
2401327a:	d901      	bls.n	24013280 <HAL_RCC_DeInit+0xb4>
    {
      return HAL_TIMEOUT;
2401327c:	2303      	movs	r3, #3
2401327e:	e0b6      	b.n	240133ee <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24013280:	4b5e      	ldr	r3, [pc, #376]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013282:	691b      	ldr	r3, [r3, #16]
24013284:	f003 0338 	and.w	r3, r3, #56	; 0x38
24013288:	2b00      	cmp	r3, #0
2401328a:	d1ee      	bne.n	2401326a <HAL_RCC_DeInit+0x9e>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2401328c:	f7ee fec6 	bl	2400201c <HAL_GetTick>
24013290:	6078      	str	r0, [r7, #4]

  /* Reset CSION, CSIKERON, HSEON, HSI48ON, HSECSSON, HSIDIV bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON | RCC_CR_HSIDIV | RCC_CR_HSIDIVF | RCC_CR_CSION | RCC_CR_CSIKERON  \
24013292:	4b5a      	ldr	r3, [pc, #360]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013294:	681a      	ldr	r2, [r3, #0]
24013296:	4959      	ldr	r1, [pc, #356]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013298:	4b5d      	ldr	r3, [pc, #372]	; (24013410 <HAL_RCC_DeInit+0x244>)
2401329a:	4013      	ands	r3, r2
2401329c:	600b      	str	r3, [r1, #0]
            | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);

  /* Wait till HSE is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
2401329e:	e008      	b.n	240132b2 <HAL_RCC_DeInit+0xe6>
  {
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
240132a0:	f7ee febc 	bl	2400201c <HAL_GetTick>
240132a4:	4602      	mov	r2, r0
240132a6:	687b      	ldr	r3, [r7, #4]
240132a8:	1ad3      	subs	r3, r2, r3
240132aa:	2b64      	cmp	r3, #100	; 0x64
240132ac:	d901      	bls.n	240132b2 <HAL_RCC_DeInit+0xe6>
    {
      return HAL_TIMEOUT;
240132ae:	2303      	movs	r3, #3
240132b0:	e09d      	b.n	240133ee <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
240132b2:	4b52      	ldr	r3, [pc, #328]	; (240133fc <HAL_RCC_DeInit+0x230>)
240132b4:	681b      	ldr	r3, [r3, #0]
240132b6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240132ba:	2b00      	cmp	r3, #0
240132bc:	d1f0      	bne.n	240132a0 <HAL_RCC_DeInit+0xd4>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
240132be:	f7ee fead 	bl	2400201c <HAL_GetTick>
240132c2:	6078      	str	r0, [r7, #4]

  /* Clear PLLON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
240132c4:	4b4d      	ldr	r3, [pc, #308]	; (240133fc <HAL_RCC_DeInit+0x230>)
240132c6:	681b      	ldr	r3, [r3, #0]
240132c8:	4a4c      	ldr	r2, [pc, #304]	; (240133fc <HAL_RCC_DeInit+0x230>)
240132ca:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
240132ce:	6013      	str	r3, [r2, #0]

  /* Wait till PLL is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
240132d0:	e008      	b.n	240132e4 <HAL_RCC_DeInit+0x118>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
240132d2:	f7ee fea3 	bl	2400201c <HAL_GetTick>
240132d6:	4602      	mov	r2, r0
240132d8:	687b      	ldr	r3, [r7, #4]
240132da:	1ad3      	subs	r3, r2, r3
240132dc:	2b02      	cmp	r3, #2
240132de:	d901      	bls.n	240132e4 <HAL_RCC_DeInit+0x118>
    {
      return HAL_TIMEOUT;
240132e0:	2303      	movs	r3, #3
240132e2:	e084      	b.n	240133ee <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
240132e4:	4b45      	ldr	r3, [pc, #276]	; (240133fc <HAL_RCC_DeInit+0x230>)
240132e6:	681b      	ldr	r3, [r3, #0]
240132e8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240132ec:	2b00      	cmp	r3, #0
240132ee:	d1f0      	bne.n	240132d2 <HAL_RCC_DeInit+0x106>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
240132f0:	f7ee fe94 	bl	2400201c <HAL_GetTick>
240132f4:	6078      	str	r0, [r7, #4]

  /* Reset PLL2ON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
240132f6:	4b41      	ldr	r3, [pc, #260]	; (240133fc <HAL_RCC_DeInit+0x230>)
240132f8:	681b      	ldr	r3, [r3, #0]
240132fa:	4a40      	ldr	r2, [pc, #256]	; (240133fc <HAL_RCC_DeInit+0x230>)
240132fc:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
24013300:	6013      	str	r3, [r2, #0]

  /* Wait till PLL2 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
24013302:	e008      	b.n	24013316 <HAL_RCC_DeInit+0x14a>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24013304:	f7ee fe8a 	bl	2400201c <HAL_GetTick>
24013308:	4602      	mov	r2, r0
2401330a:	687b      	ldr	r3, [r7, #4]
2401330c:	1ad3      	subs	r3, r2, r3
2401330e:	2b02      	cmp	r3, #2
24013310:	d901      	bls.n	24013316 <HAL_RCC_DeInit+0x14a>
    {
      return HAL_TIMEOUT;
24013312:	2303      	movs	r3, #3
24013314:	e06b      	b.n	240133ee <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
24013316:	4b39      	ldr	r3, [pc, #228]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013318:	681b      	ldr	r3, [r3, #0]
2401331a:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2401331e:	2b00      	cmp	r3, #0
24013320:	d1f0      	bne.n	24013304 <HAL_RCC_DeInit+0x138>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24013322:	f7ee fe7b 	bl	2400201c <HAL_GetTick>
24013326:	6078      	str	r0, [r7, #4]

  /* Reset PLL3 bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
24013328:	4b34      	ldr	r3, [pc, #208]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401332a:	681b      	ldr	r3, [r3, #0]
2401332c:	4a33      	ldr	r2, [pc, #204]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401332e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
24013332:	6013      	str	r3, [r2, #0]

  /* Wait till PLL3 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
24013334:	e008      	b.n	24013348 <HAL_RCC_DeInit+0x17c>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24013336:	f7ee fe71 	bl	2400201c <HAL_GetTick>
2401333a:	4602      	mov	r2, r0
2401333c:	687b      	ldr	r3, [r7, #4]
2401333e:	1ad3      	subs	r3, r2, r3
24013340:	2b02      	cmp	r3, #2
24013342:	d901      	bls.n	24013348 <HAL_RCC_DeInit+0x17c>
    {
      return HAL_TIMEOUT;
24013344:	2303      	movs	r3, #3
24013346:	e052      	b.n	240133ee <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
24013348:	4b2c      	ldr	r3, [pc, #176]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401334a:	681b      	ldr	r3, [r3, #0]
2401334c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24013350:	2b00      	cmp	r3, #0
24013352:	d1f0      	bne.n	24013336 <HAL_RCC_DeInit+0x16a>
    }
  }

#if defined(RCC_D1CFGR_HPRE)
  /* Reset D1CFGR register */
  CLEAR_REG(RCC->D1CFGR);
24013354:	4b29      	ldr	r3, [pc, #164]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013356:	2200      	movs	r2, #0
24013358:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  CLEAR_REG(RCC->D2CFGR);
2401335a:	4b28      	ldr	r3, [pc, #160]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401335c:	2200      	movs	r2, #0
2401335e:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  CLEAR_REG(RCC->D3CFGR);
24013360:	4b26      	ldr	r3, [pc, #152]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013362:	2200      	movs	r2, #0
24013364:	621a      	str	r2, [r3, #32]
  /* Reset SRDCFGR register */
  CLEAR_REG(RCC->SRDCFGR);
#endif

  /* Reset PLLCKSELR register to default value */
  RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM1_5 | RCC_PLLCKSELR_DIVM2_5 | RCC_PLLCKSELR_DIVM3_5;
24013366:	4b25      	ldr	r3, [pc, #148]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013368:	4a2a      	ldr	r2, [pc, #168]	; (24013414 <HAL_RCC_DeInit+0x248>)
2401336a:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register to default value */
  WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);
2401336c:	4b23      	ldr	r3, [pc, #140]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401336e:	4a2a      	ldr	r2, [pc, #168]	; (24013418 <HAL_RCC_DeInit+0x24c>)
24013370:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset PLL1DIVR register to default value */
  WRITE_REG(RCC->PLL1DIVR, 0x01010280U);
24013372:	4b22      	ldr	r3, [pc, #136]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013374:	4a29      	ldr	r2, [pc, #164]	; (2401341c <HAL_RCC_DeInit+0x250>)
24013376:	631a      	str	r2, [r3, #48]	; 0x30

  /* Reset PLL1FRACR register */
  CLEAR_REG(RCC->PLL1FRACR);
24013378:	4b20      	ldr	r3, [pc, #128]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401337a:	2200      	movs	r2, #0
2401337c:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register to default value */
  WRITE_REG(RCC->PLL2DIVR, 0x01010280U);
2401337e:	4b1f      	ldr	r3, [pc, #124]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013380:	4a26      	ldr	r2, [pc, #152]	; (2401341c <HAL_RCC_DeInit+0x250>)
24013382:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */
  CLEAR_REG(RCC->PLL2FRACR);
24013384:	4b1d      	ldr	r3, [pc, #116]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013386:	2200      	movs	r2, #0
24013388:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Reset PLL3DIVR register to default value */
  WRITE_REG(RCC->PLL3DIVR, 0x01010280U);
2401338a:	4b1c      	ldr	r3, [pc, #112]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401338c:	4a23      	ldr	r2, [pc, #140]	; (2401341c <HAL_RCC_DeInit+0x250>)
2401338e:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  CLEAR_REG(RCC->PLL3FRACR);
24013390:	4b1a      	ldr	r3, [pc, #104]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013392:	2200      	movs	r2, #0
24013394:	645a      	str	r2, [r3, #68]	; 0x44
  /* Reset HSEEXT  */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEEXT);
#endif /* RCC_CR_HSEEXT */

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
24013396:	4b19      	ldr	r3, [pc, #100]	; (240133fc <HAL_RCC_DeInit+0x230>)
24013398:	681b      	ldr	r3, [r3, #0]
2401339a:	4a18      	ldr	r2, [pc, #96]	; (240133fc <HAL_RCC_DeInit+0x230>)
2401339c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
240133a0:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
240133a2:	4b16      	ldr	r3, [pc, #88]	; (240133fc <HAL_RCC_DeInit+0x230>)
240133a4:	2200      	movs	r2, #0
240133a6:	661a      	str	r2, [r3, #96]	; 0x60

  /* Clear all interrupts flags */
  WRITE_REG(RCC->CICR, 0xFFFFFFFFU);
240133a8:	4b14      	ldr	r3, [pc, #80]	; (240133fc <HAL_RCC_DeInit+0x230>)
240133aa:	f04f 32ff 	mov.w	r2, #4294967295
240133ae:	669a      	str	r2, [r3, #104]	; 0x68

  /* Reset all RSR flags */
  SET_BIT(RCC->RSR, RCC_RSR_RMVF);
240133b0:	4b12      	ldr	r3, [pc, #72]	; (240133fc <HAL_RCC_DeInit+0x230>)
240133b2:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
240133b6:	4a11      	ldr	r2, [pc, #68]	; (240133fc <HAL_RCC_DeInit+0x230>)
240133b8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240133bc:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
240133c0:	4b0d      	ldr	r3, [pc, #52]	; (240133f8 <HAL_RCC_DeInit+0x22c>)
240133c2:	681b      	ldr	r3, [r3, #0]
240133c4:	f003 0308 	and.w	r3, r3, #8
240133c8:	2b00      	cmp	r3, #0
240133ca:	d00f      	beq.n	240133ec <HAL_RCC_DeInit+0x220>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
240133cc:	4b0a      	ldr	r3, [pc, #40]	; (240133f8 <HAL_RCC_DeInit+0x22c>)
240133ce:	681b      	ldr	r3, [r3, #0]
240133d0:	f023 030f 	bic.w	r3, r3, #15
240133d4:	4a08      	ldr	r2, [pc, #32]	; (240133f8 <HAL_RCC_DeInit+0x22c>)
240133d6:	f043 0307 	orr.w	r3, r3, #7
240133da:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
240133dc:	4b06      	ldr	r3, [pc, #24]	; (240133f8 <HAL_RCC_DeInit+0x22c>)
240133de:	681b      	ldr	r3, [r3, #0]
240133e0:	f003 030f 	and.w	r3, r3, #15
240133e4:	2b07      	cmp	r3, #7
240133e6:	d001      	beq.n	240133ec <HAL_RCC_DeInit+0x220>
    {
      return HAL_ERROR;
240133e8:	2301      	movs	r3, #1
240133ea:	e000      	b.n	240133ee <HAL_RCC_DeInit+0x222>
    }

  }

  return HAL_OK;
240133ec:	2300      	movs	r3, #0
}
240133ee:	4618      	mov	r0, r3
240133f0:	3708      	adds	r7, #8
240133f2:	46bd      	mov	sp, r7
240133f4:	bd80      	pop	{r7, pc}
240133f6:	bf00      	nop
240133f8:	52002000 	.word	0x52002000
240133fc:	58024400 	.word	0x58024400
24013400:	240004b0 	.word	0x240004b0
24013404:	03d09000 	.word	0x03d09000
24013408:	240004b4 	.word	0x240004b4
2401340c:	240004b8 	.word	0x240004b8
24013410:	fff6ed45 	.word	0xfff6ed45
24013414:	02020200 	.word	0x02020200
24013418:	01ff0000 	.word	0x01ff0000
2401341c:	01010280 	.word	0x01010280

24013420 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
24013420:	b580      	push	{r7, lr}
24013422:	b08c      	sub	sp, #48	; 0x30
24013424:	af00      	add	r7, sp, #0
24013426:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
24013428:	687b      	ldr	r3, [r7, #4]
2401342a:	2b00      	cmp	r3, #0
2401342c:	d102      	bne.n	24013434 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
2401342e:	2301      	movs	r3, #1
24013430:	f000 bc48 	b.w	24013cc4 <HAL_RCC_OscConfig+0x8a4>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
24013434:	687b      	ldr	r3, [r7, #4]
24013436:	681b      	ldr	r3, [r3, #0]
24013438:	f003 0301 	and.w	r3, r3, #1
2401343c:	2b00      	cmp	r3, #0
2401343e:	f000 8088 	beq.w	24013552 <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24013442:	4b99      	ldr	r3, [pc, #612]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013444:	691b      	ldr	r3, [r3, #16]
24013446:	f003 0338 	and.w	r3, r3, #56	; 0x38
2401344a:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
2401344c:	4b96      	ldr	r3, [pc, #600]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
2401344e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013450:	62bb      	str	r3, [r7, #40]	; 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
24013452:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24013454:	2b10      	cmp	r3, #16
24013456:	d007      	beq.n	24013468 <HAL_RCC_OscConfig+0x48>
24013458:	6afb      	ldr	r3, [r7, #44]	; 0x2c
2401345a:	2b18      	cmp	r3, #24
2401345c:	d111      	bne.n	24013482 <HAL_RCC_OscConfig+0x62>
2401345e:	6abb      	ldr	r3, [r7, #40]	; 0x28
24013460:	f003 0303 	and.w	r3, r3, #3
24013464:	2b02      	cmp	r3, #2
24013466:	d10c      	bne.n	24013482 <HAL_RCC_OscConfig+0x62>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
24013468:	4b8f      	ldr	r3, [pc, #572]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
2401346a:	681b      	ldr	r3, [r3, #0]
2401346c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24013470:	2b00      	cmp	r3, #0
24013472:	d06d      	beq.n	24013550 <HAL_RCC_OscConfig+0x130>
24013474:	687b      	ldr	r3, [r7, #4]
24013476:	685b      	ldr	r3, [r3, #4]
24013478:	2b00      	cmp	r3, #0
2401347a:	d169      	bne.n	24013550 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
2401347c:	2301      	movs	r3, #1
2401347e:	f000 bc21 	b.w	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
24013482:	687b      	ldr	r3, [r7, #4]
24013484:	685b      	ldr	r3, [r3, #4]
24013486:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401348a:	d106      	bne.n	2401349a <HAL_RCC_OscConfig+0x7a>
2401348c:	4b86      	ldr	r3, [pc, #536]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
2401348e:	681b      	ldr	r3, [r3, #0]
24013490:	4a85      	ldr	r2, [pc, #532]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013492:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24013496:	6013      	str	r3, [r2, #0]
24013498:	e02e      	b.n	240134f8 <HAL_RCC_OscConfig+0xd8>
2401349a:	687b      	ldr	r3, [r7, #4]
2401349c:	685b      	ldr	r3, [r3, #4]
2401349e:	2b00      	cmp	r3, #0
240134a0:	d10c      	bne.n	240134bc <HAL_RCC_OscConfig+0x9c>
240134a2:	4b81      	ldr	r3, [pc, #516]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134a4:	681b      	ldr	r3, [r3, #0]
240134a6:	4a80      	ldr	r2, [pc, #512]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134a8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
240134ac:	6013      	str	r3, [r2, #0]
240134ae:	4b7e      	ldr	r3, [pc, #504]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134b0:	681b      	ldr	r3, [r3, #0]
240134b2:	4a7d      	ldr	r2, [pc, #500]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134b4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
240134b8:	6013      	str	r3, [r2, #0]
240134ba:	e01d      	b.n	240134f8 <HAL_RCC_OscConfig+0xd8>
240134bc:	687b      	ldr	r3, [r7, #4]
240134be:	685b      	ldr	r3, [r3, #4]
240134c0:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
240134c4:	d10c      	bne.n	240134e0 <HAL_RCC_OscConfig+0xc0>
240134c6:	4b78      	ldr	r3, [pc, #480]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134c8:	681b      	ldr	r3, [r3, #0]
240134ca:	4a77      	ldr	r2, [pc, #476]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134cc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
240134d0:	6013      	str	r3, [r2, #0]
240134d2:	4b75      	ldr	r3, [pc, #468]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134d4:	681b      	ldr	r3, [r3, #0]
240134d6:	4a74      	ldr	r2, [pc, #464]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134d8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240134dc:	6013      	str	r3, [r2, #0]
240134de:	e00b      	b.n	240134f8 <HAL_RCC_OscConfig+0xd8>
240134e0:	4b71      	ldr	r3, [pc, #452]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134e2:	681b      	ldr	r3, [r3, #0]
240134e4:	4a70      	ldr	r2, [pc, #448]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134e6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
240134ea:	6013      	str	r3, [r2, #0]
240134ec:	4b6e      	ldr	r3, [pc, #440]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134ee:	681b      	ldr	r3, [r3, #0]
240134f0:	4a6d      	ldr	r2, [pc, #436]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240134f2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
240134f6:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
240134f8:	687b      	ldr	r3, [r7, #4]
240134fa:	685b      	ldr	r3, [r3, #4]
240134fc:	2b00      	cmp	r3, #0
240134fe:	d013      	beq.n	24013528 <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013500:	f7ee fd8c 	bl	2400201c <HAL_GetTick>
24013504:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24013506:	e008      	b.n	2401351a <HAL_RCC_OscConfig+0xfa>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
24013508:	f7ee fd88 	bl	2400201c <HAL_GetTick>
2401350c:	4602      	mov	r2, r0
2401350e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013510:	1ad3      	subs	r3, r2, r3
24013512:	2b64      	cmp	r3, #100	; 0x64
24013514:	d901      	bls.n	2401351a <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
24013516:	2303      	movs	r3, #3
24013518:	e3d4      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
2401351a:	4b63      	ldr	r3, [pc, #396]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
2401351c:	681b      	ldr	r3, [r3, #0]
2401351e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24013522:	2b00      	cmp	r3, #0
24013524:	d0f0      	beq.n	24013508 <HAL_RCC_OscConfig+0xe8>
24013526:	e014      	b.n	24013552 <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013528:	f7ee fd78 	bl	2400201c <HAL_GetTick>
2401352c:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
2401352e:	e008      	b.n	24013542 <HAL_RCC_OscConfig+0x122>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
24013530:	f7ee fd74 	bl	2400201c <HAL_GetTick>
24013534:	4602      	mov	r2, r0
24013536:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013538:	1ad3      	subs	r3, r2, r3
2401353a:	2b64      	cmp	r3, #100	; 0x64
2401353c:	d901      	bls.n	24013542 <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
2401353e:	2303      	movs	r3, #3
24013540:	e3c0      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
24013542:	4b59      	ldr	r3, [pc, #356]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013544:	681b      	ldr	r3, [r3, #0]
24013546:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2401354a:	2b00      	cmp	r3, #0
2401354c:	d1f0      	bne.n	24013530 <HAL_RCC_OscConfig+0x110>
2401354e:	e000      	b.n	24013552 <HAL_RCC_OscConfig+0x132>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
24013550:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
24013552:	687b      	ldr	r3, [r7, #4]
24013554:	681b      	ldr	r3, [r3, #0]
24013556:	f003 0302 	and.w	r3, r3, #2
2401355a:	2b00      	cmp	r3, #0
2401355c:	f000 80ca 	beq.w	240136f4 <HAL_RCC_OscConfig+0x2d4>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24013560:	4b51      	ldr	r3, [pc, #324]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013562:	691b      	ldr	r3, [r3, #16]
24013564:	f003 0338 	and.w	r3, r3, #56	; 0x38
24013568:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
2401356a:	4b4f      	ldr	r3, [pc, #316]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
2401356c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401356e:	61fb      	str	r3, [r7, #28]
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
24013570:	6a3b      	ldr	r3, [r7, #32]
24013572:	2b00      	cmp	r3, #0
24013574:	d007      	beq.n	24013586 <HAL_RCC_OscConfig+0x166>
24013576:	6a3b      	ldr	r3, [r7, #32]
24013578:	2b18      	cmp	r3, #24
2401357a:	d156      	bne.n	2401362a <HAL_RCC_OscConfig+0x20a>
2401357c:	69fb      	ldr	r3, [r7, #28]
2401357e:	f003 0303 	and.w	r3, r3, #3
24013582:	2b00      	cmp	r3, #0
24013584:	d151      	bne.n	2401362a <HAL_RCC_OscConfig+0x20a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24013586:	4b48      	ldr	r3, [pc, #288]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013588:	681b      	ldr	r3, [r3, #0]
2401358a:	f003 0304 	and.w	r3, r3, #4
2401358e:	2b00      	cmp	r3, #0
24013590:	d005      	beq.n	2401359e <HAL_RCC_OscConfig+0x17e>
24013592:	687b      	ldr	r3, [r7, #4]
24013594:	68db      	ldr	r3, [r3, #12]
24013596:	2b00      	cmp	r3, #0
24013598:	d101      	bne.n	2401359e <HAL_RCC_OscConfig+0x17e>
      {
        return HAL_ERROR;
2401359a:	2301      	movs	r3, #1
2401359c:	e392      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      }
      /* Otherwise, only HSI division and calibration are allowed */
      else
      {
        /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
2401359e:	4b42      	ldr	r3, [pc, #264]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240135a0:	681b      	ldr	r3, [r3, #0]
240135a2:	f023 0219 	bic.w	r2, r3, #25
240135a6:	687b      	ldr	r3, [r7, #4]
240135a8:	68db      	ldr	r3, [r3, #12]
240135aa:	493f      	ldr	r1, [pc, #252]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240135ac:	4313      	orrs	r3, r2
240135ae:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240135b0:	f7ee fd34 	bl	2400201c <HAL_GetTick>
240135b4:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
240135b6:	e008      	b.n	240135ca <HAL_RCC_OscConfig+0x1aa>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
240135b8:	f7ee fd30 	bl	2400201c <HAL_GetTick>
240135bc:	4602      	mov	r2, r0
240135be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240135c0:	1ad3      	subs	r3, r2, r3
240135c2:	2b02      	cmp	r3, #2
240135c4:	d901      	bls.n	240135ca <HAL_RCC_OscConfig+0x1aa>
          {
            return HAL_TIMEOUT;
240135c6:	2303      	movs	r3, #3
240135c8:	e37c      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
240135ca:	4b37      	ldr	r3, [pc, #220]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240135cc:	681b      	ldr	r3, [r3, #0]
240135ce:	f003 0304 	and.w	r3, r3, #4
240135d2:	2b00      	cmp	r3, #0
240135d4:	d0f0      	beq.n	240135b8 <HAL_RCC_OscConfig+0x198>
          }
        }
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
240135d6:	f7ee fdbb 	bl	24002150 <HAL_GetREVID>
240135da:	4603      	mov	r3, r0
240135dc:	f241 0203 	movw	r2, #4099	; 0x1003
240135e0:	4293      	cmp	r3, r2
240135e2:	d817      	bhi.n	24013614 <HAL_RCC_OscConfig+0x1f4>
240135e4:	687b      	ldr	r3, [r7, #4]
240135e6:	691b      	ldr	r3, [r3, #16]
240135e8:	2b40      	cmp	r3, #64	; 0x40
240135ea:	d108      	bne.n	240135fe <HAL_RCC_OscConfig+0x1de>
240135ec:	4b2e      	ldr	r3, [pc, #184]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240135ee:	685b      	ldr	r3, [r3, #4]
240135f0:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
240135f4:	4a2c      	ldr	r2, [pc, #176]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240135f6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240135fa:	6053      	str	r3, [r2, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
240135fc:	e07a      	b.n	240136f4 <HAL_RCC_OscConfig+0x2d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
240135fe:	4b2a      	ldr	r3, [pc, #168]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013600:	685b      	ldr	r3, [r3, #4]
24013602:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
24013606:	687b      	ldr	r3, [r7, #4]
24013608:	691b      	ldr	r3, [r3, #16]
2401360a:	031b      	lsls	r3, r3, #12
2401360c:	4926      	ldr	r1, [pc, #152]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
2401360e:	4313      	orrs	r3, r2
24013610:	604b      	str	r3, [r1, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24013612:	e06f      	b.n	240136f4 <HAL_RCC_OscConfig+0x2d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24013614:	4b24      	ldr	r3, [pc, #144]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013616:	685b      	ldr	r3, [r3, #4]
24013618:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
2401361c:	687b      	ldr	r3, [r7, #4]
2401361e:	691b      	ldr	r3, [r3, #16]
24013620:	061b      	lsls	r3, r3, #24
24013622:	4921      	ldr	r1, [pc, #132]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013624:	4313      	orrs	r3, r2
24013626:	604b      	str	r3, [r1, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24013628:	e064      	b.n	240136f4 <HAL_RCC_OscConfig+0x2d4>
    }

    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
2401362a:	687b      	ldr	r3, [r7, #4]
2401362c:	68db      	ldr	r3, [r3, #12]
2401362e:	2b00      	cmp	r3, #0
24013630:	d047      	beq.n	240136c2 <HAL_RCC_OscConfig+0x2a2>
      {
        /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
24013632:	4b1d      	ldr	r3, [pc, #116]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013634:	681b      	ldr	r3, [r3, #0]
24013636:	f023 0219 	bic.w	r2, r3, #25
2401363a:	687b      	ldr	r3, [r7, #4]
2401363c:	68db      	ldr	r3, [r3, #12]
2401363e:	491a      	ldr	r1, [pc, #104]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013640:	4313      	orrs	r3, r2
24013642:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013644:	f7ee fcea 	bl	2400201c <HAL_GetTick>
24013648:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
2401364a:	e008      	b.n	2401365e <HAL_RCC_OscConfig+0x23e>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
2401364c:	f7ee fce6 	bl	2400201c <HAL_GetTick>
24013650:	4602      	mov	r2, r0
24013652:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013654:	1ad3      	subs	r3, r2, r3
24013656:	2b02      	cmp	r3, #2
24013658:	d901      	bls.n	2401365e <HAL_RCC_OscConfig+0x23e>
          {
            return HAL_TIMEOUT;
2401365a:	2303      	movs	r3, #3
2401365c:	e332      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
2401365e:	4b12      	ldr	r3, [pc, #72]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013660:	681b      	ldr	r3, [r3, #0]
24013662:	f003 0304 	and.w	r3, r3, #4
24013666:	2b00      	cmp	r3, #0
24013668:	d0f0      	beq.n	2401364c <HAL_RCC_OscConfig+0x22c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
2401366a:	f7ee fd71 	bl	24002150 <HAL_GetREVID>
2401366e:	4603      	mov	r3, r0
24013670:	f241 0203 	movw	r2, #4099	; 0x1003
24013674:	4293      	cmp	r3, r2
24013676:	d819      	bhi.n	240136ac <HAL_RCC_OscConfig+0x28c>
24013678:	687b      	ldr	r3, [r7, #4]
2401367a:	691b      	ldr	r3, [r3, #16]
2401367c:	2b40      	cmp	r3, #64	; 0x40
2401367e:	d108      	bne.n	24013692 <HAL_RCC_OscConfig+0x272>
24013680:	4b09      	ldr	r3, [pc, #36]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013682:	685b      	ldr	r3, [r3, #4]
24013684:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
24013688:	4a07      	ldr	r2, [pc, #28]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
2401368a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2401368e:	6053      	str	r3, [r2, #4]
24013690:	e030      	b.n	240136f4 <HAL_RCC_OscConfig+0x2d4>
24013692:	4b05      	ldr	r3, [pc, #20]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
24013694:	685b      	ldr	r3, [r3, #4]
24013696:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
2401369a:	687b      	ldr	r3, [r7, #4]
2401369c:	691b      	ldr	r3, [r3, #16]
2401369e:	031b      	lsls	r3, r3, #12
240136a0:	4901      	ldr	r1, [pc, #4]	; (240136a8 <HAL_RCC_OscConfig+0x288>)
240136a2:	4313      	orrs	r3, r2
240136a4:	604b      	str	r3, [r1, #4]
240136a6:	e025      	b.n	240136f4 <HAL_RCC_OscConfig+0x2d4>
240136a8:	58024400 	.word	0x58024400
240136ac:	4b9a      	ldr	r3, [pc, #616]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240136ae:	685b      	ldr	r3, [r3, #4]
240136b0:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
240136b4:	687b      	ldr	r3, [r7, #4]
240136b6:	691b      	ldr	r3, [r3, #16]
240136b8:	061b      	lsls	r3, r3, #24
240136ba:	4997      	ldr	r1, [pc, #604]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240136bc:	4313      	orrs	r3, r2
240136be:	604b      	str	r3, [r1, #4]
240136c0:	e018      	b.n	240136f4 <HAL_RCC_OscConfig+0x2d4>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
240136c2:	4b95      	ldr	r3, [pc, #596]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240136c4:	681b      	ldr	r3, [r3, #0]
240136c6:	4a94      	ldr	r2, [pc, #592]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240136c8:	f023 0301 	bic.w	r3, r3, #1
240136cc:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240136ce:	f7ee fca5 	bl	2400201c <HAL_GetTick>
240136d2:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
240136d4:	e008      	b.n	240136e8 <HAL_RCC_OscConfig+0x2c8>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
240136d6:	f7ee fca1 	bl	2400201c <HAL_GetTick>
240136da:	4602      	mov	r2, r0
240136dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240136de:	1ad3      	subs	r3, r2, r3
240136e0:	2b02      	cmp	r3, #2
240136e2:	d901      	bls.n	240136e8 <HAL_RCC_OscConfig+0x2c8>
          {
            return HAL_TIMEOUT;
240136e4:	2303      	movs	r3, #3
240136e6:	e2ed      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
240136e8:	4b8b      	ldr	r3, [pc, #556]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240136ea:	681b      	ldr	r3, [r3, #0]
240136ec:	f003 0304 	and.w	r3, r3, #4
240136f0:	2b00      	cmp	r3, #0
240136f2:	d1f0      	bne.n	240136d6 <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
240136f4:	687b      	ldr	r3, [r7, #4]
240136f6:	681b      	ldr	r3, [r3, #0]
240136f8:	f003 0310 	and.w	r3, r3, #16
240136fc:	2b00      	cmp	r3, #0
240136fe:	f000 80a9 	beq.w	24013854 <HAL_RCC_OscConfig+0x434>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24013702:	4b85      	ldr	r3, [pc, #532]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013704:	691b      	ldr	r3, [r3, #16]
24013706:	f003 0338 	and.w	r3, r3, #56	; 0x38
2401370a:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
2401370c:	4b82      	ldr	r3, [pc, #520]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401370e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013710:	617b      	str	r3, [r7, #20]
    if ((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
24013712:	69bb      	ldr	r3, [r7, #24]
24013714:	2b08      	cmp	r3, #8
24013716:	d007      	beq.n	24013728 <HAL_RCC_OscConfig+0x308>
24013718:	69bb      	ldr	r3, [r7, #24]
2401371a:	2b18      	cmp	r3, #24
2401371c:	d13a      	bne.n	24013794 <HAL_RCC_OscConfig+0x374>
2401371e:	697b      	ldr	r3, [r7, #20]
24013720:	f003 0303 	and.w	r3, r3, #3
24013724:	2b01      	cmp	r3, #1
24013726:	d135      	bne.n	24013794 <HAL_RCC_OscConfig+0x374>
    {
      /* When CSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
24013728:	4b7b      	ldr	r3, [pc, #492]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401372a:	681b      	ldr	r3, [r3, #0]
2401372c:	f403 7380 	and.w	r3, r3, #256	; 0x100
24013730:	2b00      	cmp	r3, #0
24013732:	d005      	beq.n	24013740 <HAL_RCC_OscConfig+0x320>
24013734:	687b      	ldr	r3, [r7, #4]
24013736:	69db      	ldr	r3, [r3, #28]
24013738:	2b80      	cmp	r3, #128	; 0x80
2401373a:	d001      	beq.n	24013740 <HAL_RCC_OscConfig+0x320>
      {
        return HAL_ERROR;
2401373c:	2301      	movs	r3, #1
2401373e:	e2c1      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
24013740:	f7ee fd06 	bl	24002150 <HAL_GetREVID>
24013744:	4603      	mov	r3, r0
24013746:	f241 0203 	movw	r2, #4099	; 0x1003
2401374a:	4293      	cmp	r3, r2
2401374c:	d817      	bhi.n	2401377e <HAL_RCC_OscConfig+0x35e>
2401374e:	687b      	ldr	r3, [r7, #4]
24013750:	6a1b      	ldr	r3, [r3, #32]
24013752:	2b20      	cmp	r3, #32
24013754:	d108      	bne.n	24013768 <HAL_RCC_OscConfig+0x348>
24013756:	4b70      	ldr	r3, [pc, #448]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013758:	685b      	ldr	r3, [r3, #4]
2401375a:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
2401375e:	4a6e      	ldr	r2, [pc, #440]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013760:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24013764:	6053      	str	r3, [r2, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
24013766:	e075      	b.n	24013854 <HAL_RCC_OscConfig+0x434>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
24013768:	4b6b      	ldr	r3, [pc, #428]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401376a:	685b      	ldr	r3, [r3, #4]
2401376c:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
24013770:	687b      	ldr	r3, [r7, #4]
24013772:	6a1b      	ldr	r3, [r3, #32]
24013774:	069b      	lsls	r3, r3, #26
24013776:	4968      	ldr	r1, [pc, #416]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013778:	4313      	orrs	r3, r2
2401377a:	604b      	str	r3, [r1, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
2401377c:	e06a      	b.n	24013854 <HAL_RCC_OscConfig+0x434>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
2401377e:	4b66      	ldr	r3, [pc, #408]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013780:	68db      	ldr	r3, [r3, #12]
24013782:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
24013786:	687b      	ldr	r3, [r7, #4]
24013788:	6a1b      	ldr	r3, [r3, #32]
2401378a:	061b      	lsls	r3, r3, #24
2401378c:	4962      	ldr	r1, [pc, #392]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401378e:	4313      	orrs	r3, r2
24013790:	60cb      	str	r3, [r1, #12]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
24013792:	e05f      	b.n	24013854 <HAL_RCC_OscConfig+0x434>
      }
    }
    else
    {
      /* Check the CSI State */
      if ((RCC_OscInitStruct->CSIState) != RCC_CSI_OFF)
24013794:	687b      	ldr	r3, [r7, #4]
24013796:	69db      	ldr	r3, [r3, #28]
24013798:	2b00      	cmp	r3, #0
2401379a:	d042      	beq.n	24013822 <HAL_RCC_OscConfig+0x402>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
2401379c:	4b5e      	ldr	r3, [pc, #376]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401379e:	681b      	ldr	r3, [r3, #0]
240137a0:	4a5d      	ldr	r2, [pc, #372]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240137a2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
240137a6:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240137a8:	f7ee fc38 	bl	2400201c <HAL_GetTick>
240137ac:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240137ae:	e008      	b.n	240137c2 <HAL_RCC_OscConfig+0x3a2>
        {
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
240137b0:	f7ee fc34 	bl	2400201c <HAL_GetTick>
240137b4:	4602      	mov	r2, r0
240137b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240137b8:	1ad3      	subs	r3, r2, r3
240137ba:	2b02      	cmp	r3, #2
240137bc:	d901      	bls.n	240137c2 <HAL_RCC_OscConfig+0x3a2>
          {
            return HAL_TIMEOUT;
240137be:	2303      	movs	r3, #3
240137c0:	e280      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240137c2:	4b55      	ldr	r3, [pc, #340]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240137c4:	681b      	ldr	r3, [r3, #0]
240137c6:	f403 7380 	and.w	r3, r3, #256	; 0x100
240137ca:	2b00      	cmp	r3, #0
240137cc:	d0f0      	beq.n	240137b0 <HAL_RCC_OscConfig+0x390>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
240137ce:	f7ee fcbf 	bl	24002150 <HAL_GetREVID>
240137d2:	4603      	mov	r3, r0
240137d4:	f241 0203 	movw	r2, #4099	; 0x1003
240137d8:	4293      	cmp	r3, r2
240137da:	d817      	bhi.n	2401380c <HAL_RCC_OscConfig+0x3ec>
240137dc:	687b      	ldr	r3, [r7, #4]
240137de:	6a1b      	ldr	r3, [r3, #32]
240137e0:	2b20      	cmp	r3, #32
240137e2:	d108      	bne.n	240137f6 <HAL_RCC_OscConfig+0x3d6>
240137e4:	4b4c      	ldr	r3, [pc, #304]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240137e6:	685b      	ldr	r3, [r3, #4]
240137e8:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
240137ec:	4a4a      	ldr	r2, [pc, #296]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240137ee:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
240137f2:	6053      	str	r3, [r2, #4]
240137f4:	e02e      	b.n	24013854 <HAL_RCC_OscConfig+0x434>
240137f6:	4b48      	ldr	r3, [pc, #288]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240137f8:	685b      	ldr	r3, [r3, #4]
240137fa:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
240137fe:	687b      	ldr	r3, [r7, #4]
24013800:	6a1b      	ldr	r3, [r3, #32]
24013802:	069b      	lsls	r3, r3, #26
24013804:	4944      	ldr	r1, [pc, #272]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013806:	4313      	orrs	r3, r2
24013808:	604b      	str	r3, [r1, #4]
2401380a:	e023      	b.n	24013854 <HAL_RCC_OscConfig+0x434>
2401380c:	4b42      	ldr	r3, [pc, #264]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401380e:	68db      	ldr	r3, [r3, #12]
24013810:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
24013814:	687b      	ldr	r3, [r7, #4]
24013816:	6a1b      	ldr	r3, [r3, #32]
24013818:	061b      	lsls	r3, r3, #24
2401381a:	493f      	ldr	r1, [pc, #252]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401381c:	4313      	orrs	r3, r2
2401381e:	60cb      	str	r3, [r1, #12]
24013820:	e018      	b.n	24013854 <HAL_RCC_OscConfig+0x434>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
24013822:	4b3d      	ldr	r3, [pc, #244]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013824:	681b      	ldr	r3, [r3, #0]
24013826:	4a3c      	ldr	r2, [pc, #240]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013828:	f023 0380 	bic.w	r3, r3, #128	; 0x80
2401382c:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2401382e:	f7ee fbf5 	bl	2400201c <HAL_GetTick>
24013832:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
24013834:	e008      	b.n	24013848 <HAL_RCC_OscConfig+0x428>
        {
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
24013836:	f7ee fbf1 	bl	2400201c <HAL_GetTick>
2401383a:	4602      	mov	r2, r0
2401383c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401383e:	1ad3      	subs	r3, r2, r3
24013840:	2b02      	cmp	r3, #2
24013842:	d901      	bls.n	24013848 <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
24013844:	2303      	movs	r3, #3
24013846:	e23d      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
24013848:	4b33      	ldr	r3, [pc, #204]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401384a:	681b      	ldr	r3, [r3, #0]
2401384c:	f403 7380 	and.w	r3, r3, #256	; 0x100
24013850:	2b00      	cmp	r3, #0
24013852:	d1f0      	bne.n	24013836 <HAL_RCC_OscConfig+0x416>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
24013854:	687b      	ldr	r3, [r7, #4]
24013856:	681b      	ldr	r3, [r3, #0]
24013858:	f003 0308 	and.w	r3, r3, #8
2401385c:	2b00      	cmp	r3, #0
2401385e:	d036      	beq.n	240138ce <HAL_RCC_OscConfig+0x4ae>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
24013860:	687b      	ldr	r3, [r7, #4]
24013862:	695b      	ldr	r3, [r3, #20]
24013864:	2b00      	cmp	r3, #0
24013866:	d019      	beq.n	2401389c <HAL_RCC_OscConfig+0x47c>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
24013868:	4b2b      	ldr	r3, [pc, #172]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401386a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2401386c:	4a2a      	ldr	r2, [pc, #168]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401386e:	f043 0301 	orr.w	r3, r3, #1
24013872:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24013874:	f7ee fbd2 	bl	2400201c <HAL_GetTick>
24013878:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
2401387a:	e008      	b.n	2401388e <HAL_RCC_OscConfig+0x46e>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
2401387c:	f7ee fbce 	bl	2400201c <HAL_GetTick>
24013880:	4602      	mov	r2, r0
24013882:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013884:	1ad3      	subs	r3, r2, r3
24013886:	2b02      	cmp	r3, #2
24013888:	d901      	bls.n	2401388e <HAL_RCC_OscConfig+0x46e>
        {
          return HAL_TIMEOUT;
2401388a:	2303      	movs	r3, #3
2401388c:	e21a      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
2401388e:	4b22      	ldr	r3, [pc, #136]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
24013890:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24013892:	f003 0302 	and.w	r3, r3, #2
24013896:	2b00      	cmp	r3, #0
24013898:	d0f0      	beq.n	2401387c <HAL_RCC_OscConfig+0x45c>
2401389a:	e018      	b.n	240138ce <HAL_RCC_OscConfig+0x4ae>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
2401389c:	4b1e      	ldr	r3, [pc, #120]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401389e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
240138a0:	4a1d      	ldr	r2, [pc, #116]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240138a2:	f023 0301 	bic.w	r3, r3, #1
240138a6:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
240138a8:	f7ee fbb8 	bl	2400201c <HAL_GetTick>
240138ac:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
240138ae:	e008      	b.n	240138c2 <HAL_RCC_OscConfig+0x4a2>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
240138b0:	f7ee fbb4 	bl	2400201c <HAL_GetTick>
240138b4:	4602      	mov	r2, r0
240138b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240138b8:	1ad3      	subs	r3, r2, r3
240138ba:	2b02      	cmp	r3, #2
240138bc:	d901      	bls.n	240138c2 <HAL_RCC_OscConfig+0x4a2>
        {
          return HAL_TIMEOUT;
240138be:	2303      	movs	r3, #3
240138c0:	e200      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
240138c2:	4b15      	ldr	r3, [pc, #84]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240138c4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
240138c6:	f003 0302 	and.w	r3, r3, #2
240138ca:	2b00      	cmp	r3, #0
240138cc:	d1f0      	bne.n	240138b0 <HAL_RCC_OscConfig+0x490>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
240138ce:	687b      	ldr	r3, [r7, #4]
240138d0:	681b      	ldr	r3, [r3, #0]
240138d2:	f003 0320 	and.w	r3, r3, #32
240138d6:	2b00      	cmp	r3, #0
240138d8:	d039      	beq.n	2401394e <HAL_RCC_OscConfig+0x52e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if ((RCC_OscInitStruct->HSI48State) != RCC_HSI48_OFF)
240138da:	687b      	ldr	r3, [r7, #4]
240138dc:	699b      	ldr	r3, [r3, #24]
240138de:	2b00      	cmp	r3, #0
240138e0:	d01c      	beq.n	2401391c <HAL_RCC_OscConfig+0x4fc>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
240138e2:	4b0d      	ldr	r3, [pc, #52]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240138e4:	681b      	ldr	r3, [r3, #0]
240138e6:	4a0c      	ldr	r2, [pc, #48]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
240138e8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
240138ec:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
240138ee:	f7ee fb95 	bl	2400201c <HAL_GetTick>
240138f2:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
240138f4:	e008      	b.n	24013908 <HAL_RCC_OscConfig+0x4e8>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
240138f6:	f7ee fb91 	bl	2400201c <HAL_GetTick>
240138fa:	4602      	mov	r2, r0
240138fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240138fe:	1ad3      	subs	r3, r2, r3
24013900:	2b02      	cmp	r3, #2
24013902:	d901      	bls.n	24013908 <HAL_RCC_OscConfig+0x4e8>
        {
          return HAL_TIMEOUT;
24013904:	2303      	movs	r3, #3
24013906:	e1dd      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
24013908:	4b03      	ldr	r3, [pc, #12]	; (24013918 <HAL_RCC_OscConfig+0x4f8>)
2401390a:	681b      	ldr	r3, [r3, #0]
2401390c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24013910:	2b00      	cmp	r3, #0
24013912:	d0f0      	beq.n	240138f6 <HAL_RCC_OscConfig+0x4d6>
24013914:	e01b      	b.n	2401394e <HAL_RCC_OscConfig+0x52e>
24013916:	bf00      	nop
24013918:	58024400 	.word	0x58024400
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
2401391c:	4b9b      	ldr	r3, [pc, #620]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
2401391e:	681b      	ldr	r3, [r3, #0]
24013920:	4a9a      	ldr	r2, [pc, #616]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013922:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
24013926:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
24013928:	f7ee fb78 	bl	2400201c <HAL_GetTick>
2401392c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
2401392e:	e008      	b.n	24013942 <HAL_RCC_OscConfig+0x522>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
24013930:	f7ee fb74 	bl	2400201c <HAL_GetTick>
24013934:	4602      	mov	r2, r0
24013936:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013938:	1ad3      	subs	r3, r2, r3
2401393a:	2b02      	cmp	r3, #2
2401393c:	d901      	bls.n	24013942 <HAL_RCC_OscConfig+0x522>
        {
          return HAL_TIMEOUT;
2401393e:	2303      	movs	r3, #3
24013940:	e1c0      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
24013942:	4b92      	ldr	r3, [pc, #584]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013944:	681b      	ldr	r3, [r3, #0]
24013946:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2401394a:	2b00      	cmp	r3, #0
2401394c:	d1f0      	bne.n	24013930 <HAL_RCC_OscConfig+0x510>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
2401394e:	687b      	ldr	r3, [r7, #4]
24013950:	681b      	ldr	r3, [r3, #0]
24013952:	f003 0304 	and.w	r3, r3, #4
24013956:	2b00      	cmp	r3, #0
24013958:	f000 8081 	beq.w	24013a5e <HAL_RCC_OscConfig+0x63e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
2401395c:	4b8c      	ldr	r3, [pc, #560]	; (24013b90 <HAL_RCC_OscConfig+0x770>)
2401395e:	681b      	ldr	r3, [r3, #0]
24013960:	4a8b      	ldr	r2, [pc, #556]	; (24013b90 <HAL_RCC_OscConfig+0x770>)
24013962:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24013966:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
24013968:	f7ee fb58 	bl	2400201c <HAL_GetTick>
2401396c:	6278      	str	r0, [r7, #36]	; 0x24

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
2401396e:	e008      	b.n	24013982 <HAL_RCC_OscConfig+0x562>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
24013970:	f7ee fb54 	bl	2400201c <HAL_GetTick>
24013974:	4602      	mov	r2, r0
24013976:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013978:	1ad3      	subs	r3, r2, r3
2401397a:	2b64      	cmp	r3, #100	; 0x64
2401397c:	d901      	bls.n	24013982 <HAL_RCC_OscConfig+0x562>
      {
        return HAL_TIMEOUT;
2401397e:	2303      	movs	r3, #3
24013980:	e1a0      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
24013982:	4b83      	ldr	r3, [pc, #524]	; (24013b90 <HAL_RCC_OscConfig+0x770>)
24013984:	681b      	ldr	r3, [r3, #0]
24013986:	f403 7380 	and.w	r3, r3, #256	; 0x100
2401398a:	2b00      	cmp	r3, #0
2401398c:	d0f0      	beq.n	24013970 <HAL_RCC_OscConfig+0x550>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
2401398e:	687b      	ldr	r3, [r7, #4]
24013990:	689b      	ldr	r3, [r3, #8]
24013992:	2b01      	cmp	r3, #1
24013994:	d106      	bne.n	240139a4 <HAL_RCC_OscConfig+0x584>
24013996:	4b7d      	ldr	r3, [pc, #500]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013998:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401399a:	4a7c      	ldr	r2, [pc, #496]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
2401399c:	f043 0301 	orr.w	r3, r3, #1
240139a0:	6713      	str	r3, [r2, #112]	; 0x70
240139a2:	e02d      	b.n	24013a00 <HAL_RCC_OscConfig+0x5e0>
240139a4:	687b      	ldr	r3, [r7, #4]
240139a6:	689b      	ldr	r3, [r3, #8]
240139a8:	2b00      	cmp	r3, #0
240139aa:	d10c      	bne.n	240139c6 <HAL_RCC_OscConfig+0x5a6>
240139ac:	4b77      	ldr	r3, [pc, #476]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139ae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240139b0:	4a76      	ldr	r2, [pc, #472]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139b2:	f023 0301 	bic.w	r3, r3, #1
240139b6:	6713      	str	r3, [r2, #112]	; 0x70
240139b8:	4b74      	ldr	r3, [pc, #464]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139ba:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240139bc:	4a73      	ldr	r2, [pc, #460]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139be:	f023 0304 	bic.w	r3, r3, #4
240139c2:	6713      	str	r3, [r2, #112]	; 0x70
240139c4:	e01c      	b.n	24013a00 <HAL_RCC_OscConfig+0x5e0>
240139c6:	687b      	ldr	r3, [r7, #4]
240139c8:	689b      	ldr	r3, [r3, #8]
240139ca:	2b05      	cmp	r3, #5
240139cc:	d10c      	bne.n	240139e8 <HAL_RCC_OscConfig+0x5c8>
240139ce:	4b6f      	ldr	r3, [pc, #444]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240139d2:	4a6e      	ldr	r2, [pc, #440]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139d4:	f043 0304 	orr.w	r3, r3, #4
240139d8:	6713      	str	r3, [r2, #112]	; 0x70
240139da:	4b6c      	ldr	r3, [pc, #432]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139dc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240139de:	4a6b      	ldr	r2, [pc, #428]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139e0:	f043 0301 	orr.w	r3, r3, #1
240139e4:	6713      	str	r3, [r2, #112]	; 0x70
240139e6:	e00b      	b.n	24013a00 <HAL_RCC_OscConfig+0x5e0>
240139e8:	4b68      	ldr	r3, [pc, #416]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240139ec:	4a67      	ldr	r2, [pc, #412]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139ee:	f023 0301 	bic.w	r3, r3, #1
240139f2:	6713      	str	r3, [r2, #112]	; 0x70
240139f4:	4b65      	ldr	r3, [pc, #404]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139f6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240139f8:	4a64      	ldr	r2, [pc, #400]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
240139fa:	f023 0304 	bic.w	r3, r3, #4
240139fe:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
24013a00:	687b      	ldr	r3, [r7, #4]
24013a02:	689b      	ldr	r3, [r3, #8]
24013a04:	2b00      	cmp	r3, #0
24013a06:	d015      	beq.n	24013a34 <HAL_RCC_OscConfig+0x614>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24013a08:	f7ee fb08 	bl	2400201c <HAL_GetTick>
24013a0c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
24013a0e:	e00a      	b.n	24013a26 <HAL_RCC_OscConfig+0x606>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
24013a10:	f7ee fb04 	bl	2400201c <HAL_GetTick>
24013a14:	4602      	mov	r2, r0
24013a16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013a18:	1ad3      	subs	r3, r2, r3
24013a1a:	f241 3288 	movw	r2, #5000	; 0x1388
24013a1e:	4293      	cmp	r3, r2
24013a20:	d901      	bls.n	24013a26 <HAL_RCC_OscConfig+0x606>
        {
          return HAL_TIMEOUT;
24013a22:	2303      	movs	r3, #3
24013a24:	e14e      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
24013a26:	4b59      	ldr	r3, [pc, #356]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013a28:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013a2a:	f003 0302 	and.w	r3, r3, #2
24013a2e:	2b00      	cmp	r3, #0
24013a30:	d0ee      	beq.n	24013a10 <HAL_RCC_OscConfig+0x5f0>
24013a32:	e014      	b.n	24013a5e <HAL_RCC_OscConfig+0x63e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24013a34:	f7ee faf2 	bl	2400201c <HAL_GetTick>
24013a38:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
24013a3a:	e00a      	b.n	24013a52 <HAL_RCC_OscConfig+0x632>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
24013a3c:	f7ee faee 	bl	2400201c <HAL_GetTick>
24013a40:	4602      	mov	r2, r0
24013a42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013a44:	1ad3      	subs	r3, r2, r3
24013a46:	f241 3288 	movw	r2, #5000	; 0x1388
24013a4a:	4293      	cmp	r3, r2
24013a4c:	d901      	bls.n	24013a52 <HAL_RCC_OscConfig+0x632>
        {
          return HAL_TIMEOUT;
24013a4e:	2303      	movs	r3, #3
24013a50:	e138      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
24013a52:	4b4e      	ldr	r3, [pc, #312]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013a54:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013a56:	f003 0302 	and.w	r3, r3, #2
24013a5a:	2b00      	cmp	r3, #0
24013a5c:	d1ee      	bne.n	24013a3c <HAL_RCC_OscConfig+0x61c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
24013a5e:	687b      	ldr	r3, [r7, #4]
24013a60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24013a62:	2b00      	cmp	r3, #0
24013a64:	f000 812d 	beq.w	24013cc2 <HAL_RCC_OscConfig+0x8a2>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
24013a68:	4b48      	ldr	r3, [pc, #288]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013a6a:	691b      	ldr	r3, [r3, #16]
24013a6c:	f003 0338 	and.w	r3, r3, #56	; 0x38
24013a70:	2b18      	cmp	r3, #24
24013a72:	f000 80bd 	beq.w	24013bf0 <HAL_RCC_OscConfig+0x7d0>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
24013a76:	687b      	ldr	r3, [r7, #4]
24013a78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24013a7a:	2b02      	cmp	r3, #2
24013a7c:	f040 809e 	bne.w	24013bbc <HAL_RCC_OscConfig+0x79c>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
24013a80:	4b42      	ldr	r3, [pc, #264]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013a82:	681b      	ldr	r3, [r3, #0]
24013a84:	4a41      	ldr	r2, [pc, #260]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013a86:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
24013a8a:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013a8c:	f7ee fac6 	bl	2400201c <HAL_GetTick>
24013a90:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
24013a92:	e008      	b.n	24013aa6 <HAL_RCC_OscConfig+0x686>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24013a94:	f7ee fac2 	bl	2400201c <HAL_GetTick>
24013a98:	4602      	mov	r2, r0
24013a9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013a9c:	1ad3      	subs	r3, r2, r3
24013a9e:	2b02      	cmp	r3, #2
24013aa0:	d901      	bls.n	24013aa6 <HAL_RCC_OscConfig+0x686>
          {
            return HAL_TIMEOUT;
24013aa2:	2303      	movs	r3, #3
24013aa4:	e10e      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
24013aa6:	4b39      	ldr	r3, [pc, #228]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013aa8:	681b      	ldr	r3, [r3, #0]
24013aaa:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24013aae:	2b00      	cmp	r3, #0
24013ab0:	d1f0      	bne.n	24013a94 <HAL_RCC_OscConfig+0x674>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
24013ab2:	4b36      	ldr	r3, [pc, #216]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013ab4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24013ab6:	4b37      	ldr	r3, [pc, #220]	; (24013b94 <HAL_RCC_OscConfig+0x774>)
24013ab8:	4013      	ands	r3, r2
24013aba:	687a      	ldr	r2, [r7, #4]
24013abc:	6a91      	ldr	r1, [r2, #40]	; 0x28
24013abe:	687a      	ldr	r2, [r7, #4]
24013ac0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
24013ac2:	0112      	lsls	r2, r2, #4
24013ac4:	430a      	orrs	r2, r1
24013ac6:	4931      	ldr	r1, [pc, #196]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013ac8:	4313      	orrs	r3, r2
24013aca:	628b      	str	r3, [r1, #40]	; 0x28
24013acc:	687b      	ldr	r3, [r7, #4]
24013ace:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013ad0:	3b01      	subs	r3, #1
24013ad2:	f3c3 0208 	ubfx	r2, r3, #0, #9
24013ad6:	687b      	ldr	r3, [r7, #4]
24013ad8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24013ada:	3b01      	subs	r3, #1
24013adc:	025b      	lsls	r3, r3, #9
24013ade:	b29b      	uxth	r3, r3
24013ae0:	431a      	orrs	r2, r3
24013ae2:	687b      	ldr	r3, [r7, #4]
24013ae4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013ae6:	3b01      	subs	r3, #1
24013ae8:	041b      	lsls	r3, r3, #16
24013aea:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
24013aee:	431a      	orrs	r2, r3
24013af0:	687b      	ldr	r3, [r7, #4]
24013af2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24013af4:	3b01      	subs	r3, #1
24013af6:	061b      	lsls	r3, r3, #24
24013af8:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
24013afc:	4923      	ldr	r1, [pc, #140]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013afe:	4313      	orrs	r3, r2
24013b00:	630b      	str	r3, [r1, #48]	; 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Disable PLLFRACN . */
        __HAL_RCC_PLLFRACN_DISABLE();
24013b02:	4b22      	ldr	r3, [pc, #136]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013b06:	4a21      	ldr	r2, [pc, #132]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b08:	f023 0301 	bic.w	r3, r3, #1
24013b0c:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Configure PLL PLL1FRACN */
        __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
24013b0e:	4b1f      	ldr	r3, [pc, #124]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b10:	6b5a      	ldr	r2, [r3, #52]	; 0x34
24013b12:	4b21      	ldr	r3, [pc, #132]	; (24013b98 <HAL_RCC_OscConfig+0x778>)
24013b14:	4013      	ands	r3, r2
24013b16:	687a      	ldr	r2, [r7, #4]
24013b18:	6c92      	ldr	r2, [r2, #72]	; 0x48
24013b1a:	00d2      	lsls	r2, r2, #3
24013b1c:	491b      	ldr	r1, [pc, #108]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b1e:	4313      	orrs	r3, r2
24013b20:	634b      	str	r3, [r1, #52]	; 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
24013b22:	4b1a      	ldr	r3, [pc, #104]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013b26:	f023 020c 	bic.w	r2, r3, #12
24013b2a:	687b      	ldr	r3, [r7, #4]
24013b2c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013b2e:	4917      	ldr	r1, [pc, #92]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b30:	4313      	orrs	r3, r2
24013b32:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
24013b34:	4b15      	ldr	r3, [pc, #84]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013b38:	f023 0202 	bic.w	r2, r3, #2
24013b3c:	687b      	ldr	r3, [r7, #4]
24013b3e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24013b40:	4912      	ldr	r1, [pc, #72]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b42:	4313      	orrs	r3, r2
24013b44:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Enable PLL System Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
24013b46:	4b11      	ldr	r3, [pc, #68]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013b4a:	4a10      	ldr	r2, [pc, #64]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b4c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24013b50:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1Q Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013b52:	4b0e      	ldr	r3, [pc, #56]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013b56:	4a0d      	ldr	r2, [pc, #52]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b58:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013b5c:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1R  Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
24013b5e:	4b0b      	ldr	r3, [pc, #44]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013b62:	4a0a      	ldr	r2, [pc, #40]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b64:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24013b68:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1FRACN . */
        __HAL_RCC_PLLFRACN_ENABLE();
24013b6a:	4b08      	ldr	r3, [pc, #32]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013b6e:	4a07      	ldr	r2, [pc, #28]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b70:	f043 0301 	orr.w	r3, r3, #1
24013b74:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
24013b76:	4b05      	ldr	r3, [pc, #20]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b78:	681b      	ldr	r3, [r3, #0]
24013b7a:	4a04      	ldr	r2, [pc, #16]	; (24013b8c <HAL_RCC_OscConfig+0x76c>)
24013b7c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
24013b80:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013b82:	f7ee fa4b 	bl	2400201c <HAL_GetTick>
24013b86:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24013b88:	e011      	b.n	24013bae <HAL_RCC_OscConfig+0x78e>
24013b8a:	bf00      	nop
24013b8c:	58024400 	.word	0x58024400
24013b90:	58024800 	.word	0x58024800
24013b94:	fffffc0c 	.word	0xfffffc0c
24013b98:	ffff0007 	.word	0xffff0007
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24013b9c:	f7ee fa3e 	bl	2400201c <HAL_GetTick>
24013ba0:	4602      	mov	r2, r0
24013ba2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013ba4:	1ad3      	subs	r3, r2, r3
24013ba6:	2b02      	cmp	r3, #2
24013ba8:	d901      	bls.n	24013bae <HAL_RCC_OscConfig+0x78e>
          {
            return HAL_TIMEOUT;
24013baa:	2303      	movs	r3, #3
24013bac:	e08a      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24013bae:	4b47      	ldr	r3, [pc, #284]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013bb0:	681b      	ldr	r3, [r3, #0]
24013bb2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24013bb6:	2b00      	cmp	r3, #0
24013bb8:	d0f0      	beq.n	24013b9c <HAL_RCC_OscConfig+0x77c>
24013bba:	e082      	b.n	24013cc2 <HAL_RCC_OscConfig+0x8a2>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
24013bbc:	4b43      	ldr	r3, [pc, #268]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013bbe:	681b      	ldr	r3, [r3, #0]
24013bc0:	4a42      	ldr	r2, [pc, #264]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013bc2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
24013bc6:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013bc8:	f7ee fa28 	bl	2400201c <HAL_GetTick>
24013bcc:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
24013bce:	e008      	b.n	24013be2 <HAL_RCC_OscConfig+0x7c2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24013bd0:	f7ee fa24 	bl	2400201c <HAL_GetTick>
24013bd4:	4602      	mov	r2, r0
24013bd6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013bd8:	1ad3      	subs	r3, r2, r3
24013bda:	2b02      	cmp	r3, #2
24013bdc:	d901      	bls.n	24013be2 <HAL_RCC_OscConfig+0x7c2>
          {
            return HAL_TIMEOUT;
24013bde:	2303      	movs	r3, #3
24013be0:	e070      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
24013be2:	4b3a      	ldr	r3, [pc, #232]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013be4:	681b      	ldr	r3, [r3, #0]
24013be6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24013bea:	2b00      	cmp	r3, #0
24013bec:	d1f0      	bne.n	24013bd0 <HAL_RCC_OscConfig+0x7b0>
24013bee:	e068      	b.n	24013cc2 <HAL_RCC_OscConfig+0x8a2>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
24013bf0:	4b36      	ldr	r3, [pc, #216]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013bf2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013bf4:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
24013bf6:	4b35      	ldr	r3, [pc, #212]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013bf8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013bfa:	60fb      	str	r3, [r7, #12]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
24013bfc:	687b      	ldr	r3, [r7, #4]
24013bfe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24013c00:	2b01      	cmp	r3, #1
24013c02:	d031      	beq.n	24013c68 <HAL_RCC_OscConfig+0x848>
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
24013c04:	693b      	ldr	r3, [r7, #16]
24013c06:	f003 0203 	and.w	r2, r3, #3
24013c0a:	687b      	ldr	r3, [r7, #4]
24013c0c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
24013c0e:	429a      	cmp	r2, r3
24013c10:	d12a      	bne.n	24013c68 <HAL_RCC_OscConfig+0x848>
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
24013c12:	693b      	ldr	r3, [r7, #16]
24013c14:	091b      	lsrs	r3, r3, #4
24013c16:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24013c1a:	687b      	ldr	r3, [r7, #4]
24013c1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
24013c1e:	429a      	cmp	r2, r3
24013c20:	d122      	bne.n	24013c68 <HAL_RCC_OscConfig+0x848>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24013c22:	68fb      	ldr	r3, [r7, #12]
24013c24:	f3c3 0208 	ubfx	r2, r3, #0, #9
24013c28:	687b      	ldr	r3, [r7, #4]
24013c2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013c2c:	3b01      	subs	r3, #1
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
24013c2e:	429a      	cmp	r2, r3
24013c30:	d11a      	bne.n	24013c68 <HAL_RCC_OscConfig+0x848>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24013c32:	68fb      	ldr	r3, [r7, #12]
24013c34:	0a5b      	lsrs	r3, r3, #9
24013c36:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24013c3a:	687b      	ldr	r3, [r7, #4]
24013c3c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24013c3e:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24013c40:	429a      	cmp	r2, r3
24013c42:	d111      	bne.n	24013c68 <HAL_RCC_OscConfig+0x848>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
24013c44:	68fb      	ldr	r3, [r7, #12]
24013c46:	0c1b      	lsrs	r3, r3, #16
24013c48:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24013c4c:	687b      	ldr	r3, [r7, #4]
24013c4e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013c50:	3b01      	subs	r3, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24013c52:	429a      	cmp	r2, r3
24013c54:	d108      	bne.n	24013c68 <HAL_RCC_OscConfig+0x848>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
24013c56:	68fb      	ldr	r3, [r7, #12]
24013c58:	0e1b      	lsrs	r3, r3, #24
24013c5a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24013c5e:	687b      	ldr	r3, [r7, #4]
24013c60:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24013c62:	3b01      	subs	r3, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
24013c64:	429a      	cmp	r2, r3
24013c66:	d001      	beq.n	24013c6c <HAL_RCC_OscConfig+0x84c>
      {
        return HAL_ERROR;
24013c68:	2301      	movs	r3, #1
24013c6a:	e02b      	b.n	24013cc4 <HAL_RCC_OscConfig+0x8a4>
      }
      else
      {
        /* Check if only fractional part needs to be updated  */
        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);
24013c6c:	4b17      	ldr	r3, [pc, #92]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013c6e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24013c70:	08db      	lsrs	r3, r3, #3
24013c72:	f3c3 030c 	ubfx	r3, r3, #0, #13
24013c76:	613b      	str	r3, [r7, #16]
        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)
24013c78:	687b      	ldr	r3, [r7, #4]
24013c7a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24013c7c:	693a      	ldr	r2, [r7, #16]
24013c7e:	429a      	cmp	r2, r3
24013c80:	d01f      	beq.n	24013cc2 <HAL_RCC_OscConfig+0x8a2>
        {
          assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
          /* Disable PLL1FRACEN */
          __HAL_RCC_PLLFRACN_DISABLE();
24013c82:	4b12      	ldr	r3, [pc, #72]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013c84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013c86:	4a11      	ldr	r2, [pc, #68]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013c88:	f023 0301 	bic.w	r3, r3, #1
24013c8c:	62d3      	str	r3, [r2, #44]	; 0x2c
          /* Get Start Tick*/
          tickstart = HAL_GetTick();
24013c8e:	f7ee f9c5 	bl	2400201c <HAL_GetTick>
24013c92:	6278      	str	r0, [r7, #36]	; 0x24
          /* Wait at least 2 CK_REF (PLL input source divided by M) period to make sure next latched value will be taken into account. */
          while ((HAL_GetTick() - tickstart) < PLL_FRAC_TIMEOUT_VALUE)
24013c94:	bf00      	nop
24013c96:	f7ee f9c1 	bl	2400201c <HAL_GetTick>
24013c9a:	4602      	mov	r2, r0
24013c9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013c9e:	4293      	cmp	r3, r2
24013ca0:	d0f9      	beq.n	24013c96 <HAL_RCC_OscConfig+0x876>
          {
          }
          /* Configure PLL1 PLL1FRACN */
          __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
24013ca2:	4b0a      	ldr	r3, [pc, #40]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013ca4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
24013ca6:	4b0a      	ldr	r3, [pc, #40]	; (24013cd0 <HAL_RCC_OscConfig+0x8b0>)
24013ca8:	4013      	ands	r3, r2
24013caa:	687a      	ldr	r2, [r7, #4]
24013cac:	6c92      	ldr	r2, [r2, #72]	; 0x48
24013cae:	00d2      	lsls	r2, r2, #3
24013cb0:	4906      	ldr	r1, [pc, #24]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013cb2:	4313      	orrs	r3, r2
24013cb4:	634b      	str	r3, [r1, #52]	; 0x34
          /* Enable PLL1FRACEN to latch new value. */
          __HAL_RCC_PLLFRACN_ENABLE();
24013cb6:	4b05      	ldr	r3, [pc, #20]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013cb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013cba:	4a04      	ldr	r2, [pc, #16]	; (24013ccc <HAL_RCC_OscConfig+0x8ac>)
24013cbc:	f043 0301 	orr.w	r3, r3, #1
24013cc0:	62d3      	str	r3, [r2, #44]	; 0x2c
        }
      }
    }
  }
  return HAL_OK;
24013cc2:	2300      	movs	r3, #0
}
24013cc4:	4618      	mov	r0, r3
24013cc6:	3730      	adds	r7, #48	; 0x30
24013cc8:	46bd      	mov	sp, r7
24013cca:	bd80      	pop	{r7, pc}
24013ccc:	58024400 	.word	0x58024400
24013cd0:	ffff0007 	.word	0xffff0007

24013cd4 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
24013cd4:	b580      	push	{r7, lr}
24013cd6:	b086      	sub	sp, #24
24013cd8:	af00      	add	r7, sp, #0
24013cda:	6078      	str	r0, [r7, #4]
24013cdc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
24013cde:	687b      	ldr	r3, [r7, #4]
24013ce0:	2b00      	cmp	r3, #0
24013ce2:	d101      	bne.n	24013ce8 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
24013ce4:	2301      	movs	r3, #1
24013ce6:	e19c      	b.n	24014022 <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
24013ce8:	4b8a      	ldr	r3, [pc, #552]	; (24013f14 <HAL_RCC_ClockConfig+0x240>)
24013cea:	681b      	ldr	r3, [r3, #0]
24013cec:	f003 030f 	and.w	r3, r3, #15
24013cf0:	683a      	ldr	r2, [r7, #0]
24013cf2:	429a      	cmp	r2, r3
24013cf4:	d910      	bls.n	24013d18 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
24013cf6:	4b87      	ldr	r3, [pc, #540]	; (24013f14 <HAL_RCC_ClockConfig+0x240>)
24013cf8:	681b      	ldr	r3, [r3, #0]
24013cfa:	f023 020f 	bic.w	r2, r3, #15
24013cfe:	4985      	ldr	r1, [pc, #532]	; (24013f14 <HAL_RCC_ClockConfig+0x240>)
24013d00:	683b      	ldr	r3, [r7, #0]
24013d02:	4313      	orrs	r3, r2
24013d04:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
24013d06:	4b83      	ldr	r3, [pc, #524]	; (24013f14 <HAL_RCC_ClockConfig+0x240>)
24013d08:	681b      	ldr	r3, [r3, #0]
24013d0a:	f003 030f 	and.w	r3, r3, #15
24013d0e:	683a      	ldr	r2, [r7, #0]
24013d10:	429a      	cmp	r2, r3
24013d12:	d001      	beq.n	24013d18 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
24013d14:	2301      	movs	r3, #1
24013d16:	e184      	b.n	24014022 <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
24013d18:	687b      	ldr	r3, [r7, #4]
24013d1a:	681b      	ldr	r3, [r3, #0]
24013d1c:	f003 0304 	and.w	r3, r3, #4
24013d20:	2b00      	cmp	r3, #0
24013d22:	d010      	beq.n	24013d46 <HAL_RCC_ClockConfig+0x72>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if ((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
24013d24:	687b      	ldr	r3, [r7, #4]
24013d26:	691a      	ldr	r2, [r3, #16]
24013d28:	4b7b      	ldr	r3, [pc, #492]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d2a:	699b      	ldr	r3, [r3, #24]
24013d2c:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013d30:	429a      	cmp	r2, r3
24013d32:	d908      	bls.n	24013d46 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
24013d34:	4b78      	ldr	r3, [pc, #480]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d36:	699b      	ldr	r3, [r3, #24]
24013d38:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013d3c:	687b      	ldr	r3, [r7, #4]
24013d3e:	691b      	ldr	r3, [r3, #16]
24013d40:	4975      	ldr	r1, [pc, #468]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d42:	4313      	orrs	r3, r2
24013d44:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
24013d46:	687b      	ldr	r3, [r7, #4]
24013d48:	681b      	ldr	r3, [r3, #0]
24013d4a:	f003 0308 	and.w	r3, r3, #8
24013d4e:	2b00      	cmp	r3, #0
24013d50:	d010      	beq.n	24013d74 <HAL_RCC_ClockConfig+0xa0>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if ((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
24013d52:	687b      	ldr	r3, [r7, #4]
24013d54:	695a      	ldr	r2, [r3, #20]
24013d56:	4b70      	ldr	r3, [pc, #448]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d58:	69db      	ldr	r3, [r3, #28]
24013d5a:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013d5e:	429a      	cmp	r2, r3
24013d60:	d908      	bls.n	24013d74 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
24013d62:	4b6d      	ldr	r3, [pc, #436]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d64:	69db      	ldr	r3, [r3, #28]
24013d66:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013d6a:	687b      	ldr	r3, [r7, #4]
24013d6c:	695b      	ldr	r3, [r3, #20]
24013d6e:	496a      	ldr	r1, [pc, #424]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d70:	4313      	orrs	r3, r2
24013d72:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    }
#endif
  }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
24013d74:	687b      	ldr	r3, [r7, #4]
24013d76:	681b      	ldr	r3, [r3, #0]
24013d78:	f003 0310 	and.w	r3, r3, #16
24013d7c:	2b00      	cmp	r3, #0
24013d7e:	d010      	beq.n	24013da2 <HAL_RCC_ClockConfig+0xce>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if ((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24013d80:	687b      	ldr	r3, [r7, #4]
24013d82:	699a      	ldr	r2, [r3, #24]
24013d84:	4b64      	ldr	r3, [pc, #400]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d86:	69db      	ldr	r3, [r3, #28]
24013d88:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
24013d8c:	429a      	cmp	r2, r3
24013d8e:	d908      	bls.n	24013da2 <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24013d90:	4b61      	ldr	r3, [pc, #388]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d92:	69db      	ldr	r3, [r3, #28]
24013d94:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
24013d98:	687b      	ldr	r3, [r7, #4]
24013d9a:	699b      	ldr	r3, [r3, #24]
24013d9c:	495e      	ldr	r1, [pc, #376]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013d9e:	4313      	orrs	r3, r2
24013da0:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24013da2:	687b      	ldr	r3, [r7, #4]
24013da4:	681b      	ldr	r3, [r3, #0]
24013da6:	f003 0320 	and.w	r3, r3, #32
24013daa:	2b00      	cmp	r3, #0
24013dac:	d010      	beq.n	24013dd0 <HAL_RCC_ClockConfig+0xfc>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if ((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24013dae:	687b      	ldr	r3, [r7, #4]
24013db0:	69da      	ldr	r2, [r3, #28]
24013db2:	4b59      	ldr	r3, [pc, #356]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013db4:	6a1b      	ldr	r3, [r3, #32]
24013db6:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013dba:	429a      	cmp	r2, r3
24013dbc:	d908      	bls.n	24013dd0 <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
24013dbe:	4b56      	ldr	r3, [pc, #344]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013dc0:	6a1b      	ldr	r3, [r3, #32]
24013dc2:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013dc6:	687b      	ldr	r3, [r7, #4]
24013dc8:	69db      	ldr	r3, [r3, #28]
24013dca:	4953      	ldr	r1, [pc, #332]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013dcc:	4313      	orrs	r3, r2
24013dce:	620b      	str	r3, [r1, #32]
    }
#endif
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24013dd0:	687b      	ldr	r3, [r7, #4]
24013dd2:	681b      	ldr	r3, [r3, #0]
24013dd4:	f003 0302 	and.w	r3, r3, #2
24013dd8:	2b00      	cmp	r3, #0
24013dda:	d010      	beq.n	24013dfe <HAL_RCC_ClockConfig+0x12a>
  {
#if defined (RCC_D1CFGR_HPRE)
    if ((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24013ddc:	687b      	ldr	r3, [r7, #4]
24013dde:	68da      	ldr	r2, [r3, #12]
24013de0:	4b4d      	ldr	r3, [pc, #308]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013de2:	699b      	ldr	r3, [r3, #24]
24013de4:	f003 030f 	and.w	r3, r3, #15
24013de8:	429a      	cmp	r2, r3
24013dea:	d908      	bls.n	24013dfe <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24013dec:	4b4a      	ldr	r3, [pc, #296]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013dee:	699b      	ldr	r3, [r3, #24]
24013df0:	f023 020f 	bic.w	r2, r3, #15
24013df4:	687b      	ldr	r3, [r7, #4]
24013df6:	68db      	ldr	r3, [r3, #12]
24013df8:	4947      	ldr	r1, [pc, #284]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013dfa:	4313      	orrs	r3, r2
24013dfc:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
24013dfe:	687b      	ldr	r3, [r7, #4]
24013e00:	681b      	ldr	r3, [r3, #0]
24013e02:	f003 0301 	and.w	r3, r3, #1
24013e06:	2b00      	cmp	r3, #0
24013e08:	d055      	beq.n	24013eb6 <HAL_RCC_ClockConfig+0x1e2>
  {
    assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
24013e0a:	4b43      	ldr	r3, [pc, #268]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013e0c:	699b      	ldr	r3, [r3, #24]
24013e0e:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
24013e12:	687b      	ldr	r3, [r7, #4]
24013e14:	689b      	ldr	r3, [r3, #8]
24013e16:	4940      	ldr	r1, [pc, #256]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013e18:	4313      	orrs	r3, r2
24013e1a:	618b      	str	r3, [r1, #24]
#else
    MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
24013e1c:	687b      	ldr	r3, [r7, #4]
24013e1e:	685b      	ldr	r3, [r3, #4]
24013e20:	2b02      	cmp	r3, #2
24013e22:	d107      	bne.n	24013e34 <HAL_RCC_ClockConfig+0x160>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24013e24:	4b3c      	ldr	r3, [pc, #240]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013e26:	681b      	ldr	r3, [r3, #0]
24013e28:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24013e2c:	2b00      	cmp	r3, #0
24013e2e:	d121      	bne.n	24013e74 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
24013e30:	2301      	movs	r3, #1
24013e32:	e0f6      	b.n	24014022 <HAL_RCC_ClockConfig+0x34e>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
24013e34:	687b      	ldr	r3, [r7, #4]
24013e36:	685b      	ldr	r3, [r3, #4]
24013e38:	2b03      	cmp	r3, #3
24013e3a:	d107      	bne.n	24013e4c <HAL_RCC_ClockConfig+0x178>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24013e3c:	4b36      	ldr	r3, [pc, #216]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013e3e:	681b      	ldr	r3, [r3, #0]
24013e40:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24013e44:	2b00      	cmp	r3, #0
24013e46:	d115      	bne.n	24013e74 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
24013e48:	2301      	movs	r3, #1
24013e4a:	e0ea      	b.n	24014022 <HAL_RCC_ClockConfig+0x34e>
      }
    }
    /* CSI is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
24013e4c:	687b      	ldr	r3, [r7, #4]
24013e4e:	685b      	ldr	r3, [r3, #4]
24013e50:	2b01      	cmp	r3, #1
24013e52:	d107      	bne.n	24013e64 <HAL_RCC_ClockConfig+0x190>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
24013e54:	4b30      	ldr	r3, [pc, #192]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013e56:	681b      	ldr	r3, [r3, #0]
24013e58:	f403 7380 	and.w	r3, r3, #256	; 0x100
24013e5c:	2b00      	cmp	r3, #0
24013e5e:	d109      	bne.n	24013e74 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
24013e60:	2301      	movs	r3, #1
24013e62:	e0de      	b.n	24014022 <HAL_RCC_ClockConfig+0x34e>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24013e64:	4b2c      	ldr	r3, [pc, #176]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013e66:	681b      	ldr	r3, [r3, #0]
24013e68:	f003 0304 	and.w	r3, r3, #4
24013e6c:	2b00      	cmp	r3, #0
24013e6e:	d101      	bne.n	24013e74 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
24013e70:	2301      	movs	r3, #1
24013e72:	e0d6      	b.n	24014022 <HAL_RCC_ClockConfig+0x34e>
      }
    }
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
24013e74:	4b28      	ldr	r3, [pc, #160]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013e76:	691b      	ldr	r3, [r3, #16]
24013e78:	f023 0207 	bic.w	r2, r3, #7
24013e7c:	687b      	ldr	r3, [r7, #4]
24013e7e:	685b      	ldr	r3, [r3, #4]
24013e80:	4925      	ldr	r1, [pc, #148]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013e82:	4313      	orrs	r3, r2
24013e84:	610b      	str	r3, [r1, #16]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24013e86:	f7ee f8c9 	bl	2400201c <HAL_GetTick>
24013e8a:	6178      	str	r0, [r7, #20]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24013e8c:	e00a      	b.n	24013ea4 <HAL_RCC_ClockConfig+0x1d0>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
24013e8e:	f7ee f8c5 	bl	2400201c <HAL_GetTick>
24013e92:	4602      	mov	r2, r0
24013e94:	697b      	ldr	r3, [r7, #20]
24013e96:	1ad3      	subs	r3, r2, r3
24013e98:	f241 3288 	movw	r2, #5000	; 0x1388
24013e9c:	4293      	cmp	r3, r2
24013e9e:	d901      	bls.n	24013ea4 <HAL_RCC_ClockConfig+0x1d0>
      {
        return HAL_TIMEOUT;
24013ea0:	2303      	movs	r3, #3
24013ea2:	e0be      	b.n	24014022 <HAL_RCC_ClockConfig+0x34e>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24013ea4:	4b1c      	ldr	r3, [pc, #112]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013ea6:	691b      	ldr	r3, [r3, #16]
24013ea8:	f003 0238 	and.w	r2, r3, #56	; 0x38
24013eac:	687b      	ldr	r3, [r7, #4]
24013eae:	685b      	ldr	r3, [r3, #4]
24013eb0:	00db      	lsls	r3, r3, #3
24013eb2:	429a      	cmp	r2, r3
24013eb4:	d1eb      	bne.n	24013e8e <HAL_RCC_ClockConfig+0x1ba>

  }

  /* Decreasing the BUS frequency divider */
  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24013eb6:	687b      	ldr	r3, [r7, #4]
24013eb8:	681b      	ldr	r3, [r3, #0]
24013eba:	f003 0302 	and.w	r3, r3, #2
24013ebe:	2b00      	cmp	r3, #0
24013ec0:	d010      	beq.n	24013ee4 <HAL_RCC_ClockConfig+0x210>
  {
#if defined(RCC_D1CFGR_HPRE)
    if ((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24013ec2:	687b      	ldr	r3, [r7, #4]
24013ec4:	68da      	ldr	r2, [r3, #12]
24013ec6:	4b14      	ldr	r3, [pc, #80]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013ec8:	699b      	ldr	r3, [r3, #24]
24013eca:	f003 030f 	and.w	r3, r3, #15
24013ece:	429a      	cmp	r2, r3
24013ed0:	d208      	bcs.n	24013ee4 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24013ed2:	4b11      	ldr	r3, [pc, #68]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013ed4:	699b      	ldr	r3, [r3, #24]
24013ed6:	f023 020f 	bic.w	r2, r3, #15
24013eda:	687b      	ldr	r3, [r7, #4]
24013edc:	68db      	ldr	r3, [r3, #12]
24013ede:	490e      	ldr	r1, [pc, #56]	; (24013f18 <HAL_RCC_ClockConfig+0x244>)
24013ee0:	4313      	orrs	r3, r2
24013ee2:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
24013ee4:	4b0b      	ldr	r3, [pc, #44]	; (24013f14 <HAL_RCC_ClockConfig+0x240>)
24013ee6:	681b      	ldr	r3, [r3, #0]
24013ee8:	f003 030f 	and.w	r3, r3, #15
24013eec:	683a      	ldr	r2, [r7, #0]
24013eee:	429a      	cmp	r2, r3
24013ef0:	d214      	bcs.n	24013f1c <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
24013ef2:	4b08      	ldr	r3, [pc, #32]	; (24013f14 <HAL_RCC_ClockConfig+0x240>)
24013ef4:	681b      	ldr	r3, [r3, #0]
24013ef6:	f023 020f 	bic.w	r2, r3, #15
24013efa:	4906      	ldr	r1, [pc, #24]	; (24013f14 <HAL_RCC_ClockConfig+0x240>)
24013efc:	683b      	ldr	r3, [r7, #0]
24013efe:	4313      	orrs	r3, r2
24013f00:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
24013f02:	4b04      	ldr	r3, [pc, #16]	; (24013f14 <HAL_RCC_ClockConfig+0x240>)
24013f04:	681b      	ldr	r3, [r3, #0]
24013f06:	f003 030f 	and.w	r3, r3, #15
24013f0a:	683a      	ldr	r2, [r7, #0]
24013f0c:	429a      	cmp	r2, r3
24013f0e:	d005      	beq.n	24013f1c <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
24013f10:	2301      	movs	r3, #1
24013f12:	e086      	b.n	24014022 <HAL_RCC_ClockConfig+0x34e>
24013f14:	52002000 	.word	0x52002000
24013f18:	58024400 	.word	0x58024400
    }
  }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
24013f1c:	687b      	ldr	r3, [r7, #4]
24013f1e:	681b      	ldr	r3, [r3, #0]
24013f20:	f003 0304 	and.w	r3, r3, #4
24013f24:	2b00      	cmp	r3, #0
24013f26:	d010      	beq.n	24013f4a <HAL_RCC_ClockConfig+0x276>
  {
#if defined(RCC_D1CFGR_D1PPRE)
    if ((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
24013f28:	687b      	ldr	r3, [r7, #4]
24013f2a:	691a      	ldr	r2, [r3, #16]
24013f2c:	4b3f      	ldr	r3, [pc, #252]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013f2e:	699b      	ldr	r3, [r3, #24]
24013f30:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013f34:	429a      	cmp	r2, r3
24013f36:	d208      	bcs.n	24013f4a <HAL_RCC_ClockConfig+0x276>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
24013f38:	4b3c      	ldr	r3, [pc, #240]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013f3a:	699b      	ldr	r3, [r3, #24]
24013f3c:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013f40:	687b      	ldr	r3, [r7, #4]
24013f42:	691b      	ldr	r3, [r3, #16]
24013f44:	4939      	ldr	r1, [pc, #228]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013f46:	4313      	orrs	r3, r2
24013f48:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
24013f4a:	687b      	ldr	r3, [r7, #4]
24013f4c:	681b      	ldr	r3, [r3, #0]
24013f4e:	f003 0308 	and.w	r3, r3, #8
24013f52:	2b00      	cmp	r3, #0
24013f54:	d010      	beq.n	24013f78 <HAL_RCC_ClockConfig+0x2a4>
  {
#if defined(RCC_D2CFGR_D2PPRE1)
    if ((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
24013f56:	687b      	ldr	r3, [r7, #4]
24013f58:	695a      	ldr	r2, [r3, #20]
24013f5a:	4b34      	ldr	r3, [pc, #208]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013f5c:	69db      	ldr	r3, [r3, #28]
24013f5e:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013f62:	429a      	cmp	r2, r3
24013f64:	d208      	bcs.n	24013f78 <HAL_RCC_ClockConfig+0x2a4>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
24013f66:	4b31      	ldr	r3, [pc, #196]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013f68:	69db      	ldr	r3, [r3, #28]
24013f6a:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013f6e:	687b      	ldr	r3, [r7, #4]
24013f70:	695b      	ldr	r3, [r3, #20]
24013f72:	492e      	ldr	r1, [pc, #184]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013f74:	4313      	orrs	r3, r2
24013f76:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
24013f78:	687b      	ldr	r3, [r7, #4]
24013f7a:	681b      	ldr	r3, [r3, #0]
24013f7c:	f003 0310 	and.w	r3, r3, #16
24013f80:	2b00      	cmp	r3, #0
24013f82:	d010      	beq.n	24013fa6 <HAL_RCC_ClockConfig+0x2d2>
  {
#if defined (RCC_D2CFGR_D2PPRE2)
    if ((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24013f84:	687b      	ldr	r3, [r7, #4]
24013f86:	699a      	ldr	r2, [r3, #24]
24013f88:	4b28      	ldr	r3, [pc, #160]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013f8a:	69db      	ldr	r3, [r3, #28]
24013f8c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
24013f90:	429a      	cmp	r2, r3
24013f92:	d208      	bcs.n	24013fa6 <HAL_RCC_ClockConfig+0x2d2>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24013f94:	4b25      	ldr	r3, [pc, #148]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013f96:	69db      	ldr	r3, [r3, #28]
24013f98:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
24013f9c:	687b      	ldr	r3, [r7, #4]
24013f9e:	699b      	ldr	r3, [r3, #24]
24013fa0:	4922      	ldr	r1, [pc, #136]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013fa2:	4313      	orrs	r3, r2
24013fa4:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24013fa6:	687b      	ldr	r3, [r7, #4]
24013fa8:	681b      	ldr	r3, [r3, #0]
24013faa:	f003 0320 	and.w	r3, r3, #32
24013fae:	2b00      	cmp	r3, #0
24013fb0:	d010      	beq.n	24013fd4 <HAL_RCC_ClockConfig+0x300>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if ((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24013fb2:	687b      	ldr	r3, [r7, #4]
24013fb4:	69da      	ldr	r2, [r3, #28]
24013fb6:	4b1d      	ldr	r3, [pc, #116]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013fb8:	6a1b      	ldr	r3, [r3, #32]
24013fba:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013fbe:	429a      	cmp	r2, r3
24013fc0:	d208      	bcs.n	24013fd4 <HAL_RCC_ClockConfig+0x300>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
24013fc2:	4b1a      	ldr	r3, [pc, #104]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013fc4:	6a1b      	ldr	r3, [r3, #32]
24013fc6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013fca:	687b      	ldr	r3, [r7, #4]
24013fcc:	69db      	ldr	r3, [r3, #28]
24013fce:	4917      	ldr	r1, [pc, #92]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013fd0:	4313      	orrs	r3, r2
24013fd2:	620b      	str	r3, [r1, #32]
#endif
  }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
24013fd4:	f000 f8be 	bl	24014154 <HAL_RCC_GetSysClockFreq>
24013fd8:	4602      	mov	r2, r0
24013fda:	4b14      	ldr	r3, [pc, #80]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013fdc:	699b      	ldr	r3, [r3, #24]
24013fde:	0a1b      	lsrs	r3, r3, #8
24013fe0:	f003 030f 	and.w	r3, r3, #15
24013fe4:	4912      	ldr	r1, [pc, #72]	; (24014030 <HAL_RCC_ClockConfig+0x35c>)
24013fe6:	5ccb      	ldrb	r3, [r1, r3]
24013fe8:	f003 031f 	and.w	r3, r3, #31
24013fec:	fa22 f303 	lsr.w	r3, r2, r3
24013ff0:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24013ff2:	4b0e      	ldr	r3, [pc, #56]	; (2401402c <HAL_RCC_ClockConfig+0x358>)
24013ff4:	699b      	ldr	r3, [r3, #24]
24013ff6:	f003 030f 	and.w	r3, r3, #15
24013ffa:	4a0d      	ldr	r2, [pc, #52]	; (24014030 <HAL_RCC_ClockConfig+0x35c>)
24013ffc:	5cd3      	ldrb	r3, [r2, r3]
24013ffe:	f003 031f 	and.w	r3, r3, #31
24014002:	693a      	ldr	r2, [r7, #16]
24014004:	fa22 f303 	lsr.w	r3, r2, r3
24014008:	4a0a      	ldr	r2, [pc, #40]	; (24014034 <HAL_RCC_ClockConfig+0x360>)
2401400a:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
2401400c:	4a0a      	ldr	r2, [pc, #40]	; (24014038 <HAL_RCC_ClockConfig+0x364>)
2401400e:	693b      	ldr	r3, [r7, #16]
24014010:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick(uwTickPrio);
24014012:	4b0a      	ldr	r3, [pc, #40]	; (2401403c <HAL_RCC_ClockConfig+0x368>)
24014014:	681b      	ldr	r3, [r3, #0]
24014016:	4618      	mov	r0, r3
24014018:	f7ed fab4 	bl	24001584 <HAL_InitTick>
2401401c:	4603      	mov	r3, r0
2401401e:	73fb      	strb	r3, [r7, #15]

  return halstatus;
24014020:	7bfb      	ldrb	r3, [r7, #15]
}
24014022:	4618      	mov	r0, r3
24014024:	3718      	adds	r7, #24
24014026:	46bd      	mov	sp, r7
24014028:	bd80      	pop	{r7, pc}
2401402a:	bf00      	nop
2401402c:	58024400 	.word	0x58024400
24014030:	24020f94 	.word	0x24020f94
24014034:	240004b4 	.word	0x240004b4
24014038:	240004b0 	.word	0x240004b0
2401403c:	240004b8 	.word	0x240004b8

24014040 <HAL_RCC_MCOConfig>:
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
24014040:	b580      	push	{r7, lr}
24014042:	b08c      	sub	sp, #48	; 0x30
24014044:	af00      	add	r7, sp, #0
24014046:	60f8      	str	r0, [r7, #12]
24014048:	60b9      	str	r1, [r7, #8]
2401404a:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if (RCC_MCOx == RCC_MCO1)
2401404c:	68fb      	ldr	r3, [r7, #12]
2401404e:	2b00      	cmp	r3, #0
24014050:	d12a      	bne.n	240140a8 <HAL_RCC_MCOConfig+0x68>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
24014052:	4b2d      	ldr	r3, [pc, #180]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
24014054:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24014058:	4a2b      	ldr	r2, [pc, #172]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
2401405a:	f043 0301 	orr.w	r3, r3, #1
2401405e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24014062:	4b29      	ldr	r3, [pc, #164]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
24014064:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24014068:	f003 0301 	and.w	r3, r3, #1
2401406c:	61bb      	str	r3, [r7, #24]
2401406e:	69bb      	ldr	r3, [r7, #24]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
24014070:	f44f 7380 	mov.w	r3, #256	; 0x100
24014074:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24014076:	2302      	movs	r3, #2
24014078:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2401407a:	2303      	movs	r3, #3
2401407c:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
2401407e:	2300      	movs	r3, #0
24014080:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
24014082:	2300      	movs	r3, #0
24014084:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
24014086:	f107 031c 	add.w	r3, r7, #28
2401408a:	4619      	mov	r1, r3
2401408c:	481f      	ldr	r0, [pc, #124]	; (2401410c <HAL_RCC_MCOConfig+0xcc>)
2401408e:	f7f5 f9cb 	bl	24009428 <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
24014092:	4b1d      	ldr	r3, [pc, #116]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
24014094:	691b      	ldr	r3, [r3, #16]
24014096:	f023 72fe 	bic.w	r2, r3, #33292288	; 0x1fc0000
2401409a:	68b9      	ldr	r1, [r7, #8]
2401409c:	687b      	ldr	r3, [r7, #4]
2401409e:	430b      	orrs	r3, r1
240140a0:	4919      	ldr	r1, [pc, #100]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
240140a2:	4313      	orrs	r3, r2
240140a4:	610b      	str	r3, [r1, #16]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
  }
}
240140a6:	e02a      	b.n	240140fe <HAL_RCC_MCOConfig+0xbe>
    MCO2_CLK_ENABLE();
240140a8:	4b17      	ldr	r3, [pc, #92]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
240140aa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240140ae:	4a16      	ldr	r2, [pc, #88]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
240140b0:	f043 0304 	orr.w	r3, r3, #4
240140b4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240140b8:	4b13      	ldr	r3, [pc, #76]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
240140ba:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240140be:	f003 0304 	and.w	r3, r3, #4
240140c2:	617b      	str	r3, [r7, #20]
240140c4:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = MCO2_PIN;
240140c6:	f44f 7300 	mov.w	r3, #512	; 0x200
240140ca:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
240140cc:	2302      	movs	r3, #2
240140ce:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
240140d0:	2303      	movs	r3, #3
240140d2:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
240140d4:	2300      	movs	r3, #0
240140d6:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
240140d8:	2300      	movs	r3, #0
240140da:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
240140dc:	f107 031c 	add.w	r3, r7, #28
240140e0:	4619      	mov	r1, r3
240140e2:	480b      	ldr	r0, [pc, #44]	; (24014110 <HAL_RCC_MCOConfig+0xd0>)
240140e4:	f7f5 f9a0 	bl	24009428 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
240140e8:	4b07      	ldr	r3, [pc, #28]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
240140ea:	691b      	ldr	r3, [r3, #16]
240140ec:	f023 427e 	bic.w	r2, r3, #4261412864	; 0xfe000000
240140f0:	687b      	ldr	r3, [r7, #4]
240140f2:	01d9      	lsls	r1, r3, #7
240140f4:	68bb      	ldr	r3, [r7, #8]
240140f6:	430b      	orrs	r3, r1
240140f8:	4903      	ldr	r1, [pc, #12]	; (24014108 <HAL_RCC_MCOConfig+0xc8>)
240140fa:	4313      	orrs	r3, r2
240140fc:	610b      	str	r3, [r1, #16]
}
240140fe:	bf00      	nop
24014100:	3730      	adds	r7, #48	; 0x30
24014102:	46bd      	mov	sp, r7
24014104:	bd80      	pop	{r7, pc}
24014106:	bf00      	nop
24014108:	58024400 	.word	0x58024400
2401410c:	58020000 	.word	0x58020000
24014110:	58020800 	.word	0x58020800

24014114 <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M NMI (Non-Mask-able Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
24014114:	b480      	push	{r7}
24014116:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;
24014118:	4b05      	ldr	r3, [pc, #20]	; (24014130 <HAL_RCC_EnableCSS+0x1c>)
2401411a:	681b      	ldr	r3, [r3, #0]
2401411c:	4a04      	ldr	r2, [pc, #16]	; (24014130 <HAL_RCC_EnableCSS+0x1c>)
2401411e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
24014122:	6013      	str	r3, [r2, #0]
}
24014124:	bf00      	nop
24014126:	46bd      	mov	sp, r7
24014128:	f85d 7b04 	ldr.w	r7, [sp], #4
2401412c:	4770      	bx	lr
2401412e:	bf00      	nop
24014130:	58024400 	.word	0x58024400

24014134 <HAL_RCC_DisableCSS>:
/**
  * @brief  Disables the Clock Security System.
  * @retval None
  */
void HAL_RCC_DisableCSS(void)
{
24014134:	b480      	push	{r7}
24014136:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);
24014138:	4b05      	ldr	r3, [pc, #20]	; (24014150 <HAL_RCC_DisableCSS+0x1c>)
2401413a:	681b      	ldr	r3, [r3, #0]
2401413c:	4a04      	ldr	r2, [pc, #16]	; (24014150 <HAL_RCC_DisableCSS+0x1c>)
2401413e:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
24014142:	6013      	str	r3, [r2, #0]
}
24014144:	bf00      	nop
24014146:	46bd      	mov	sp, r7
24014148:	f85d 7b04 	ldr.w	r7, [sp], #4
2401414c:	4770      	bx	lr
2401414e:	bf00      	nop
24014150:	58024400 	.word	0x58024400

24014154 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
24014154:	b480      	push	{r7}
24014156:	b089      	sub	sp, #36	; 0x24
24014158:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
2401415a:	4bb3      	ldr	r3, [pc, #716]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
2401415c:	691b      	ldr	r3, [r3, #16]
2401415e:	f003 0338 	and.w	r3, r3, #56	; 0x38
24014162:	2b18      	cmp	r3, #24
24014164:	f200 8155 	bhi.w	24014412 <HAL_RCC_GetSysClockFreq+0x2be>
24014168:	a201      	add	r2, pc, #4	; (adr r2, 24014170 <HAL_RCC_GetSysClockFreq+0x1c>)
2401416a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401416e:	bf00      	nop
24014170:	240141d5 	.word	0x240141d5
24014174:	24014413 	.word	0x24014413
24014178:	24014413 	.word	0x24014413
2401417c:	24014413 	.word	0x24014413
24014180:	24014413 	.word	0x24014413
24014184:	24014413 	.word	0x24014413
24014188:	24014413 	.word	0x24014413
2401418c:	24014413 	.word	0x24014413
24014190:	240141fb 	.word	0x240141fb
24014194:	24014413 	.word	0x24014413
24014198:	24014413 	.word	0x24014413
2401419c:	24014413 	.word	0x24014413
240141a0:	24014413 	.word	0x24014413
240141a4:	24014413 	.word	0x24014413
240141a8:	24014413 	.word	0x24014413
240141ac:	24014413 	.word	0x24014413
240141b0:	24014201 	.word	0x24014201
240141b4:	24014413 	.word	0x24014413
240141b8:	24014413 	.word	0x24014413
240141bc:	24014413 	.word	0x24014413
240141c0:	24014413 	.word	0x24014413
240141c4:	24014413 	.word	0x24014413
240141c8:	24014413 	.word	0x24014413
240141cc:	24014413 	.word	0x24014413
240141d0:	24014207 	.word	0x24014207
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
240141d4:	4b94      	ldr	r3, [pc, #592]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
240141d6:	681b      	ldr	r3, [r3, #0]
240141d8:	f003 0320 	and.w	r3, r3, #32
240141dc:	2b00      	cmp	r3, #0
240141de:	d009      	beq.n	240141f4 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
240141e0:	4b91      	ldr	r3, [pc, #580]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
240141e2:	681b      	ldr	r3, [r3, #0]
240141e4:	08db      	lsrs	r3, r3, #3
240141e6:	f003 0303 	and.w	r3, r3, #3
240141ea:	4a90      	ldr	r2, [pc, #576]	; (2401442c <HAL_RCC_GetSysClockFreq+0x2d8>)
240141ec:	fa22 f303 	lsr.w	r3, r2, r3
240141f0:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

      break;
240141f2:	e111      	b.n	24014418 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
240141f4:	4b8d      	ldr	r3, [pc, #564]	; (2401442c <HAL_RCC_GetSysClockFreq+0x2d8>)
240141f6:	61bb      	str	r3, [r7, #24]
      break;
240141f8:	e10e      	b.n	24014418 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
240141fa:	4b8d      	ldr	r3, [pc, #564]	; (24014430 <HAL_RCC_GetSysClockFreq+0x2dc>)
240141fc:	61bb      	str	r3, [r7, #24]
      break;
240141fe:	e10b      	b.n	24014418 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
24014200:	4b8c      	ldr	r3, [pc, #560]	; (24014434 <HAL_RCC_GetSysClockFreq+0x2e0>)
24014202:	61bb      	str	r3, [r7, #24]
      break;
24014204:	e108      	b.n	24014418 <HAL_RCC_GetSysClockFreq+0x2c4>
    case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24014206:	4b88      	ldr	r3, [pc, #544]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
24014208:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401420a:	f003 0303 	and.w	r3, r3, #3
2401420e:	617b      	str	r3, [r7, #20]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
24014210:	4b85      	ldr	r3, [pc, #532]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
24014212:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014214:	091b      	lsrs	r3, r3, #4
24014216:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2401421a:	613b      	str	r3, [r7, #16]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
2401421c:	4b82      	ldr	r3, [pc, #520]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
2401421e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014220:	f003 0301 	and.w	r3, r3, #1
24014224:	60fb      	str	r3, [r7, #12]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
24014226:	4b80      	ldr	r3, [pc, #512]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
24014228:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401422a:	08db      	lsrs	r3, r3, #3
2401422c:	f3c3 030c 	ubfx	r3, r3, #0, #13
24014230:	68fa      	ldr	r2, [r7, #12]
24014232:	fb02 f303 	mul.w	r3, r2, r3
24014236:	ee07 3a90 	vmov	s15, r3
2401423a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401423e:	edc7 7a02 	vstr	s15, [r7, #8]

      if (pllm != 0U)
24014242:	693b      	ldr	r3, [r7, #16]
24014244:	2b00      	cmp	r3, #0
24014246:	f000 80e1 	beq.w	2401440c <HAL_RCC_GetSysClockFreq+0x2b8>
2401424a:	697b      	ldr	r3, [r7, #20]
2401424c:	2b02      	cmp	r3, #2
2401424e:	f000 8083 	beq.w	24014358 <HAL_RCC_GetSysClockFreq+0x204>
24014252:	697b      	ldr	r3, [r7, #20]
24014254:	2b02      	cmp	r3, #2
24014256:	f200 80a1 	bhi.w	2401439c <HAL_RCC_GetSysClockFreq+0x248>
2401425a:	697b      	ldr	r3, [r7, #20]
2401425c:	2b00      	cmp	r3, #0
2401425e:	d003      	beq.n	24014268 <HAL_RCC_GetSysClockFreq+0x114>
24014260:	697b      	ldr	r3, [r7, #20]
24014262:	2b01      	cmp	r3, #1
24014264:	d056      	beq.n	24014314 <HAL_RCC_GetSysClockFreq+0x1c0>
24014266:	e099      	b.n	2401439c <HAL_RCC_GetSysClockFreq+0x248>
      {
        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24014268:	4b6f      	ldr	r3, [pc, #444]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
2401426a:	681b      	ldr	r3, [r3, #0]
2401426c:	f003 0320 	and.w	r3, r3, #32
24014270:	2b00      	cmp	r3, #0
24014272:	d02d      	beq.n	240142d0 <HAL_RCC_GetSysClockFreq+0x17c>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
24014274:	4b6c      	ldr	r3, [pc, #432]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
24014276:	681b      	ldr	r3, [r3, #0]
24014278:	08db      	lsrs	r3, r3, #3
2401427a:	f003 0303 	and.w	r3, r3, #3
2401427e:	4a6b      	ldr	r2, [pc, #428]	; (2401442c <HAL_RCC_GetSysClockFreq+0x2d8>)
24014280:	fa22 f303 	lsr.w	r3, r2, r3
24014284:	607b      	str	r3, [r7, #4]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
24014286:	687b      	ldr	r3, [r7, #4]
24014288:	ee07 3a90 	vmov	s15, r3
2401428c:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014290:	693b      	ldr	r3, [r7, #16]
24014292:	ee07 3a90 	vmov	s15, r3
24014296:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401429a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401429e:	4b62      	ldr	r3, [pc, #392]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
240142a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240142a2:	f3c3 0308 	ubfx	r3, r3, #0, #9
240142a6:	ee07 3a90 	vmov	s15, r3
240142aa:	eef8 6a67 	vcvt.f32.u32	s13, s15
240142ae:	ed97 6a02 	vldr	s12, [r7, #8]
240142b2:	eddf 5a61 	vldr	s11, [pc, #388]	; 24014438 <HAL_RCC_GetSysClockFreq+0x2e4>
240142b6:	eec6 7a25 	vdiv.f32	s15, s12, s11
240142ba:	ee76 7aa7 	vadd.f32	s15, s13, s15
240142be:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240142c2:	ee77 7aa6 	vadd.f32	s15, s15, s13
240142c6:	ee67 7a27 	vmul.f32	s15, s14, s15
240142ca:	edc7 7a07 	vstr	s15, [r7, #28]
            }
            else
            {
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
            }
            break;
240142ce:	e087      	b.n	240143e0 <HAL_RCC_GetSysClockFreq+0x28c>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
240142d0:	693b      	ldr	r3, [r7, #16]
240142d2:	ee07 3a90 	vmov	s15, r3
240142d6:	eef8 7a67 	vcvt.f32.u32	s15, s15
240142da:	eddf 6a58 	vldr	s13, [pc, #352]	; 2401443c <HAL_RCC_GetSysClockFreq+0x2e8>
240142de:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240142e2:	4b51      	ldr	r3, [pc, #324]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
240142e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240142e6:	f3c3 0308 	ubfx	r3, r3, #0, #9
240142ea:	ee07 3a90 	vmov	s15, r3
240142ee:	eef8 6a67 	vcvt.f32.u32	s13, s15
240142f2:	ed97 6a02 	vldr	s12, [r7, #8]
240142f6:	eddf 5a50 	vldr	s11, [pc, #320]	; 24014438 <HAL_RCC_GetSysClockFreq+0x2e4>
240142fa:	eec6 7a25 	vdiv.f32	s15, s12, s11
240142fe:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014302:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014306:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401430a:	ee67 7a27 	vmul.f32	s15, s14, s15
2401430e:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
24014312:	e065      	b.n	240143e0 <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
24014314:	693b      	ldr	r3, [r7, #16]
24014316:	ee07 3a90 	vmov	s15, r3
2401431a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401431e:	eddf 6a48 	vldr	s13, [pc, #288]	; 24014440 <HAL_RCC_GetSysClockFreq+0x2ec>
24014322:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014326:	4b40      	ldr	r3, [pc, #256]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
24014328:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401432a:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401432e:	ee07 3a90 	vmov	s15, r3
24014332:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014336:	ed97 6a02 	vldr	s12, [r7, #8]
2401433a:	eddf 5a3f 	vldr	s11, [pc, #252]	; 24014438 <HAL_RCC_GetSysClockFreq+0x2e4>
2401433e:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014342:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014346:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401434a:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401434e:	ee67 7a27 	vmul.f32	s15, s14, s15
24014352:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
24014356:	e043      	b.n	240143e0 <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
24014358:	693b      	ldr	r3, [r7, #16]
2401435a:	ee07 3a90 	vmov	s15, r3
2401435e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014362:	eddf 6a38 	vldr	s13, [pc, #224]	; 24014444 <HAL_RCC_GetSysClockFreq+0x2f0>
24014366:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401436a:	4b2f      	ldr	r3, [pc, #188]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
2401436c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401436e:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014372:	ee07 3a90 	vmov	s15, r3
24014376:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401437a:	ed97 6a02 	vldr	s12, [r7, #8]
2401437e:	eddf 5a2e 	vldr	s11, [pc, #184]	; 24014438 <HAL_RCC_GetSysClockFreq+0x2e4>
24014382:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014386:	ee76 7aa7 	vadd.f32	s15, s13, s15
2401438a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401438e:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014392:	ee67 7a27 	vmul.f32	s15, s14, s15
24014396:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
2401439a:	e021      	b.n	240143e0 <HAL_RCC_GetSysClockFreq+0x28c>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
2401439c:	693b      	ldr	r3, [r7, #16]
2401439e:	ee07 3a90 	vmov	s15, r3
240143a2:	eef8 7a67 	vcvt.f32.u32	s15, s15
240143a6:	eddf 6a26 	vldr	s13, [pc, #152]	; 24014440 <HAL_RCC_GetSysClockFreq+0x2ec>
240143aa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240143ae:	4b1e      	ldr	r3, [pc, #120]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
240143b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240143b2:	f3c3 0308 	ubfx	r3, r3, #0, #9
240143b6:	ee07 3a90 	vmov	s15, r3
240143ba:	eef8 6a67 	vcvt.f32.u32	s13, s15
240143be:	ed97 6a02 	vldr	s12, [r7, #8]
240143c2:	eddf 5a1d 	vldr	s11, [pc, #116]	; 24014438 <HAL_RCC_GetSysClockFreq+0x2e4>
240143c6:	eec6 7a25 	vdiv.f32	s15, s12, s11
240143ca:	ee76 7aa7 	vadd.f32	s15, s13, s15
240143ce:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240143d2:	ee77 7aa6 	vadd.f32	s15, s15, s13
240143d6:	ee67 7a27 	vmul.f32	s15, s14, s15
240143da:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
240143de:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
240143e0:	4b11      	ldr	r3, [pc, #68]	; (24014428 <HAL_RCC_GetSysClockFreq+0x2d4>)
240143e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240143e4:	0a5b      	lsrs	r3, r3, #9
240143e6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240143ea:	3301      	adds	r3, #1
240143ec:	603b      	str	r3, [r7, #0]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
240143ee:	683b      	ldr	r3, [r7, #0]
240143f0:	ee07 3a90 	vmov	s15, r3
240143f4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
240143f8:	edd7 6a07 	vldr	s13, [r7, #28]
240143fc:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014400:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014404:	ee17 3a90 	vmov	r3, s15
24014408:	61bb      	str	r3, [r7, #24]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
2401440a:	e005      	b.n	24014418 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = 0U;
2401440c:	2300      	movs	r3, #0
2401440e:	61bb      	str	r3, [r7, #24]
      break;
24014410:	e002      	b.n	24014418 <HAL_RCC_GetSysClockFreq+0x2c4>

    default:
      sysclockfreq = CSI_VALUE;
24014412:	4b07      	ldr	r3, [pc, #28]	; (24014430 <HAL_RCC_GetSysClockFreq+0x2dc>)
24014414:	61bb      	str	r3, [r7, #24]
      break;
24014416:	bf00      	nop
  }

  return sysclockfreq;
24014418:	69bb      	ldr	r3, [r7, #24]
}
2401441a:	4618      	mov	r0, r3
2401441c:	3724      	adds	r7, #36	; 0x24
2401441e:	46bd      	mov	sp, r7
24014420:	f85d 7b04 	ldr.w	r7, [sp], #4
24014424:	4770      	bx	lr
24014426:	bf00      	nop
24014428:	58024400 	.word	0x58024400
2401442c:	03d09000 	.word	0x03d09000
24014430:	003d0900 	.word	0x003d0900
24014434:	017d7840 	.word	0x017d7840
24014438:	46000000 	.word	0x46000000
2401443c:	4c742400 	.word	0x4c742400
24014440:	4a742400 	.word	0x4a742400
24014444:	4bbebc20 	.word	0x4bbebc20

24014448 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
24014448:	b580      	push	{r7, lr}
2401444a:	b082      	sub	sp, #8
2401444c:	af00      	add	r7, sp, #0
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
2401444e:	f7ff fe81 	bl	24014154 <HAL_RCC_GetSysClockFreq>
24014452:	4602      	mov	r2, r0
24014454:	4b10      	ldr	r3, [pc, #64]	; (24014498 <HAL_RCC_GetHCLKFreq+0x50>)
24014456:	699b      	ldr	r3, [r3, #24]
24014458:	0a1b      	lsrs	r3, r3, #8
2401445a:	f003 030f 	and.w	r3, r3, #15
2401445e:	490f      	ldr	r1, [pc, #60]	; (2401449c <HAL_RCC_GetHCLKFreq+0x54>)
24014460:	5ccb      	ldrb	r3, [r1, r3]
24014462:	f003 031f 	and.w	r3, r3, #31
24014466:	fa22 f303 	lsr.w	r3, r2, r3
2401446a:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
2401446c:	4b0a      	ldr	r3, [pc, #40]	; (24014498 <HAL_RCC_GetHCLKFreq+0x50>)
2401446e:	699b      	ldr	r3, [r3, #24]
24014470:	f003 030f 	and.w	r3, r3, #15
24014474:	4a09      	ldr	r2, [pc, #36]	; (2401449c <HAL_RCC_GetHCLKFreq+0x54>)
24014476:	5cd3      	ldrb	r3, [r2, r3]
24014478:	f003 031f 	and.w	r3, r3, #31
2401447c:	687a      	ldr	r2, [r7, #4]
2401447e:	fa22 f303 	lsr.w	r3, r2, r3
24014482:	4a07      	ldr	r2, [pc, #28]	; (240144a0 <HAL_RCC_GetHCLKFreq+0x58>)
24014484:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24014486:	4a07      	ldr	r2, [pc, #28]	; (240144a4 <HAL_RCC_GetHCLKFreq+0x5c>)
24014488:	687b      	ldr	r3, [r7, #4]
2401448a:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
2401448c:	4b04      	ldr	r3, [pc, #16]	; (240144a0 <HAL_RCC_GetHCLKFreq+0x58>)
2401448e:	681b      	ldr	r3, [r3, #0]
}
24014490:	4618      	mov	r0, r3
24014492:	3708      	adds	r7, #8
24014494:	46bd      	mov	sp, r7
24014496:	bd80      	pop	{r7, pc}
24014498:	58024400 	.word	0x58024400
2401449c:	24020f94 	.word	0x24020f94
240144a0:	240004b4 	.word	0x240004b4
240144a4:	240004b0 	.word	0x240004b0

240144a8 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
240144a8:	b580      	push	{r7, lr}
240144aa:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
240144ac:	f7ff ffcc 	bl	24014448 <HAL_RCC_GetHCLKFreq>
240144b0:	4602      	mov	r2, r0
240144b2:	4b06      	ldr	r3, [pc, #24]	; (240144cc <HAL_RCC_GetPCLK1Freq+0x24>)
240144b4:	69db      	ldr	r3, [r3, #28]
240144b6:	091b      	lsrs	r3, r3, #4
240144b8:	f003 0307 	and.w	r3, r3, #7
240144bc:	4904      	ldr	r1, [pc, #16]	; (240144d0 <HAL_RCC_GetPCLK1Freq+0x28>)
240144be:	5ccb      	ldrb	r3, [r1, r3]
240144c0:	f003 031f 	and.w	r3, r3, #31
240144c4:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
240144c8:	4618      	mov	r0, r3
240144ca:	bd80      	pop	{r7, pc}
240144cc:	58024400 	.word	0x58024400
240144d0:	24020f94 	.word	0x24020f94

240144d4 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
240144d4:	b580      	push	{r7, lr}
240144d6:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2) >> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
240144d8:	f7ff ffb6 	bl	24014448 <HAL_RCC_GetHCLKFreq>
240144dc:	4602      	mov	r2, r0
240144de:	4b06      	ldr	r3, [pc, #24]	; (240144f8 <HAL_RCC_GetPCLK2Freq+0x24>)
240144e0:	69db      	ldr	r3, [r3, #28]
240144e2:	0a1b      	lsrs	r3, r3, #8
240144e4:	f003 0307 	and.w	r3, r3, #7
240144e8:	4904      	ldr	r1, [pc, #16]	; (240144fc <HAL_RCC_GetPCLK2Freq+0x28>)
240144ea:	5ccb      	ldrb	r3, [r1, r3]
240144ec:	f003 031f 	and.w	r3, r3, #31
240144f0:	fa22 f303 	lsr.w	r3, r2, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2) >> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
240144f4:	4618      	mov	r0, r3
240144f6:	bd80      	pop	{r7, pc}
240144f8:	58024400 	.word	0x58024400
240144fc:	24020f94 	.word	0x24020f94

24014500 <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
  * will be configured.
  * @retval None
  */
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
24014500:	b580      	push	{r7, lr}
24014502:	b082      	sub	sp, #8
24014504:	af00      	add	r7, sp, #0
24014506:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
24014508:	687b      	ldr	r3, [r7, #4]
2401450a:	223f      	movs	r2, #63	; 0x3f
2401450c:	601a      	str	r2, [r3, #0]
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }
#else
  if ((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
2401450e:	4b72      	ldr	r3, [pc, #456]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
24014510:	681b      	ldr	r3, [r3, #0]
24014512:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24014516:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2401451a:	d104      	bne.n	24014526 <HAL_RCC_GetOscConfig+0x26>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
2401451c:	687b      	ldr	r3, [r7, #4]
2401451e:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
24014522:	605a      	str	r2, [r3, #4]
24014524:	e00e      	b.n	24014544 <HAL_RCC_GetOscConfig+0x44>
  }
  else if ((RCC->CR & RCC_CR_HSEON) == RCC_CR_HSEON)
24014526:	4b6c      	ldr	r3, [pc, #432]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
24014528:	681b      	ldr	r3, [r3, #0]
2401452a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401452e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24014532:	d104      	bne.n	2401453e <HAL_RCC_GetOscConfig+0x3e>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
24014534:	687b      	ldr	r3, [r7, #4]
24014536:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2401453a:	605a      	str	r2, [r3, #4]
2401453c:	e002      	b.n	24014544 <HAL_RCC_GetOscConfig+0x44>
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
2401453e:	687b      	ldr	r3, [r7, #4]
24014540:	2200      	movs	r2, #0
24014542:	605a      	str	r2, [r3, #4]
  }
#endif /* RCC_CR_HSEEXT */

  /* Get the CSI configuration -----------------------------------------------*/
  if ((RCC->CR & RCC_CR_CSION) == RCC_CR_CSION)
24014544:	4b64      	ldr	r3, [pc, #400]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
24014546:	681b      	ldr	r3, [r3, #0]
24014548:	f003 0380 	and.w	r3, r3, #128	; 0x80
2401454c:	2b80      	cmp	r3, #128	; 0x80
2401454e:	d103      	bne.n	24014558 <HAL_RCC_GetOscConfig+0x58>
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_ON;
24014550:	687b      	ldr	r3, [r7, #4]
24014552:	2280      	movs	r2, #128	; 0x80
24014554:	61da      	str	r2, [r3, #28]
24014556:	e002      	b.n	2401455e <HAL_RCC_GetOscConfig+0x5e>
  }
  else
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_OFF;
24014558:	687b      	ldr	r3, [r7, #4]
2401455a:	2200      	movs	r2, #0
2401455c:	61da      	str	r2, [r3, #28]
  }

#if defined(RCC_VER_X)
  if (HAL_GetREVID() <= REV_ID_Y)
2401455e:	f7ed fdf7 	bl	24002150 <HAL_GetREVID>
24014562:	4603      	mov	r3, r0
24014564:	f241 0203 	movw	r2, #4099	; 0x1003
24014568:	4293      	cmp	r3, r2
2401456a:	d807      	bhi.n	2401457c <HAL_RCC_GetOscConfig+0x7c>
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);
2401456c:	4b5a      	ldr	r3, [pc, #360]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401456e:	685b      	ldr	r3, [r3, #4]
24014570:	0e9b      	lsrs	r3, r3, #26
24014572:	f003 021f 	and.w	r2, r3, #31
24014576:	687b      	ldr	r3, [r7, #4]
24014578:	621a      	str	r2, [r3, #32]
2401457a:	e006      	b.n	2401458a <HAL_RCC_GetOscConfig+0x8a>
  }
  else
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
2401457c:	4b56      	ldr	r3, [pc, #344]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401457e:	68db      	ldr	r3, [r3, #12]
24014580:	0e1b      	lsrs	r3, r3, #24
24014582:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24014586:	687b      	ldr	r3, [r7, #4]
24014588:	621a      	str	r2, [r3, #32]
#else
  RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
#endif /*RCC_VER_X*/

  /* Get the HSI configuration -----------------------------------------------*/
  if ((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)
2401458a:	4b53      	ldr	r3, [pc, #332]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401458c:	681b      	ldr	r3, [r3, #0]
2401458e:	f003 0301 	and.w	r3, r3, #1
24014592:	2b01      	cmp	r3, #1
24014594:	d103      	bne.n	2401459e <HAL_RCC_GetOscConfig+0x9e>
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
24014596:	687b      	ldr	r3, [r7, #4]
24014598:	2201      	movs	r2, #1
2401459a:	60da      	str	r2, [r3, #12]
2401459c:	e002      	b.n	240145a4 <HAL_RCC_GetOscConfig+0xa4>
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
2401459e:	687b      	ldr	r3, [r7, #4]
240145a0:	2200      	movs	r2, #0
240145a2:	60da      	str	r2, [r3, #12]
  }

#if defined(RCC_VER_X)
  if (HAL_GetREVID() <= REV_ID_Y)
240145a4:	f7ed fdd4 	bl	24002150 <HAL_GetREVID>
240145a8:	4603      	mov	r3, r0
240145aa:	f241 0203 	movw	r2, #4099	; 0x1003
240145ae:	4293      	cmp	r3, r2
240145b0:	d807      	bhi.n	240145c2 <HAL_RCC_GetOscConfig+0xc2>
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);
240145b2:	4b49      	ldr	r3, [pc, #292]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
240145b4:	685b      	ldr	r3, [r3, #4]
240145b6:	0b1b      	lsrs	r3, r3, #12
240145b8:	f003 023f 	and.w	r2, r3, #63	; 0x3f
240145bc:	687b      	ldr	r3, [r7, #4]
240145be:	611a      	str	r2, [r3, #16]
240145c0:	e006      	b.n	240145d0 <HAL_RCC_GetOscConfig+0xd0>
  }
  else
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
240145c2:	4b45      	ldr	r3, [pc, #276]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
240145c4:	685b      	ldr	r3, [r3, #4]
240145c6:	0e1b      	lsrs	r3, r3, #24
240145c8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
240145cc:	687b      	ldr	r3, [r7, #4]
240145ce:	611a      	str	r2, [r3, #16]
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }
#else
  if ((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
240145d0:	4b41      	ldr	r3, [pc, #260]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
240145d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240145d4:	f003 0304 	and.w	r3, r3, #4
240145d8:	2b04      	cmp	r3, #4
240145da:	d103      	bne.n	240145e4 <HAL_RCC_GetOscConfig+0xe4>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
240145dc:	687b      	ldr	r3, [r7, #4]
240145de:	2205      	movs	r2, #5
240145e0:	609a      	str	r2, [r3, #8]
240145e2:	e00c      	b.n	240145fe <HAL_RCC_GetOscConfig+0xfe>
  }
  else if ((RCC->BDCR & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
240145e4:	4b3c      	ldr	r3, [pc, #240]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
240145e6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240145e8:	f003 0301 	and.w	r3, r3, #1
240145ec:	2b01      	cmp	r3, #1
240145ee:	d103      	bne.n	240145f8 <HAL_RCC_GetOscConfig+0xf8>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
240145f0:	687b      	ldr	r3, [r7, #4]
240145f2:	2201      	movs	r2, #1
240145f4:	609a      	str	r2, [r3, #8]
240145f6:	e002      	b.n	240145fe <HAL_RCC_GetOscConfig+0xfe>
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
240145f8:	687b      	ldr	r3, [r7, #4]
240145fa:	2200      	movs	r2, #0
240145fc:	609a      	str	r2, [r3, #8]
  }
#endif /* RCC_BDCR_LSEEXT */

  /* Get the LSI configuration -----------------------------------------------*/
  if ((RCC->CSR & RCC_CSR_LSION) == RCC_CSR_LSION)
240145fe:	4b36      	ldr	r3, [pc, #216]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
24014600:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24014602:	f003 0301 	and.w	r3, r3, #1
24014606:	2b01      	cmp	r3, #1
24014608:	d103      	bne.n	24014612 <HAL_RCC_GetOscConfig+0x112>
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
2401460a:	687b      	ldr	r3, [r7, #4]
2401460c:	2201      	movs	r2, #1
2401460e:	615a      	str	r2, [r3, #20]
24014610:	e002      	b.n	24014618 <HAL_RCC_GetOscConfig+0x118>
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
24014612:	687b      	ldr	r3, [r7, #4]
24014614:	2200      	movs	r2, #0
24014616:	615a      	str	r2, [r3, #20]
  }

  /* Get the HSI48 configuration ---------------------------------------------*/
  if ((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)
24014618:	4b2f      	ldr	r3, [pc, #188]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401461a:	681b      	ldr	r3, [r3, #0]
2401461c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
24014620:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014624:	d103      	bne.n	2401462e <HAL_RCC_GetOscConfig+0x12e>
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
24014626:	687b      	ldr	r3, [r7, #4]
24014628:	2201      	movs	r2, #1
2401462a:	619a      	str	r2, [r3, #24]
2401462c:	e002      	b.n	24014634 <HAL_RCC_GetOscConfig+0x134>
  }
  else
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
2401462e:	687b      	ldr	r3, [r7, #4]
24014630:	2200      	movs	r2, #0
24014632:	619a      	str	r2, [r3, #24]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if ((RCC->CR & RCC_CR_PLLON) == RCC_CR_PLLON)
24014634:	4b28      	ldr	r3, [pc, #160]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
24014636:	681b      	ldr	r3, [r3, #0]
24014638:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2401463c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
24014640:	d103      	bne.n	2401464a <HAL_RCC_GetOscConfig+0x14a>
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
24014642:	687b      	ldr	r3, [r7, #4]
24014644:	2202      	movs	r2, #2
24014646:	625a      	str	r2, [r3, #36]	; 0x24
24014648:	e002      	b.n	24014650 <HAL_RCC_GetOscConfig+0x150>
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
2401464a:	687b      	ldr	r3, [r7, #4]
2401464c:	2201      	movs	r2, #1
2401464e:	625a      	str	r2, [r3, #36]	; 0x24
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24014650:	4b21      	ldr	r3, [pc, #132]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
24014652:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014654:	f003 0203 	and.w	r2, r3, #3
24014658:	687b      	ldr	r3, [r7, #4]
2401465a:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos);
2401465c:	4b1e      	ldr	r3, [pc, #120]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401465e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014660:	091b      	lsrs	r3, r3, #4
24014662:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24014666:	687b      	ldr	r3, [r7, #4]
24014668:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos) + 1U;
2401466a:	4b1b      	ldr	r3, [pc, #108]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401466c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401466e:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014672:	1c5a      	adds	r2, r3, #1
24014674:	687b      	ldr	r3, [r7, #4]
24014676:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) + 1U;
24014678:	4b17      	ldr	r3, [pc, #92]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401467a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401467c:	0e1b      	lsrs	r3, r3, #24
2401467e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014682:	1c5a      	adds	r2, r3, #1
24014684:	687b      	ldr	r3, [r7, #4]
24014686:	63da      	str	r2, [r3, #60]	; 0x3c
  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) + 1U;
24014688:	4b13      	ldr	r3, [pc, #76]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401468a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401468c:	0a5b      	lsrs	r3, r3, #9
2401468e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014692:	1c5a      	adds	r2, r3, #1
24014694:	687b      	ldr	r3, [r7, #4]
24014696:	635a      	str	r2, [r3, #52]	; 0x34
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) + 1U;
24014698:	4b0f      	ldr	r3, [pc, #60]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
2401469a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401469c:	0c1b      	lsrs	r3, r3, #16
2401469e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240146a2:	1c5a      	adds	r2, r3, #1
240146a4:	687b      	ldr	r3, [r7, #4]
240146a6:	639a      	str	r2, [r3, #56]	; 0x38
  RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));
240146a8:	4b0b      	ldr	r3, [pc, #44]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
240146aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240146ac:	f003 020c 	and.w	r2, r3, #12
240146b0:	687b      	ldr	r3, [r7, #4]
240146b2:	641a      	str	r2, [r3, #64]	; 0x40
  RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);
240146b4:	4b08      	ldr	r3, [pc, #32]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
240146b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240146b8:	085b      	lsrs	r3, r3, #1
240146ba:	f003 0201 	and.w	r2, r3, #1
240146be:	687b      	ldr	r3, [r7, #4]
240146c0:	645a      	str	r2, [r3, #68]	; 0x44
  RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));
240146c2:	4b05      	ldr	r3, [pc, #20]	; (240146d8 <HAL_RCC_GetOscConfig+0x1d8>)
240146c4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240146c6:	08db      	lsrs	r3, r3, #3
240146c8:	f3c3 020c 	ubfx	r2, r3, #0, #13
240146cc:	687b      	ldr	r3, [r7, #4]
240146ce:	649a      	str	r2, [r3, #72]	; 0x48
}
240146d0:	bf00      	nop
240146d2:	3708      	adds	r7, #8
240146d4:	46bd      	mov	sp, r7
240146d6:	bd80      	pop	{r7, pc}
240146d8:	58024400 	.word	0x58024400

240146dc <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
240146dc:	b480      	push	{r7}
240146de:	b083      	sub	sp, #12
240146e0:	af00      	add	r7, sp, #0
240146e2:	6078      	str	r0, [r7, #4]
240146e4:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
240146e6:	687b      	ldr	r3, [r7, #4]
240146e8:	223f      	movs	r2, #63	; 0x3f
240146ea:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
240146ec:	4b1a      	ldr	r3, [pc, #104]	; (24014758 <HAL_RCC_GetClockConfig+0x7c>)
240146ee:	691b      	ldr	r3, [r3, #16]
240146f0:	f003 0207 	and.w	r2, r3, #7
240146f4:	687b      	ldr	r3, [r7, #4]
240146f6:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
240146f8:	4b17      	ldr	r3, [pc, #92]	; (24014758 <HAL_RCC_GetClockConfig+0x7c>)
240146fa:	699b      	ldr	r3, [r3, #24]
240146fc:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
24014700:	687b      	ldr	r3, [r7, #4]
24014702:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
24014704:	4b14      	ldr	r3, [pc, #80]	; (24014758 <HAL_RCC_GetClockConfig+0x7c>)
24014706:	699b      	ldr	r3, [r3, #24]
24014708:	f003 020f 	and.w	r2, r3, #15
2401470c:	687b      	ldr	r3, [r7, #4]
2401470e:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
24014710:	4b11      	ldr	r3, [pc, #68]	; (24014758 <HAL_RCC_GetClockConfig+0x7c>)
24014712:	699b      	ldr	r3, [r3, #24]
24014714:	f003 0270 	and.w	r2, r3, #112	; 0x70
24014718:	687b      	ldr	r3, [r7, #4]
2401471a:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
2401471c:	4b0e      	ldr	r3, [pc, #56]	; (24014758 <HAL_RCC_GetClockConfig+0x7c>)
2401471e:	69db      	ldr	r3, [r3, #28]
24014720:	f003 0270 	and.w	r2, r3, #112	; 0x70
24014724:	687b      	ldr	r3, [r7, #4]
24014726:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
24014728:	4b0b      	ldr	r3, [pc, #44]	; (24014758 <HAL_RCC_GetClockConfig+0x7c>)
2401472a:	69db      	ldr	r3, [r3, #28]
2401472c:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
24014730:	687b      	ldr	r3, [r7, #4]
24014732:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
24014734:	4b08      	ldr	r3, [pc, #32]	; (24014758 <HAL_RCC_GetClockConfig+0x7c>)
24014736:	6a1b      	ldr	r3, [r3, #32]
24014738:	f003 0270 	and.w	r2, r3, #112	; 0x70
2401473c:	687b      	ldr	r3, [r7, #4]
2401473e:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
24014740:	4b06      	ldr	r3, [pc, #24]	; (2401475c <HAL_RCC_GetClockConfig+0x80>)
24014742:	681b      	ldr	r3, [r3, #0]
24014744:	f003 020f 	and.w	r2, r3, #15
24014748:	683b      	ldr	r3, [r7, #0]
2401474a:	601a      	str	r2, [r3, #0]
}
2401474c:	bf00      	nop
2401474e:	370c      	adds	r7, #12
24014750:	46bd      	mov	sp, r7
24014752:	f85d 7b04 	ldr.w	r7, [sp], #4
24014756:	4770      	bx	lr
24014758:	58024400 	.word	0x58024400
2401475c:	52002000 	.word	0x52002000

24014760 <HAL_RCC_NMI_IRQHandler>:
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
24014760:	b580      	push	{r7, lr}
24014762:	af00      	add	r7, sp, #0
  /* Check RCC CSSF flag  */
  if (__HAL_RCC_GET_IT(RCC_IT_CSS))
24014764:	4b07      	ldr	r3, [pc, #28]	; (24014784 <HAL_RCC_NMI_IRQHandler+0x24>)
24014766:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24014768:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2401476c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
24014770:	d105      	bne.n	2401477e <HAL_RCC_NMI_IRQHandler+0x1e>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
24014772:	f000 f809 	bl	24014788 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
24014776:	4b03      	ldr	r3, [pc, #12]	; (24014784 <HAL_RCC_NMI_IRQHandler+0x24>)
24014778:	f44f 6280 	mov.w	r2, #1024	; 0x400
2401477c:	669a      	str	r2, [r3, #104]	; 0x68
  }
}
2401477e:	bf00      	nop
24014780:	bd80      	pop	{r7, pc}
24014782:	bf00      	nop
24014784:	58024400 	.word	0x58024400

24014788 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback
  * @retval none
  */
__weak void HAL_RCC_CSSCallback(void)
{
24014788:	b480      	push	{r7}
2401478a:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback could be implemented in the user file
   */
}
2401478c:	bf00      	nop
2401478e:	46bd      	mov	sp, r7
24014790:	f85d 7b04 	ldr.w	r7, [sp], #4
24014794:	4770      	bx	lr
	...

24014798 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
24014798:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
2401479c:	b0ca      	sub	sp, #296	; 0x128
2401479e:	af00      	add	r7, sp, #0
240147a0:	f8c7 0114 	str.w	r0, [r7, #276]	; 0x114
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
240147a4:	2300      	movs	r3, #0
240147a6:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
240147aa:	2300      	movs	r3, #0
240147ac:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
240147b0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240147b4:	e9d3 2300 	ldrd	r2, r3, [r3]
240147b8:	f002 6400 	and.w	r4, r2, #134217728	; 0x8000000
240147bc:	2500      	movs	r5, #0
240147be:	ea54 0305 	orrs.w	r3, r4, r5
240147c2:	d049      	beq.n	24014858 <HAL_RCCEx_PeriphCLKConfig+0xc0>
  {

    switch (PeriphClkInit->SpdifrxClockSelection)
240147c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240147c8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240147ca:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
240147ce:	d02f      	beq.n	24014830 <HAL_RCCEx_PeriphCLKConfig+0x98>
240147d0:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
240147d4:	d828      	bhi.n	24014828 <HAL_RCCEx_PeriphCLKConfig+0x90>
240147d6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240147da:	d01a      	beq.n	24014812 <HAL_RCCEx_PeriphCLKConfig+0x7a>
240147dc:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240147e0:	d822      	bhi.n	24014828 <HAL_RCCEx_PeriphCLKConfig+0x90>
240147e2:	2b00      	cmp	r3, #0
240147e4:	d003      	beq.n	240147ee <HAL_RCCEx_PeriphCLKConfig+0x56>
240147e6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
240147ea:	d007      	beq.n	240147fc <HAL_RCCEx_PeriphCLKConfig+0x64>
240147ec:	e01c      	b.n	24014828 <HAL_RCCEx_PeriphCLKConfig+0x90>
    {
      case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
        /* Enable PLL1Q Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240147ee:	4bb8      	ldr	r3, [pc, #736]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
240147f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240147f2:	4ab7      	ldr	r2, [pc, #732]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
240147f4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240147f8:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
240147fa:	e01a      	b.n	24014832 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
240147fc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014800:	3308      	adds	r3, #8
24014802:	2102      	movs	r1, #2
24014804:	4618      	mov	r0, r3
24014806:	f002 ff4d 	bl	240176a4 <RCCEx_PLL2_Config>
2401480a:	4603      	mov	r3, r0
2401480c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
24014810:	e00f      	b.n	24014832 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
24014812:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014816:	3328      	adds	r3, #40	; 0x28
24014818:	2102      	movs	r1, #2
2401481a:	4618      	mov	r0, r3
2401481c:	f002 fff4 	bl	24017808 <RCCEx_PLL3_Config>
24014820:	4603      	mov	r3, r0
24014822:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
24014826:	e004      	b.n	24014832 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        /* Internal OSC clock is used as source of SPDIFRX clock*/
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
24014828:	2301      	movs	r3, #1
2401482a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
2401482e:	e000      	b.n	24014832 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        break;
24014830:	bf00      	nop
    }

    if (ret == HAL_OK)
24014832:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014836:	2b00      	cmp	r3, #0
24014838:	d10a      	bne.n	24014850 <HAL_RCCEx_PeriphCLKConfig+0xb8>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
2401483a:	4ba5      	ldr	r3, [pc, #660]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
2401483c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401483e:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
24014842:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014846:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24014848:	4aa1      	ldr	r2, [pc, #644]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
2401484a:	430b      	orrs	r3, r1
2401484c:	6513      	str	r3, [r2, #80]	; 0x50
2401484e:	e003      	b.n	24014858 <HAL_RCCEx_PeriphCLKConfig+0xc0>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014850:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014854:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
24014858:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401485c:	e9d3 2300 	ldrd	r2, r3, [r3]
24014860:	f402 7880 	and.w	r8, r2, #256	; 0x100
24014864:	f04f 0900 	mov.w	r9, #0
24014868:	ea58 0309 	orrs.w	r3, r8, r9
2401486c:	d047      	beq.n	240148fe <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    switch (PeriphClkInit->Sai1ClockSelection)
2401486e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014872:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014874:	2b04      	cmp	r3, #4
24014876:	d82a      	bhi.n	240148ce <HAL_RCCEx_PeriphCLKConfig+0x136>
24014878:	a201      	add	r2, pc, #4	; (adr r2, 24014880 <HAL_RCCEx_PeriphCLKConfig+0xe8>)
2401487a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401487e:	bf00      	nop
24014880:	24014895 	.word	0x24014895
24014884:	240148a3 	.word	0x240148a3
24014888:	240148b9 	.word	0x240148b9
2401488c:	240148d7 	.word	0x240148d7
24014890:	240148d7 	.word	0x240148d7
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014894:	4b8e      	ldr	r3, [pc, #568]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
24014896:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014898:	4a8d      	ldr	r2, [pc, #564]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
2401489a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2401489e:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
240148a0:	e01a      	b.n	240148d8 <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
240148a2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240148a6:	3308      	adds	r3, #8
240148a8:	2100      	movs	r1, #0
240148aa:	4618      	mov	r0, r3
240148ac:	f002 fefa 	bl	240176a4 <RCCEx_PLL2_Config>
240148b0:	4603      	mov	r3, r0
240148b2:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
240148b6:	e00f      	b.n	240148d8 <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
240148b8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240148bc:	3328      	adds	r3, #40	; 0x28
240148be:	2100      	movs	r1, #0
240148c0:	4618      	mov	r0, r3
240148c2:	f002 ffa1 	bl	24017808 <RCCEx_PLL3_Config>
240148c6:	4603      	mov	r3, r0
240148c8:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
240148cc:	e004      	b.n	240148d8 <HAL_RCCEx_PeriphCLKConfig+0x140>
        /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
        /* SAI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
240148ce:	2301      	movs	r3, #1
240148d0:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
240148d4:	e000      	b.n	240148d8 <HAL_RCCEx_PeriphCLKConfig+0x140>
        break;
240148d6:	bf00      	nop
    }

    if (ret == HAL_OK)
240148d8:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240148dc:	2b00      	cmp	r3, #0
240148de:	d10a      	bne.n	240148f6 <HAL_RCCEx_PeriphCLKConfig+0x15e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
240148e0:	4b7b      	ldr	r3, [pc, #492]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
240148e2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240148e4:	f023 0107 	bic.w	r1, r3, #7
240148e8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240148ec:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240148ee:	4a78      	ldr	r2, [pc, #480]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
240148f0:	430b      	orrs	r3, r1
240148f2:	6513      	str	r3, [r2, #80]	; 0x50
240148f4:	e003      	b.n	240148fe <HAL_RCCEx_PeriphCLKConfig+0x166>
    }
    else
    {
      /* set overall return value */
      status = ret;
240148f6:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240148fa:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
240148fe:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014902:	e9d3 2300 	ldrd	r2, r3, [r3]
24014906:	f402 7a00 	and.w	sl, r2, #512	; 0x200
2401490a:	f04f 0b00 	mov.w	fp, #0
2401490e:	ea5a 030b 	orrs.w	r3, sl, fp
24014912:	d04c      	beq.n	240149ae <HAL_RCCEx_PeriphCLKConfig+0x216>
  {
    switch (PeriphClkInit->Sai23ClockSelection)
24014914:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014918:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2401491a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401491e:	d030      	beq.n	24014982 <HAL_RCCEx_PeriphCLKConfig+0x1ea>
24014920:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24014924:	d829      	bhi.n	2401497a <HAL_RCCEx_PeriphCLKConfig+0x1e2>
24014926:	2bc0      	cmp	r3, #192	; 0xc0
24014928:	d02d      	beq.n	24014986 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
2401492a:	2bc0      	cmp	r3, #192	; 0xc0
2401492c:	d825      	bhi.n	2401497a <HAL_RCCEx_PeriphCLKConfig+0x1e2>
2401492e:	2b80      	cmp	r3, #128	; 0x80
24014930:	d018      	beq.n	24014964 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
24014932:	2b80      	cmp	r3, #128	; 0x80
24014934:	d821      	bhi.n	2401497a <HAL_RCCEx_PeriphCLKConfig+0x1e2>
24014936:	2b00      	cmp	r3, #0
24014938:	d002      	beq.n	24014940 <HAL_RCCEx_PeriphCLKConfig+0x1a8>
2401493a:	2b40      	cmp	r3, #64	; 0x40
2401493c:	d007      	beq.n	2401494e <HAL_RCCEx_PeriphCLKConfig+0x1b6>
2401493e:	e01c      	b.n	2401497a <HAL_RCCEx_PeriphCLKConfig+0x1e2>
    {
      case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014940:	4b63      	ldr	r3, [pc, #396]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
24014942:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014944:	4a62      	ldr	r2, [pc, #392]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
24014946:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2401494a:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
2401494c:	e01c      	b.n	24014988 <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
2401494e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014952:	3308      	adds	r3, #8
24014954:	2100      	movs	r1, #0
24014956:	4618      	mov	r0, r3
24014958:	f002 fea4 	bl	240176a4 <RCCEx_PLL2_Config>
2401495c:	4603      	mov	r3, r0
2401495e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
24014962:	e011      	b.n	24014988 <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
24014964:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014968:	3328      	adds	r3, #40	; 0x28
2401496a:	2100      	movs	r1, #0
2401496c:	4618      	mov	r0, r3
2401496e:	f002 ff4b 	bl	24017808 <RCCEx_PLL3_Config>
24014972:	4603      	mov	r3, r0
24014974:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
24014978:	e006      	b.n	24014988 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
        /* SAI2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
2401497a:	2301      	movs	r3, #1
2401497c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014980:	e002      	b.n	24014988 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
24014982:	bf00      	nop
24014984:	e000      	b.n	24014988 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
24014986:	bf00      	nop
    }

    if (ret == HAL_OK)
24014988:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
2401498c:	2b00      	cmp	r3, #0
2401498e:	d10a      	bne.n	240149a6 <HAL_RCCEx_PeriphCLKConfig+0x20e>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
24014990:	4b4f      	ldr	r3, [pc, #316]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
24014992:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014994:	f423 71e0 	bic.w	r1, r3, #448	; 0x1c0
24014998:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401499c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2401499e:	4a4c      	ldr	r2, [pc, #304]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
240149a0:	430b      	orrs	r3, r1
240149a2:	6513      	str	r3, [r2, #80]	; 0x50
240149a4:	e003      	b.n	240149ae <HAL_RCCEx_PeriphCLKConfig+0x216>
    }
    else
    {
      /* set overall return value */
      status = ret;
240149a6:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240149aa:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
240149ae:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240149b2:	e9d3 2300 	ldrd	r2, r3, [r3]
240149b6:	f402 6380 	and.w	r3, r2, #1024	; 0x400
240149ba:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
240149be:	2300      	movs	r3, #0
240149c0:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
240149c4:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	; 0x108
240149c8:	460b      	mov	r3, r1
240149ca:	4313      	orrs	r3, r2
240149cc:	d053      	beq.n	24014a76 <HAL_RCCEx_PeriphCLKConfig+0x2de>
  {
    switch (PeriphClkInit->Sai4AClockSelection)
240149ce:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240149d2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
240149d6:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
240149da:	d035      	beq.n	24014a48 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
240149dc:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
240149e0:	d82e      	bhi.n	24014a40 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
240149e2:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
240149e6:	d031      	beq.n	24014a4c <HAL_RCCEx_PeriphCLKConfig+0x2b4>
240149e8:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
240149ec:	d828      	bhi.n	24014a40 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
240149ee:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240149f2:	d01a      	beq.n	24014a2a <HAL_RCCEx_PeriphCLKConfig+0x292>
240149f4:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240149f8:	d822      	bhi.n	24014a40 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
240149fa:	2b00      	cmp	r3, #0
240149fc:	d003      	beq.n	24014a06 <HAL_RCCEx_PeriphCLKConfig+0x26e>
240149fe:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24014a02:	d007      	beq.n	24014a14 <HAL_RCCEx_PeriphCLKConfig+0x27c>
24014a04:	e01c      	b.n	24014a40 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
    {
      case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014a06:	4b32      	ldr	r3, [pc, #200]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
24014a08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014a0a:	4a31      	ldr	r2, [pc, #196]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
24014a0c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014a10:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
24014a12:	e01c      	b.n	24014a4e <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
24014a14:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014a18:	3308      	adds	r3, #8
24014a1a:	2100      	movs	r1, #0
24014a1c:	4618      	mov	r0, r3
24014a1e:	f002 fe41 	bl	240176a4 <RCCEx_PLL2_Config>
24014a22:	4603      	mov	r3, r0
24014a24:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
24014a28:	e011      	b.n	24014a4e <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
24014a2a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014a2e:	3328      	adds	r3, #40	; 0x28
24014a30:	2100      	movs	r1, #0
24014a32:	4618      	mov	r0, r3
24014a34:	f002 fee8 	bl	24017808 <RCCEx_PLL3_Config>
24014a38:	4603      	mov	r3, r0
24014a3a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
24014a3e:	e006      	b.n	24014a4e <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        /* SAI4A clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
24014a40:	2301      	movs	r3, #1
24014a42:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014a46:	e002      	b.n	24014a4e <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
24014a48:	bf00      	nop
24014a4a:	e000      	b.n	24014a4e <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
24014a4c:	bf00      	nop
    }

    if (ret == HAL_OK)
24014a4e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014a52:	2b00      	cmp	r3, #0
24014a54:	d10b      	bne.n	24014a6e <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
24014a56:	4b1e      	ldr	r3, [pc, #120]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
24014a58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014a5a:	f423 0160 	bic.w	r1, r3, #14680064	; 0xe00000
24014a5e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014a62:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
24014a66:	4a1a      	ldr	r2, [pc, #104]	; (24014ad0 <HAL_RCCEx_PeriphCLKConfig+0x338>)
24014a68:	430b      	orrs	r3, r1
24014a6a:	6593      	str	r3, [r2, #88]	; 0x58
24014a6c:	e003      	b.n	24014a76 <HAL_RCCEx_PeriphCLKConfig+0x2de>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014a6e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014a72:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
24014a76:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014a7a:	e9d3 2300 	ldrd	r2, r3, [r3]
24014a7e:	f402 6300 	and.w	r3, r2, #2048	; 0x800
24014a82:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
24014a86:	2300      	movs	r3, #0
24014a88:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
24014a8c:	e9d7 1240 	ldrd	r1, r2, [r7, #256]	; 0x100
24014a90:	460b      	mov	r3, r1
24014a92:	4313      	orrs	r3, r2
24014a94:	d056      	beq.n	24014b44 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
  {
    switch (PeriphClkInit->Sai4BClockSelection)
24014a96:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014a9a:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
24014a9e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
24014aa2:	d038      	beq.n	24014b16 <HAL_RCCEx_PeriphCLKConfig+0x37e>
24014aa4:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
24014aa8:	d831      	bhi.n	24014b0e <HAL_RCCEx_PeriphCLKConfig+0x376>
24014aaa:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
24014aae:	d034      	beq.n	24014b1a <HAL_RCCEx_PeriphCLKConfig+0x382>
24014ab0:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
24014ab4:	d82b      	bhi.n	24014b0e <HAL_RCCEx_PeriphCLKConfig+0x376>
24014ab6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24014aba:	d01d      	beq.n	24014af8 <HAL_RCCEx_PeriphCLKConfig+0x360>
24014abc:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24014ac0:	d825      	bhi.n	24014b0e <HAL_RCCEx_PeriphCLKConfig+0x376>
24014ac2:	2b00      	cmp	r3, #0
24014ac4:	d006      	beq.n	24014ad4 <HAL_RCCEx_PeriphCLKConfig+0x33c>
24014ac6:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
24014aca:	d00a      	beq.n	24014ae2 <HAL_RCCEx_PeriphCLKConfig+0x34a>
24014acc:	e01f      	b.n	24014b0e <HAL_RCCEx_PeriphCLKConfig+0x376>
24014ace:	bf00      	nop
24014ad0:	58024400 	.word	0x58024400
    {
      case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014ad4:	4ba2      	ldr	r3, [pc, #648]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014ad6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014ad8:	4aa1      	ldr	r2, [pc, #644]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014ada:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014ade:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
24014ae0:	e01c      	b.n	24014b1c <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
24014ae2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014ae6:	3308      	adds	r3, #8
24014ae8:	2100      	movs	r1, #0
24014aea:	4618      	mov	r0, r3
24014aec:	f002 fdda 	bl	240176a4 <RCCEx_PLL2_Config>
24014af0:	4603      	mov	r3, r0
24014af2:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
24014af6:	e011      	b.n	24014b1c <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
24014af8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014afc:	3328      	adds	r3, #40	; 0x28
24014afe:	2100      	movs	r1, #0
24014b00:	4618      	mov	r0, r3
24014b02:	f002 fe81 	bl	24017808 <RCCEx_PLL3_Config>
24014b06:	4603      	mov	r3, r0
24014b08:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
24014b0c:	e006      	b.n	24014b1c <HAL_RCCEx_PeriphCLKConfig+0x384>
        /* SAI4B clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
24014b0e:	2301      	movs	r3, #1
24014b10:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014b14:	e002      	b.n	24014b1c <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
24014b16:	bf00      	nop
24014b18:	e000      	b.n	24014b1c <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
24014b1a:	bf00      	nop
    }

    if (ret == HAL_OK)
24014b1c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014b20:	2b00      	cmp	r3, #0
24014b22:	d10b      	bne.n	24014b3c <HAL_RCCEx_PeriphCLKConfig+0x3a4>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
24014b24:	4b8e      	ldr	r3, [pc, #568]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014b26:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014b28:	f023 61e0 	bic.w	r1, r3, #117440512	; 0x7000000
24014b2c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014b30:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
24014b34:	4a8a      	ldr	r2, [pc, #552]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014b36:	430b      	orrs	r3, r1
24014b38:	6593      	str	r3, [r2, #88]	; 0x58
24014b3a:	e003      	b.n	24014b44 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014b3c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014b40:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
24014b44:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014b48:	e9d3 2300 	ldrd	r2, r3, [r3]
24014b4c:	f002 7300 	and.w	r3, r2, #33554432	; 0x2000000
24014b50:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
24014b54:	2300      	movs	r3, #0
24014b56:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
24014b5a:	e9d7 123e 	ldrd	r1, r2, [r7, #248]	; 0xf8
24014b5e:	460b      	mov	r3, r1
24014b60:	4313      	orrs	r3, r2
24014b62:	d03a      	beq.n	24014bda <HAL_RCCEx_PeriphCLKConfig+0x442>
  {
    switch (PeriphClkInit->QspiClockSelection)
24014b64:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014b68:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014b6a:	2b30      	cmp	r3, #48	; 0x30
24014b6c:	d01f      	beq.n	24014bae <HAL_RCCEx_PeriphCLKConfig+0x416>
24014b6e:	2b30      	cmp	r3, #48	; 0x30
24014b70:	d819      	bhi.n	24014ba6 <HAL_RCCEx_PeriphCLKConfig+0x40e>
24014b72:	2b20      	cmp	r3, #32
24014b74:	d00c      	beq.n	24014b90 <HAL_RCCEx_PeriphCLKConfig+0x3f8>
24014b76:	2b20      	cmp	r3, #32
24014b78:	d815      	bhi.n	24014ba6 <HAL_RCCEx_PeriphCLKConfig+0x40e>
24014b7a:	2b00      	cmp	r3, #0
24014b7c:	d019      	beq.n	24014bb2 <HAL_RCCEx_PeriphCLKConfig+0x41a>
24014b7e:	2b10      	cmp	r3, #16
24014b80:	d111      	bne.n	24014ba6 <HAL_RCCEx_PeriphCLKConfig+0x40e>
    {
      case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
        /* Enable QSPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014b82:	4b77      	ldr	r3, [pc, #476]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014b84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014b86:	4a76      	ldr	r2, [pc, #472]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014b88:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014b8c:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* QSPI clock source configuration done later after clock selection check */
        break;
24014b8e:	e011      	b.n	24014bb4 <HAL_RCCEx_PeriphCLKConfig+0x41c>

      case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
24014b90:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014b94:	3308      	adds	r3, #8
24014b96:	2102      	movs	r1, #2
24014b98:	4618      	mov	r0, r3
24014b9a:	f002 fd83 	bl	240176a4 <RCCEx_PLL2_Config>
24014b9e:	4603      	mov	r3, r0
24014ba0:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* QSPI clock source configuration done later after clock selection check */
        break;
24014ba4:	e006      	b.n	24014bb4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
      case RCC_QSPICLKSOURCE_D1HCLK:
        /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
24014ba6:	2301      	movs	r3, #1
24014ba8:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014bac:	e002      	b.n	24014bb4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
24014bae:	bf00      	nop
24014bb0:	e000      	b.n	24014bb4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
24014bb2:	bf00      	nop
    }

    if (ret == HAL_OK)
24014bb4:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014bb8:	2b00      	cmp	r3, #0
24014bba:	d10a      	bne.n	24014bd2 <HAL_RCCEx_PeriphCLKConfig+0x43a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
24014bbc:	4b68      	ldr	r3, [pc, #416]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014bbe:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014bc0:	f023 0130 	bic.w	r1, r3, #48	; 0x30
24014bc4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014bc8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014bca:	4a65      	ldr	r2, [pc, #404]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014bcc:	430b      	orrs	r3, r1
24014bce:	64d3      	str	r3, [r2, #76]	; 0x4c
24014bd0:	e003      	b.n	24014bda <HAL_RCCEx_PeriphCLKConfig+0x442>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014bd2:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014bd6:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
24014bda:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014bde:	e9d3 2300 	ldrd	r2, r3, [r3]
24014be2:	f402 5380 	and.w	r3, r2, #4096	; 0x1000
24014be6:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
24014bea:	2300      	movs	r3, #0
24014bec:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
24014bf0:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	; 0xf0
24014bf4:	460b      	mov	r3, r1
24014bf6:	4313      	orrs	r3, r2
24014bf8:	d051      	beq.n	24014c9e <HAL_RCCEx_PeriphCLKConfig+0x506>
  {
    switch (PeriphClkInit->Spi123ClockSelection)
24014bfa:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014bfe:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24014c00:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24014c04:	d035      	beq.n	24014c72 <HAL_RCCEx_PeriphCLKConfig+0x4da>
24014c06:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24014c0a:	d82e      	bhi.n	24014c6a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
24014c0c:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
24014c10:	d031      	beq.n	24014c76 <HAL_RCCEx_PeriphCLKConfig+0x4de>
24014c12:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
24014c16:	d828      	bhi.n	24014c6a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
24014c18:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24014c1c:	d01a      	beq.n	24014c54 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
24014c1e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24014c22:	d822      	bhi.n	24014c6a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
24014c24:	2b00      	cmp	r3, #0
24014c26:	d003      	beq.n	24014c30 <HAL_RCCEx_PeriphCLKConfig+0x498>
24014c28:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014c2c:	d007      	beq.n	24014c3e <HAL_RCCEx_PeriphCLKConfig+0x4a6>
24014c2e:	e01c      	b.n	24014c6a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
    {
      case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014c30:	4b4b      	ldr	r3, [pc, #300]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014c32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014c34:	4a4a      	ldr	r2, [pc, #296]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014c36:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014c3a:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
24014c3c:	e01c      	b.n	24014c78 <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
24014c3e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014c42:	3308      	adds	r3, #8
24014c44:	2100      	movs	r1, #0
24014c46:	4618      	mov	r0, r3
24014c48:	f002 fd2c 	bl	240176a4 <RCCEx_PLL2_Config>
24014c4c:	4603      	mov	r3, r0
24014c4e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
24014c52:	e011      	b.n	24014c78 <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
24014c54:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014c58:	3328      	adds	r3, #40	; 0x28
24014c5a:	2100      	movs	r1, #0
24014c5c:	4618      	mov	r0, r3
24014c5e:	f002 fdd3 	bl	24017808 <RCCEx_PLL3_Config>
24014c62:	4603      	mov	r3, r0
24014c64:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
24014c68:	e006      	b.n	24014c78 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
24014c6a:	2301      	movs	r3, #1
24014c6c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014c70:	e002      	b.n	24014c78 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
24014c72:	bf00      	nop
24014c74:	e000      	b.n	24014c78 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
24014c76:	bf00      	nop
    }

    if (ret == HAL_OK)
24014c78:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014c7c:	2b00      	cmp	r3, #0
24014c7e:	d10a      	bne.n	24014c96 <HAL_RCCEx_PeriphCLKConfig+0x4fe>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
24014c80:	4b37      	ldr	r3, [pc, #220]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014c82:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014c84:	f423 41e0 	bic.w	r1, r3, #28672	; 0x7000
24014c88:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014c8c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24014c8e:	4a34      	ldr	r2, [pc, #208]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014c90:	430b      	orrs	r3, r1
24014c92:	6513      	str	r3, [r2, #80]	; 0x50
24014c94:	e003      	b.n	24014c9e <HAL_RCCEx_PeriphCLKConfig+0x506>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014c96:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014c9a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
24014c9e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014ca2:	e9d3 2300 	ldrd	r2, r3, [r3]
24014ca6:	f402 5300 	and.w	r3, r2, #8192	; 0x2000
24014caa:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
24014cae:	2300      	movs	r3, #0
24014cb0:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
24014cb4:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	; 0xe8
24014cb8:	460b      	mov	r3, r1
24014cba:	4313      	orrs	r3, r2
24014cbc:	d056      	beq.n	24014d6c <HAL_RCCEx_PeriphCLKConfig+0x5d4>
  {
    switch (PeriphClkInit->Spi45ClockSelection)
24014cbe:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014cc2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24014cc4:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
24014cc8:	d033      	beq.n	24014d32 <HAL_RCCEx_PeriphCLKConfig+0x59a>
24014cca:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
24014cce:	d82c      	bhi.n	24014d2a <HAL_RCCEx_PeriphCLKConfig+0x592>
24014cd0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24014cd4:	d02f      	beq.n	24014d36 <HAL_RCCEx_PeriphCLKConfig+0x59e>
24014cd6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24014cda:	d826      	bhi.n	24014d2a <HAL_RCCEx_PeriphCLKConfig+0x592>
24014cdc:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
24014ce0:	d02b      	beq.n	24014d3a <HAL_RCCEx_PeriphCLKConfig+0x5a2>
24014ce2:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
24014ce6:	d820      	bhi.n	24014d2a <HAL_RCCEx_PeriphCLKConfig+0x592>
24014ce8:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24014cec:	d012      	beq.n	24014d14 <HAL_RCCEx_PeriphCLKConfig+0x57c>
24014cee:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24014cf2:	d81a      	bhi.n	24014d2a <HAL_RCCEx_PeriphCLKConfig+0x592>
24014cf4:	2b00      	cmp	r3, #0
24014cf6:	d022      	beq.n	24014d3e <HAL_RCCEx_PeriphCLKConfig+0x5a6>
24014cf8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24014cfc:	d115      	bne.n	24014d2a <HAL_RCCEx_PeriphCLKConfig+0x592>
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
24014cfe:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014d02:	3308      	adds	r3, #8
24014d04:	2101      	movs	r1, #1
24014d06:	4618      	mov	r0, r3
24014d08:	f002 fccc 	bl	240176a4 <RCCEx_PLL2_Config>
24014d0c:	4603      	mov	r3, r0
24014d0e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
24014d12:	e015      	b.n	24014d40 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
      case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
24014d14:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014d18:	3328      	adds	r3, #40	; 0x28
24014d1a:	2101      	movs	r1, #1
24014d1c:	4618      	mov	r0, r3
24014d1e:	f002 fd73 	bl	24017808 <RCCEx_PLL3_Config>
24014d22:	4603      	mov	r3, r0
24014d24:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
24014d28:	e00a      	b.n	24014d40 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        /* HSE,  oscillator is used as source of SPI4/5 clock */
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
24014d2a:	2301      	movs	r3, #1
24014d2c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014d30:	e006      	b.n	24014d40 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
24014d32:	bf00      	nop
24014d34:	e004      	b.n	24014d40 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
24014d36:	bf00      	nop
24014d38:	e002      	b.n	24014d40 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
24014d3a:	bf00      	nop
24014d3c:	e000      	b.n	24014d40 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
24014d3e:	bf00      	nop
    }

    if (ret == HAL_OK)
24014d40:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014d44:	2b00      	cmp	r3, #0
24014d46:	d10d      	bne.n	24014d64 <HAL_RCCEx_PeriphCLKConfig+0x5cc>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
24014d48:	4b05      	ldr	r3, [pc, #20]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014d4a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014d4c:	f423 21e0 	bic.w	r1, r3, #458752	; 0x70000
24014d50:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014d54:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24014d56:	4a02      	ldr	r2, [pc, #8]	; (24014d60 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
24014d58:	430b      	orrs	r3, r1
24014d5a:	6513      	str	r3, [r2, #80]	; 0x50
24014d5c:	e006      	b.n	24014d6c <HAL_RCCEx_PeriphCLKConfig+0x5d4>
24014d5e:	bf00      	nop
24014d60:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
24014d64:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014d68:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
24014d6c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014d70:	e9d3 2300 	ldrd	r2, r3, [r3]
24014d74:	f402 4380 	and.w	r3, r2, #16384	; 0x4000
24014d78:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
24014d7c:	2300      	movs	r3, #0
24014d7e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
24014d82:	e9d7 1238 	ldrd	r1, r2, [r7, #224]	; 0xe0
24014d86:	460b      	mov	r3, r1
24014d88:	4313      	orrs	r3, r2
24014d8a:	d055      	beq.n	24014e38 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
  {
    switch (PeriphClkInit->Spi6ClockSelection)
24014d8c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014d90:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24014d94:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24014d98:	d033      	beq.n	24014e02 <HAL_RCCEx_PeriphCLKConfig+0x66a>
24014d9a:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24014d9e:	d82c      	bhi.n	24014dfa <HAL_RCCEx_PeriphCLKConfig+0x662>
24014da0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24014da4:	d02f      	beq.n	24014e06 <HAL_RCCEx_PeriphCLKConfig+0x66e>
24014da6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24014daa:	d826      	bhi.n	24014dfa <HAL_RCCEx_PeriphCLKConfig+0x662>
24014dac:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24014db0:	d02b      	beq.n	24014e0a <HAL_RCCEx_PeriphCLKConfig+0x672>
24014db2:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24014db6:	d820      	bhi.n	24014dfa <HAL_RCCEx_PeriphCLKConfig+0x662>
24014db8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014dbc:	d012      	beq.n	24014de4 <HAL_RCCEx_PeriphCLKConfig+0x64c>
24014dbe:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014dc2:	d81a      	bhi.n	24014dfa <HAL_RCCEx_PeriphCLKConfig+0x662>
24014dc4:	2b00      	cmp	r3, #0
24014dc6:	d022      	beq.n	24014e0e <HAL_RCCEx_PeriphCLKConfig+0x676>
24014dc8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014dcc:	d115      	bne.n	24014dfa <HAL_RCCEx_PeriphCLKConfig+0x662>
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
24014dce:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014dd2:	3308      	adds	r3, #8
24014dd4:	2101      	movs	r1, #1
24014dd6:	4618      	mov	r0, r3
24014dd8:	f002 fc64 	bl	240176a4 <RCCEx_PLL2_Config>
24014ddc:	4603      	mov	r3, r0
24014dde:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPI6 clock source configuration done later after clock selection check */
        break;
24014de2:	e015      	b.n	24014e10 <HAL_RCCEx_PeriphCLKConfig+0x678>
      case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
24014de4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014de8:	3328      	adds	r3, #40	; 0x28
24014dea:	2101      	movs	r1, #1
24014dec:	4618      	mov	r0, r3
24014dee:	f002 fd0b 	bl	24017808 <RCCEx_PLL3_Config>
24014df2:	4603      	mov	r3, r0
24014df4:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* SPI6 clock source configuration done later after clock selection check */
        break;
24014df8:	e00a      	b.n	24014e10 <HAL_RCCEx_PeriphCLKConfig+0x678>
        /* SPI6 clock source configuration done later after clock selection check */
        break;
#endif

      default:
        ret = HAL_ERROR;
24014dfa:	2301      	movs	r3, #1
24014dfc:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014e00:	e006      	b.n	24014e10 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
24014e02:	bf00      	nop
24014e04:	e004      	b.n	24014e10 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
24014e06:	bf00      	nop
24014e08:	e002      	b.n	24014e10 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
24014e0a:	bf00      	nop
24014e0c:	e000      	b.n	24014e10 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
24014e0e:	bf00      	nop
    }

    if (ret == HAL_OK)
24014e10:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014e14:	2b00      	cmp	r3, #0
24014e16:	d10b      	bne.n	24014e30 <HAL_RCCEx_PeriphCLKConfig+0x698>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
24014e18:	4ba3      	ldr	r3, [pc, #652]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014e1a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014e1c:	f023 41e0 	bic.w	r1, r3, #1879048192	; 0x70000000
24014e20:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014e24:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24014e28:	4a9f      	ldr	r2, [pc, #636]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014e2a:	430b      	orrs	r3, r1
24014e2c:	6593      	str	r3, [r2, #88]	; 0x58
24014e2e:	e003      	b.n	24014e38 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014e30:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014e34:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
24014e38:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014e3c:	e9d3 2300 	ldrd	r2, r3, [r3]
24014e40:	f402 4300 	and.w	r3, r2, #32768	; 0x8000
24014e44:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
24014e48:	2300      	movs	r3, #0
24014e4a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
24014e4e:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	; 0xd8
24014e52:	460b      	mov	r3, r1
24014e54:	4313      	orrs	r3, r2
24014e56:	d037      	beq.n	24014ec8 <HAL_RCCEx_PeriphCLKConfig+0x730>
  {
    switch (PeriphClkInit->FdcanClockSelection)
24014e58:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014e5c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014e5e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014e62:	d00e      	beq.n	24014e82 <HAL_RCCEx_PeriphCLKConfig+0x6ea>
24014e64:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014e68:	d816      	bhi.n	24014e98 <HAL_RCCEx_PeriphCLKConfig+0x700>
24014e6a:	2b00      	cmp	r3, #0
24014e6c:	d018      	beq.n	24014ea0 <HAL_RCCEx_PeriphCLKConfig+0x708>
24014e6e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014e72:	d111      	bne.n	24014e98 <HAL_RCCEx_PeriphCLKConfig+0x700>
    {
      case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
        /* Enable FDCAN Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014e74:	4b8c      	ldr	r3, [pc, #560]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014e76:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014e78:	4a8b      	ldr	r2, [pc, #556]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014e7a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014e7e:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* FDCAN clock source configuration done later after clock selection check */
        break;
24014e80:	e00f      	b.n	24014ea2 <HAL_RCCEx_PeriphCLKConfig+0x70a>

      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
24014e82:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014e86:	3308      	adds	r3, #8
24014e88:	2101      	movs	r1, #1
24014e8a:	4618      	mov	r0, r3
24014e8c:	f002 fc0a 	bl	240176a4 <RCCEx_PLL2_Config>
24014e90:	4603      	mov	r3, r0
24014e92:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* FDCAN clock source configuration done later after clock selection check */
        break;
24014e96:	e004      	b.n	24014ea2 <HAL_RCCEx_PeriphCLKConfig+0x70a>
        /* HSE is used as clock source for FDCAN*/
        /* FDCAN clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
24014e98:	2301      	movs	r3, #1
24014e9a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014e9e:	e000      	b.n	24014ea2 <HAL_RCCEx_PeriphCLKConfig+0x70a>
        break;
24014ea0:	bf00      	nop
    }

    if (ret == HAL_OK)
24014ea2:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014ea6:	2b00      	cmp	r3, #0
24014ea8:	d10a      	bne.n	24014ec0 <HAL_RCCEx_PeriphCLKConfig+0x728>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
24014eaa:	4b7f      	ldr	r3, [pc, #508]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014eac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014eae:	f023 5140 	bic.w	r1, r3, #805306368	; 0x30000000
24014eb2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014eb6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014eb8:	4a7b      	ldr	r2, [pc, #492]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014eba:	430b      	orrs	r3, r1
24014ebc:	6513      	str	r3, [r2, #80]	; 0x50
24014ebe:	e003      	b.n	24014ec8 <HAL_RCCEx_PeriphCLKConfig+0x730>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014ec0:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014ec4:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
24014ec8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014ecc:	e9d3 2300 	ldrd	r2, r3, [r3]
24014ed0:	f002 7380 	and.w	r3, r2, #16777216	; 0x1000000
24014ed4:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
24014ed8:	2300      	movs	r3, #0
24014eda:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
24014ede:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	; 0xd0
24014ee2:	460b      	mov	r3, r1
24014ee4:	4313      	orrs	r3, r2
24014ee6:	d039      	beq.n	24014f5c <HAL_RCCEx_PeriphCLKConfig+0x7c4>
  {
    switch (PeriphClkInit->FmcClockSelection)
24014ee8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014eec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24014eee:	2b03      	cmp	r3, #3
24014ef0:	d81c      	bhi.n	24014f2c <HAL_RCCEx_PeriphCLKConfig+0x794>
24014ef2:	a201      	add	r2, pc, #4	; (adr r2, 24014ef8 <HAL_RCCEx_PeriphCLKConfig+0x760>)
24014ef4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24014ef8:	24014f35 	.word	0x24014f35
24014efc:	24014f09 	.word	0x24014f09
24014f00:	24014f17 	.word	0x24014f17
24014f04:	24014f35 	.word	0x24014f35
    {
      case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
        /* Enable FMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014f08:	4b67      	ldr	r3, [pc, #412]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014f0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014f0c:	4a66      	ldr	r2, [pc, #408]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014f0e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014f12:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* FMC clock source configuration done later after clock selection check */
        break;
24014f14:	e00f      	b.n	24014f36 <HAL_RCCEx_PeriphCLKConfig+0x79e>

      case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
24014f16:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014f1a:	3308      	adds	r3, #8
24014f1c:	2102      	movs	r1, #2
24014f1e:	4618      	mov	r0, r3
24014f20:	f002 fbc0 	bl	240176a4 <RCCEx_PLL2_Config>
24014f24:	4603      	mov	r3, r0
24014f26:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* FMC clock source configuration done later after clock selection check */
        break;
24014f2a:	e004      	b.n	24014f36 <HAL_RCCEx_PeriphCLKConfig+0x79e>
      case RCC_FMCCLKSOURCE_HCLK:
        /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
24014f2c:	2301      	movs	r3, #1
24014f2e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014f32:	e000      	b.n	24014f36 <HAL_RCCEx_PeriphCLKConfig+0x79e>
        break;
24014f34:	bf00      	nop
    }

    if (ret == HAL_OK)
24014f36:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014f3a:	2b00      	cmp	r3, #0
24014f3c:	d10a      	bne.n	24014f54 <HAL_RCCEx_PeriphCLKConfig+0x7bc>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
24014f3e:	4b5a      	ldr	r3, [pc, #360]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014f40:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014f42:	f023 0103 	bic.w	r1, r3, #3
24014f46:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014f4a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24014f4c:	4a56      	ldr	r2, [pc, #344]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014f4e:	430b      	orrs	r3, r1
24014f50:	64d3      	str	r3, [r2, #76]	; 0x4c
24014f52:	e003      	b.n	24014f5c <HAL_RCCEx_PeriphCLKConfig+0x7c4>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014f54:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014f58:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
24014f5c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014f60:	e9d3 2300 	ldrd	r2, r3, [r3]
24014f64:	f402 0380 	and.w	r3, r2, #4194304	; 0x400000
24014f68:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
24014f6c:	2300      	movs	r3, #0
24014f6e:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
24014f72:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	; 0xc8
24014f76:	460b      	mov	r3, r1
24014f78:	4313      	orrs	r3, r2
24014f7a:	f000 809f 	beq.w	240150bc <HAL_RCCEx_PeriphCLKConfig+0x924>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
24014f7e:	4b4b      	ldr	r3, [pc, #300]	; (240150ac <HAL_RCCEx_PeriphCLKConfig+0x914>)
24014f80:	681b      	ldr	r3, [r3, #0]
24014f82:	4a4a      	ldr	r2, [pc, #296]	; (240150ac <HAL_RCCEx_PeriphCLKConfig+0x914>)
24014f84:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24014f88:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
24014f8a:	f7ed f847 	bl	2400201c <HAL_GetTick>
24014f8e:	f8c7 0120 	str.w	r0, [r7, #288]	; 0x120

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
24014f92:	e00b      	b.n	24014fac <HAL_RCCEx_PeriphCLKConfig+0x814>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
24014f94:	f7ed f842 	bl	2400201c <HAL_GetTick>
24014f98:	4602      	mov	r2, r0
24014f9a:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
24014f9e:	1ad3      	subs	r3, r2, r3
24014fa0:	2b64      	cmp	r3, #100	; 0x64
24014fa2:	d903      	bls.n	24014fac <HAL_RCCEx_PeriphCLKConfig+0x814>
      {
        ret = HAL_TIMEOUT;
24014fa4:	2303      	movs	r3, #3
24014fa6:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24014faa:	e005      	b.n	24014fb8 <HAL_RCCEx_PeriphCLKConfig+0x820>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
24014fac:	4b3f      	ldr	r3, [pc, #252]	; (240150ac <HAL_RCCEx_PeriphCLKConfig+0x914>)
24014fae:	681b      	ldr	r3, [r3, #0]
24014fb0:	f403 7380 	and.w	r3, r3, #256	; 0x100
24014fb4:	2b00      	cmp	r3, #0
24014fb6:	d0ed      	beq.n	24014f94 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      }
    }

    if (ret == HAL_OK)
24014fb8:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24014fbc:	2b00      	cmp	r3, #0
24014fbe:	d179      	bne.n	240150b4 <HAL_RCCEx_PeriphCLKConfig+0x91c>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if ((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
24014fc0:	4b39      	ldr	r3, [pc, #228]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014fc2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
24014fc4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24014fc8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
24014fcc:	4053      	eors	r3, r2
24014fce:	f403 7340 	and.w	r3, r3, #768	; 0x300
24014fd2:	2b00      	cmp	r3, #0
24014fd4:	d015      	beq.n	24015002 <HAL_RCCEx_PeriphCLKConfig+0x86a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
24014fd6:	4b34      	ldr	r3, [pc, #208]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014fd8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014fda:	f423 7340 	bic.w	r3, r3, #768	; 0x300
24014fde:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
24014fe2:	4b31      	ldr	r3, [pc, #196]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014fe4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014fe6:	4a30      	ldr	r2, [pc, #192]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014fe8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24014fec:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
24014fee:	4b2e      	ldr	r3, [pc, #184]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014ff0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014ff2:	4a2d      	ldr	r2, [pc, #180]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014ff4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24014ff8:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
24014ffa:	4a2b      	ldr	r2, [pc, #172]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24014ffc:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
24015000:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
24015002:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015006:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
2401500a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401500e:	d118      	bne.n	24015042 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24015010:	f7ed f804 	bl	2400201c <HAL_GetTick>
24015014:	f8c7 0120 	str.w	r0, [r7, #288]	; 0x120

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
24015018:	e00d      	b.n	24015036 <HAL_RCCEx_PeriphCLKConfig+0x89e>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
2401501a:	f7ec ffff 	bl	2400201c <HAL_GetTick>
2401501e:	4602      	mov	r2, r0
24015020:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
24015024:	1ad2      	subs	r2, r2, r3
24015026:	f241 3388 	movw	r3, #5000	; 0x1388
2401502a:	429a      	cmp	r2, r3
2401502c:	d903      	bls.n	24015036 <HAL_RCCEx_PeriphCLKConfig+0x89e>
          {
            ret = HAL_TIMEOUT;
2401502e:	2303      	movs	r3, #3
24015030:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
            break;
24015034:	e005      	b.n	24015042 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
24015036:	4b1c      	ldr	r3, [pc, #112]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24015038:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401503a:	f003 0302 	and.w	r3, r3, #2
2401503e:	2b00      	cmp	r3, #0
24015040:	d0eb      	beq.n	2401501a <HAL_RCCEx_PeriphCLKConfig+0x882>
          }
        }
      }

      if (ret == HAL_OK)
24015042:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015046:	2b00      	cmp	r3, #0
24015048:	d129      	bne.n	2401509e <HAL_RCCEx_PeriphCLKConfig+0x906>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
2401504a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401504e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
24015052:	f403 7340 	and.w	r3, r3, #768	; 0x300
24015056:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
2401505a:	d10e      	bne.n	2401507a <HAL_RCCEx_PeriphCLKConfig+0x8e2>
2401505c:	4b12      	ldr	r3, [pc, #72]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
2401505e:	691b      	ldr	r3, [r3, #16]
24015060:	f423 517c 	bic.w	r1, r3, #16128	; 0x3f00
24015064:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015068:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
2401506c:	091a      	lsrs	r2, r3, #4
2401506e:	4b10      	ldr	r3, [pc, #64]	; (240150b0 <HAL_RCCEx_PeriphCLKConfig+0x918>)
24015070:	4013      	ands	r3, r2
24015072:	4a0d      	ldr	r2, [pc, #52]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24015074:	430b      	orrs	r3, r1
24015076:	6113      	str	r3, [r2, #16]
24015078:	e005      	b.n	24015086 <HAL_RCCEx_PeriphCLKConfig+0x8ee>
2401507a:	4b0b      	ldr	r3, [pc, #44]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
2401507c:	691b      	ldr	r3, [r3, #16]
2401507e:	4a0a      	ldr	r2, [pc, #40]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24015080:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
24015084:	6113      	str	r3, [r2, #16]
24015086:	4b08      	ldr	r3, [pc, #32]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24015088:	6f19      	ldr	r1, [r3, #112]	; 0x70
2401508a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401508e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
24015092:	f3c3 030b 	ubfx	r3, r3, #0, #12
24015096:	4a04      	ldr	r2, [pc, #16]	; (240150a8 <HAL_RCCEx_PeriphCLKConfig+0x910>)
24015098:	430b      	orrs	r3, r1
2401509a:	6713      	str	r3, [r2, #112]	; 0x70
2401509c:	e00e      	b.n	240150bc <HAL_RCCEx_PeriphCLKConfig+0x924>
      }
      else
      {
        /* set overall return value */
        status = ret;
2401509e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240150a2:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
240150a6:	e009      	b.n	240150bc <HAL_RCCEx_PeriphCLKConfig+0x924>
240150a8:	58024400 	.word	0x58024400
240150ac:	58024800 	.word	0x58024800
240150b0:	00ffffcf 	.word	0x00ffffcf
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
240150b4:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240150b8:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
240150bc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240150c0:	e9d3 2300 	ldrd	r2, r3, [r3]
240150c4:	f002 0301 	and.w	r3, r2, #1
240150c8:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
240150cc:	2300      	movs	r3, #0
240150ce:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
240150d2:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	; 0xc0
240150d6:	460b      	mov	r3, r1
240150d8:	4313      	orrs	r3, r2
240150da:	f000 8089 	beq.w	240151f0 <HAL_RCCEx_PeriphCLKConfig+0xa58>
  {
    switch (PeriphClkInit->Usart16ClockSelection)
240150de:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240150e2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
240150e4:	2b28      	cmp	r3, #40	; 0x28
240150e6:	d86b      	bhi.n	240151c0 <HAL_RCCEx_PeriphCLKConfig+0xa28>
240150e8:	a201      	add	r2, pc, #4	; (adr r2, 240150f0 <HAL_RCCEx_PeriphCLKConfig+0x958>)
240150ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240150ee:	bf00      	nop
240150f0:	240151c9 	.word	0x240151c9
240150f4:	240151c1 	.word	0x240151c1
240150f8:	240151c1 	.word	0x240151c1
240150fc:	240151c1 	.word	0x240151c1
24015100:	240151c1 	.word	0x240151c1
24015104:	240151c1 	.word	0x240151c1
24015108:	240151c1 	.word	0x240151c1
2401510c:	240151c1 	.word	0x240151c1
24015110:	24015195 	.word	0x24015195
24015114:	240151c1 	.word	0x240151c1
24015118:	240151c1 	.word	0x240151c1
2401511c:	240151c1 	.word	0x240151c1
24015120:	240151c1 	.word	0x240151c1
24015124:	240151c1 	.word	0x240151c1
24015128:	240151c1 	.word	0x240151c1
2401512c:	240151c1 	.word	0x240151c1
24015130:	240151ab 	.word	0x240151ab
24015134:	240151c1 	.word	0x240151c1
24015138:	240151c1 	.word	0x240151c1
2401513c:	240151c1 	.word	0x240151c1
24015140:	240151c1 	.word	0x240151c1
24015144:	240151c1 	.word	0x240151c1
24015148:	240151c1 	.word	0x240151c1
2401514c:	240151c1 	.word	0x240151c1
24015150:	240151c9 	.word	0x240151c9
24015154:	240151c1 	.word	0x240151c1
24015158:	240151c1 	.word	0x240151c1
2401515c:	240151c1 	.word	0x240151c1
24015160:	240151c1 	.word	0x240151c1
24015164:	240151c1 	.word	0x240151c1
24015168:	240151c1 	.word	0x240151c1
2401516c:	240151c1 	.word	0x240151c1
24015170:	240151c9 	.word	0x240151c9
24015174:	240151c1 	.word	0x240151c1
24015178:	240151c1 	.word	0x240151c1
2401517c:	240151c1 	.word	0x240151c1
24015180:	240151c1 	.word	0x240151c1
24015184:	240151c1 	.word	0x240151c1
24015188:	240151c1 	.word	0x240151c1
2401518c:	240151c1 	.word	0x240151c1
24015190:	240151c9 	.word	0x240151c9
      case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
24015194:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015198:	3308      	adds	r3, #8
2401519a:	2101      	movs	r1, #1
2401519c:	4618      	mov	r0, r3
2401519e:	f002 fa81 	bl	240176a4 <RCCEx_PLL2_Config>
240151a2:	4603      	mov	r3, r0
240151a4:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
240151a8:	e00f      	b.n	240151ca <HAL_RCCEx_PeriphCLKConfig+0xa32>

      case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
240151aa:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240151ae:	3328      	adds	r3, #40	; 0x28
240151b0:	2101      	movs	r1, #1
240151b2:	4618      	mov	r0, r3
240151b4:	f002 fb28 	bl	24017808 <RCCEx_PLL3_Config>
240151b8:	4603      	mov	r3, r0
240151ba:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
240151be:	e004      	b.n	240151ca <HAL_RCCEx_PeriphCLKConfig+0xa32>
        /* LSE,  oscillator is used as source of USART1/6 clock */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
240151c0:	2301      	movs	r3, #1
240151c2:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
240151c6:	e000      	b.n	240151ca <HAL_RCCEx_PeriphCLKConfig+0xa32>
        break;
240151c8:	bf00      	nop
    }

    if (ret == HAL_OK)
240151ca:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240151ce:	2b00      	cmp	r3, #0
240151d0:	d10a      	bne.n	240151e8 <HAL_RCCEx_PeriphCLKConfig+0xa50>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
240151d2:	4bbf      	ldr	r3, [pc, #764]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
240151d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240151d6:	f023 0138 	bic.w	r1, r3, #56	; 0x38
240151da:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240151de:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
240151e0:	4abb      	ldr	r2, [pc, #748]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
240151e2:	430b      	orrs	r3, r1
240151e4:	6553      	str	r3, [r2, #84]	; 0x54
240151e6:	e003      	b.n	240151f0 <HAL_RCCEx_PeriphCLKConfig+0xa58>
    }
    else
    {
      /* set overall return value */
      status = ret;
240151e8:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240151ec:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
240151f0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240151f4:	e9d3 2300 	ldrd	r2, r3, [r3]
240151f8:	f002 0302 	and.w	r3, r2, #2
240151fc:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
24015200:	2300      	movs	r3, #0
24015202:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
24015206:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	; 0xb8
2401520a:	460b      	mov	r3, r1
2401520c:	4313      	orrs	r3, r2
2401520e:	d041      	beq.n	24015294 <HAL_RCCEx_PeriphCLKConfig+0xafc>
  {
    switch (PeriphClkInit->Usart234578ClockSelection)
24015210:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015214:	6f9b      	ldr	r3, [r3, #120]	; 0x78
24015216:	2b05      	cmp	r3, #5
24015218:	d824      	bhi.n	24015264 <HAL_RCCEx_PeriphCLKConfig+0xacc>
2401521a:	a201      	add	r2, pc, #4	; (adr r2, 24015220 <HAL_RCCEx_PeriphCLKConfig+0xa88>)
2401521c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24015220:	2401526d 	.word	0x2401526d
24015224:	24015239 	.word	0x24015239
24015228:	2401524f 	.word	0x2401524f
2401522c:	2401526d 	.word	0x2401526d
24015230:	2401526d 	.word	0x2401526d
24015234:	2401526d 	.word	0x2401526d
      case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
24015238:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401523c:	3308      	adds	r3, #8
2401523e:	2101      	movs	r1, #1
24015240:	4618      	mov	r0, r3
24015242:	f002 fa2f 	bl	240176a4 <RCCEx_PLL2_Config>
24015246:	4603      	mov	r3, r0
24015248:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
2401524c:	e00f      	b.n	2401526e <HAL_RCCEx_PeriphCLKConfig+0xad6>

      case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
2401524e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015252:	3328      	adds	r3, #40	; 0x28
24015254:	2101      	movs	r1, #1
24015256:	4618      	mov	r0, r3
24015258:	f002 fad6 	bl	24017808 <RCCEx_PLL3_Config>
2401525c:	4603      	mov	r3, r0
2401525e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
24015262:	e004      	b.n	2401526e <HAL_RCCEx_PeriphCLKConfig+0xad6>
        /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
24015264:	2301      	movs	r3, #1
24015266:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
2401526a:	e000      	b.n	2401526e <HAL_RCCEx_PeriphCLKConfig+0xad6>
        break;
2401526c:	bf00      	nop
    }

    if (ret == HAL_OK)
2401526e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015272:	2b00      	cmp	r3, #0
24015274:	d10a      	bne.n	2401528c <HAL_RCCEx_PeriphCLKConfig+0xaf4>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
24015276:	4b96      	ldr	r3, [pc, #600]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
24015278:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401527a:	f023 0107 	bic.w	r1, r3, #7
2401527e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015282:	6f9b      	ldr	r3, [r3, #120]	; 0x78
24015284:	4a92      	ldr	r2, [pc, #584]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
24015286:	430b      	orrs	r3, r1
24015288:	6553      	str	r3, [r2, #84]	; 0x54
2401528a:	e003      	b.n	24015294 <HAL_RCCEx_PeriphCLKConfig+0xafc>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401528c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015290:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
24015294:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015298:	e9d3 2300 	ldrd	r2, r3, [r3]
2401529c:	f002 0304 	and.w	r3, r2, #4
240152a0:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
240152a4:	2300      	movs	r3, #0
240152a6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
240152aa:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	; 0xb0
240152ae:	460b      	mov	r3, r1
240152b0:	4313      	orrs	r3, r2
240152b2:	d044      	beq.n	2401533e <HAL_RCCEx_PeriphCLKConfig+0xba6>
  {
    switch (PeriphClkInit->Lpuart1ClockSelection)
240152b4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240152b8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
240152bc:	2b05      	cmp	r3, #5
240152be:	d825      	bhi.n	2401530c <HAL_RCCEx_PeriphCLKConfig+0xb74>
240152c0:	a201      	add	r2, pc, #4	; (adr r2, 240152c8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
240152c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240152c6:	bf00      	nop
240152c8:	24015315 	.word	0x24015315
240152cc:	240152e1 	.word	0x240152e1
240152d0:	240152f7 	.word	0x240152f7
240152d4:	24015315 	.word	0x24015315
240152d8:	24015315 	.word	0x24015315
240152dc:	24015315 	.word	0x24015315
      case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
240152e0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240152e4:	3308      	adds	r3, #8
240152e6:	2101      	movs	r1, #1
240152e8:	4618      	mov	r0, r3
240152ea:	f002 f9db 	bl	240176a4 <RCCEx_PLL2_Config>
240152ee:	4603      	mov	r3, r0
240152f0:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
240152f4:	e00f      	b.n	24015316 <HAL_RCCEx_PeriphCLKConfig+0xb7e>

      case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
240152f6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240152fa:	3328      	adds	r3, #40	; 0x28
240152fc:	2101      	movs	r1, #1
240152fe:	4618      	mov	r0, r3
24015300:	f002 fa82 	bl	24017808 <RCCEx_PLL3_Config>
24015304:	4603      	mov	r3, r0
24015306:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
2401530a:	e004      	b.n	24015316 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        /* LSE,  oscillator is used as source of LPUART1 clock */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
2401530c:	2301      	movs	r3, #1
2401530e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24015312:	e000      	b.n	24015316 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
24015314:	bf00      	nop
    }

    if (ret == HAL_OK)
24015316:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
2401531a:	2b00      	cmp	r3, #0
2401531c:	d10b      	bne.n	24015336 <HAL_RCCEx_PeriphCLKConfig+0xb9e>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
2401531e:	4b6c      	ldr	r3, [pc, #432]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
24015320:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015322:	f023 0107 	bic.w	r1, r3, #7
24015326:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401532a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2401532e:	4a68      	ldr	r2, [pc, #416]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
24015330:	430b      	orrs	r3, r1
24015332:	6593      	str	r3, [r2, #88]	; 0x58
24015334:	e003      	b.n	2401533e <HAL_RCCEx_PeriphCLKConfig+0xba6>
    }
    else
    {
      /* set overall return value */
      status = ret;
24015336:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
2401533a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
2401533e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015342:	e9d3 2300 	ldrd	r2, r3, [r3]
24015346:	f002 0320 	and.w	r3, r2, #32
2401534a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
2401534e:	2300      	movs	r3, #0
24015350:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
24015354:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	; 0xa8
24015358:	460b      	mov	r3, r1
2401535a:	4313      	orrs	r3, r2
2401535c:	d055      	beq.n	2401540a <HAL_RCCEx_PeriphCLKConfig+0xc72>
  {
    switch (PeriphClkInit->Lptim1ClockSelection)
2401535e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015362:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
24015366:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
2401536a:	d033      	beq.n	240153d4 <HAL_RCCEx_PeriphCLKConfig+0xc3c>
2401536c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24015370:	d82c      	bhi.n	240153cc <HAL_RCCEx_PeriphCLKConfig+0xc34>
24015372:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24015376:	d02f      	beq.n	240153d8 <HAL_RCCEx_PeriphCLKConfig+0xc40>
24015378:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401537c:	d826      	bhi.n	240153cc <HAL_RCCEx_PeriphCLKConfig+0xc34>
2401537e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24015382:	d02b      	beq.n	240153dc <HAL_RCCEx_PeriphCLKConfig+0xc44>
24015384:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24015388:	d820      	bhi.n	240153cc <HAL_RCCEx_PeriphCLKConfig+0xc34>
2401538a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401538e:	d012      	beq.n	240153b6 <HAL_RCCEx_PeriphCLKConfig+0xc1e>
24015390:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015394:	d81a      	bhi.n	240153cc <HAL_RCCEx_PeriphCLKConfig+0xc34>
24015396:	2b00      	cmp	r3, #0
24015398:	d022      	beq.n	240153e0 <HAL_RCCEx_PeriphCLKConfig+0xc48>
2401539a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2401539e:	d115      	bne.n	240153cc <HAL_RCCEx_PeriphCLKConfig+0xc34>
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
240153a0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240153a4:	3308      	adds	r3, #8
240153a6:	2100      	movs	r1, #0
240153a8:	4618      	mov	r0, r3
240153aa:	f002 f97b 	bl	240176a4 <RCCEx_PLL2_Config>
240153ae:	4603      	mov	r3, r0
240153b0:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
240153b4:	e015      	b.n	240153e2 <HAL_RCCEx_PeriphCLKConfig+0xc4a>

      case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
240153b6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240153ba:	3328      	adds	r3, #40	; 0x28
240153bc:	2102      	movs	r1, #2
240153be:	4618      	mov	r0, r3
240153c0:	f002 fa22 	bl	24017808 <RCCEx_PLL3_Config>
240153c4:	4603      	mov	r3, r0
240153c6:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
240153ca:	e00a      	b.n	240153e2 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
240153cc:	2301      	movs	r3, #1
240153ce:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
240153d2:	e006      	b.n	240153e2 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
240153d4:	bf00      	nop
240153d6:	e004      	b.n	240153e2 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
240153d8:	bf00      	nop
240153da:	e002      	b.n	240153e2 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
240153dc:	bf00      	nop
240153de:	e000      	b.n	240153e2 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
240153e0:	bf00      	nop
    }

    if (ret == HAL_OK)
240153e2:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240153e6:	2b00      	cmp	r3, #0
240153e8:	d10b      	bne.n	24015402 <HAL_RCCEx_PeriphCLKConfig+0xc6a>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
240153ea:	4b39      	ldr	r3, [pc, #228]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
240153ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240153ee:	f023 41e0 	bic.w	r1, r3, #1879048192	; 0x70000000
240153f2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240153f6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
240153fa:	4a35      	ldr	r2, [pc, #212]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
240153fc:	430b      	orrs	r3, r1
240153fe:	6553      	str	r3, [r2, #84]	; 0x54
24015400:	e003      	b.n	2401540a <HAL_RCCEx_PeriphCLKConfig+0xc72>
    }
    else
    {
      /* set overall return value */
      status = ret;
24015402:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015406:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
2401540a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401540e:	e9d3 2300 	ldrd	r2, r3, [r3]
24015412:	f002 0340 	and.w	r3, r2, #64	; 0x40
24015416:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
2401541a:	2300      	movs	r3, #0
2401541c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
24015420:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	; 0xa0
24015424:	460b      	mov	r3, r1
24015426:	4313      	orrs	r3, r2
24015428:	d058      	beq.n	240154dc <HAL_RCCEx_PeriphCLKConfig+0xd44>
  {
    switch (PeriphClkInit->Lptim2ClockSelection)
2401542a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401542e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
24015432:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
24015436:	d033      	beq.n	240154a0 <HAL_RCCEx_PeriphCLKConfig+0xd08>
24015438:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
2401543c:	d82c      	bhi.n	24015498 <HAL_RCCEx_PeriphCLKConfig+0xd00>
2401543e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24015442:	d02f      	beq.n	240154a4 <HAL_RCCEx_PeriphCLKConfig+0xd0c>
24015444:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24015448:	d826      	bhi.n	24015498 <HAL_RCCEx_PeriphCLKConfig+0xd00>
2401544a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
2401544e:	d02b      	beq.n	240154a8 <HAL_RCCEx_PeriphCLKConfig+0xd10>
24015450:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
24015454:	d820      	bhi.n	24015498 <HAL_RCCEx_PeriphCLKConfig+0xd00>
24015456:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401545a:	d012      	beq.n	24015482 <HAL_RCCEx_PeriphCLKConfig+0xcea>
2401545c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
24015460:	d81a      	bhi.n	24015498 <HAL_RCCEx_PeriphCLKConfig+0xd00>
24015462:	2b00      	cmp	r3, #0
24015464:	d022      	beq.n	240154ac <HAL_RCCEx_PeriphCLKConfig+0xd14>
24015466:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401546a:	d115      	bne.n	24015498 <HAL_RCCEx_PeriphCLKConfig+0xd00>
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
2401546c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015470:	3308      	adds	r3, #8
24015472:	2100      	movs	r1, #0
24015474:	4618      	mov	r0, r3
24015476:	f002 f915 	bl	240176a4 <RCCEx_PLL2_Config>
2401547a:	4603      	mov	r3, r0
2401547c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
24015480:	e015      	b.n	240154ae <HAL_RCCEx_PeriphCLKConfig+0xd16>

      case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
24015482:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015486:	3328      	adds	r3, #40	; 0x28
24015488:	2102      	movs	r1, #2
2401548a:	4618      	mov	r0, r3
2401548c:	f002 f9bc 	bl	24017808 <RCCEx_PLL3_Config>
24015490:	4603      	mov	r3, r0
24015492:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
24015496:	e00a      	b.n	240154ae <HAL_RCCEx_PeriphCLKConfig+0xd16>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
24015498:	2301      	movs	r3, #1
2401549a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
2401549e:	e006      	b.n	240154ae <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
240154a0:	bf00      	nop
240154a2:	e004      	b.n	240154ae <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
240154a4:	bf00      	nop
240154a6:	e002      	b.n	240154ae <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
240154a8:	bf00      	nop
240154aa:	e000      	b.n	240154ae <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
240154ac:	bf00      	nop
    }

    if (ret == HAL_OK)
240154ae:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240154b2:	2b00      	cmp	r3, #0
240154b4:	d10e      	bne.n	240154d4 <HAL_RCCEx_PeriphCLKConfig+0xd3c>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
240154b6:	4b06      	ldr	r3, [pc, #24]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
240154b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240154ba:	f423 51e0 	bic.w	r1, r3, #7168	; 0x1c00
240154be:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240154c2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
240154c6:	4a02      	ldr	r2, [pc, #8]	; (240154d0 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
240154c8:	430b      	orrs	r3, r1
240154ca:	6593      	str	r3, [r2, #88]	; 0x58
240154cc:	e006      	b.n	240154dc <HAL_RCCEx_PeriphCLKConfig+0xd44>
240154ce:	bf00      	nop
240154d0:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
240154d4:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240154d8:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
240154dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240154e0:	e9d3 2300 	ldrd	r2, r3, [r3]
240154e4:	f002 0380 	and.w	r3, r2, #128	; 0x80
240154e8:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
240154ec:	2300      	movs	r3, #0
240154ee:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
240154f2:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	; 0x98
240154f6:	460b      	mov	r3, r1
240154f8:	4313      	orrs	r3, r2
240154fa:	d055      	beq.n	240155a8 <HAL_RCCEx_PeriphCLKConfig+0xe10>
  {
    switch (PeriphClkInit->Lptim345ClockSelection)
240154fc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015500:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
24015504:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
24015508:	d033      	beq.n	24015572 <HAL_RCCEx_PeriphCLKConfig+0xdda>
2401550a:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
2401550e:	d82c      	bhi.n	2401556a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
24015510:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24015514:	d02f      	beq.n	24015576 <HAL_RCCEx_PeriphCLKConfig+0xdde>
24015516:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2401551a:	d826      	bhi.n	2401556a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
2401551c:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
24015520:	d02b      	beq.n	2401557a <HAL_RCCEx_PeriphCLKConfig+0xde2>
24015522:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
24015526:	d820      	bhi.n	2401556a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
24015528:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401552c:	d012      	beq.n	24015554 <HAL_RCCEx_PeriphCLKConfig+0xdbc>
2401552e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24015532:	d81a      	bhi.n	2401556a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
24015534:	2b00      	cmp	r3, #0
24015536:	d022      	beq.n	2401557e <HAL_RCCEx_PeriphCLKConfig+0xde6>
24015538:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401553c:	d115      	bne.n	2401556a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
      case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
2401553e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015542:	3308      	adds	r3, #8
24015544:	2100      	movs	r1, #0
24015546:	4618      	mov	r0, r3
24015548:	f002 f8ac 	bl	240176a4 <RCCEx_PLL2_Config>
2401554c:	4603      	mov	r3, r0
2401554e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
24015552:	e015      	b.n	24015580 <HAL_RCCEx_PeriphCLKConfig+0xde8>

      case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
24015554:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015558:	3328      	adds	r3, #40	; 0x28
2401555a:	2102      	movs	r1, #2
2401555c:	4618      	mov	r0, r3
2401555e:	f002 f953 	bl	24017808 <RCCEx_PLL3_Config>
24015562:	4603      	mov	r3, r0
24015564:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
24015568:	e00a      	b.n	24015580 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
2401556a:	2301      	movs	r3, #1
2401556c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
24015570:	e006      	b.n	24015580 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
24015572:	bf00      	nop
24015574:	e004      	b.n	24015580 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
24015576:	bf00      	nop
24015578:	e002      	b.n	24015580 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
2401557a:	bf00      	nop
2401557c:	e000      	b.n	24015580 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
2401557e:	bf00      	nop
    }

    if (ret == HAL_OK)
24015580:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015584:	2b00      	cmp	r3, #0
24015586:	d10b      	bne.n	240155a0 <HAL_RCCEx_PeriphCLKConfig+0xe08>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
24015588:	4ba1      	ldr	r3, [pc, #644]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
2401558a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401558c:	f423 4160 	bic.w	r1, r3, #57344	; 0xe000
24015590:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015594:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
24015598:	4a9d      	ldr	r2, [pc, #628]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
2401559a:	430b      	orrs	r3, r1
2401559c:	6593      	str	r3, [r2, #88]	; 0x58
2401559e:	e003      	b.n	240155a8 <HAL_RCCEx_PeriphCLKConfig+0xe10>
    }
    else
    {
      /* set overall return value */
      status = ret;
240155a0:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240155a4:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126

    __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
240155a8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240155ac:	e9d3 2300 	ldrd	r2, r3, [r3]
240155b0:	f002 0308 	and.w	r3, r2, #8
240155b4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
240155b8:	2300      	movs	r3, #0
240155ba:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
240155be:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	; 0x90
240155c2:	460b      	mov	r3, r1
240155c4:	4313      	orrs	r3, r2
240155c6:	d01e      	beq.n	24015606 <HAL_RCCEx_PeriphCLKConfig+0xe6e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection) == RCC_I2C123CLKSOURCE_PLL3)
240155c8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240155cc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
240155d0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
240155d4:	d10c      	bne.n	240155f0 <HAL_RCCEx_PeriphCLKConfig+0xe58>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
240155d6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240155da:	3328      	adds	r3, #40	; 0x28
240155dc:	2102      	movs	r1, #2
240155de:	4618      	mov	r0, r3
240155e0:	f002 f912 	bl	24017808 <RCCEx_PLL3_Config>
240155e4:	4603      	mov	r3, r0
240155e6:	2b00      	cmp	r3, #0
240155e8:	d002      	beq.n	240155f0 <HAL_RCCEx_PeriphCLKConfig+0xe58>
      {
        status = HAL_ERROR;
240155ea:	2301      	movs	r3, #1
240155ec:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
      }
    }

    __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
240155f0:	4b87      	ldr	r3, [pc, #540]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
240155f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240155f4:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
240155f8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240155fc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24015600:	4a83      	ldr	r2, [pc, #524]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
24015602:	430b      	orrs	r3, r1
24015604:	6553      	str	r3, [r2, #84]	; 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
24015606:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401560a:	e9d3 2300 	ldrd	r2, r3, [r3]
2401560e:	f002 0310 	and.w	r3, r2, #16
24015612:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
24015616:	2300      	movs	r3, #0
24015618:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
2401561c:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	; 0x88
24015620:	460b      	mov	r3, r1
24015622:	4313      	orrs	r3, r2
24015624:	d01e      	beq.n	24015664 <HAL_RCCEx_PeriphCLKConfig+0xecc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3)
24015626:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401562a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2401562e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015632:	d10c      	bne.n	2401564e <HAL_RCCEx_PeriphCLKConfig+0xeb6>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
24015634:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015638:	3328      	adds	r3, #40	; 0x28
2401563a:	2102      	movs	r1, #2
2401563c:	4618      	mov	r0, r3
2401563e:	f002 f8e3 	bl	24017808 <RCCEx_PLL3_Config>
24015642:	4603      	mov	r3, r0
24015644:	2b00      	cmp	r3, #0
24015646:	d002      	beq.n	2401564e <HAL_RCCEx_PeriphCLKConfig+0xeb6>
      {
        status = HAL_ERROR;
24015648:	2301      	movs	r3, #1
2401564a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
      }
    }

    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
2401564e:	4b70      	ldr	r3, [pc, #448]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
24015650:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015652:	f423 7140 	bic.w	r1, r3, #768	; 0x300
24015656:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401565a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2401565e:	4a6c      	ldr	r2, [pc, #432]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
24015660:	430b      	orrs	r3, r1
24015662:	6593      	str	r3, [r2, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
24015664:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015668:	e9d3 2300 	ldrd	r2, r3, [r3]
2401566c:	f402 2300 	and.w	r3, r2, #524288	; 0x80000
24015670:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
24015674:	2300      	movs	r3, #0
24015676:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
2401567a:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	; 0x80
2401567e:	460b      	mov	r3, r1
24015680:	4313      	orrs	r3, r2
24015682:	d03e      	beq.n	24015702 <HAL_RCCEx_PeriphCLKConfig+0xf6a>
  {
    switch (PeriphClkInit->AdcClockSelection)
24015684:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015688:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
2401568c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015690:	d022      	beq.n	240156d8 <HAL_RCCEx_PeriphCLKConfig+0xf40>
24015692:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015696:	d81b      	bhi.n	240156d0 <HAL_RCCEx_PeriphCLKConfig+0xf38>
24015698:	2b00      	cmp	r3, #0
2401569a:	d003      	beq.n	240156a4 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
2401569c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240156a0:	d00b      	beq.n	240156ba <HAL_RCCEx_PeriphCLKConfig+0xf22>
240156a2:	e015      	b.n	240156d0 <HAL_RCCEx_PeriphCLKConfig+0xf38>
    {

      case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
240156a4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240156a8:	3308      	adds	r3, #8
240156aa:	2100      	movs	r1, #0
240156ac:	4618      	mov	r0, r3
240156ae:	f001 fff9 	bl	240176a4 <RCCEx_PLL2_Config>
240156b2:	4603      	mov	r3, r0
240156b4:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
240156b8:	e00f      	b.n	240156da <HAL_RCCEx_PeriphCLKConfig+0xf42>

      case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
240156ba:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240156be:	3328      	adds	r3, #40	; 0x28
240156c0:	2102      	movs	r1, #2
240156c2:	4618      	mov	r0, r3
240156c4:	f002 f8a0 	bl	24017808 <RCCEx_PLL3_Config>
240156c8:	4603      	mov	r3, r0
240156ca:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
240156ce:	e004      	b.n	240156da <HAL_RCCEx_PeriphCLKConfig+0xf42>
        /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
        /* ADC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
240156d0:	2301      	movs	r3, #1
240156d2:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
240156d6:	e000      	b.n	240156da <HAL_RCCEx_PeriphCLKConfig+0xf42>
        break;
240156d8:	bf00      	nop
    }

    if (ret == HAL_OK)
240156da:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240156de:	2b00      	cmp	r3, #0
240156e0:	d10b      	bne.n	240156fa <HAL_RCCEx_PeriphCLKConfig+0xf62>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
240156e2:	4b4b      	ldr	r3, [pc, #300]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
240156e4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240156e6:	f423 3140 	bic.w	r1, r3, #196608	; 0x30000
240156ea:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240156ee:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
240156f2:	4a47      	ldr	r2, [pc, #284]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
240156f4:	430b      	orrs	r3, r1
240156f6:	6593      	str	r3, [r2, #88]	; 0x58
240156f8:	e003      	b.n	24015702 <HAL_RCCEx_PeriphCLKConfig+0xf6a>
    }
    else
    {
      /* set overall return value */
      status = ret;
240156fa:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240156fe:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
24015702:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015706:	e9d3 2300 	ldrd	r2, r3, [r3]
2401570a:	f402 2380 	and.w	r3, r2, #262144	; 0x40000
2401570e:	67bb      	str	r3, [r7, #120]	; 0x78
24015710:	2300      	movs	r3, #0
24015712:	67fb      	str	r3, [r7, #124]	; 0x7c
24015714:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	; 0x78
24015718:	460b      	mov	r3, r1
2401571a:	4313      	orrs	r3, r2
2401571c:	d03b      	beq.n	24015796 <HAL_RCCEx_PeriphCLKConfig+0xffe>
  {

    switch (PeriphClkInit->UsbClockSelection)
2401571e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015722:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24015726:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
2401572a:	d01f      	beq.n	2401576c <HAL_RCCEx_PeriphCLKConfig+0xfd4>
2401572c:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24015730:	d818      	bhi.n	24015764 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
24015732:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
24015736:	d003      	beq.n	24015740 <HAL_RCCEx_PeriphCLKConfig+0xfa8>
24015738:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2401573c:	d007      	beq.n	2401574e <HAL_RCCEx_PeriphCLKConfig+0xfb6>
2401573e:	e011      	b.n	24015764 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
    {
      case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
        /* Enable USB Clock output generated form System USB . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24015740:	4b33      	ldr	r3, [pc, #204]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
24015742:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015744:	4a32      	ldr	r2, [pc, #200]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
24015746:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2401574a:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* USB clock source configuration done later after clock selection check */
        break;
2401574c:	e00f      	b.n	2401576e <HAL_RCCEx_PeriphCLKConfig+0xfd6>

      case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
2401574e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015752:	3328      	adds	r3, #40	; 0x28
24015754:	2101      	movs	r1, #1
24015756:	4618      	mov	r0, r3
24015758:	f002 f856 	bl	24017808 <RCCEx_PLL3_Config>
2401575c:	4603      	mov	r3, r0
2401575e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* USB clock source configuration done later after clock selection check */
        break;
24015762:	e004      	b.n	2401576e <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        /* HSI48 oscillator is used as source of USB clock */
        /* USB clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
24015764:	2301      	movs	r3, #1
24015766:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
2401576a:	e000      	b.n	2401576e <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        break;
2401576c:	bf00      	nop
    }

    if (ret == HAL_OK)
2401576e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015772:	2b00      	cmp	r3, #0
24015774:	d10b      	bne.n	2401578e <HAL_RCCEx_PeriphCLKConfig+0xff6>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
24015776:	4b26      	ldr	r3, [pc, #152]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
24015778:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401577a:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
2401577e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015782:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24015786:	4a22      	ldr	r2, [pc, #136]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
24015788:	430b      	orrs	r3, r1
2401578a:	6553      	str	r3, [r2, #84]	; 0x54
2401578c:	e003      	b.n	24015796 <HAL_RCCEx_PeriphCLKConfig+0xffe>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401578e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015792:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
24015796:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401579a:	e9d3 2300 	ldrd	r2, r3, [r3]
2401579e:	f402 3380 	and.w	r3, r2, #65536	; 0x10000
240157a2:	673b      	str	r3, [r7, #112]	; 0x70
240157a4:	2300      	movs	r3, #0
240157a6:	677b      	str	r3, [r7, #116]	; 0x74
240157a8:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	; 0x70
240157ac:	460b      	mov	r3, r1
240157ae:	4313      	orrs	r3, r2
240157b0:	d034      	beq.n	2401581c <HAL_RCCEx_PeriphCLKConfig+0x1084>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch (PeriphClkInit->SdmmcClockSelection)
240157b2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240157b6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240157b8:	2b00      	cmp	r3, #0
240157ba:	d003      	beq.n	240157c4 <HAL_RCCEx_PeriphCLKConfig+0x102c>
240157bc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240157c0:	d007      	beq.n	240157d2 <HAL_RCCEx_PeriphCLKConfig+0x103a>
240157c2:	e011      	b.n	240157e8 <HAL_RCCEx_PeriphCLKConfig+0x1050>
    {
      case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
        /* Enable SDMMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240157c4:	4b12      	ldr	r3, [pc, #72]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
240157c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240157c8:	4a11      	ldr	r2, [pc, #68]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
240157ca:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240157ce:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SDMMC clock source configuration done later after clock selection check */
        break;
240157d0:	e00e      	b.n	240157f0 <HAL_RCCEx_PeriphCLKConfig+0x1058>

      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
240157d2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240157d6:	3308      	adds	r3, #8
240157d8:	2102      	movs	r1, #2
240157da:	4618      	mov	r0, r3
240157dc:	f001 ff62 	bl	240176a4 <RCCEx_PLL2_Config>
240157e0:	4603      	mov	r3, r0
240157e2:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SDMMC clock source configuration done later after clock selection check */
        break;
240157e6:	e003      	b.n	240157f0 <HAL_RCCEx_PeriphCLKConfig+0x1058>

      default:
        ret = HAL_ERROR;
240157e8:	2301      	movs	r3, #1
240157ea:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
240157ee:	bf00      	nop
    }

    if (ret == HAL_OK)
240157f0:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240157f4:	2b00      	cmp	r3, #0
240157f6:	d10d      	bne.n	24015814 <HAL_RCCEx_PeriphCLKConfig+0x107c>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
240157f8:	4b05      	ldr	r3, [pc, #20]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
240157fa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240157fc:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
24015800:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015804:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015806:	4a02      	ldr	r2, [pc, #8]	; (24015810 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
24015808:	430b      	orrs	r3, r1
2401580a:	64d3      	str	r3, [r2, #76]	; 0x4c
2401580c:	e006      	b.n	2401581c <HAL_RCCEx_PeriphCLKConfig+0x1084>
2401580e:	bf00      	nop
24015810:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
24015814:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015818:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
2401581c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015820:	e9d3 2300 	ldrd	r2, r3, [r3]
24015824:	f002 5300 	and.w	r3, r2, #536870912	; 0x20000000
24015828:	66bb      	str	r3, [r7, #104]	; 0x68
2401582a:	2300      	movs	r3, #0
2401582c:	66fb      	str	r3, [r7, #108]	; 0x6c
2401582e:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	; 0x68
24015832:	460b      	mov	r3, r1
24015834:	4313      	orrs	r3, r2
24015836:	d00c      	beq.n	24015852 <HAL_RCCEx_PeriphCLKConfig+0x10ba>
  {
    if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
24015838:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401583c:	3328      	adds	r3, #40	; 0x28
2401583e:	2102      	movs	r1, #2
24015840:	4618      	mov	r0, r3
24015842:	f001 ffe1 	bl	24017808 <RCCEx_PLL3_Config>
24015846:	4603      	mov	r3, r0
24015848:	2b00      	cmp	r3, #0
2401584a:	d002      	beq.n	24015852 <HAL_RCCEx_PeriphCLKConfig+0x10ba>
    {
      status = HAL_ERROR;
2401584c:	2301      	movs	r3, #1
2401584e:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
24015852:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015856:	e9d3 2300 	ldrd	r2, r3, [r3]
2401585a:	f402 3300 	and.w	r3, r2, #131072	; 0x20000
2401585e:	663b      	str	r3, [r7, #96]	; 0x60
24015860:	2300      	movs	r3, #0
24015862:	667b      	str	r3, [r7, #100]	; 0x64
24015864:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	; 0x60
24015868:	460b      	mov	r3, r1
2401586a:	4313      	orrs	r3, r2
2401586c:	d038      	beq.n	240158e0 <HAL_RCCEx_PeriphCLKConfig+0x1148>
  {

    switch (PeriphClkInit->RngClockSelection)
2401586e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015872:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24015876:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
2401587a:	d018      	beq.n	240158ae <HAL_RCCEx_PeriphCLKConfig+0x1116>
2401587c:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
24015880:	d811      	bhi.n	240158a6 <HAL_RCCEx_PeriphCLKConfig+0x110e>
24015882:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24015886:	d014      	beq.n	240158b2 <HAL_RCCEx_PeriphCLKConfig+0x111a>
24015888:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2401588c:	d80b      	bhi.n	240158a6 <HAL_RCCEx_PeriphCLKConfig+0x110e>
2401588e:	2b00      	cmp	r3, #0
24015890:	d011      	beq.n	240158b6 <HAL_RCCEx_PeriphCLKConfig+0x111e>
24015892:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015896:	d106      	bne.n	240158a6 <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
        /* Enable RNG Clock output generated form System RNG . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24015898:	4bc3      	ldr	r3, [pc, #780]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
2401589a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401589c:	4ac2      	ldr	r2, [pc, #776]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
2401589e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240158a2:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* RNG clock source configuration done later after clock selection check */
        break;
240158a4:	e008      	b.n	240158b8 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
240158a6:	2301      	movs	r3, #1
240158a8:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
240158ac:	e004      	b.n	240158b8 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
240158ae:	bf00      	nop
240158b0:	e002      	b.n	240158b8 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
240158b2:	bf00      	nop
240158b4:	e000      	b.n	240158b8 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
240158b6:	bf00      	nop
    }

    if (ret == HAL_OK)
240158b8:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240158bc:	2b00      	cmp	r3, #0
240158be:	d10b      	bne.n	240158d8 <HAL_RCCEx_PeriphCLKConfig+0x1140>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
240158c0:	4bb9      	ldr	r3, [pc, #740]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
240158c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240158c4:	f423 7140 	bic.w	r1, r3, #768	; 0x300
240158c8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240158cc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
240158d0:	4ab5      	ldr	r2, [pc, #724]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
240158d2:	430b      	orrs	r3, r1
240158d4:	6553      	str	r3, [r2, #84]	; 0x54
240158d6:	e003      	b.n	240158e0 <HAL_RCCEx_PeriphCLKConfig+0x1148>
    }
    else
    {
      /* set overall return value */
      status = ret;
240158d8:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
240158dc:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
240158e0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240158e4:	e9d3 2300 	ldrd	r2, r3, [r3]
240158e8:	f402 1380 	and.w	r3, r2, #1048576	; 0x100000
240158ec:	65bb      	str	r3, [r7, #88]	; 0x58
240158ee:	2300      	movs	r3, #0
240158f0:	65fb      	str	r3, [r7, #92]	; 0x5c
240158f2:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	; 0x58
240158f6:	460b      	mov	r3, r1
240158f8:	4313      	orrs	r3, r2
240158fa:	d009      	beq.n	24015910 <HAL_RCCEx_PeriphCLKConfig+0x1178>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
240158fc:	4baa      	ldr	r3, [pc, #680]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
240158fe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015900:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
24015904:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015908:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2401590a:	4aa7      	ldr	r2, [pc, #668]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
2401590c:	430b      	orrs	r3, r1
2401590e:	6513      	str	r3, [r2, #80]	; 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
24015910:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015914:	e9d3 2300 	ldrd	r2, r3, [r3]
24015918:	f002 5380 	and.w	r3, r2, #268435456	; 0x10000000
2401591c:	653b      	str	r3, [r7, #80]	; 0x50
2401591e:	2300      	movs	r3, #0
24015920:	657b      	str	r3, [r7, #84]	; 0x54
24015922:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
24015926:	460b      	mov	r3, r1
24015928:	4313      	orrs	r3, r2
2401592a:	d00a      	beq.n	24015942 <HAL_RCCEx_PeriphCLKConfig+0x11aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
2401592c:	4b9e      	ldr	r3, [pc, #632]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
2401592e:	691b      	ldr	r3, [r3, #16]
24015930:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
24015934:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015938:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
2401593c:	4a9a      	ldr	r2, [pc, #616]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
2401593e:	430b      	orrs	r3, r1
24015940:	6113      	str	r3, [r2, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
24015942:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015946:	e9d3 2300 	ldrd	r2, r3, [r3]
2401594a:	f402 1300 	and.w	r3, r2, #2097152	; 0x200000
2401594e:	64bb      	str	r3, [r7, #72]	; 0x48
24015950:	2300      	movs	r3, #0
24015952:	64fb      	str	r3, [r7, #76]	; 0x4c
24015954:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	; 0x48
24015958:	460b      	mov	r3, r1
2401595a:	4313      	orrs	r3, r2
2401595c:	d009      	beq.n	24015972 <HAL_RCCEx_PeriphCLKConfig+0x11da>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
2401595e:	4b92      	ldr	r3, [pc, #584]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
24015960:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015962:	f023 7180 	bic.w	r1, r3, #16777216	; 0x1000000
24015966:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
2401596a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2401596c:	4a8e      	ldr	r2, [pc, #568]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
2401596e:	430b      	orrs	r3, r1
24015970:	6513      	str	r3, [r2, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
24015972:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015976:	e9d3 2300 	ldrd	r2, r3, [r3]
2401597a:	f002 4380 	and.w	r3, r2, #1073741824	; 0x40000000
2401597e:	643b      	str	r3, [r7, #64]	; 0x40
24015980:	2300      	movs	r3, #0
24015982:	647b      	str	r3, [r7, #68]	; 0x44
24015984:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	; 0x40
24015988:	460b      	mov	r3, r1
2401598a:	4313      	orrs	r3, r2
2401598c:	d00e      	beq.n	240159ac <HAL_RCCEx_PeriphCLKConfig+0x1214>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
2401598e:	4b86      	ldr	r3, [pc, #536]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
24015990:	691b      	ldr	r3, [r3, #16]
24015992:	4a85      	ldr	r2, [pc, #532]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
24015994:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24015998:	6113      	str	r3, [r2, #16]
2401599a:	4b83      	ldr	r3, [pc, #524]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
2401599c:	6919      	ldr	r1, [r3, #16]
2401599e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240159a2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
240159a6:	4a80      	ldr	r2, [pc, #512]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
240159a8:	430b      	orrs	r3, r1
240159aa:	6113      	str	r3, [r2, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
240159ac:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240159b0:	e9d3 2300 	ldrd	r2, r3, [r3]
240159b4:	f002 4300 	and.w	r3, r2, #2147483648	; 0x80000000
240159b8:	63bb      	str	r3, [r7, #56]	; 0x38
240159ba:	2300      	movs	r3, #0
240159bc:	63fb      	str	r3, [r7, #60]	; 0x3c
240159be:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	; 0x38
240159c2:	460b      	mov	r3, r1
240159c4:	4313      	orrs	r3, r2
240159c6:	d009      	beq.n	240159dc <HAL_RCCEx_PeriphCLKConfig+0x1244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
240159c8:	4b77      	ldr	r3, [pc, #476]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
240159ca:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240159cc:	f023 5140 	bic.w	r1, r3, #805306368	; 0x30000000
240159d0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240159d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240159d6:	4a74      	ldr	r2, [pc, #464]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
240159d8:	430b      	orrs	r3, r1
240159da:	64d3      	str	r3, [r2, #76]	; 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
240159dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
240159e0:	e9d3 2300 	ldrd	r2, r3, [r3]
240159e4:	f402 0300 	and.w	r3, r2, #8388608	; 0x800000
240159e8:	633b      	str	r3, [r7, #48]	; 0x30
240159ea:	2300      	movs	r3, #0
240159ec:	637b      	str	r3, [r7, #52]	; 0x34
240159ee:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
240159f2:	460b      	mov	r3, r1
240159f4:	4313      	orrs	r3, r2
240159f6:	d00a      	beq.n	24015a0e <HAL_RCCEx_PeriphCLKConfig+0x1276>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
240159f8:	4b6b      	ldr	r3, [pc, #428]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
240159fa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240159fc:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
24015a00:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015a04:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
24015a08:	4a67      	ldr	r2, [pc, #412]	; (24015ba8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
24015a0a:	430b      	orrs	r3, r1
24015a0c:	6553      	str	r3, [r2, #84]	; 0x54
  }

  /*---------------------------- PLL2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVP) == RCC_PERIPHCLK_PLL2_DIVP)
24015a0e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015a12:	e9d3 2300 	ldrd	r2, r3, [r3]
24015a16:	2100      	movs	r1, #0
24015a18:	62b9      	str	r1, [r7, #40]	; 0x28
24015a1a:	f003 0301 	and.w	r3, r3, #1
24015a1e:	62fb      	str	r3, [r7, #44]	; 0x2c
24015a20:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
24015a24:	460b      	mov	r3, r1
24015a26:	4313      	orrs	r3, r2
24015a28:	d011      	beq.n	24015a4e <HAL_RCCEx_PeriphCLKConfig+0x12b6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
24015a2a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015a2e:	3308      	adds	r3, #8
24015a30:	2100      	movs	r1, #0
24015a32:	4618      	mov	r0, r3
24015a34:	f001 fe36 	bl	240176a4 <RCCEx_PLL2_Config>
24015a38:	4603      	mov	r3, r0
24015a3a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
24015a3e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015a42:	2b00      	cmp	r3, #0
24015a44:	d003      	beq.n	24015a4e <HAL_RCCEx_PeriphCLKConfig+0x12b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
24015a46:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015a4a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    } 
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVQ) == RCC_PERIPHCLK_PLL2_DIVQ)
24015a4e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015a52:	e9d3 2300 	ldrd	r2, r3, [r3]
24015a56:	2100      	movs	r1, #0
24015a58:	6239      	str	r1, [r7, #32]
24015a5a:	f003 0302 	and.w	r3, r3, #2
24015a5e:	627b      	str	r3, [r7, #36]	; 0x24
24015a60:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
24015a64:	460b      	mov	r3, r1
24015a66:	4313      	orrs	r3, r2
24015a68:	d011      	beq.n	24015a8e <HAL_RCCEx_PeriphCLKConfig+0x12f6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
24015a6a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015a6e:	3308      	adds	r3, #8
24015a70:	2101      	movs	r1, #1
24015a72:	4618      	mov	r0, r3
24015a74:	f001 fe16 	bl	240176a4 <RCCEx_PLL2_Config>
24015a78:	4603      	mov	r3, r0
24015a7a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
24015a7e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015a82:	2b00      	cmp	r3, #0
24015a84:	d003      	beq.n	24015a8e <HAL_RCCEx_PeriphCLKConfig+0x12f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
24015a86:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015a8a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVR) == RCC_PERIPHCLK_PLL2_DIVR)
24015a8e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015a92:	e9d3 2300 	ldrd	r2, r3, [r3]
24015a96:	2100      	movs	r1, #0
24015a98:	61b9      	str	r1, [r7, #24]
24015a9a:	f003 0304 	and.w	r3, r3, #4
24015a9e:	61fb      	str	r3, [r7, #28]
24015aa0:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
24015aa4:	460b      	mov	r3, r1
24015aa6:	4313      	orrs	r3, r2
24015aa8:	d011      	beq.n	24015ace <HAL_RCCEx_PeriphCLKConfig+0x1336>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
24015aaa:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015aae:	3308      	adds	r3, #8
24015ab0:	2102      	movs	r1, #2
24015ab2:	4618      	mov	r0, r3
24015ab4:	f001 fdf6 	bl	240176a4 <RCCEx_PLL2_Config>
24015ab8:	4603      	mov	r3, r0
24015aba:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
24015abe:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015ac2:	2b00      	cmp	r3, #0
24015ac4:	d003      	beq.n	24015ace <HAL_RCCEx_PeriphCLKConfig+0x1336>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
24015ac6:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015aca:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  

  /*---------------------------- PLL3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVP) == RCC_PERIPHCLK_PLL3_DIVP)
24015ace:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015ad2:	e9d3 2300 	ldrd	r2, r3, [r3]
24015ad6:	2100      	movs	r1, #0
24015ad8:	6139      	str	r1, [r7, #16]
24015ada:	f003 0308 	and.w	r3, r3, #8
24015ade:	617b      	str	r3, [r7, #20]
24015ae0:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
24015ae4:	460b      	mov	r3, r1
24015ae6:	4313      	orrs	r3, r2
24015ae8:	d011      	beq.n	24015b0e <HAL_RCCEx_PeriphCLKConfig+0x1376>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
24015aea:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015aee:	3328      	adds	r3, #40	; 0x28
24015af0:	2100      	movs	r1, #0
24015af2:	4618      	mov	r0, r3
24015af4:	f001 fe88 	bl	24017808 <RCCEx_PLL3_Config>
24015af8:	4603      	mov	r3, r0
24015afa:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
  
    if (ret == HAL_OK)
24015afe:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015b02:	2b00      	cmp	r3, #0
24015b04:	d003      	beq.n	24015b0e <HAL_RCCEx_PeriphCLKConfig+0x1376>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
24015b06:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015b0a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVQ) == RCC_PERIPHCLK_PLL3_DIVQ)
24015b0e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015b12:	e9d3 2300 	ldrd	r2, r3, [r3]
24015b16:	2100      	movs	r1, #0
24015b18:	60b9      	str	r1, [r7, #8]
24015b1a:	f003 0310 	and.w	r3, r3, #16
24015b1e:	60fb      	str	r3, [r7, #12]
24015b20:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
24015b24:	460b      	mov	r3, r1
24015b26:	4313      	orrs	r3, r2
24015b28:	d011      	beq.n	24015b4e <HAL_RCCEx_PeriphCLKConfig+0x13b6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
24015b2a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015b2e:	3328      	adds	r3, #40	; 0x28
24015b30:	2101      	movs	r1, #1
24015b32:	4618      	mov	r0, r3
24015b34:	f001 fe68 	bl	24017808 <RCCEx_PLL3_Config>
24015b38:	4603      	mov	r3, r0
24015b3a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
24015b3e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015b42:	2b00      	cmp	r3, #0
24015b44:	d003      	beq.n	24015b4e <HAL_RCCEx_PeriphCLKConfig+0x13b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
24015b46:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015b4a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVR) == RCC_PERIPHCLK_PLL3_DIVR)
24015b4e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015b52:	e9d3 2300 	ldrd	r2, r3, [r3]
24015b56:	2100      	movs	r1, #0
24015b58:	6039      	str	r1, [r7, #0]
24015b5a:	f003 0320 	and.w	r3, r3, #32
24015b5e:	607b      	str	r3, [r7, #4]
24015b60:	e9d7 1200 	ldrd	r1, r2, [r7]
24015b64:	460b      	mov	r3, r1
24015b66:	4313      	orrs	r3, r2
24015b68:	d011      	beq.n	24015b8e <HAL_RCCEx_PeriphCLKConfig+0x13f6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
24015b6a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
24015b6e:	3328      	adds	r3, #40	; 0x28
24015b70:	2102      	movs	r1, #2
24015b72:	4618      	mov	r0, r3
24015b74:	f001 fe48 	bl	24017808 <RCCEx_PLL3_Config>
24015b78:	4603      	mov	r3, r0
24015b7a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
24015b7e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015b82:	2b00      	cmp	r3, #0
24015b84:	d003      	beq.n	24015b8e <HAL_RCCEx_PeriphCLKConfig+0x13f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
24015b86:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
24015b8a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    } 
  }

  if (status == HAL_OK)
24015b8e:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
24015b92:	2b00      	cmp	r3, #0
24015b94:	d101      	bne.n	24015b9a <HAL_RCCEx_PeriphCLKConfig+0x1402>
  {
    return HAL_OK;
24015b96:	2300      	movs	r3, #0
24015b98:	e000      	b.n	24015b9c <HAL_RCCEx_PeriphCLKConfig+0x1404>
  }
  return HAL_ERROR;
24015b9a:	2301      	movs	r3, #1
}
24015b9c:	4618      	mov	r0, r3
24015b9e:	f507 7794 	add.w	r7, r7, #296	; 0x128
24015ba2:	46bd      	mov	sp, r7
24015ba4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
24015ba8:	58024400 	.word	0x58024400

24015bac <HAL_RCCEx_GetPeriphCLKConfig>:
  * @retval None
  *
  *   (*) : Available on some STM32H7 lines only.
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
24015bac:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
24015bb0:	b08b      	sub	sp, #44	; 0x2c
24015bb2:	af00      	add	r7, sp, #0
24015bb4:	6278      	str	r0, [r7, #36]	; 0x24
  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection =
24015bb6:	6a79      	ldr	r1, [r7, #36]	; 0x24
24015bb8:	4aab      	ldr	r2, [pc, #684]	; (24015e68 <HAL_RCCEx_GetPeriphCLKConfig+0x2bc>)
24015bba:	f04f 0300 	mov.w	r3, #0
24015bbe:	e9c1 2300 	strd	r2, r3, [r1]
    RCC_PERIPHCLK_CKPER;

#if defined(I2C5)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C1235;
#else
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C123;
24015bc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015bc4:	e9d3 2300 	ldrd	r2, r3, [r3]
24015bc8:	f042 0408 	orr.w	r4, r2, #8
24015bcc:	461d      	mov	r5, r3
24015bce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015bd0:	e9c3 4500 	strd	r4, r5, [r3]
#endif /* RCC_CDCCIP1R_SAI2ASEL */
#if defined(RCC_CDCCIP1R_SAI2BSEL)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2B;
#endif /* RCC_CDCCIP1R_SAI2BSEL */
#if defined(SAI3)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI23;
24015bd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015bd6:	e9d3 2300 	ldrd	r2, r3, [r3]
24015bda:	f442 7100 	orr.w	r1, r2, #512	; 0x200
24015bde:	61b9      	str	r1, [r7, #24]
24015be0:	61fb      	str	r3, [r7, #28]
24015be2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015be4:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
24015be8:	e9c3 1200 	strd	r1, r2, [r3]
#endif /* SAI3 */
#if defined(SAI4)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4A;
24015bec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015bee:	e9d3 2300 	ldrd	r2, r3, [r3]
24015bf2:	f442 6180 	orr.w	r1, r2, #1024	; 0x400
24015bf6:	6139      	str	r1, [r7, #16]
24015bf8:	617b      	str	r3, [r7, #20]
24015bfa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015bfc:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
24015c00:	e9c3 1200 	strd	r1, r2, [r3]
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4B;
24015c04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c06:	e9d3 2300 	ldrd	r2, r3, [r3]
24015c0a:	f442 6100 	orr.w	r1, r2, #2048	; 0x800
24015c0e:	60b9      	str	r1, [r7, #8]
24015c10:	60fb      	str	r3, [r7, #12]
24015c12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c14:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
24015c18:	e9c3 1200 	strd	r1, r2, [r3]
#endif /* SAI4 */
#if defined(DFSDM2_BASE)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DFSDM2;
#endif /* DFSDM2 */
#if defined(QUADSPI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_QSPI;
24015c1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c1e:	e9d3 2300 	ldrd	r2, r3, [r3]
24015c22:	f042 7100 	orr.w	r1, r2, #33554432	; 0x2000000
24015c26:	6039      	str	r1, [r7, #0]
24015c28:	607b      	str	r3, [r7, #4]
24015c2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c2c:	e9d7 1200 	ldrd	r1, r2, [r7]
24015c30:	e9c3 1200 	strd	r1, r2, [r3]
#endif /* QUADSPI */
#if defined(OCTOSPI1) || defined(OCTOSPI2)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_OSPI;
#endif /* OCTOSPI1 || OCTOSPI2 */
#if defined(HRTIM1)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_HRTIM1;
24015c34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c36:	e9d3 2300 	ldrd	r2, r3, [r3]
24015c3a:	f042 5a80 	orr.w	sl, r2, #268435456	; 0x10000000
24015c3e:	469b      	mov	fp, r3
24015c40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c42:	e9c3 ab00 	strd	sl, fp, [r3]
#endif /* HRTIM1 */
#if defined(LTDC)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LTDC;
24015c46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c48:	e9d3 2300 	ldrd	r2, r3, [r3]
24015c4c:	f042 5800 	orr.w	r8, r2, #536870912	; 0x20000000
24015c50:	4699      	mov	r9, r3
24015c52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c54:	e9c3 8900 	strd	r8, r9, [r3]
#if defined(DSI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DSI;
#endif /* DSI */

  /* Get the PLL3 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> RCC_PLLCKSELR_DIVM3_Pos);
24015c58:	4b84      	ldr	r3, [pc, #528]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015c5a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24015c5c:	0d1b      	lsrs	r3, r3, #20
24015c5e:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24015c62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c64:	629a      	str	r2, [r3, #40]	; 0x28
  PeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_N3) >> RCC_PLL3DIVR_N3_Pos) + 1U;
24015c66:	4b81      	ldr	r3, [pc, #516]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015c68:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24015c6a:	f3c3 0308 	ubfx	r3, r3, #0, #9
24015c6e:	1c5a      	adds	r2, r3, #1
24015c70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c72:	62da      	str	r2, [r3, #44]	; 0x2c
  PeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> RCC_PLL3DIVR_R3_Pos) + 1U;
24015c74:	4b7d      	ldr	r3, [pc, #500]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015c76:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24015c78:	0e1b      	lsrs	r3, r3, #24
24015c7a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015c7e:	1c5a      	adds	r2, r3, #1
24015c80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c82:	639a      	str	r2, [r3, #56]	; 0x38
  PeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> RCC_PLL3DIVR_P3_Pos) + 1U;
24015c84:	4b79      	ldr	r3, [pc, #484]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015c86:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24015c88:	0a5b      	lsrs	r3, r3, #9
24015c8a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015c8e:	1c5a      	adds	r2, r3, #1
24015c90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015c92:	631a      	str	r2, [r3, #48]	; 0x30
  PeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> RCC_PLL3DIVR_Q3_Pos) + 1U;
24015c94:	4b75      	ldr	r3, [pc, #468]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015c96:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24015c98:	0c1b      	lsrs	r3, r3, #16
24015c9a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015c9e:	1c5a      	adds	r2, r3, #1
24015ca0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015ca2:	635a      	str	r2, [r3, #52]	; 0x34
  PeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> RCC_PLLCFGR_PLL3RGE_Pos);
24015ca4:	4b71      	ldr	r3, [pc, #452]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015ca6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015ca8:	0a9b      	lsrs	r3, r3, #10
24015caa:	f003 0203 	and.w	r2, r3, #3
24015cae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015cb0:	63da      	str	r2, [r3, #60]	; 0x3c
  PeriphClkInit->PLL3.PLL3VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3VCOSEL) >> RCC_PLLCFGR_PLL3VCOSEL_Pos);
24015cb2:	4b6e      	ldr	r3, [pc, #440]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015cb4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015cb6:	0a5b      	lsrs	r3, r3, #9
24015cb8:	f003 0201 	and.w	r2, r3, #1
24015cbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015cbe:	641a      	str	r2, [r3, #64]	; 0x40

  /* Get the PLL2 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> RCC_PLLCKSELR_DIVM2_Pos);
24015cc0:	4b6a      	ldr	r3, [pc, #424]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015cc2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24015cc4:	0b1b      	lsrs	r3, r3, #12
24015cc6:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24015cca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015ccc:	609a      	str	r2, [r3, #8]
  PeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_N2) >> RCC_PLL2DIVR_N2_Pos) + 1U;
24015cce:	4b67      	ldr	r3, [pc, #412]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015cd0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24015cd2:	f3c3 0308 	ubfx	r3, r3, #0, #9
24015cd6:	1c5a      	adds	r2, r3, #1
24015cd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015cda:	60da      	str	r2, [r3, #12]
  PeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> RCC_PLL2DIVR_R2_Pos) + 1U;
24015cdc:	4b63      	ldr	r3, [pc, #396]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015cde:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24015ce0:	0e1b      	lsrs	r3, r3, #24
24015ce2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015ce6:	1c5a      	adds	r2, r3, #1
24015ce8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015cea:	619a      	str	r2, [r3, #24]
  PeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> RCC_PLL2DIVR_P2_Pos) + 1U;
24015cec:	4b5f      	ldr	r3, [pc, #380]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015cee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24015cf0:	0a5b      	lsrs	r3, r3, #9
24015cf2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015cf6:	1c5a      	adds	r2, r3, #1
24015cf8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015cfa:	611a      	str	r2, [r3, #16]
  PeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> RCC_PLL2DIVR_Q2_Pos) + 1U;
24015cfc:	4b5b      	ldr	r3, [pc, #364]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015cfe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24015d00:	0c1b      	lsrs	r3, r3, #16
24015d02:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015d06:	1c5a      	adds	r2, r3, #1
24015d08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d0a:	615a      	str	r2, [r3, #20]
  PeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> RCC_PLLCFGR_PLL2RGE_Pos);
24015d0c:	4b57      	ldr	r3, [pc, #348]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015d10:	099b      	lsrs	r3, r3, #6
24015d12:	f003 0203 	and.w	r2, r3, #3
24015d16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d18:	61da      	str	r2, [r3, #28]
  PeriphClkInit->PLL2.PLL2VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2VCOSEL) >> RCC_PLLCFGR_PLL2VCOSEL_Pos);
24015d1a:	4b54      	ldr	r3, [pc, #336]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015d1e:	095b      	lsrs	r3, r3, #5
24015d20:	f003 0201 	and.w	r2, r3, #1
24015d24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d26:	621a      	str	r2, [r3, #32]

  /* Get the USART1 configuration --------------------------------------------*/
  PeriphClkInit->Usart16ClockSelection      = __HAL_RCC_GET_USART16_SOURCE();
24015d28:	4b50      	ldr	r3, [pc, #320]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d2a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015d2c:	f003 0238 	and.w	r2, r3, #56	; 0x38
24015d30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d32:	67da      	str	r2, [r3, #124]	; 0x7c
  /* Get the USART2/3/4/5/7/8 clock source -----------------------------------*/
  PeriphClkInit->Usart234578ClockSelection  = __HAL_RCC_GET_USART234578_SOURCE();
24015d34:	4b4d      	ldr	r3, [pc, #308]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d36:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015d38:	f003 0207 	and.w	r2, r3, #7
24015d3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d3e:	679a      	str	r2, [r3, #120]	; 0x78
  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection      = __HAL_RCC_GET_LPUART1_SOURCE();
24015d40:	4b4a      	ldr	r3, [pc, #296]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d42:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015d44:	f003 0207 	and.w	r2, r3, #7
24015d48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d4a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#if defined(I2C5)
  /* Get the I2C1/2/3/5 clock source -----------------------------------------*/
  PeriphClkInit->I2c1235ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
#else
  /* Get the I2C1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->I2c123ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
24015d4e:	4b47      	ldr	r3, [pc, #284]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d50:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015d52:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
24015d56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d58:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#endif /*I2C5*/
  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection       = __HAL_RCC_GET_LPTIM1_SOURCE();
24015d5c:	4b43      	ldr	r3, [pc, #268]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d5e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015d60:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
24015d64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d66:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection       = __HAL_RCC_GET_LPTIM2_SOURCE();
24015d6a:	4b40      	ldr	r3, [pc, #256]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d6c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015d6e:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
24015d72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d74:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  /* Get the LPTIM3/4/5 clock source -----------------------------------------*/
  PeriphClkInit->Lptim345ClockSelection     = __HAL_RCC_GET_LPTIM345_SOURCE();
24015d78:	4b3c      	ldr	r3, [pc, #240]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d7a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015d7c:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
24015d80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d82:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection         = __HAL_RCC_GET_SAI1_SOURCE();
24015d86:	4b39      	ldr	r3, [pc, #228]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d88:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015d8a:	f003 0207 	and.w	r2, r3, #7
24015d8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d90:	659a      	str	r2, [r3, #88]	; 0x58
#if defined(SAI3)
  /* Get the SAI2/3 clock source ---------------------------------------------*/
  PeriphClkInit->Sai23ClockSelection        = __HAL_RCC_GET_SAI23_SOURCE();
24015d92:	4b36      	ldr	r3, [pc, #216]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015d94:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015d96:	f403 72e0 	and.w	r2, r3, #448	; 0x1c0
24015d9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015d9c:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Get the SAI2B clock source ---------------------------------------------*/
  PeriphClkInit->Sai2BClockSelection        = __HAL_RCC_GET_SAI2B_SOURCE();
#endif  /*SAI2B*/
#if defined(SAI4)
  /* Get the SAI4A clock source ----------------------------------------------*/
  PeriphClkInit->Sai4AClockSelection        = __HAL_RCC_GET_SAI4A_SOURCE();
24015d9e:	4b33      	ldr	r3, [pc, #204]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015da0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015da2:	f403 0260 	and.w	r2, r3, #14680064	; 0xe00000
24015da6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015da8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  /* Get the SAI4B clock source ----------------------------------------------*/
  PeriphClkInit->Sai4BClockSelection        = __HAL_RCC_GET_SAI4B_SOURCE();
24015dac:	4b2f      	ldr	r3, [pc, #188]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015dae:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015db0:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
24015db4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015db6:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif  /*SAI4*/
  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection          = __HAL_RCC_GET_RTC_SOURCE();
24015dba:	4b2c      	ldr	r3, [pc, #176]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015dbc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24015dbe:	f403 7240 	and.w	r2, r3, #768	; 0x300
24015dc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015dc4:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection          = __HAL_RCC_GET_USB_SOURCE();
24015dc8:	4b28      	ldr	r3, [pc, #160]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015dca:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015dcc:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
24015dd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015dd2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  /* Get the SDMMC clock source ----------------------------------------------*/
  PeriphClkInit->SdmmcClockSelection        = __HAL_RCC_GET_SDMMC_SOURCE();
24015dd6:	4b25      	ldr	r3, [pc, #148]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015dd8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015dda:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
24015dde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015de0:	651a      	str	r2, [r3, #80]	; 0x50
  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection          = __HAL_RCC_GET_RNG_SOURCE();
24015de2:	4b22      	ldr	r3, [pc, #136]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015de4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015de6:	f403 7240 	and.w	r2, r3, #768	; 0x300
24015dea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015dec:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#if defined(HRTIM1)
  /* Get the HRTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Hrtim1ClockSelection       = __HAL_RCC_GET_HRTIM1_SOURCE();
24015df0:	4b1e      	ldr	r3, [pc, #120]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015df2:	691b      	ldr	r3, [r3, #16]
24015df4:	f403 4280 	and.w	r2, r3, #16384	; 0x4000
24015df8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015dfa:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
#endif /* HRTIM1 */
  /* Get the ADC clock source ------------------------------------------------*/
  PeriphClkInit->AdcClockSelection          = __HAL_RCC_GET_ADC_SOURCE();
24015dfe:	4b1b      	ldr	r3, [pc, #108]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e00:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015e02:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
24015e06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e08:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  /* Get the SWPMI1 clock source ---------------------------------------------*/
  PeriphClkInit->Swpmi1ClockSelection       = __HAL_RCC_GET_SWPMI1_SOURCE();
24015e0c:	4b17      	ldr	r3, [pc, #92]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e0e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015e10:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
24015e14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e16:	675a      	str	r2, [r3, #116]	; 0x74
  /* Get the DFSDM1 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection       = __HAL_RCC_GET_DFSDM1_SOURCE();
24015e18:	4b14      	ldr	r3, [pc, #80]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e1a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015e1c:	f003 7280 	and.w	r2, r3, #16777216	; 0x1000000
24015e20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e22:	66da      	str	r2, [r3, #108]	; 0x6c
#if defined(DFSDM2_BASE)
  /* Get the DFSDM2 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm2ClockSelection       = __HAL_RCC_GET_DFSDM2_SOURCE();
#endif /* DFSDM2 */
  /* Get the SPDIFRX clock source --------------------------------------------*/
  PeriphClkInit->SpdifrxClockSelection      = __HAL_RCC_GET_SPDIFRX_SOURCE();
24015e24:	4b11      	ldr	r3, [pc, #68]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e26:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015e28:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
24015e2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e2e:	669a      	str	r2, [r3, #104]	; 0x68
  /* Get the SPI1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->Spi123ClockSelection       = __HAL_RCC_GET_SPI123_SOURCE();
24015e30:	4b0e      	ldr	r3, [pc, #56]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e32:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015e34:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
24015e38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e3a:	661a      	str	r2, [r3, #96]	; 0x60
  /* Get the SPI4/5 clock source ---------------------------------------------*/
  PeriphClkInit->Spi45ClockSelection        = __HAL_RCC_GET_SPI45_SOURCE();
24015e3c:	4b0b      	ldr	r3, [pc, #44]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e3e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015e40:	f403 22e0 	and.w	r2, r3, #458752	; 0x70000
24015e44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e46:	665a      	str	r2, [r3, #100]	; 0x64
  /* Get the SPI6 clock source -----------------------------------------------*/
  PeriphClkInit->Spi6ClockSelection         = __HAL_RCC_GET_SPI6_SOURCE();
24015e48:	4b08      	ldr	r3, [pc, #32]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e4a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015e4c:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
24015e50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e52:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  /* Get the FDCAN clock source ----------------------------------------------*/
  PeriphClkInit->FdcanClockSelection        = __HAL_RCC_GET_FDCAN_SOURCE();
24015e56:	4b05      	ldr	r3, [pc, #20]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e58:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015e5a:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
24015e5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e60:	671a      	str	r2, [r3, #112]	; 0x70
  /* Get the CEC clock source ------------------------------------------------*/
  PeriphClkInit->CecClockSelection          = __HAL_RCC_GET_CEC_SOURCE();
24015e62:	4b02      	ldr	r3, [pc, #8]	; (24015e6c <HAL_RCCEx_GetPeriphCLKConfig+0x2c0>)
24015e64:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015e66:	e003      	b.n	24015e70 <HAL_RCCEx_GetPeriphCLKConfig+0x2c4>
24015e68:	c9fff1f7 	.word	0xc9fff1f7
24015e6c:	58024400 	.word	0x58024400
24015e70:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
24015e74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e76:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  /* Get the FMC clock source ------------------------------------------------*/
  PeriphClkInit->FmcClockSelection          = __HAL_RCC_GET_FMC_SOURCE();
24015e7a:	4b14      	ldr	r3, [pc, #80]	; (24015ecc <HAL_RCCEx_GetPeriphCLKConfig+0x320>)
24015e7c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015e7e:	f003 0203 	and.w	r2, r3, #3
24015e82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e84:	649a      	str	r2, [r3, #72]	; 0x48
#if defined(QUADSPI)
  /* Get the QSPI clock source -----------------------------------------------*/
  PeriphClkInit->QspiClockSelection         = __HAL_RCC_GET_QSPI_SOURCE();
24015e86:	4b11      	ldr	r3, [pc, #68]	; (24015ecc <HAL_RCCEx_GetPeriphCLKConfig+0x320>)
24015e88:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015e8a:	f003 0230 	and.w	r2, r3, #48	; 0x30
24015e8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e90:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Get the DSI clock source ------------------------------------------------*/
  PeriphClkInit->DsiClockSelection          = __HAL_RCC_GET_DSI_SOURCE();
#endif /*DSI*/

  /* Get the CKPER clock source ----------------------------------------------*/
  PeriphClkInit->CkperClockSelection        = __HAL_RCC_GET_CLKP_SOURCE();
24015e92:	4b0e      	ldr	r3, [pc, #56]	; (24015ecc <HAL_RCCEx_GetPeriphCLKConfig+0x320>)
24015e94:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015e96:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
24015e9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015e9c:	655a      	str	r2, [r3, #84]	; 0x54

  /* Get the TIM Prescaler configuration -------------------------------------*/
  if ((RCC->CFGR & RCC_CFGR_TIMPRE) == 0U)
24015e9e:	4b0b      	ldr	r3, [pc, #44]	; (24015ecc <HAL_RCCEx_GetPeriphCLKConfig+0x320>)
24015ea0:	691b      	ldr	r3, [r3, #16]
24015ea2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24015ea6:	2b00      	cmp	r3, #0
24015ea8:	d104      	bne.n	24015eb4 <HAL_RCCEx_GetPeriphCLKConfig+0x308>
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
24015eaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015eac:	2200      	movs	r2, #0
24015eae:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
}
24015eb2:	e004      	b.n	24015ebe <HAL_RCCEx_GetPeriphCLKConfig+0x312>
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
24015eb4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24015eb6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
24015eba:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
}
24015ebe:	bf00      	nop
24015ec0:	372c      	adds	r7, #44	; 0x2c
24015ec2:	46bd      	mov	sp, r7
24015ec4:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
24015ec8:	4770      	bx	lr
24015eca:	bf00      	nop
24015ecc:	58024400 	.word	0x58024400

24015ed0 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
24015ed0:	b580      	push	{r7, lr}
24015ed2:	b090      	sub	sp, #64	; 0x40
24015ed4:	af00      	add	r7, sp, #0
24015ed6:	e9c7 0100 	strd	r0, r1, [r7]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
24015eda:	e9d7 2300 	ldrd	r2, r3, [r7]
24015ede:	f5a2 7180 	sub.w	r1, r2, #256	; 0x100
24015ee2:	430b      	orrs	r3, r1
24015ee4:	f040 8094 	bne.w	24016010 <HAL_RCCEx_GetPeriphCLKFreq+0x140>
  {

    saiclocksource = __HAL_RCC_GET_SAI1_SOURCE();
24015ee8:	4b9e      	ldr	r3, [pc, #632]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015eea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015eec:	f003 0307 	and.w	r3, r3, #7
24015ef0:	633b      	str	r3, [r7, #48]	; 0x30

    switch (saiclocksource)
24015ef2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015ef4:	2b04      	cmp	r3, #4
24015ef6:	f200 8087 	bhi.w	24016008 <HAL_RCCEx_GetPeriphCLKFreq+0x138>
24015efa:	a201      	add	r2, pc, #4	; (adr r2, 24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x30>)
24015efc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24015f00:	24015f15 	.word	0x24015f15
24015f04:	24015f3d 	.word	0x24015f3d
24015f08:	24015f65 	.word	0x24015f65
24015f0c:	24016001 	.word	0x24016001
24015f10:	24015f8d 	.word	0x24015f8d
    {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
24015f14:	4b93      	ldr	r3, [pc, #588]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015f16:	681b      	ldr	r3, [r3, #0]
24015f18:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24015f1c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24015f20:	d108      	bne.n	24015f34 <HAL_RCCEx_GetPeriphCLKFreq+0x64>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24015f22:	f107 0324 	add.w	r3, r7, #36	; 0x24
24015f26:	4618      	mov	r0, r3
24015f28:	f001 f826 	bl	24016f78 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
24015f2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
24015f2e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24015f30:	f000 bd45 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24015f34:	2300      	movs	r3, #0
24015f36:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24015f38:	f000 bd41 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24015f3c:	4b89      	ldr	r3, [pc, #548]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015f3e:	681b      	ldr	r3, [r3, #0]
24015f40:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015f44:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24015f48:	d108      	bne.n	24015f5c <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24015f4a:	f107 0318 	add.w	r3, r7, #24
24015f4e:	4618      	mov	r0, r3
24015f50:	f000 fd6a 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
24015f54:	69bb      	ldr	r3, [r7, #24]
24015f56:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24015f58:	f000 bd31 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24015f5c:	2300      	movs	r3, #0
24015f5e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24015f60:	f000 bd2d 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
24015f64:	4b7f      	ldr	r3, [pc, #508]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015f66:	681b      	ldr	r3, [r3, #0]
24015f68:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24015f6c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015f70:	d108      	bne.n	24015f84 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24015f72:	f107 030c 	add.w	r3, r7, #12
24015f76:	4618      	mov	r0, r3
24015f78:	f000 feaa 	bl	24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
24015f7c:	68fb      	ldr	r3, [r7, #12]
24015f7e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24015f80:	f000 bd1d 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24015f84:	2300      	movs	r3, #0
24015f86:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24015f88:	f000 bd19 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
24015f8c:	4b75      	ldr	r3, [pc, #468]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015f8e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015f90:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24015f94:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
24015f96:	4b73      	ldr	r3, [pc, #460]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015f98:	681b      	ldr	r3, [r3, #0]
24015f9a:	f003 0304 	and.w	r3, r3, #4
24015f9e:	2b04      	cmp	r3, #4
24015fa0:	d10c      	bne.n	24015fbc <HAL_RCCEx_GetPeriphCLKFreq+0xec>
24015fa2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015fa4:	2b00      	cmp	r3, #0
24015fa6:	d109      	bne.n	24015fbc <HAL_RCCEx_GetPeriphCLKFreq+0xec>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
24015fa8:	4b6e      	ldr	r3, [pc, #440]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015faa:	681b      	ldr	r3, [r3, #0]
24015fac:	08db      	lsrs	r3, r3, #3
24015fae:	f003 0303 	and.w	r3, r3, #3
24015fb2:	4a6d      	ldr	r2, [pc, #436]	; (24016168 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24015fb4:	fa22 f303 	lsr.w	r3, r2, r3
24015fb8:	63fb      	str	r3, [r7, #60]	; 0x3c
24015fba:	e01f      	b.n	24015ffc <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
24015fbc:	4b69      	ldr	r3, [pc, #420]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015fbe:	681b      	ldr	r3, [r3, #0]
24015fc0:	f403 7380 	and.w	r3, r3, #256	; 0x100
24015fc4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015fc8:	d106      	bne.n	24015fd8 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
24015fca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015fcc:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24015fd0:	d102      	bne.n	24015fd8 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
24015fd2:	4b66      	ldr	r3, [pc, #408]	; (2401616c <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
24015fd4:	63fb      	str	r3, [r7, #60]	; 0x3c
24015fd6:	e011      	b.n	24015ffc <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
24015fd8:	4b62      	ldr	r3, [pc, #392]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24015fda:	681b      	ldr	r3, [r3, #0]
24015fdc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24015fe0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015fe4:	d106      	bne.n	24015ff4 <HAL_RCCEx_GetPeriphCLKFreq+0x124>
24015fe6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015fe8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015fec:	d102      	bne.n	24015ff4 <HAL_RCCEx_GetPeriphCLKFreq+0x124>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
24015fee:	4b60      	ldr	r3, [pc, #384]	; (24016170 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
24015ff0:	63fb      	str	r3, [r7, #60]	; 0x3c
24015ff2:	e003      	b.n	24015ffc <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
24015ff4:	2300      	movs	r3, #0
24015ff6:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
24015ff8:	f000 bce1 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
24015ffc:	f000 bcdf 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
24016000:	4b5c      	ldr	r3, [pc, #368]	; (24016174 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
24016002:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016004:	f000 bcdb 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
24016008:	2300      	movs	r3, #0
2401600a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401600c:	f000 bcd7 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
24016010:	e9d7 2300 	ldrd	r2, r3, [r7]
24016014:	f5a2 7100 	sub.w	r1, r2, #512	; 0x200
24016018:	430b      	orrs	r3, r1
2401601a:	f040 80ad 	bne.w	24016178 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>
  {

    saiclocksource = __HAL_RCC_GET_SAI23_SOURCE();
2401601e:	4b51      	ldr	r3, [pc, #324]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24016020:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24016022:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
24016026:	633b      	str	r3, [r7, #48]	; 0x30

    switch (saiclocksource)
24016028:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401602a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401602e:	d056      	beq.n	240160de <HAL_RCCEx_GetPeriphCLKFreq+0x20e>
24016030:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24016032:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24016036:	f200 8090 	bhi.w	2401615a <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
2401603a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401603c:	2bc0      	cmp	r3, #192	; 0xc0
2401603e:	f000 8088 	beq.w	24016152 <HAL_RCCEx_GetPeriphCLKFreq+0x282>
24016042:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24016044:	2bc0      	cmp	r3, #192	; 0xc0
24016046:	f200 8088 	bhi.w	2401615a <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
2401604a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401604c:	2b80      	cmp	r3, #128	; 0x80
2401604e:	d032      	beq.n	240160b6 <HAL_RCCEx_GetPeriphCLKFreq+0x1e6>
24016050:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24016052:	2b80      	cmp	r3, #128	; 0x80
24016054:	f200 8081 	bhi.w	2401615a <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
24016058:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401605a:	2b00      	cmp	r3, #0
2401605c:	d003      	beq.n	24016066 <HAL_RCCEx_GetPeriphCLKFreq+0x196>
2401605e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24016060:	2b40      	cmp	r3, #64	; 0x40
24016062:	d014      	beq.n	2401608e <HAL_RCCEx_GetPeriphCLKFreq+0x1be>
24016064:	e079      	b.n	2401615a <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
    {
      case RCC_SAI23CLKSOURCE_PLL: /* PLL1 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
24016066:	4b3f      	ldr	r3, [pc, #252]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24016068:	681b      	ldr	r3, [r3, #0]
2401606a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2401606e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24016072:	d108      	bne.n	24016086 <HAL_RCCEx_GetPeriphCLKFreq+0x1b6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24016074:	f107 0324 	add.w	r3, r7, #36	; 0x24
24016078:	4618      	mov	r0, r3
2401607a:	f000 ff7d 	bl	24016f78 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2401607e:	6abb      	ldr	r3, [r7, #40]	; 0x28
24016080:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016082:	f000 bc9c 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016086:	2300      	movs	r3, #0
24016088:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401608a:	f000 bc98 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
2401608e:	4b35      	ldr	r3, [pc, #212]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24016090:	681b      	ldr	r3, [r3, #0]
24016092:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24016096:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2401609a:	d108      	bne.n	240160ae <HAL_RCCEx_GetPeriphCLKFreq+0x1de>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2401609c:	f107 0318 	add.w	r3, r7, #24
240160a0:	4618      	mov	r0, r3
240160a2:	f000 fcc1 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240160a6:	69bb      	ldr	r3, [r7, #24]
240160a8:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240160aa:	f000 bc88 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240160ae:	2300      	movs	r3, #0
240160b0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240160b2:	f000 bc84 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
240160b6:	4b2b      	ldr	r3, [pc, #172]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
240160b8:	681b      	ldr	r3, [r3, #0]
240160ba:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240160be:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240160c2:	d108      	bne.n	240160d6 <HAL_RCCEx_GetPeriphCLKFreq+0x206>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240160c4:	f107 030c 	add.w	r3, r7, #12
240160c8:	4618      	mov	r0, r3
240160ca:	f000 fe01 	bl	24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
240160ce:	68fb      	ldr	r3, [r7, #12]
240160d0:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240160d2:	f000 bc74 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240160d6:	2300      	movs	r3, #0
240160d8:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240160da:	f000 bc70 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
240160de:	4b21      	ldr	r3, [pc, #132]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
240160e0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240160e2:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
240160e6:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
240160e8:	4b1e      	ldr	r3, [pc, #120]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
240160ea:	681b      	ldr	r3, [r3, #0]
240160ec:	f003 0304 	and.w	r3, r3, #4
240160f0:	2b04      	cmp	r3, #4
240160f2:	d10c      	bne.n	2401610e <HAL_RCCEx_GetPeriphCLKFreq+0x23e>
240160f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240160f6:	2b00      	cmp	r3, #0
240160f8:	d109      	bne.n	2401610e <HAL_RCCEx_GetPeriphCLKFreq+0x23e>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
240160fa:	4b1a      	ldr	r3, [pc, #104]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
240160fc:	681b      	ldr	r3, [r3, #0]
240160fe:	08db      	lsrs	r3, r3, #3
24016100:	f003 0303 	and.w	r3, r3, #3
24016104:	4a18      	ldr	r2, [pc, #96]	; (24016168 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24016106:	fa22 f303 	lsr.w	r3, r2, r3
2401610a:	63fb      	str	r3, [r7, #60]	; 0x3c
2401610c:	e01f      	b.n	2401614e <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
2401610e:	4b15      	ldr	r3, [pc, #84]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
24016110:	681b      	ldr	r3, [r3, #0]
24016112:	f403 7380 	and.w	r3, r3, #256	; 0x100
24016116:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401611a:	d106      	bne.n	2401612a <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
2401611c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401611e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24016122:	d102      	bne.n	2401612a <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
24016124:	4b11      	ldr	r3, [pc, #68]	; (2401616c <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
24016126:	63fb      	str	r3, [r7, #60]	; 0x3c
24016128:	e011      	b.n	2401614e <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
2401612a:	4b0e      	ldr	r3, [pc, #56]	; (24016164 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
2401612c:	681b      	ldr	r3, [r3, #0]
2401612e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24016132:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24016136:	d106      	bne.n	24016146 <HAL_RCCEx_GetPeriphCLKFreq+0x276>
24016138:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401613a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401613e:	d102      	bne.n	24016146 <HAL_RCCEx_GetPeriphCLKFreq+0x276>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
24016140:	4b0b      	ldr	r3, [pc, #44]	; (24016170 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
24016142:	63fb      	str	r3, [r7, #60]	; 0x3c
24016144:	e003      	b.n	2401614e <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
24016146:	2300      	movs	r3, #0
24016148:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
2401614a:	f000 bc38 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
2401614e:	f000 bc36 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
24016152:	4b08      	ldr	r3, [pc, #32]	; (24016174 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
24016154:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016156:	f000 bc32 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
2401615a:	2300      	movs	r3, #0
2401615c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401615e:	f000 bc2e 	b.w	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
24016162:	bf00      	nop
24016164:	58024400 	.word	0x58024400
24016168:	03d09000 	.word	0x03d09000
2401616c:	003d0900 	.word	0x003d0900
24016170:	017d7840 	.word	0x017d7840
24016174:	00bb8000 	.word	0x00bb8000
    }
  }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
24016178:	e9d7 2300 	ldrd	r2, r3, [r7]
2401617c:	f5a2 6180 	sub.w	r1, r2, #1024	; 0x400
24016180:	430b      	orrs	r3, r1
24016182:	f040 809c 	bne.w	240162be <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
  {

    saiclocksource = __HAL_RCC_GET_SAI4A_SOURCE();
24016186:	4b9e      	ldr	r3, [pc, #632]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016188:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401618a:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
2401618e:	633b      	str	r3, [r7, #48]	; 0x30

    switch (saiclocksource)
24016190:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24016192:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
24016196:	d054      	beq.n	24016242 <HAL_RCCEx_GetPeriphCLKFreq+0x372>
24016198:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401619a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2401619e:	f200 808b 	bhi.w	240162b8 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
240161a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240161a4:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
240161a8:	f000 8083 	beq.w	240162b2 <HAL_RCCEx_GetPeriphCLKFreq+0x3e2>
240161ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240161ae:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
240161b2:	f200 8081 	bhi.w	240162b8 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
240161b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240161b8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240161bc:	d02f      	beq.n	2401621e <HAL_RCCEx_GetPeriphCLKFreq+0x34e>
240161be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240161c0:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240161c4:	d878      	bhi.n	240162b8 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
240161c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240161c8:	2b00      	cmp	r3, #0
240161ca:	d004      	beq.n	240161d6 <HAL_RCCEx_GetPeriphCLKFreq+0x306>
240161cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240161ce:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240161d2:	d012      	beq.n	240161fa <HAL_RCCEx_GetPeriphCLKFreq+0x32a>
240161d4:	e070      	b.n	240162b8 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
    {
      case RCC_SAI4ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
240161d6:	4b8a      	ldr	r3, [pc, #552]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
240161d8:	681b      	ldr	r3, [r3, #0]
240161da:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240161de:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
240161e2:	d107      	bne.n	240161f4 <HAL_RCCEx_GetPeriphCLKFreq+0x324>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240161e4:	f107 0324 	add.w	r3, r7, #36	; 0x24
240161e8:	4618      	mov	r0, r3
240161ea:	f000 fec5 	bl	24016f78 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240161ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
240161f0:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240161f2:	e3e4      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240161f4:	2300      	movs	r3, #0
240161f6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240161f8:	e3e1      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI4ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
240161fa:	4b81      	ldr	r3, [pc, #516]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
240161fc:	681b      	ldr	r3, [r3, #0]
240161fe:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24016202:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24016206:	d107      	bne.n	24016218 <HAL_RCCEx_GetPeriphCLKFreq+0x348>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24016208:	f107 0318 	add.w	r3, r7, #24
2401620c:	4618      	mov	r0, r3
2401620e:	f000 fc0b 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
24016212:	69bb      	ldr	r3, [r7, #24]
24016214:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016216:	e3d2      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016218:	2300      	movs	r3, #0
2401621a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401621c:	e3cf      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
2401621e:	4b78      	ldr	r3, [pc, #480]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016220:	681b      	ldr	r3, [r3, #0]
24016222:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24016226:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401622a:	d107      	bne.n	2401623c <HAL_RCCEx_GetPeriphCLKFreq+0x36c>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2401622c:	f107 030c 	add.w	r3, r7, #12
24016230:	4618      	mov	r0, r3
24016232:	f000 fd4d 	bl	24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
24016236:	68fb      	ldr	r3, [r7, #12]
24016238:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
2401623a:	e3c0      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
2401623c:	2300      	movs	r3, #0
2401623e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016240:	e3bd      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI4A*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
24016242:	4b6f      	ldr	r3, [pc, #444]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016244:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24016246:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2401624a:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
2401624c:	4b6c      	ldr	r3, [pc, #432]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
2401624e:	681b      	ldr	r3, [r3, #0]
24016250:	f003 0304 	and.w	r3, r3, #4
24016254:	2b04      	cmp	r3, #4
24016256:	d10c      	bne.n	24016272 <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
24016258:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401625a:	2b00      	cmp	r3, #0
2401625c:	d109      	bne.n	24016272 <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
2401625e:	4b68      	ldr	r3, [pc, #416]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016260:	681b      	ldr	r3, [r3, #0]
24016262:	08db      	lsrs	r3, r3, #3
24016264:	f003 0303 	and.w	r3, r3, #3
24016268:	4a66      	ldr	r2, [pc, #408]	; (24016404 <HAL_RCCEx_GetPeriphCLKFreq+0x534>)
2401626a:	fa22 f303 	lsr.w	r3, r2, r3
2401626e:	63fb      	str	r3, [r7, #60]	; 0x3c
24016270:	e01e      	b.n	240162b0 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
24016272:	4b63      	ldr	r3, [pc, #396]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016274:	681b      	ldr	r3, [r3, #0]
24016276:	f403 7380 	and.w	r3, r3, #256	; 0x100
2401627a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401627e:	d106      	bne.n	2401628e <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
24016280:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24016282:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24016286:	d102      	bne.n	2401628e <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
24016288:	4b5f      	ldr	r3, [pc, #380]	; (24016408 <HAL_RCCEx_GetPeriphCLKFreq+0x538>)
2401628a:	63fb      	str	r3, [r7, #60]	; 0x3c
2401628c:	e010      	b.n	240162b0 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
2401628e:	4b5c      	ldr	r3, [pc, #368]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016290:	681b      	ldr	r3, [r3, #0]
24016292:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24016296:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2401629a:	d106      	bne.n	240162aa <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
2401629c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401629e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240162a2:	d102      	bne.n	240162aa <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
240162a4:	4b59      	ldr	r3, [pc, #356]	; (2401640c <HAL_RCCEx_GetPeriphCLKFreq+0x53c>)
240162a6:	63fb      	str	r3, [r7, #60]	; 0x3c
240162a8:	e002      	b.n	240162b0 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
240162aa:	2300      	movs	r3, #0
240162ac:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
240162ae:	e386      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
240162b0:	e385      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_PIN: /* External clock is the clock source for SAI4A */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
240162b2:	4b57      	ldr	r3, [pc, #348]	; (24016410 <HAL_RCCEx_GetPeriphCLKFreq+0x540>)
240162b4:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240162b6:	e382      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
240162b8:	2300      	movs	r3, #0
240162ba:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240162bc:	e37f      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
240162be:	e9d7 2300 	ldrd	r2, r3, [r7]
240162c2:	f5a2 6100 	sub.w	r1, r2, #2048	; 0x800
240162c6:	430b      	orrs	r3, r1
240162c8:	f040 80a7 	bne.w	2401641a <HAL_RCCEx_GetPeriphCLKFreq+0x54a>
  {

    saiclocksource = __HAL_RCC_GET_SAI4B_SOURCE();
240162cc:	4b4c      	ldr	r3, [pc, #304]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
240162ce:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240162d0:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
240162d4:	633b      	str	r3, [r7, #48]	; 0x30

    switch (saiclocksource)
240162d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240162d8:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
240162dc:	d055      	beq.n	2401638a <HAL_RCCEx_GetPeriphCLKFreq+0x4ba>
240162de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240162e0:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
240162e4:	f200 8096 	bhi.w	24016414 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
240162e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240162ea:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
240162ee:	f000 8084 	beq.w	240163fa <HAL_RCCEx_GetPeriphCLKFreq+0x52a>
240162f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240162f4:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
240162f8:	f200 808c 	bhi.w	24016414 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
240162fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240162fe:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24016302:	d030      	beq.n	24016366 <HAL_RCCEx_GetPeriphCLKFreq+0x496>
24016304:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24016306:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2401630a:	f200 8083 	bhi.w	24016414 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
2401630e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24016310:	2b00      	cmp	r3, #0
24016312:	d004      	beq.n	2401631e <HAL_RCCEx_GetPeriphCLKFreq+0x44e>
24016314:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24016316:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2401631a:	d012      	beq.n	24016342 <HAL_RCCEx_GetPeriphCLKFreq+0x472>
2401631c:	e07a      	b.n	24016414 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
    {
      case RCC_SAI4BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
2401631e:	4b38      	ldr	r3, [pc, #224]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016320:	681b      	ldr	r3, [r3, #0]
24016322:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24016326:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2401632a:	d107      	bne.n	2401633c <HAL_RCCEx_GetPeriphCLKFreq+0x46c>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2401632c:	f107 0324 	add.w	r3, r7, #36	; 0x24
24016330:	4618      	mov	r0, r3
24016332:	f000 fe21 	bl	24016f78 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
24016336:	6abb      	ldr	r3, [r7, #40]	; 0x28
24016338:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
2401633a:	e340      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
2401633c:	2300      	movs	r3, #0
2401633e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016340:	e33d      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI4BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24016342:	4b2f      	ldr	r3, [pc, #188]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016344:	681b      	ldr	r3, [r3, #0]
24016346:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2401634a:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2401634e:	d107      	bne.n	24016360 <HAL_RCCEx_GetPeriphCLKFreq+0x490>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24016350:	f107 0318 	add.w	r3, r7, #24
24016354:	4618      	mov	r0, r3
24016356:	f000 fb67 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2401635a:	69bb      	ldr	r3, [r7, #24]
2401635c:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
2401635e:	e32e      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016360:	2300      	movs	r3, #0
24016362:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016364:	e32b      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
24016366:	4b26      	ldr	r3, [pc, #152]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016368:	681b      	ldr	r3, [r3, #0]
2401636a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2401636e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24016372:	d107      	bne.n	24016384 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24016374:	f107 030c 	add.w	r3, r7, #12
24016378:	4618      	mov	r0, r3
2401637a:	f000 fca9 	bl	24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2401637e:	68fb      	ldr	r3, [r7, #12]
24016380:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016382:	e31c      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016384:	2300      	movs	r3, #0
24016386:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016388:	e319      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI4B*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
2401638a:	4b1d      	ldr	r3, [pc, #116]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
2401638c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401638e:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24016392:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
24016394:	4b1a      	ldr	r3, [pc, #104]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
24016396:	681b      	ldr	r3, [r3, #0]
24016398:	f003 0304 	and.w	r3, r3, #4
2401639c:	2b04      	cmp	r3, #4
2401639e:	d10c      	bne.n	240163ba <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
240163a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240163a2:	2b00      	cmp	r3, #0
240163a4:	d109      	bne.n	240163ba <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
240163a6:	4b16      	ldr	r3, [pc, #88]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
240163a8:	681b      	ldr	r3, [r3, #0]
240163aa:	08db      	lsrs	r3, r3, #3
240163ac:	f003 0303 	and.w	r3, r3, #3
240163b0:	4a14      	ldr	r2, [pc, #80]	; (24016404 <HAL_RCCEx_GetPeriphCLKFreq+0x534>)
240163b2:	fa22 f303 	lsr.w	r3, r2, r3
240163b6:	63fb      	str	r3, [r7, #60]	; 0x3c
240163b8:	e01e      	b.n	240163f8 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
240163ba:	4b11      	ldr	r3, [pc, #68]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
240163bc:	681b      	ldr	r3, [r3, #0]
240163be:	f403 7380 	and.w	r3, r3, #256	; 0x100
240163c2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240163c6:	d106      	bne.n	240163d6 <HAL_RCCEx_GetPeriphCLKFreq+0x506>
240163c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240163ca:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
240163ce:	d102      	bne.n	240163d6 <HAL_RCCEx_GetPeriphCLKFreq+0x506>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
240163d0:	4b0d      	ldr	r3, [pc, #52]	; (24016408 <HAL_RCCEx_GetPeriphCLKFreq+0x538>)
240163d2:	63fb      	str	r3, [r7, #60]	; 0x3c
240163d4:	e010      	b.n	240163f8 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
240163d6:	4b0a      	ldr	r3, [pc, #40]	; (24016400 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
240163d8:	681b      	ldr	r3, [r3, #0]
240163da:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240163de:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
240163e2:	d106      	bne.n	240163f2 <HAL_RCCEx_GetPeriphCLKFreq+0x522>
240163e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240163e6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240163ea:	d102      	bne.n	240163f2 <HAL_RCCEx_GetPeriphCLKFreq+0x522>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
240163ec:	4b07      	ldr	r3, [pc, #28]	; (2401640c <HAL_RCCEx_GetPeriphCLKFreq+0x53c>)
240163ee:	63fb      	str	r3, [r7, #60]	; 0x3c
240163f0:	e002      	b.n	240163f8 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
240163f2:	2300      	movs	r3, #0
240163f4:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
240163f6:	e2e2      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
240163f8:	e2e1      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_PIN: /* External clock is the clock source for SAI4B */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
240163fa:	4b05      	ldr	r3, [pc, #20]	; (24016410 <HAL_RCCEx_GetPeriphCLKFreq+0x540>)
240163fc:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240163fe:	e2de      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
24016400:	58024400 	.word	0x58024400
24016404:	03d09000 	.word	0x03d09000
24016408:	003d0900 	.word	0x003d0900
2401640c:	017d7840 	.word	0x017d7840
24016410:	00bb8000 	.word	0x00bb8000
      }

      default :
      {
        frequency = 0;
24016414:	2300      	movs	r3, #0
24016416:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016418:	e2d1      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
2401641a:	e9d7 2300 	ldrd	r2, r3, [r7]
2401641e:	f5a2 5180 	sub.w	r1, r2, #4096	; 0x1000
24016422:	430b      	orrs	r3, r1
24016424:	f040 809c 	bne.w	24016560 <HAL_RCCEx_GetPeriphCLKFreq+0x690>
  {
    /* Get SPI1/2/3 clock source */
    srcclk = __HAL_RCC_GET_SPI123_SOURCE();
24016428:	4b93      	ldr	r3, [pc, #588]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
2401642a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401642c:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
24016430:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
24016432:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016434:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24016438:	d054      	beq.n	240164e4 <HAL_RCCEx_GetPeriphCLKFreq+0x614>
2401643a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401643c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24016440:	f200 808b 	bhi.w	2401655a <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
24016444:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016446:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
2401644a:	f000 8083 	beq.w	24016554 <HAL_RCCEx_GetPeriphCLKFreq+0x684>
2401644e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016450:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
24016454:	f200 8081 	bhi.w	2401655a <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
24016458:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401645a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401645e:	d02f      	beq.n	240164c0 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>
24016460:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016462:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24016466:	d878      	bhi.n	2401655a <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
24016468:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401646a:	2b00      	cmp	r3, #0
2401646c:	d004      	beq.n	24016478 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
2401646e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016470:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24016474:	d012      	beq.n	2401649c <HAL_RCCEx_GetPeriphCLKFreq+0x5cc>
24016476:	e070      	b.n	2401655a <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
    {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
24016478:	4b7f      	ldr	r3, [pc, #508]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
2401647a:	681b      	ldr	r3, [r3, #0]
2401647c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24016480:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24016484:	d107      	bne.n	24016496 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24016486:	f107 0324 	add.w	r3, r7, #36	; 0x24
2401648a:	4618      	mov	r0, r3
2401648c:	f000 fd74 	bl	24016f78 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
24016490:	6abb      	ldr	r3, [r7, #40]	; 0x28
24016492:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016494:	e293      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016496:	2300      	movs	r3, #0
24016498:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401649a:	e290      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
2401649c:	4b76      	ldr	r3, [pc, #472]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
2401649e:	681b      	ldr	r3, [r3, #0]
240164a0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
240164a4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
240164a8:	d107      	bne.n	240164ba <HAL_RCCEx_GetPeriphCLKFreq+0x5ea>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240164aa:	f107 0318 	add.w	r3, r7, #24
240164ae:	4618      	mov	r0, r3
240164b0:	f000 faba 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240164b4:	69bb      	ldr	r3, [r7, #24]
240164b6:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240164b8:	e281      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240164ba:	2300      	movs	r3, #0
240164bc:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240164be:	e27e      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
240164c0:	4b6d      	ldr	r3, [pc, #436]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
240164c2:	681b      	ldr	r3, [r3, #0]
240164c4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240164c8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240164cc:	d107      	bne.n	240164de <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240164ce:	f107 030c 	add.w	r3, r7, #12
240164d2:	4618      	mov	r0, r3
240164d4:	f000 fbfc 	bl	24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
240164d8:	68fb      	ldr	r3, [r7, #12]
240164da:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240164dc:	e26f      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240164de:	2300      	movs	r3, #0
240164e0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240164e2:	e26c      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for SPI123 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
240164e4:	4b64      	ldr	r3, [pc, #400]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
240164e6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240164e8:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
240164ec:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
240164ee:	4b62      	ldr	r3, [pc, #392]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
240164f0:	681b      	ldr	r3, [r3, #0]
240164f2:	f003 0304 	and.w	r3, r3, #4
240164f6:	2b04      	cmp	r3, #4
240164f8:	d10c      	bne.n	24016514 <HAL_RCCEx_GetPeriphCLKFreq+0x644>
240164fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240164fc:	2b00      	cmp	r3, #0
240164fe:	d109      	bne.n	24016514 <HAL_RCCEx_GetPeriphCLKFreq+0x644>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
24016500:	4b5d      	ldr	r3, [pc, #372]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
24016502:	681b      	ldr	r3, [r3, #0]
24016504:	08db      	lsrs	r3, r3, #3
24016506:	f003 0303 	and.w	r3, r3, #3
2401650a:	4a5c      	ldr	r2, [pc, #368]	; (2401667c <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>)
2401650c:	fa22 f303 	lsr.w	r3, r2, r3
24016510:	63fb      	str	r3, [r7, #60]	; 0x3c
24016512:	e01e      	b.n	24016552 <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
24016514:	4b58      	ldr	r3, [pc, #352]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
24016516:	681b      	ldr	r3, [r3, #0]
24016518:	f403 7380 	and.w	r3, r3, #256	; 0x100
2401651c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24016520:	d106      	bne.n	24016530 <HAL_RCCEx_GetPeriphCLKFreq+0x660>
24016522:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24016524:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24016528:	d102      	bne.n	24016530 <HAL_RCCEx_GetPeriphCLKFreq+0x660>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
2401652a:	4b55      	ldr	r3, [pc, #340]	; (24016680 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
2401652c:	63fb      	str	r3, [r7, #60]	; 0x3c
2401652e:	e010      	b.n	24016552 <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
24016530:	4b51      	ldr	r3, [pc, #324]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
24016532:	681b      	ldr	r3, [r3, #0]
24016534:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24016538:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2401653c:	d106      	bne.n	2401654c <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
2401653e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24016540:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24016544:	d102      	bne.n	2401654c <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
24016546:	4b4f      	ldr	r3, [pc, #316]	; (24016684 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
24016548:	63fb      	str	r3, [r7, #60]	; 0x3c
2401654a:	e002      	b.n	24016552 <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
2401654c:	2300      	movs	r3, #0
2401654e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
24016550:	e235      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
24016552:	e234      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
24016554:	4b4c      	ldr	r3, [pc, #304]	; (24016688 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>)
24016556:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016558:	e231      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
2401655a:	2300      	movs	r3, #0
2401655c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401655e:	e22e      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI45)
24016560:	e9d7 2300 	ldrd	r2, r3, [r7]
24016564:	f5a2 5100 	sub.w	r1, r2, #8192	; 0x2000
24016568:	430b      	orrs	r3, r1
2401656a:	f040 808f 	bne.w	2401668c <HAL_RCCEx_GetPeriphCLKFreq+0x7bc>
  {
    /* Get SPI45 clock source */
    srcclk = __HAL_RCC_GET_SPI45_SOURCE();
2401656e:	4b42      	ldr	r3, [pc, #264]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
24016570:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24016572:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
24016576:	63bb      	str	r3, [r7, #56]	; 0x38
    switch (srcclk)
24016578:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401657a:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
2401657e:	d06b      	beq.n	24016658 <HAL_RCCEx_GetPeriphCLKFreq+0x788>
24016580:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016582:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
24016586:	d874      	bhi.n	24016672 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
24016588:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401658a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2401658e:	d056      	beq.n	2401663e <HAL_RCCEx_GetPeriphCLKFreq+0x76e>
24016590:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016592:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24016596:	d86c      	bhi.n	24016672 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
24016598:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401659a:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
2401659e:	d03b      	beq.n	24016618 <HAL_RCCEx_GetPeriphCLKFreq+0x748>
240165a0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240165a2:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
240165a6:	d864      	bhi.n	24016672 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
240165a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240165aa:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
240165ae:	d021      	beq.n	240165f4 <HAL_RCCEx_GetPeriphCLKFreq+0x724>
240165b0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240165b2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
240165b6:	d85c      	bhi.n	24016672 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
240165b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240165ba:	2b00      	cmp	r3, #0
240165bc:	d004      	beq.n	240165c8 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
240165be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240165c0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240165c4:	d004      	beq.n	240165d0 <HAL_RCCEx_GetPeriphCLKFreq+0x700>
240165c6:	e054      	b.n	24016672 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
    {
      case RCC_SPI45CLKSOURCE_PCLK2: /* CD/D2 PCLK2 is the clock source for SPI4/5 */
      {
        frequency = HAL_RCC_GetPCLK1Freq();
240165c8:	f7fd ff6e 	bl	240144a8 <HAL_RCC_GetPCLK1Freq>
240165cc:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
240165ce:	e1f6      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
240165d0:	4b29      	ldr	r3, [pc, #164]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
240165d2:	681b      	ldr	r3, [r3, #0]
240165d4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
240165d8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
240165dc:	d107      	bne.n	240165ee <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240165de:	f107 0318 	add.w	r3, r7, #24
240165e2:	4618      	mov	r0, r3
240165e4:	f000 fa20 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
240165e8:	69fb      	ldr	r3, [r7, #28]
240165ea:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240165ec:	e1e7      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240165ee:	2300      	movs	r3, #0
240165f0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240165f2:	e1e4      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
240165f4:	4b20      	ldr	r3, [pc, #128]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
240165f6:	681b      	ldr	r3, [r3, #0]
240165f8:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240165fc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24016600:	d107      	bne.n	24016612 <HAL_RCCEx_GetPeriphCLKFreq+0x742>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24016602:	f107 030c 	add.w	r3, r7, #12
24016606:	4618      	mov	r0, r3
24016608:	f000 fb62 	bl	24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
2401660c:	693b      	ldr	r3, [r7, #16]
2401660e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016610:	e1d5      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016612:	2300      	movs	r3, #0
24016614:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016616:	e1d2      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_HSI: /* HSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
24016618:	4b17      	ldr	r3, [pc, #92]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
2401661a:	681b      	ldr	r3, [r3, #0]
2401661c:	f003 0304 	and.w	r3, r3, #4
24016620:	2b04      	cmp	r3, #4
24016622:	d109      	bne.n	24016638 <HAL_RCCEx_GetPeriphCLKFreq+0x768>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
24016624:	4b14      	ldr	r3, [pc, #80]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
24016626:	681b      	ldr	r3, [r3, #0]
24016628:	08db      	lsrs	r3, r3, #3
2401662a:	f003 0303 	and.w	r3, r3, #3
2401662e:	4a13      	ldr	r2, [pc, #76]	; (2401667c <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>)
24016630:	fa22 f303 	lsr.w	r3, r2, r3
24016634:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016636:	e1c2      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016638:	2300      	movs	r3, #0
2401663a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401663c:	e1bf      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_CSI: /* CSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
2401663e:	4b0e      	ldr	r3, [pc, #56]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
24016640:	681b      	ldr	r3, [r3, #0]
24016642:	f403 7380 	and.w	r3, r3, #256	; 0x100
24016646:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401664a:	d102      	bne.n	24016652 <HAL_RCCEx_GetPeriphCLKFreq+0x782>
        {
          frequency = CSI_VALUE;
2401664c:	4b0c      	ldr	r3, [pc, #48]	; (24016680 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
2401664e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016650:	e1b5      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016652:	2300      	movs	r3, #0
24016654:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016656:	e1b2      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_HSE: /* HSE is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
24016658:	4b07      	ldr	r3, [pc, #28]	; (24016678 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
2401665a:	681b      	ldr	r3, [r3, #0]
2401665c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24016660:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24016664:	d102      	bne.n	2401666c <HAL_RCCEx_GetPeriphCLKFreq+0x79c>
        {
          frequency = HSE_VALUE;
24016666:	4b07      	ldr	r3, [pc, #28]	; (24016684 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
24016668:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
2401666a:	e1a8      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
2401666c:	2300      	movs	r3, #0
2401666e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016670:	e1a5      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
24016672:	2300      	movs	r3, #0
24016674:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016676:	e1a2      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
24016678:	58024400 	.word	0x58024400
2401667c:	03d09000 	.word	0x03d09000
24016680:	003d0900 	.word	0x003d0900
24016684:	017d7840 	.word	0x017d7840
24016688:	00bb8000 	.word	0x00bb8000
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
2401668c:	e9d7 2300 	ldrd	r2, r3, [r7]
24016690:	f5a2 2100 	sub.w	r1, r2, #524288	; 0x80000
24016694:	430b      	orrs	r3, r1
24016696:	d173      	bne.n	24016780 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>
  {
    /* Get ADC clock source */
    srcclk = __HAL_RCC_GET_ADC_SOURCE();
24016698:	4b9c      	ldr	r3, [pc, #624]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
2401669a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401669c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
240166a0:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
240166a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240166a4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
240166a8:	d02f      	beq.n	2401670a <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
240166aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240166ac:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
240166b0:	d863      	bhi.n	2401677a <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
240166b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240166b4:	2b00      	cmp	r3, #0
240166b6:	d004      	beq.n	240166c2 <HAL_RCCEx_GetPeriphCLKFreq+0x7f2>
240166b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240166ba:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240166be:	d012      	beq.n	240166e6 <HAL_RCCEx_GetPeriphCLKFreq+0x816>
240166c0:	e05b      	b.n	2401677a <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
    {
      case RCC_ADCCLKSOURCE_PLL2:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
240166c2:	4b92      	ldr	r3, [pc, #584]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
240166c4:	681b      	ldr	r3, [r3, #0]
240166c6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
240166ca:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
240166ce:	d107      	bne.n	240166e0 <HAL_RCCEx_GetPeriphCLKFreq+0x810>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240166d0:	f107 0318 	add.w	r3, r7, #24
240166d4:	4618      	mov	r0, r3
240166d6:	f000 f9a7 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240166da:	69bb      	ldr	r3, [r7, #24]
240166dc:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240166de:	e16e      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240166e0:	2300      	movs	r3, #0
240166e2:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240166e4:	e16b      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_ADCCLKSOURCE_PLL3:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
240166e6:	4b89      	ldr	r3, [pc, #548]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
240166e8:	681b      	ldr	r3, [r3, #0]
240166ea:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240166ee:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240166f2:	d107      	bne.n	24016704 <HAL_RCCEx_GetPeriphCLKFreq+0x834>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240166f4:	f107 030c 	add.w	r3, r7, #12
240166f8:	4618      	mov	r0, r3
240166fa:	f000 fae9 	bl	24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
240166fe:	697b      	ldr	r3, [r7, #20]
24016700:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016702:	e15c      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016704:	2300      	movs	r3, #0
24016706:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016708:	e159      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_ADCCLKSOURCE_CLKP:
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
2401670a:	4b80      	ldr	r3, [pc, #512]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
2401670c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401670e:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24016712:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
24016714:	4b7d      	ldr	r3, [pc, #500]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
24016716:	681b      	ldr	r3, [r3, #0]
24016718:	f003 0304 	and.w	r3, r3, #4
2401671c:	2b04      	cmp	r3, #4
2401671e:	d10c      	bne.n	2401673a <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
24016720:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24016722:	2b00      	cmp	r3, #0
24016724:	d109      	bne.n	2401673a <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
24016726:	4b79      	ldr	r3, [pc, #484]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
24016728:	681b      	ldr	r3, [r3, #0]
2401672a:	08db      	lsrs	r3, r3, #3
2401672c:	f003 0303 	and.w	r3, r3, #3
24016730:	4a77      	ldr	r2, [pc, #476]	; (24016910 <HAL_RCCEx_GetPeriphCLKFreq+0xa40>)
24016732:	fa22 f303 	lsr.w	r3, r2, r3
24016736:	63fb      	str	r3, [r7, #60]	; 0x3c
24016738:	e01e      	b.n	24016778 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
2401673a:	4b74      	ldr	r3, [pc, #464]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
2401673c:	681b      	ldr	r3, [r3, #0]
2401673e:	f403 7380 	and.w	r3, r3, #256	; 0x100
24016742:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24016746:	d106      	bne.n	24016756 <HAL_RCCEx_GetPeriphCLKFreq+0x886>
24016748:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401674a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2401674e:	d102      	bne.n	24016756 <HAL_RCCEx_GetPeriphCLKFreq+0x886>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
24016750:	4b70      	ldr	r3, [pc, #448]	; (24016914 <HAL_RCCEx_GetPeriphCLKFreq+0xa44>)
24016752:	63fb      	str	r3, [r7, #60]	; 0x3c
24016754:	e010      	b.n	24016778 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
24016756:	4b6d      	ldr	r3, [pc, #436]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
24016758:	681b      	ldr	r3, [r3, #0]
2401675a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2401675e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24016762:	d106      	bne.n	24016772 <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
24016764:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24016766:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401676a:	d102      	bne.n	24016772 <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
2401676c:	4b6a      	ldr	r3, [pc, #424]	; (24016918 <HAL_RCCEx_GetPeriphCLKFreq+0xa48>)
2401676e:	63fb      	str	r3, [r7, #60]	; 0x3c
24016770:	e002      	b.n	24016778 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
24016772:	2300      	movs	r3, #0
24016774:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
24016776:	e122      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
24016778:	e121      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
2401677a:	2300      	movs	r3, #0
2401677c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401677e:	e11e      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
24016780:	e9d7 2300 	ldrd	r2, r3, [r7]
24016784:	f5a2 3180 	sub.w	r1, r2, #65536	; 0x10000
24016788:	430b      	orrs	r3, r1
2401678a:	d133      	bne.n	240167f4 <HAL_RCCEx_GetPeriphCLKFreq+0x924>
  {
    /* Get SDMMC clock source */
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
2401678c:	4b5f      	ldr	r3, [pc, #380]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
2401678e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24016790:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24016794:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
24016796:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016798:	2b00      	cmp	r3, #0
2401679a:	d004      	beq.n	240167a6 <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
2401679c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401679e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240167a2:	d012      	beq.n	240167ca <HAL_RCCEx_GetPeriphCLKFreq+0x8fa>
240167a4:	e023      	b.n	240167ee <HAL_RCCEx_GetPeriphCLKFreq+0x91e>
    {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
240167a6:	4b59      	ldr	r3, [pc, #356]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
240167a8:	681b      	ldr	r3, [r3, #0]
240167aa:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240167ae:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
240167b2:	d107      	bne.n	240167c4 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240167b4:	f107 0324 	add.w	r3, r7, #36	; 0x24
240167b8:	4618      	mov	r0, r3
240167ba:	f000 fbdd 	bl	24016f78 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240167be:	6abb      	ldr	r3, [r7, #40]	; 0x28
240167c0:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240167c2:	e0fc      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240167c4:	2300      	movs	r3, #0
240167c6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240167c8:	e0f9      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
240167ca:	4b50      	ldr	r3, [pc, #320]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
240167cc:	681b      	ldr	r3, [r3, #0]
240167ce:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
240167d2:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
240167d6:	d107      	bne.n	240167e8 <HAL_RCCEx_GetPeriphCLKFreq+0x918>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240167d8:	f107 0318 	add.w	r3, r7, #24
240167dc:	4618      	mov	r0, r3
240167de:	f000 f923 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
240167e2:	6a3b      	ldr	r3, [r7, #32]
240167e4:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240167e6:	e0ea      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240167e8:	2300      	movs	r3, #0
240167ea:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240167ec:	e0e7      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
240167ee:	2300      	movs	r3, #0
240167f0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240167f2:	e0e4      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
240167f4:	e9d7 2300 	ldrd	r2, r3, [r7]
240167f8:	f5a2 4180 	sub.w	r1, r2, #16384	; 0x4000
240167fc:	430b      	orrs	r3, r1
240167fe:	f040 808d 	bne.w	2401691c <HAL_RCCEx_GetPeriphCLKFreq+0xa4c>
  {
    /* Get SPI6 clock source */
    srcclk = __HAL_RCC_GET_SPI6_SOURCE();
24016802:	4b42      	ldr	r3, [pc, #264]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
24016804:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24016806:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
2401680a:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
2401680c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401680e:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24016812:	d06b      	beq.n	240168ec <HAL_RCCEx_GetPeriphCLKFreq+0xa1c>
24016814:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016816:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
2401681a:	d874      	bhi.n	24016906 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
2401681c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401681e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24016822:	d056      	beq.n	240168d2 <HAL_RCCEx_GetPeriphCLKFreq+0xa02>
24016824:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016826:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401682a:	d86c      	bhi.n	24016906 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
2401682c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401682e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24016832:	d03b      	beq.n	240168ac <HAL_RCCEx_GetPeriphCLKFreq+0x9dc>
24016834:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016836:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
2401683a:	d864      	bhi.n	24016906 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
2401683c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401683e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24016842:	d021      	beq.n	24016888 <HAL_RCCEx_GetPeriphCLKFreq+0x9b8>
24016844:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016846:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401684a:	d85c      	bhi.n	24016906 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
2401684c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401684e:	2b00      	cmp	r3, #0
24016850:	d004      	beq.n	2401685c <HAL_RCCEx_GetPeriphCLKFreq+0x98c>
24016852:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016854:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24016858:	d004      	beq.n	24016864 <HAL_RCCEx_GetPeriphCLKFreq+0x994>
2401685a:	e054      	b.n	24016906 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
    {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
      {
        frequency = HAL_RCCEx_GetD3PCLK1Freq();
2401685c:	f000 f8ce 	bl	240169fc <HAL_RCCEx_GetD3PCLK1Freq>
24016860:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
24016862:	e0ac      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24016864:	4b29      	ldr	r3, [pc, #164]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
24016866:	681b      	ldr	r3, [r3, #0]
24016868:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2401686c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24016870:	d107      	bne.n	24016882 <HAL_RCCEx_GetPeriphCLKFreq+0x9b2>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24016872:	f107 0318 	add.w	r3, r7, #24
24016876:	4618      	mov	r0, r3
24016878:	f000 f8d6 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
2401687c:	69fb      	ldr	r3, [r7, #28]
2401687e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016880:	e09d      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016882:	2300      	movs	r3, #0
24016884:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016886:	e09a      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
24016888:	4b20      	ldr	r3, [pc, #128]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
2401688a:	681b      	ldr	r3, [r3, #0]
2401688c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24016890:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24016894:	d107      	bne.n	240168a6 <HAL_RCCEx_GetPeriphCLKFreq+0x9d6>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24016896:	f107 030c 	add.w	r3, r7, #12
2401689a:	4618      	mov	r0, r3
2401689c:	f000 fa18 	bl	24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
240168a0:	693b      	ldr	r3, [r7, #16]
240168a2:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240168a4:	e08b      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240168a6:	2300      	movs	r3, #0
240168a8:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240168aa:	e088      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
240168ac:	4b17      	ldr	r3, [pc, #92]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
240168ae:	681b      	ldr	r3, [r3, #0]
240168b0:	f003 0304 	and.w	r3, r3, #4
240168b4:	2b04      	cmp	r3, #4
240168b6:	d109      	bne.n	240168cc <HAL_RCCEx_GetPeriphCLKFreq+0x9fc>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
240168b8:	4b14      	ldr	r3, [pc, #80]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
240168ba:	681b      	ldr	r3, [r3, #0]
240168bc:	08db      	lsrs	r3, r3, #3
240168be:	f003 0303 	and.w	r3, r3, #3
240168c2:	4a13      	ldr	r2, [pc, #76]	; (24016910 <HAL_RCCEx_GetPeriphCLKFreq+0xa40>)
240168c4:	fa22 f303 	lsr.w	r3, r2, r3
240168c8:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240168ca:	e078      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240168cc:	2300      	movs	r3, #0
240168ce:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240168d0:	e075      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
240168d2:	4b0e      	ldr	r3, [pc, #56]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
240168d4:	681b      	ldr	r3, [r3, #0]
240168d6:	f403 7380 	and.w	r3, r3, #256	; 0x100
240168da:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240168de:	d102      	bne.n	240168e6 <HAL_RCCEx_GetPeriphCLKFreq+0xa16>
        {
          frequency = CSI_VALUE;
240168e0:	4b0c      	ldr	r3, [pc, #48]	; (24016914 <HAL_RCCEx_GetPeriphCLKFreq+0xa44>)
240168e2:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240168e4:	e06b      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240168e6:	2300      	movs	r3, #0
240168e8:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240168ea:	e068      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
240168ec:	4b07      	ldr	r3, [pc, #28]	; (2401690c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
240168ee:	681b      	ldr	r3, [r3, #0]
240168f0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240168f4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
240168f8:	d102      	bne.n	24016900 <HAL_RCCEx_GetPeriphCLKFreq+0xa30>
        {
          frequency = HSE_VALUE;
240168fa:	4b07      	ldr	r3, [pc, #28]	; (24016918 <HAL_RCCEx_GetPeriphCLKFreq+0xa48>)
240168fc:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240168fe:	e05e      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016900:	2300      	movs	r3, #0
24016902:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
24016904:	e05b      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
        break;
      }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
      {
        frequency = 0;
24016906:	2300      	movs	r3, #0
24016908:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401690a:	e058      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
2401690c:	58024400 	.word	0x58024400
24016910:	03d09000 	.word	0x03d09000
24016914:	003d0900 	.word	0x003d0900
24016918:	017d7840 	.word	0x017d7840
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)
2401691c:	e9d7 2300 	ldrd	r2, r3, [r7]
24016920:	f5a2 4100 	sub.w	r1, r2, #32768	; 0x8000
24016924:	430b      	orrs	r3, r1
24016926:	d148      	bne.n	240169ba <HAL_RCCEx_GetPeriphCLKFreq+0xaea>
  {
    /* Get FDCAN clock source */
    srcclk = __HAL_RCC_GET_FDCAN_SOURCE();
24016928:	4b27      	ldr	r3, [pc, #156]	; (240169c8 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
2401692a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401692c:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24016930:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
24016932:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016934:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24016938:	d02a      	beq.n	24016990 <HAL_RCCEx_GetPeriphCLKFreq+0xac0>
2401693a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401693c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24016940:	d838      	bhi.n	240169b4 <HAL_RCCEx_GetPeriphCLKFreq+0xae4>
24016942:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24016944:	2b00      	cmp	r3, #0
24016946:	d004      	beq.n	24016952 <HAL_RCCEx_GetPeriphCLKFreq+0xa82>
24016948:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401694a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2401694e:	d00d      	beq.n	2401696c <HAL_RCCEx_GetPeriphCLKFreq+0xa9c>
24016950:	e030      	b.n	240169b4 <HAL_RCCEx_GetPeriphCLKFreq+0xae4>
    {
      case RCC_FDCANCLKSOURCE_HSE: /* HSE is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
24016952:	4b1d      	ldr	r3, [pc, #116]	; (240169c8 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
24016954:	681b      	ldr	r3, [r3, #0]
24016956:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2401695a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2401695e:	d102      	bne.n	24016966 <HAL_RCCEx_GetPeriphCLKFreq+0xa96>
        {
          frequency = HSE_VALUE;
24016960:	4b1a      	ldr	r3, [pc, #104]	; (240169cc <HAL_RCCEx_GetPeriphCLKFreq+0xafc>)
24016962:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016964:	e02b      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
24016966:	2300      	movs	r3, #0
24016968:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401696a:	e028      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_FDCANCLKSOURCE_PLL: /* PLL is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
2401696c:	4b16      	ldr	r3, [pc, #88]	; (240169c8 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
2401696e:	681b      	ldr	r3, [r3, #0]
24016970:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24016974:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24016978:	d107      	bne.n	2401698a <HAL_RCCEx_GetPeriphCLKFreq+0xaba>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2401697a:	f107 0324 	add.w	r3, r7, #36	; 0x24
2401697e:	4618      	mov	r0, r3
24016980:	f000 fafa 	bl	24016f78 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
24016984:	6abb      	ldr	r3, [r7, #40]	; 0x28
24016986:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
24016988:	e019      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
2401698a:	2300      	movs	r3, #0
2401698c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
2401698e:	e016      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24016990:	4b0d      	ldr	r3, [pc, #52]	; (240169c8 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
24016992:	681b      	ldr	r3, [r3, #0]
24016994:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24016998:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2401699c:	d107      	bne.n	240169ae <HAL_RCCEx_GetPeriphCLKFreq+0xade>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2401699e:	f107 0318 	add.w	r3, r7, #24
240169a2:	4618      	mov	r0, r3
240169a4:	f000 f840 	bl	24016a28 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
240169a8:	69fb      	ldr	r3, [r7, #28]
240169aa:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
240169ac:	e007      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
240169ae:	2300      	movs	r3, #0
240169b0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240169b2:	e004      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
240169b4:	2300      	movs	r3, #0
240169b6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
240169b8:	e001      	b.n	240169be <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else
  {
    frequency = 0;
240169ba:	2300      	movs	r3, #0
240169bc:	63fb      	str	r3, [r7, #60]	; 0x3c
  }

  return frequency;
240169be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
240169c0:	4618      	mov	r0, r3
240169c2:	3740      	adds	r7, #64	; 0x40
240169c4:	46bd      	mov	sp, r7
240169c6:	bd80      	pop	{r7, pc}
240169c8:	58024400 	.word	0x58024400
240169cc:	017d7840 	.word	0x017d7840

240169d0 <HAL_RCCEx_GetD1PCLK1Freq>:
  * @note   Each time D1PCLK1 changes, this function must be called to update the
  *         right D1PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D1PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD1PCLK1Freq(void)
{
240169d0:	b580      	push	{r7, lr}
240169d2:	af00      	add	r7, sp, #0
#if defined(RCC_D1CFGR_D1PPRE)
  /* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1PPRE) >> RCC_D1CFGR_D1PPRE_Pos] & 0x1FU));
240169d4:	f7fd fd38 	bl	24014448 <HAL_RCC_GetHCLKFreq>
240169d8:	4602      	mov	r2, r0
240169da:	4b06      	ldr	r3, [pc, #24]	; (240169f4 <HAL_RCCEx_GetD1PCLK1Freq+0x24>)
240169dc:	699b      	ldr	r3, [r3, #24]
240169de:	091b      	lsrs	r3, r3, #4
240169e0:	f003 0307 	and.w	r3, r3, #7
240169e4:	4904      	ldr	r1, [pc, #16]	; (240169f8 <HAL_RCCEx_GetD1PCLK1Freq+0x28>)
240169e6:	5ccb      	ldrb	r3, [r1, r3]
240169e8:	f003 031f 	and.w	r3, r3, #31
240169ec:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE) >> RCC_CDCFGR1_CDPPRE_Pos] & 0x1FU));
#endif
}
240169f0:	4618      	mov	r0, r3
240169f2:	bd80      	pop	{r7, pc}
240169f4:	58024400 	.word	0x58024400
240169f8:	24020f94 	.word	0x24020f94

240169fc <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
240169fc:	b580      	push	{r7, lr}
240169fe:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE) >> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
24016a00:	f7fd fd22 	bl	24014448 <HAL_RCC_GetHCLKFreq>
24016a04:	4602      	mov	r2, r0
24016a06:	4b06      	ldr	r3, [pc, #24]	; (24016a20 <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
24016a08:	6a1b      	ldr	r3, [r3, #32]
24016a0a:	091b      	lsrs	r3, r3, #4
24016a0c:	f003 0307 	and.w	r3, r3, #7
24016a10:	4904      	ldr	r1, [pc, #16]	; (24016a24 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
24016a12:	5ccb      	ldrb	r3, [r1, r3]
24016a14:	f003 031f 	and.w	r3, r3, #31
24016a18:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE) >> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
24016a1c:	4618      	mov	r0, r3
24016a1e:	bd80      	pop	{r7, pc}
24016a20:	58024400 	.word	0x58024400
24016a24:	24020f94 	.word	0x24020f94

24016a28 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
24016a28:	b480      	push	{r7}
24016a2a:	b089      	sub	sp, #36	; 0x24
24016a2c:	af00      	add	r7, sp, #0
24016a2e:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24016a30:	4ba1      	ldr	r3, [pc, #644]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016a32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016a34:	f003 0303 	and.w	r3, r3, #3
24016a38:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
24016a3a:	4b9f      	ldr	r3, [pc, #636]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016a3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016a3e:	0b1b      	lsrs	r3, r3, #12
24016a40:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24016a44:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
24016a46:	4b9c      	ldr	r3, [pc, #624]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016a48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016a4a:	091b      	lsrs	r3, r3, #4
24016a4c:	f003 0301 	and.w	r3, r3, #1
24016a50:	613b      	str	r3, [r7, #16]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
24016a52:	4b99      	ldr	r3, [pc, #612]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016a54:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24016a56:	08db      	lsrs	r3, r3, #3
24016a58:	f3c3 030c 	ubfx	r3, r3, #0, #13
24016a5c:	693a      	ldr	r2, [r7, #16]
24016a5e:	fb02 f303 	mul.w	r3, r2, r3
24016a62:	ee07 3a90 	vmov	s15, r3
24016a66:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016a6a:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
24016a6e:	697b      	ldr	r3, [r7, #20]
24016a70:	2b00      	cmp	r3, #0
24016a72:	f000 8111 	beq.w	24016c98 <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
24016a76:	69bb      	ldr	r3, [r7, #24]
24016a78:	2b02      	cmp	r3, #2
24016a7a:	f000 8083 	beq.w	24016b84 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
24016a7e:	69bb      	ldr	r3, [r7, #24]
24016a80:	2b02      	cmp	r3, #2
24016a82:	f200 80a1 	bhi.w	24016bc8 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
24016a86:	69bb      	ldr	r3, [r7, #24]
24016a88:	2b00      	cmp	r3, #0
24016a8a:	d003      	beq.n	24016a94 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
24016a8c:	69bb      	ldr	r3, [r7, #24]
24016a8e:	2b01      	cmp	r3, #1
24016a90:	d056      	beq.n	24016b40 <HAL_RCCEx_GetPLL2ClockFreq+0x118>
24016a92:	e099      	b.n	24016bc8 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24016a94:	4b88      	ldr	r3, [pc, #544]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016a96:	681b      	ldr	r3, [r3, #0]
24016a98:	f003 0320 	and.w	r3, r3, #32
24016a9c:	2b00      	cmp	r3, #0
24016a9e:	d02d      	beq.n	24016afc <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
24016aa0:	4b85      	ldr	r3, [pc, #532]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016aa2:	681b      	ldr	r3, [r3, #0]
24016aa4:	08db      	lsrs	r3, r3, #3
24016aa6:	f003 0303 	and.w	r3, r3, #3
24016aaa:	4a84      	ldr	r2, [pc, #528]	; (24016cbc <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
24016aac:	fa22 f303 	lsr.w	r3, r2, r3
24016ab0:	60bb      	str	r3, [r7, #8]
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
24016ab2:	68bb      	ldr	r3, [r7, #8]
24016ab4:	ee07 3a90 	vmov	s15, r3
24016ab8:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016abc:	697b      	ldr	r3, [r7, #20]
24016abe:	ee07 3a90 	vmov	s15, r3
24016ac2:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016ac6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016aca:	4b7b      	ldr	r3, [pc, #492]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016acc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24016ace:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016ad2:	ee07 3a90 	vmov	s15, r3
24016ad6:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016ada:	ed97 6a03 	vldr	s12, [r7, #12]
24016ade:	eddf 5a78 	vldr	s11, [pc, #480]	; 24016cc0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
24016ae2:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016ae6:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016aea:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016aee:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016af2:	ee67 7a27 	vmul.f32	s15, s14, s15
24016af6:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
        }
        break;
24016afa:	e087      	b.n	24016c0c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
24016afc:	697b      	ldr	r3, [r7, #20]
24016afe:	ee07 3a90 	vmov	s15, r3
24016b02:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016b06:	eddf 6a6f 	vldr	s13, [pc, #444]	; 24016cc4 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
24016b0a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016b0e:	4b6a      	ldr	r3, [pc, #424]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016b10:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24016b12:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016b16:	ee07 3a90 	vmov	s15, r3
24016b1a:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016b1e:	ed97 6a03 	vldr	s12, [r7, #12]
24016b22:	eddf 5a67 	vldr	s11, [pc, #412]	; 24016cc0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
24016b26:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016b2a:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016b2e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016b32:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016b36:	ee67 7a27 	vmul.f32	s15, s14, s15
24016b3a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24016b3e:	e065      	b.n	24016c0c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
24016b40:	697b      	ldr	r3, [r7, #20]
24016b42:	ee07 3a90 	vmov	s15, r3
24016b46:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016b4a:	eddf 6a5f 	vldr	s13, [pc, #380]	; 24016cc8 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
24016b4e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016b52:	4b59      	ldr	r3, [pc, #356]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016b54:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24016b56:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016b5a:	ee07 3a90 	vmov	s15, r3
24016b5e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016b62:	ed97 6a03 	vldr	s12, [r7, #12]
24016b66:	eddf 5a56 	vldr	s11, [pc, #344]	; 24016cc0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
24016b6a:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016b6e:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016b72:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016b76:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016b7a:	ee67 7a27 	vmul.f32	s15, s14, s15
24016b7e:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24016b82:	e043      	b.n	24016c0c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
24016b84:	697b      	ldr	r3, [r7, #20]
24016b86:	ee07 3a90 	vmov	s15, r3
24016b8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016b8e:	eddf 6a4f 	vldr	s13, [pc, #316]	; 24016ccc <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
24016b92:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016b96:	4b48      	ldr	r3, [pc, #288]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016b98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24016b9a:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016b9e:	ee07 3a90 	vmov	s15, r3
24016ba2:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016ba6:	ed97 6a03 	vldr	s12, [r7, #12]
24016baa:	eddf 5a45 	vldr	s11, [pc, #276]	; 24016cc0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
24016bae:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016bb2:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016bb6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016bba:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016bbe:	ee67 7a27 	vmul.f32	s15, s14, s15
24016bc2:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24016bc6:	e021      	b.n	24016c0c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      default:
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
24016bc8:	697b      	ldr	r3, [r7, #20]
24016bca:	ee07 3a90 	vmov	s15, r3
24016bce:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016bd2:	eddf 6a3d 	vldr	s13, [pc, #244]	; 24016cc8 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
24016bd6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016bda:	4b37      	ldr	r3, [pc, #220]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016bdc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24016bde:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016be2:	ee07 3a90 	vmov	s15, r3
24016be6:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016bea:	ed97 6a03 	vldr	s12, [r7, #12]
24016bee:	eddf 5a34 	vldr	s11, [pc, #208]	; 24016cc0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
24016bf2:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016bf6:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016bfa:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016bfe:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016c02:	ee67 7a27 	vmul.f32	s15, s14, s15
24016c06:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24016c0a:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> 9)  + (float_t)1)) ;
24016c0c:	4b2a      	ldr	r3, [pc, #168]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016c0e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24016c10:	0a5b      	lsrs	r3, r3, #9
24016c12:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016c16:	ee07 3a90 	vmov	s15, r3
24016c1a:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016c1e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016c22:	ee37 7a87 	vadd.f32	s14, s15, s14
24016c26:	edd7 6a07 	vldr	s13, [r7, #28]
24016c2a:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016c2e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016c32:	ee17 2a90 	vmov	r2, s15
24016c36:	687b      	ldr	r3, [r7, #4]
24016c38:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> 16) + (float_t)1)) ;
24016c3a:	4b1f      	ldr	r3, [pc, #124]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016c3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24016c3e:	0c1b      	lsrs	r3, r3, #16
24016c40:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016c44:	ee07 3a90 	vmov	s15, r3
24016c48:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016c4c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016c50:	ee37 7a87 	vadd.f32	s14, s15, s14
24016c54:	edd7 6a07 	vldr	s13, [r7, #28]
24016c58:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016c5c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016c60:	ee17 2a90 	vmov	r2, s15
24016c64:	687b      	ldr	r3, [r7, #4]
24016c66:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> 24) + (float_t)1)) ;
24016c68:	4b13      	ldr	r3, [pc, #76]	; (24016cb8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016c6a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24016c6c:	0e1b      	lsrs	r3, r3, #24
24016c6e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016c72:	ee07 3a90 	vmov	s15, r3
24016c76:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016c7a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016c7e:	ee37 7a87 	vadd.f32	s14, s15, s14
24016c82:	edd7 6a07 	vldr	s13, [r7, #28]
24016c86:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016c8a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016c8e:	ee17 2a90 	vmov	r2, s15
24016c92:	687b      	ldr	r3, [r7, #4]
24016c94:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
24016c96:	e008      	b.n	24016caa <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
24016c98:	687b      	ldr	r3, [r7, #4]
24016c9a:	2200      	movs	r2, #0
24016c9c:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
24016c9e:	687b      	ldr	r3, [r7, #4]
24016ca0:	2200      	movs	r2, #0
24016ca2:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
24016ca4:	687b      	ldr	r3, [r7, #4]
24016ca6:	2200      	movs	r2, #0
24016ca8:	609a      	str	r2, [r3, #8]
}
24016caa:	bf00      	nop
24016cac:	3724      	adds	r7, #36	; 0x24
24016cae:	46bd      	mov	sp, r7
24016cb0:	f85d 7b04 	ldr.w	r7, [sp], #4
24016cb4:	4770      	bx	lr
24016cb6:	bf00      	nop
24016cb8:	58024400 	.word	0x58024400
24016cbc:	03d09000 	.word	0x03d09000
24016cc0:	46000000 	.word	0x46000000
24016cc4:	4c742400 	.word	0x4c742400
24016cc8:	4a742400 	.word	0x4a742400
24016ccc:	4bbebc20 	.word	0x4bbebc20

24016cd0 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
24016cd0:	b480      	push	{r7}
24016cd2:	b089      	sub	sp, #36	; 0x24
24016cd4:	af00      	add	r7, sp, #0
24016cd6:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24016cd8:	4ba1      	ldr	r3, [pc, #644]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016cda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016cdc:	f003 0303 	and.w	r3, r3, #3
24016ce0:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
24016ce2:	4b9f      	ldr	r3, [pc, #636]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016ce4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016ce6:	0d1b      	lsrs	r3, r3, #20
24016ce8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24016cec:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
24016cee:	4b9c      	ldr	r3, [pc, #624]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016cf0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016cf2:	0a1b      	lsrs	r3, r3, #8
24016cf4:	f003 0301 	and.w	r3, r3, #1
24016cf8:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
24016cfa:	4b99      	ldr	r3, [pc, #612]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016cfc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24016cfe:	08db      	lsrs	r3, r3, #3
24016d00:	f3c3 030c 	ubfx	r3, r3, #0, #13
24016d04:	693a      	ldr	r2, [r7, #16]
24016d06:	fb02 f303 	mul.w	r3, r2, r3
24016d0a:	ee07 3a90 	vmov	s15, r3
24016d0e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016d12:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
24016d16:	697b      	ldr	r3, [r7, #20]
24016d18:	2b00      	cmp	r3, #0
24016d1a:	f000 8111 	beq.w	24016f40 <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
24016d1e:	69bb      	ldr	r3, [r7, #24]
24016d20:	2b02      	cmp	r3, #2
24016d22:	f000 8083 	beq.w	24016e2c <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
24016d26:	69bb      	ldr	r3, [r7, #24]
24016d28:	2b02      	cmp	r3, #2
24016d2a:	f200 80a1 	bhi.w	24016e70 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
24016d2e:	69bb      	ldr	r3, [r7, #24]
24016d30:	2b00      	cmp	r3, #0
24016d32:	d003      	beq.n	24016d3c <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
24016d34:	69bb      	ldr	r3, [r7, #24]
24016d36:	2b01      	cmp	r3, #1
24016d38:	d056      	beq.n	24016de8 <HAL_RCCEx_GetPLL3ClockFreq+0x118>
24016d3a:	e099      	b.n	24016e70 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24016d3c:	4b88      	ldr	r3, [pc, #544]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016d3e:	681b      	ldr	r3, [r3, #0]
24016d40:	f003 0320 	and.w	r3, r3, #32
24016d44:	2b00      	cmp	r3, #0
24016d46:	d02d      	beq.n	24016da4 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
24016d48:	4b85      	ldr	r3, [pc, #532]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016d4a:	681b      	ldr	r3, [r3, #0]
24016d4c:	08db      	lsrs	r3, r3, #3
24016d4e:	f003 0303 	and.w	r3, r3, #3
24016d52:	4a84      	ldr	r2, [pc, #528]	; (24016f64 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
24016d54:	fa22 f303 	lsr.w	r3, r2, r3
24016d58:	60bb      	str	r3, [r7, #8]
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
24016d5a:	68bb      	ldr	r3, [r7, #8]
24016d5c:	ee07 3a90 	vmov	s15, r3
24016d60:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016d64:	697b      	ldr	r3, [r7, #20]
24016d66:	ee07 3a90 	vmov	s15, r3
24016d6a:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016d6e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016d72:	4b7b      	ldr	r3, [pc, #492]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016d74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016d76:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016d7a:	ee07 3a90 	vmov	s15, r3
24016d7e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016d82:	ed97 6a03 	vldr	s12, [r7, #12]
24016d86:	eddf 5a78 	vldr	s11, [pc, #480]	; 24016f68 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
24016d8a:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016d8e:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016d92:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016d96:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016d9a:	ee67 7a27 	vmul.f32	s15, s14, s15
24016d9e:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
        }
        break;
24016da2:	e087      	b.n	24016eb4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
24016da4:	697b      	ldr	r3, [r7, #20]
24016da6:	ee07 3a90 	vmov	s15, r3
24016daa:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016dae:	eddf 6a6f 	vldr	s13, [pc, #444]	; 24016f6c <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
24016db2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016db6:	4b6a      	ldr	r3, [pc, #424]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016db8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016dba:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016dbe:	ee07 3a90 	vmov	s15, r3
24016dc2:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016dc6:	ed97 6a03 	vldr	s12, [r7, #12]
24016dca:	eddf 5a67 	vldr	s11, [pc, #412]	; 24016f68 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
24016dce:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016dd2:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016dd6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016dda:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016dde:	ee67 7a27 	vmul.f32	s15, s14, s15
24016de2:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24016de6:	e065      	b.n	24016eb4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
24016de8:	697b      	ldr	r3, [r7, #20]
24016dea:	ee07 3a90 	vmov	s15, r3
24016dee:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016df2:	eddf 6a5f 	vldr	s13, [pc, #380]	; 24016f70 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
24016df6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016dfa:	4b59      	ldr	r3, [pc, #356]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016dfc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016dfe:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016e02:	ee07 3a90 	vmov	s15, r3
24016e06:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016e0a:	ed97 6a03 	vldr	s12, [r7, #12]
24016e0e:	eddf 5a56 	vldr	s11, [pc, #344]	; 24016f68 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
24016e12:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016e16:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016e1a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016e1e:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016e22:	ee67 7a27 	vmul.f32	s15, s14, s15
24016e26:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24016e2a:	e043      	b.n	24016eb4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
24016e2c:	697b      	ldr	r3, [r7, #20]
24016e2e:	ee07 3a90 	vmov	s15, r3
24016e32:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016e36:	eddf 6a4f 	vldr	s13, [pc, #316]	; 24016f74 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
24016e3a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016e3e:	4b48      	ldr	r3, [pc, #288]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016e40:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016e42:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016e46:	ee07 3a90 	vmov	s15, r3
24016e4a:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016e4e:	ed97 6a03 	vldr	s12, [r7, #12]
24016e52:	eddf 5a45 	vldr	s11, [pc, #276]	; 24016f68 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
24016e56:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016e5a:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016e5e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016e62:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016e66:	ee67 7a27 	vmul.f32	s15, s14, s15
24016e6a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24016e6e:	e021      	b.n	24016eb4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      default:
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
24016e70:	697b      	ldr	r3, [r7, #20]
24016e72:	ee07 3a90 	vmov	s15, r3
24016e76:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016e7a:	eddf 6a3d 	vldr	s13, [pc, #244]	; 24016f70 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
24016e7e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016e82:	4b37      	ldr	r3, [pc, #220]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016e84:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016e86:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016e8a:	ee07 3a90 	vmov	s15, r3
24016e8e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016e92:	ed97 6a03 	vldr	s12, [r7, #12]
24016e96:	eddf 5a34 	vldr	s11, [pc, #208]	; 24016f68 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
24016e9a:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016e9e:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016ea2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016ea6:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016eaa:	ee67 7a27 	vmul.f32	s15, s14, s15
24016eae:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24016eb2:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> 9)  + (float_t)1)) ;
24016eb4:	4b2a      	ldr	r3, [pc, #168]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016eb6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016eb8:	0a5b      	lsrs	r3, r3, #9
24016eba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016ebe:	ee07 3a90 	vmov	s15, r3
24016ec2:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016ec6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016eca:	ee37 7a87 	vadd.f32	s14, s15, s14
24016ece:	edd7 6a07 	vldr	s13, [r7, #28]
24016ed2:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016ed6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016eda:	ee17 2a90 	vmov	r2, s15
24016ede:	687b      	ldr	r3, [r7, #4]
24016ee0:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> 16) + (float_t)1)) ;
24016ee2:	4b1f      	ldr	r3, [pc, #124]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016ee4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016ee6:	0c1b      	lsrs	r3, r3, #16
24016ee8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016eec:	ee07 3a90 	vmov	s15, r3
24016ef0:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016ef4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016ef8:	ee37 7a87 	vadd.f32	s14, s15, s14
24016efc:	edd7 6a07 	vldr	s13, [r7, #28]
24016f00:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016f04:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016f08:	ee17 2a90 	vmov	r2, s15
24016f0c:	687b      	ldr	r3, [r7, #4]
24016f0e:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> 24) + (float_t)1)) ;
24016f10:	4b13      	ldr	r3, [pc, #76]	; (24016f60 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016f12:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016f14:	0e1b      	lsrs	r3, r3, #24
24016f16:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016f1a:	ee07 3a90 	vmov	s15, r3
24016f1e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016f22:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016f26:	ee37 7a87 	vadd.f32	s14, s15, s14
24016f2a:	edd7 6a07 	vldr	s13, [r7, #28]
24016f2e:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016f32:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016f36:	ee17 2a90 	vmov	r2, s15
24016f3a:	687b      	ldr	r3, [r7, #4]
24016f3c:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
24016f3e:	e008      	b.n	24016f52 <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
24016f40:	687b      	ldr	r3, [r7, #4]
24016f42:	2200      	movs	r2, #0
24016f44:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
24016f46:	687b      	ldr	r3, [r7, #4]
24016f48:	2200      	movs	r2, #0
24016f4a:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
24016f4c:	687b      	ldr	r3, [r7, #4]
24016f4e:	2200      	movs	r2, #0
24016f50:	609a      	str	r2, [r3, #8]
}
24016f52:	bf00      	nop
24016f54:	3724      	adds	r7, #36	; 0x24
24016f56:	46bd      	mov	sp, r7
24016f58:	f85d 7b04 	ldr.w	r7, [sp], #4
24016f5c:	4770      	bx	lr
24016f5e:	bf00      	nop
24016f60:	58024400 	.word	0x58024400
24016f64:	03d09000 	.word	0x03d09000
24016f68:	46000000 	.word	0x46000000
24016f6c:	4c742400 	.word	0x4c742400
24016f70:	4a742400 	.word	0x4a742400
24016f74:	4bbebc20 	.word	0x4bbebc20

24016f78 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
24016f78:	b480      	push	{r7}
24016f7a:	b089      	sub	sp, #36	; 0x24
24016f7c:	af00      	add	r7, sp, #0
24016f7e:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24016f80:	4ba0      	ldr	r3, [pc, #640]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016f82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016f84:	f003 0303 	and.w	r3, r3, #3
24016f88:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4);
24016f8a:	4b9e      	ldr	r3, [pc, #632]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016f8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016f8e:	091b      	lsrs	r3, r3, #4
24016f90:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24016f94:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
24016f96:	4b9b      	ldr	r3, [pc, #620]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016f98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016f9a:	f003 0301 	and.w	r3, r3, #1
24016f9e:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
24016fa0:	4b98      	ldr	r3, [pc, #608]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016fa2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24016fa4:	08db      	lsrs	r3, r3, #3
24016fa6:	f3c3 030c 	ubfx	r3, r3, #0, #13
24016faa:	693a      	ldr	r2, [r7, #16]
24016fac:	fb02 f303 	mul.w	r3, r2, r3
24016fb0:	ee07 3a90 	vmov	s15, r3
24016fb4:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016fb8:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
24016fbc:	697b      	ldr	r3, [r7, #20]
24016fbe:	2b00      	cmp	r3, #0
24016fc0:	f000 8111 	beq.w	240171e6 <HAL_RCCEx_GetPLL1ClockFreq+0x26e>
  {
    switch (pllsource)
24016fc4:	69bb      	ldr	r3, [r7, #24]
24016fc6:	2b02      	cmp	r3, #2
24016fc8:	f000 8083 	beq.w	240170d2 <HAL_RCCEx_GetPLL1ClockFreq+0x15a>
24016fcc:	69bb      	ldr	r3, [r7, #24]
24016fce:	2b02      	cmp	r3, #2
24016fd0:	f200 80a1 	bhi.w	24017116 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
24016fd4:	69bb      	ldr	r3, [r7, #24]
24016fd6:	2b00      	cmp	r3, #0
24016fd8:	d003      	beq.n	24016fe2 <HAL_RCCEx_GetPLL1ClockFreq+0x6a>
24016fda:	69bb      	ldr	r3, [r7, #24]
24016fdc:	2b01      	cmp	r3, #1
24016fde:	d056      	beq.n	2401708e <HAL_RCCEx_GetPLL1ClockFreq+0x116>
24016fe0:	e099      	b.n	24017116 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24016fe2:	4b88      	ldr	r3, [pc, #544]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016fe4:	681b      	ldr	r3, [r3, #0]
24016fe6:	f003 0320 	and.w	r3, r3, #32
24016fea:	2b00      	cmp	r3, #0
24016fec:	d02d      	beq.n	2401704a <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
24016fee:	4b85      	ldr	r3, [pc, #532]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016ff0:	681b      	ldr	r3, [r3, #0]
24016ff2:	08db      	lsrs	r3, r3, #3
24016ff4:	f003 0303 	and.w	r3, r3, #3
24016ff8:	4a83      	ldr	r2, [pc, #524]	; (24017208 <HAL_RCCEx_GetPLL1ClockFreq+0x290>)
24016ffa:	fa22 f303 	lsr.w	r3, r2, r3
24016ffe:	60bb      	str	r3, [r7, #8]
          pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
24017000:	68bb      	ldr	r3, [r7, #8]
24017002:	ee07 3a90 	vmov	s15, r3
24017006:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401700a:	697b      	ldr	r3, [r7, #20]
2401700c:	ee07 3a90 	vmov	s15, r3
24017010:	eef8 7a67 	vcvt.f32.u32	s15, s15
24017014:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24017018:	4b7a      	ldr	r3, [pc, #488]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
2401701a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401701c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24017020:	ee07 3a90 	vmov	s15, r3
24017024:	eef8 6a67 	vcvt.f32.u32	s13, s15
24017028:	ed97 6a03 	vldr	s12, [r7, #12]
2401702c:	eddf 5a77 	vldr	s11, [pc, #476]	; 2401720c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
24017030:	eec6 7a25 	vdiv.f32	s15, s12, s11
24017034:	ee76 7aa7 	vadd.f32	s15, s13, s15
24017038:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401703c:	ee77 7aa6 	vadd.f32	s15, s15, s13
24017040:	ee67 7a27 	vmul.f32	s15, s14, s15
24017044:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
        }
        break;
24017048:	e087      	b.n	2401715a <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
2401704a:	697b      	ldr	r3, [r7, #20]
2401704c:	ee07 3a90 	vmov	s15, r3
24017050:	eef8 7a67 	vcvt.f32.u32	s15, s15
24017054:	eddf 6a6e 	vldr	s13, [pc, #440]	; 24017210 <HAL_RCCEx_GetPLL1ClockFreq+0x298>
24017058:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401705c:	4b69      	ldr	r3, [pc, #420]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
2401705e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24017060:	f3c3 0308 	ubfx	r3, r3, #0, #9
24017064:	ee07 3a90 	vmov	s15, r3
24017068:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401706c:	ed97 6a03 	vldr	s12, [r7, #12]
24017070:	eddf 5a66 	vldr	s11, [pc, #408]	; 2401720c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
24017074:	eec6 7a25 	vdiv.f32	s15, s12, s11
24017078:	ee76 7aa7 	vadd.f32	s15, s13, s15
2401707c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24017080:	ee77 7aa6 	vadd.f32	s15, s15, s13
24017084:	ee67 7a27 	vmul.f32	s15, s14, s15
24017088:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
2401708c:	e065      	b.n	2401715a <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
2401708e:	697b      	ldr	r3, [r7, #20]
24017090:	ee07 3a90 	vmov	s15, r3
24017094:	eef8 7a67 	vcvt.f32.u32	s15, s15
24017098:	eddf 6a5e 	vldr	s13, [pc, #376]	; 24017214 <HAL_RCCEx_GetPLL1ClockFreq+0x29c>
2401709c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240170a0:	4b58      	ldr	r3, [pc, #352]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240170a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240170a4:	f3c3 0308 	ubfx	r3, r3, #0, #9
240170a8:	ee07 3a90 	vmov	s15, r3
240170ac:	eef8 6a67 	vcvt.f32.u32	s13, s15
240170b0:	ed97 6a03 	vldr	s12, [r7, #12]
240170b4:	eddf 5a55 	vldr	s11, [pc, #340]	; 2401720c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
240170b8:	eec6 7a25 	vdiv.f32	s15, s12, s11
240170bc:	ee76 7aa7 	vadd.f32	s15, s13, s15
240170c0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240170c4:	ee77 7aa6 	vadd.f32	s15, s15, s13
240170c8:	ee67 7a27 	vmul.f32	s15, s14, s15
240170cc:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
240170d0:	e043      	b.n	2401715a <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
240170d2:	697b      	ldr	r3, [r7, #20]
240170d4:	ee07 3a90 	vmov	s15, r3
240170d8:	eef8 7a67 	vcvt.f32.u32	s15, s15
240170dc:	eddf 6a4e 	vldr	s13, [pc, #312]	; 24017218 <HAL_RCCEx_GetPLL1ClockFreq+0x2a0>
240170e0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240170e4:	4b47      	ldr	r3, [pc, #284]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240170e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240170e8:	f3c3 0308 	ubfx	r3, r3, #0, #9
240170ec:	ee07 3a90 	vmov	s15, r3
240170f0:	eef8 6a67 	vcvt.f32.u32	s13, s15
240170f4:	ed97 6a03 	vldr	s12, [r7, #12]
240170f8:	eddf 5a44 	vldr	s11, [pc, #272]	; 2401720c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
240170fc:	eec6 7a25 	vdiv.f32	s15, s12, s11
24017100:	ee76 7aa7 	vadd.f32	s15, s13, s15
24017104:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24017108:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401710c:	ee67 7a27 	vmul.f32	s15, s14, s15
24017110:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24017114:	e021      	b.n	2401715a <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      default:
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
24017116:	697b      	ldr	r3, [r7, #20]
24017118:	ee07 3a90 	vmov	s15, r3
2401711c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24017120:	eddf 6a3b 	vldr	s13, [pc, #236]	; 24017210 <HAL_RCCEx_GetPLL1ClockFreq+0x298>
24017124:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24017128:	4b36      	ldr	r3, [pc, #216]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
2401712a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401712c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24017130:	ee07 3a90 	vmov	s15, r3
24017134:	eef8 6a67 	vcvt.f32.u32	s13, s15
24017138:	ed97 6a03 	vldr	s12, [r7, #12]
2401713c:	eddf 5a33 	vldr	s11, [pc, #204]	; 2401720c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
24017140:	eec6 7a25 	vdiv.f32	s15, s12, s11
24017144:	ee76 7aa7 	vadd.f32	s15, s13, s15
24017148:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401714c:	ee77 7aa6 	vadd.f32	s15, s15, s13
24017150:	ee67 7a27 	vmul.f32	s15, s14, s15
24017154:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24017158:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9)  + (float_t)1)) ;
2401715a:	4b2a      	ldr	r3, [pc, #168]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
2401715c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401715e:	0a5b      	lsrs	r3, r3, #9
24017160:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24017164:	ee07 3a90 	vmov	s15, r3
24017168:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401716c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24017170:	ee37 7a87 	vadd.f32	s14, s15, s14
24017174:	edd7 6a07 	vldr	s13, [r7, #28]
24017178:	eec6 7a87 	vdiv.f32	s15, s13, s14
2401717c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24017180:	ee17 2a90 	vmov	r2, s15
24017184:	687b      	ldr	r3, [r7, #4]
24017186:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> 16) + (float_t)1)) ;
24017188:	4b1e      	ldr	r3, [pc, #120]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
2401718a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401718c:	0c1b      	lsrs	r3, r3, #16
2401718e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24017192:	ee07 3a90 	vmov	s15, r3
24017196:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401719a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2401719e:	ee37 7a87 	vadd.f32	s14, s15, s14
240171a2:	edd7 6a07 	vldr	s13, [r7, #28]
240171a6:	eec6 7a87 	vdiv.f32	s15, s13, s14
240171aa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
240171ae:	ee17 2a90 	vmov	r2, s15
240171b2:	687b      	ldr	r3, [r7, #4]
240171b4:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> 24) + (float_t)1)) ;
240171b6:	4b13      	ldr	r3, [pc, #76]	; (24017204 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240171b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240171ba:	0e1b      	lsrs	r3, r3, #24
240171bc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240171c0:	ee07 3a90 	vmov	s15, r3
240171c4:	eef8 7a67 	vcvt.f32.u32	s15, s15
240171c8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
240171cc:	ee37 7a87 	vadd.f32	s14, s15, s14
240171d0:	edd7 6a07 	vldr	s13, [r7, #28]
240171d4:	eec6 7a87 	vdiv.f32	s15, s13, s14
240171d8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
240171dc:	ee17 2a90 	vmov	r2, s15
240171e0:	687b      	ldr	r3, [r7, #4]
240171e2:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
240171e4:	e008      	b.n	240171f8 <HAL_RCCEx_GetPLL1ClockFreq+0x280>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
240171e6:	687b      	ldr	r3, [r7, #4]
240171e8:	2200      	movs	r2, #0
240171ea:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
240171ec:	687b      	ldr	r3, [r7, #4]
240171ee:	2200      	movs	r2, #0
240171f0:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
240171f2:	687b      	ldr	r3, [r7, #4]
240171f4:	2200      	movs	r2, #0
240171f6:	609a      	str	r2, [r3, #8]
}
240171f8:	bf00      	nop
240171fa:	3724      	adds	r7, #36	; 0x24
240171fc:	46bd      	mov	sp, r7
240171fe:	f85d 7b04 	ldr.w	r7, [sp], #4
24017202:	4770      	bx	lr
24017204:	58024400 	.word	0x58024400
24017208:	03d09000 	.word	0x03d09000
2401720c:	46000000 	.word	0x46000000
24017210:	4c742400 	.word	0x4c742400
24017214:	4a742400 	.word	0x4a742400
24017218:	4bbebc20 	.word	0x4bbebc20

2401721c <HAL_RCCEx_GetD1SysClockFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System current Core Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCCEx_GetD1SysClockFreq(void)
{
2401721c:	b580      	push	{r7, lr}
2401721e:	b082      	sub	sp, #8
24017220:	af00      	add	r7, sp, #0
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
24017222:	f7fc ff97 	bl	24014154 <HAL_RCC_GetSysClockFreq>
24017226:	4602      	mov	r2, r0
24017228:	4b10      	ldr	r3, [pc, #64]	; (2401726c <HAL_RCCEx_GetD1SysClockFreq+0x50>)
2401722a:	699b      	ldr	r3, [r3, #24]
2401722c:	0a1b      	lsrs	r3, r3, #8
2401722e:	f003 030f 	and.w	r3, r3, #15
24017232:	490f      	ldr	r1, [pc, #60]	; (24017270 <HAL_RCCEx_GetD1SysClockFreq+0x54>)
24017234:	5ccb      	ldrb	r3, [r1, r3]
24017236:	f003 031f 	and.w	r3, r3, #31
2401723a:	fa22 f303 	lsr.w	r3, r2, r3
2401723e:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24017240:	4b0a      	ldr	r3, [pc, #40]	; (2401726c <HAL_RCCEx_GetD1SysClockFreq+0x50>)
24017242:	699b      	ldr	r3, [r3, #24]
24017244:	f003 030f 	and.w	r3, r3, #15
24017248:	4a09      	ldr	r2, [pc, #36]	; (24017270 <HAL_RCCEx_GetD1SysClockFreq+0x54>)
2401724a:	5cd3      	ldrb	r3, [r2, r3]
2401724c:	f003 031f 	and.w	r3, r3, #31
24017250:	687a      	ldr	r2, [r7, #4]
24017252:	fa22 f303 	lsr.w	r3, r2, r3
24017256:	4a07      	ldr	r2, [pc, #28]	; (24017274 <HAL_RCCEx_GetD1SysClockFreq+0x58>)
24017258:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
2401725a:	4a07      	ldr	r2, [pc, #28]	; (24017278 <HAL_RCCEx_GetD1SysClockFreq+0x5c>)
2401725c:	687b      	ldr	r3, [r7, #4]
2401725e:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return common_system_clock;
24017260:	687b      	ldr	r3, [r7, #4]
}
24017262:	4618      	mov	r0, r3
24017264:	3708      	adds	r7, #8
24017266:	46bd      	mov	sp, r7
24017268:	bd80      	pop	{r7, pc}
2401726a:	bf00      	nop
2401726c:	58024400 	.word	0x58024400
24017270:	24020f94 	.word	0x24020f94
24017274:	240004b4 	.word	0x240004b4
24017278:	240004b0 	.word	0x240004b0

2401727c <HAL_RCCEx_EnableLSECSS>:
  *         with HAL_RCC_OscConfig() and the LSE oscillator clock is to be selected as RTC
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
2401727c:	b480      	push	{r7}
2401727e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
24017280:	4b05      	ldr	r3, [pc, #20]	; (24017298 <HAL_RCCEx_EnableLSECSS+0x1c>)
24017282:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24017284:	4a04      	ldr	r2, [pc, #16]	; (24017298 <HAL_RCCEx_EnableLSECSS+0x1c>)
24017286:	f043 0320 	orr.w	r3, r3, #32
2401728a:	6713      	str	r3, [r2, #112]	; 0x70
}
2401728c:	bf00      	nop
2401728e:	46bd      	mov	sp, r7
24017290:	f85d 7b04 	ldr.w	r7, [sp], #4
24017294:	4770      	bx	lr
24017296:	bf00      	nop
24017298:	58024400 	.word	0x58024400

2401729c <HAL_RCCEx_DisableLSECSS>:
  * @brief  Disables the LSE Clock Security System.
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
2401729c:	b480      	push	{r7}
2401729e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
240172a0:	4b08      	ldr	r3, [pc, #32]	; (240172c4 <HAL_RCCEx_DisableLSECSS+0x28>)
240172a2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240172a4:	4a07      	ldr	r2, [pc, #28]	; (240172c4 <HAL_RCCEx_DisableLSECSS+0x28>)
240172a6:	f023 0320 	bic.w	r3, r3, #32
240172aa:	6713      	str	r3, [r2, #112]	; 0x70
  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
240172ac:	4b05      	ldr	r3, [pc, #20]	; (240172c4 <HAL_RCCEx_DisableLSECSS+0x28>)
240172ae:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240172b0:	4a04      	ldr	r2, [pc, #16]	; (240172c4 <HAL_RCCEx_DisableLSECSS+0x28>)
240172b2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
240172b6:	6613      	str	r3, [r2, #96]	; 0x60
}
240172b8:	bf00      	nop
240172ba:	46bd      	mov	sp, r7
240172bc:	f85d 7b04 	ldr.w	r7, [sp], #4
240172c0:	4770      	bx	lr
240172c2:	bf00      	nop
240172c4:	58024400 	.word	0x58024400

240172c8 <HAL_RCCEx_EnableLSECSS_IT>:
  * @brief  Enable the LSE Clock Security System Interrupt & corresponding EXTI line.
  * @note   LSE Clock Security System Interrupt is mapped on EXTI line 18
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
240172c8:	b480      	push	{r7}
240172ca:	af00      	add	r7, sp, #0
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
240172cc:	4b11      	ldr	r3, [pc, #68]	; (24017314 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
240172ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240172d0:	4a10      	ldr	r2, [pc, #64]	; (24017314 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
240172d2:	f043 0320 	orr.w	r3, r3, #32
240172d6:	6713      	str	r3, [r2, #112]	; 0x70

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
240172d8:	4b0e      	ldr	r3, [pc, #56]	; (24017314 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
240172da:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240172dc:	4a0d      	ldr	r2, [pc, #52]	; (24017314 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
240172de:	f443 7300 	orr.w	r3, r3, #512	; 0x200
240172e2:	6613      	str	r3, [r2, #96]	; 0x60

  /* Enable IT on EXTI Line 18 */
#if defined(DUAL_CORE) && defined(CORE_CM4)
  __HAL_RCC_C2_LSECSS_EXTI_ENABLE_IT();
#else
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
240172e4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240172e8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
240172ec:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240172f0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
240172f4:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* DUAL_CORE && CORE_CM4 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
240172f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240172fc:	681b      	ldr	r3, [r3, #0]
240172fe:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24017302:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24017306:	6013      	str	r3, [r2, #0]
}
24017308:	bf00      	nop
2401730a:	46bd      	mov	sp, r7
2401730c:	f85d 7b04 	ldr.w	r7, [sp], #4
24017310:	4770      	bx	lr
24017312:	bf00      	nop
24017314:	58024400 	.word	0x58024400

24017318 <HAL_RCCEx_WakeUpStopCLKConfig>:
  * @note   This function shall not be called after the Clock Security System on HSE has been
  *         enabled.
  * @retval None
  */
void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
{
24017318:	b480      	push	{r7}
2401731a:	b083      	sub	sp, #12
2401731c:	af00      	add	r7, sp, #0
2401731e:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
24017320:	4b06      	ldr	r3, [pc, #24]	; (2401733c <HAL_RCCEx_WakeUpStopCLKConfig+0x24>)
24017322:	691b      	ldr	r3, [r3, #16]
24017324:	f023 0240 	bic.w	r2, r3, #64	; 0x40
24017328:	4904      	ldr	r1, [pc, #16]	; (2401733c <HAL_RCCEx_WakeUpStopCLKConfig+0x24>)
2401732a:	687b      	ldr	r3, [r7, #4]
2401732c:	4313      	orrs	r3, r2
2401732e:	610b      	str	r3, [r1, #16]
}
24017330:	bf00      	nop
24017332:	370c      	adds	r7, #12
24017334:	46bd      	mov	sp, r7
24017336:	f85d 7b04 	ldr.w	r7, [sp], #4
2401733a:	4770      	bx	lr
2401733c:	58024400 	.word	0x58024400

24017340 <HAL_RCCEx_KerWakeUpStopCLKConfig>:
  *            @arg RCC_STOP_KERWAKEUPCLOCK_CSI: CSI oscillator selection
  *            @arg RCC_STOP_KERWAKEUPCLOCK_HSI: HSI oscillator selection
  * @retval None
  */
void HAL_RCCEx_KerWakeUpStopCLKConfig(uint32_t WakeUpClk)
{
24017340:	b480      	push	{r7}
24017342:	b083      	sub	sp, #12
24017344:	af00      	add	r7, sp, #0
24017346:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_KERWAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_KERWAKEUPSTOP_CLK_CONFIG(WakeUpClk);
24017348:	4b06      	ldr	r3, [pc, #24]	; (24017364 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x24>)
2401734a:	691b      	ldr	r3, [r3, #16]
2401734c:	f023 0280 	bic.w	r2, r3, #128	; 0x80
24017350:	4904      	ldr	r1, [pc, #16]	; (24017364 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x24>)
24017352:	687b      	ldr	r3, [r7, #4]
24017354:	4313      	orrs	r3, r2
24017356:	610b      	str	r3, [r1, #16]
}
24017358:	bf00      	nop
2401735a:	370c      	adds	r7, #12
2401735c:	46bd      	mov	sp, r7
2401735e:	f85d 7b04 	ldr.w	r7, [sp], #4
24017362:	4770      	bx	lr
24017364:	58024400 	.word	0x58024400

24017368 <HAL_RCCEx_WWDGxSysResetConfig>:
  * @note   This bit can be set by software but is cleared by hardware during a system reset
  *
  * @retval None
  */
void HAL_RCCEx_WWDGxSysResetConfig(uint32_t RCC_WWDGx)
{
24017368:	b480      	push	{r7}
2401736a:	b083      	sub	sp, #12
2401736c:	af00      	add	r7, sp, #0
2401736e:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_SCOPE_WWDG(RCC_WWDGx));
  SET_BIT(RCC->GCR, RCC_WWDGx) ;
24017370:	4b06      	ldr	r3, [pc, #24]	; (2401738c <HAL_RCCEx_WWDGxSysResetConfig+0x24>)
24017372:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
24017376:	4905      	ldr	r1, [pc, #20]	; (2401738c <HAL_RCCEx_WWDGxSysResetConfig+0x24>)
24017378:	687b      	ldr	r3, [r7, #4]
2401737a:	4313      	orrs	r3, r2
2401737c:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
}
24017380:	bf00      	nop
24017382:	370c      	adds	r7, #12
24017384:	46bd      	mov	sp, r7
24017386:	f85d 7b04 	ldr.w	r7, [sp], #4
2401738a:	4770      	bx	lr
2401738c:	58024400 	.word	0x58024400

24017390 <HAL_RCCEx_CRSConfig>:
  * @brief  Start automatic synchronization for polling mode
  * @param  pInit Pointer on RCC_CRSInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
{
24017390:	b580      	push	{r7, lr}
24017392:	b084      	sub	sp, #16
24017394:	af00      	add	r7, sp, #0
24017396:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
24017398:	4b26      	ldr	r3, [pc, #152]	; (24017434 <HAL_RCCEx_CRSConfig+0xa4>)
2401739a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
2401739e:	4a25      	ldr	r2, [pc, #148]	; (24017434 <HAL_RCCEx_CRSConfig+0xa4>)
240173a0:	f043 0302 	orr.w	r3, r3, #2
240173a4:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  __HAL_RCC_CRS_RELEASE_RESET();
240173a8:	4b22      	ldr	r3, [pc, #136]	; (24017434 <HAL_RCCEx_CRSConfig+0xa4>)
240173aa:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
240173ae:	4a21      	ldr	r2, [pc, #132]	; (24017434 <HAL_RCCEx_CRSConfig+0xa4>)
240173b0:	f023 0302 	bic.w	r3, r3, #2
240173b4:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

  /* Set the SYNCDIV[2:0] bits according to Pre-scaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  if ((HAL_GetREVID() <= REV_ID_Y) && (pInit->Source == RCC_CRS_SYNC_SOURCE_USB2))
240173b8:	f7ea feca 	bl	24002150 <HAL_GetREVID>
240173bc:	4603      	mov	r3, r0
240173be:	f241 0203 	movw	r2, #4099	; 0x1003
240173c2:	4293      	cmp	r3, r2
240173c4:	d80b      	bhi.n	240173de <HAL_RCCEx_CRSConfig+0x4e>
240173c6:	687b      	ldr	r3, [r7, #4]
240173c8:	685b      	ldr	r3, [r3, #4]
240173ca:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
240173ce:	d106      	bne.n	240173de <HAL_RCCEx_CRSConfig+0x4e>
  {
    /* Use Rev.Y value of USB2 */
    value = (pInit->Prescaler | RCC_CRS_SYNC_SOURCE_PIN | pInit->Polarity);
240173d0:	687b      	ldr	r3, [r7, #4]
240173d2:	681a      	ldr	r2, [r3, #0]
240173d4:	687b      	ldr	r3, [r7, #4]
240173d6:	689b      	ldr	r3, [r3, #8]
240173d8:	4313      	orrs	r3, r2
240173da:	60fb      	str	r3, [r7, #12]
240173dc:	e008      	b.n	240173f0 <HAL_RCCEx_CRSConfig+0x60>
  }
  else
  {
    value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
240173de:	687b      	ldr	r3, [r7, #4]
240173e0:	681a      	ldr	r2, [r3, #0]
240173e2:	687b      	ldr	r3, [r7, #4]
240173e4:	685b      	ldr	r3, [r3, #4]
240173e6:	431a      	orrs	r2, r3
240173e8:	687b      	ldr	r3, [r7, #4]
240173ea:	689b      	ldr	r3, [r3, #8]
240173ec:	4313      	orrs	r3, r2
240173ee:	60fb      	str	r3, [r7, #12]
  }
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
240173f0:	687b      	ldr	r3, [r7, #4]
240173f2:	68db      	ldr	r3, [r3, #12]
240173f4:	68fa      	ldr	r2, [r7, #12]
240173f6:	4313      	orrs	r3, r2
240173f8:	60fb      	str	r3, [r7, #12]
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
240173fa:	687b      	ldr	r3, [r7, #4]
240173fc:	691b      	ldr	r3, [r3, #16]
240173fe:	041b      	lsls	r3, r3, #16
24017400:	68fa      	ldr	r2, [r7, #12]
24017402:	4313      	orrs	r3, r2
24017404:	60fb      	str	r3, [r7, #12]
  WRITE_REG(CRS->CFGR, value);
24017406:	4a0c      	ldr	r2, [pc, #48]	; (24017438 <HAL_RCCEx_CRSConfig+0xa8>)
24017408:	68fb      	ldr	r3, [r7, #12]
2401740a:	6053      	str	r3, [r2, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
2401740c:	4b0a      	ldr	r3, [pc, #40]	; (24017438 <HAL_RCCEx_CRSConfig+0xa8>)
2401740e:	681b      	ldr	r3, [r3, #0]
24017410:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
24017414:	687b      	ldr	r3, [r7, #4]
24017416:	695b      	ldr	r3, [r3, #20]
24017418:	021b      	lsls	r3, r3, #8
2401741a:	4907      	ldr	r1, [pc, #28]	; (24017438 <HAL_RCCEx_CRSConfig+0xa8>)
2401741c:	4313      	orrs	r3, r2
2401741e:	600b      	str	r3, [r1, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
24017420:	4b05      	ldr	r3, [pc, #20]	; (24017438 <HAL_RCCEx_CRSConfig+0xa8>)
24017422:	681b      	ldr	r3, [r3, #0]
24017424:	4a04      	ldr	r2, [pc, #16]	; (24017438 <HAL_RCCEx_CRSConfig+0xa8>)
24017426:	f043 0360 	orr.w	r3, r3, #96	; 0x60
2401742a:	6013      	str	r3, [r2, #0]
}
2401742c:	bf00      	nop
2401742e:	3710      	adds	r7, #16
24017430:	46bd      	mov	sp, r7
24017432:	bd80      	pop	{r7, pc}
24017434:	58024400 	.word	0x58024400
24017438:	40008400 	.word	0x40008400

2401743c <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
/**
  * @brief  Generate the software synchronization event
  * @retval None
  */
void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
{
2401743c:	b480      	push	{r7}
2401743e:	af00      	add	r7, sp, #0
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
24017440:	4b05      	ldr	r3, [pc, #20]	; (24017458 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
24017442:	681b      	ldr	r3, [r3, #0]
24017444:	4a04      	ldr	r2, [pc, #16]	; (24017458 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
24017446:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2401744a:	6013      	str	r3, [r2, #0]
}
2401744c:	bf00      	nop
2401744e:	46bd      	mov	sp, r7
24017450:	f85d 7b04 	ldr.w	r7, [sp], #4
24017454:	4770      	bx	lr
24017456:	bf00      	nop
24017458:	40008400 	.word	0x40008400

2401745c <HAL_RCCEx_CRSGetSynchronizationInfo>:
  * @brief  Return synchronization info
  * @param  pSynchroInfo Pointer on RCC_CRSSynchroInfoTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
{
2401745c:	b480      	push	{r7}
2401745e:	b083      	sub	sp, #12
24017460:	af00      	add	r7, sp, #0
24017462:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(pSynchroInfo != (void *)NULL);

  /* Get the reload value */
  pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
24017464:	4b0e      	ldr	r3, [pc, #56]	; (240174a0 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
24017466:	685b      	ldr	r3, [r3, #4]
24017468:	b29a      	uxth	r2, r3
2401746a:	687b      	ldr	r3, [r7, #4]
2401746c:	601a      	str	r2, [r3, #0]

  /* Get HSI48 oscillator smooth trimming */
  pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
2401746e:	4b0c      	ldr	r3, [pc, #48]	; (240174a0 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
24017470:	681b      	ldr	r3, [r3, #0]
24017472:	0a1b      	lsrs	r3, r3, #8
24017474:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24017478:	687b      	ldr	r3, [r7, #4]
2401747a:	605a      	str	r2, [r3, #4]

  /* Get Frequency error capture */
  pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
2401747c:	4b08      	ldr	r3, [pc, #32]	; (240174a0 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
2401747e:	689b      	ldr	r3, [r3, #8]
24017480:	0c1b      	lsrs	r3, r3, #16
24017482:	b29a      	uxth	r2, r3
24017484:	687b      	ldr	r3, [r7, #4]
24017486:	609a      	str	r2, [r3, #8]

  /* Get Frequency error direction */
  pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
24017488:	4b05      	ldr	r3, [pc, #20]	; (240174a0 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
2401748a:	689b      	ldr	r3, [r3, #8]
2401748c:	f403 4200 	and.w	r2, r3, #32768	; 0x8000
24017490:	687b      	ldr	r3, [r7, #4]
24017492:	60da      	str	r2, [r3, #12]
}
24017494:	bf00      	nop
24017496:	370c      	adds	r7, #12
24017498:	46bd      	mov	sp, r7
2401749a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401749e:	4770      	bx	lr
240174a0:	40008400 	.word	0x40008400

240174a4 <HAL_RCCEx_CRSWaitSynchronization>:
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
240174a4:	b580      	push	{r7, lr}
240174a6:	b084      	sub	sp, #16
240174a8:	af00      	add	r7, sp, #0
240174aa:	6078      	str	r0, [r7, #4]
  uint32_t crsstatus = RCC_CRS_NONE;
240174ac:	2300      	movs	r3, #0
240174ae:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Get time-out */
  tickstart = HAL_GetTick();
240174b0:	f7ea fdb4 	bl	2400201c <HAL_GetTick>
240174b4:	60b8      	str	r0, [r7, #8]

  /* Wait for CRS flag or time-out detection */
  do
  {
    if (Timeout != HAL_MAX_DELAY)
240174b6:	687b      	ldr	r3, [r7, #4]
240174b8:	f1b3 3fff 	cmp.w	r3, #4294967295
240174bc:	d00c      	beq.n	240174d8 <HAL_RCCEx_CRSWaitSynchronization+0x34>
    {
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
240174be:	f7ea fdad 	bl	2400201c <HAL_GetTick>
240174c2:	4602      	mov	r2, r0
240174c4:	68bb      	ldr	r3, [r7, #8]
240174c6:	1ad3      	subs	r3, r2, r3
240174c8:	687a      	ldr	r2, [r7, #4]
240174ca:	429a      	cmp	r2, r3
240174cc:	d302      	bcc.n	240174d4 <HAL_RCCEx_CRSWaitSynchronization+0x30>
240174ce:	687b      	ldr	r3, [r7, #4]
240174d0:	2b00      	cmp	r3, #0
240174d2:	d101      	bne.n	240174d8 <HAL_RCCEx_CRSWaitSynchronization+0x34>
      {
        crsstatus = RCC_CRS_TIMEOUT;
240174d4:	2301      	movs	r3, #1
240174d6:	60fb      	str	r3, [r7, #12]
      }
    }
    /* Check CRS SYNCOK flag  */
    if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
240174d8:	4b2a      	ldr	r3, [pc, #168]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240174da:	689b      	ldr	r3, [r3, #8]
240174dc:	f003 0301 	and.w	r3, r3, #1
240174e0:	2b01      	cmp	r3, #1
240174e2:	d106      	bne.n	240174f2 <HAL_RCCEx_CRSWaitSynchronization+0x4e>
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;
240174e4:	68fb      	ldr	r3, [r7, #12]
240174e6:	f043 0302 	orr.w	r3, r3, #2
240174ea:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
240174ec:	4b25      	ldr	r3, [pc, #148]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240174ee:	2201      	movs	r2, #1
240174f0:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNCWARN flag  */
    if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
240174f2:	4b24      	ldr	r3, [pc, #144]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240174f4:	689b      	ldr	r3, [r3, #8]
240174f6:	f003 0302 	and.w	r3, r3, #2
240174fa:	2b02      	cmp	r3, #2
240174fc:	d106      	bne.n	2401750c <HAL_RCCEx_CRSWaitSynchronization+0x68>
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;
240174fe:	68fb      	ldr	r3, [r7, #12]
24017500:	f043 0304 	orr.w	r3, r3, #4
24017504:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
24017506:	4b1f      	ldr	r3, [pc, #124]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24017508:	2202      	movs	r2, #2
2401750a:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS TRIM overflow flag  */
    if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
2401750c:	4b1d      	ldr	r3, [pc, #116]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401750e:	689b      	ldr	r3, [r3, #8]
24017510:	f403 6380 	and.w	r3, r3, #1024	; 0x400
24017514:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
24017518:	d106      	bne.n	24017528 <HAL_RCCEx_CRSWaitSynchronization+0x84>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;
2401751a:	68fb      	ldr	r3, [r7, #12]
2401751c:	f043 0320 	orr.w	r3, r3, #32
24017520:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
24017522:	4b18      	ldr	r3, [pc, #96]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24017524:	2204      	movs	r2, #4
24017526:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Error flag  */
    if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
24017528:	4b16      	ldr	r3, [pc, #88]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401752a:	689b      	ldr	r3, [r3, #8]
2401752c:	f403 7380 	and.w	r3, r3, #256	; 0x100
24017530:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24017534:	d106      	bne.n	24017544 <HAL_RCCEx_CRSWaitSynchronization+0xa0>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;
24017536:	68fb      	ldr	r3, [r7, #12]
24017538:	f043 0308 	orr.w	r3, r3, #8
2401753c:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
2401753e:	4b11      	ldr	r3, [pc, #68]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24017540:	2204      	movs	r2, #4
24017542:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNC Missed flag  */
    if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
24017544:	4b0f      	ldr	r3, [pc, #60]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24017546:	689b      	ldr	r3, [r3, #8]
24017548:	f403 7300 	and.w	r3, r3, #512	; 0x200
2401754c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24017550:	d106      	bne.n	24017560 <HAL_RCCEx_CRSWaitSynchronization+0xbc>
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;
24017552:	68fb      	ldr	r3, [r7, #12]
24017554:	f043 0310 	orr.w	r3, r3, #16
24017558:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
2401755a:	4b0a      	ldr	r3, [pc, #40]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401755c:	2204      	movs	r2, #4
2401755e:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Expected SYNC flag  */
    if (__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
24017560:	4b08      	ldr	r3, [pc, #32]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24017562:	689b      	ldr	r3, [r3, #8]
24017564:	f003 0308 	and.w	r3, r3, #8
24017568:	2b08      	cmp	r3, #8
2401756a:	d102      	bne.n	24017572 <HAL_RCCEx_CRSWaitSynchronization+0xce>
    {
      /* frequency error counter reached a zero value */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
2401756c:	4b05      	ldr	r3, [pc, #20]	; (24017584 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401756e:	2208      	movs	r2, #8
24017570:	60da      	str	r2, [r3, #12]
    }
  }
  while (RCC_CRS_NONE == crsstatus);
24017572:	68fb      	ldr	r3, [r7, #12]
24017574:	2b00      	cmp	r3, #0
24017576:	d09e      	beq.n	240174b6 <HAL_RCCEx_CRSWaitSynchronization+0x12>

  return crsstatus;
24017578:	68fb      	ldr	r3, [r7, #12]
}
2401757a:	4618      	mov	r0, r3
2401757c:	3710      	adds	r7, #16
2401757e:	46bd      	mov	sp, r7
24017580:	bd80      	pop	{r7, pc}
24017582:	bf00      	nop
24017584:	40008400 	.word	0x40008400

24017588 <HAL_RCCEx_CRS_IRQHandler>:
/**
  * @brief Handle the Clock Recovery System interrupt request.
  * @retval None
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
24017588:	b580      	push	{r7, lr}
2401758a:	b084      	sub	sp, #16
2401758c:	af00      	add	r7, sp, #0
  uint32_t crserror = RCC_CRS_NONE;
2401758e:	2300      	movs	r3, #0
24017590:	60fb      	str	r3, [r7, #12]
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
24017592:	4b33      	ldr	r3, [pc, #204]	; (24017660 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24017594:	689b      	ldr	r3, [r3, #8]
24017596:	60bb      	str	r3, [r7, #8]
  uint32_t itsources = READ_REG(CRS->CR);
24017598:	4b31      	ldr	r3, [pc, #196]	; (24017660 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2401759a:	681b      	ldr	r3, [r3, #0]
2401759c:	607b      	str	r3, [r7, #4]

  /* Check CRS SYNCOK flag  */
  if (((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
2401759e:	68bb      	ldr	r3, [r7, #8]
240175a0:	f003 0301 	and.w	r3, r3, #1
240175a4:	2b00      	cmp	r3, #0
240175a6:	d00a      	beq.n	240175be <HAL_RCCEx_CRS_IRQHandler+0x36>
240175a8:	687b      	ldr	r3, [r7, #4]
240175aa:	f003 0301 	and.w	r3, r3, #1
240175ae:	2b00      	cmp	r3, #0
240175b0:	d005      	beq.n	240175be <HAL_RCCEx_CRS_IRQHandler+0x36>
  {
    /* Clear CRS SYNC event OK flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
240175b2:	4b2b      	ldr	r3, [pc, #172]	; (24017660 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
240175b4:	2201      	movs	r2, #1
240175b6:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncOkCallback();
240175b8:	f000 f854 	bl	24017664 <HAL_RCCEx_CRS_SyncOkCallback>
240175bc:	e04b      	b.n	24017656 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS SYNCWARN flag  */
  else if (((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
240175be:	68bb      	ldr	r3, [r7, #8]
240175c0:	f003 0302 	and.w	r3, r3, #2
240175c4:	2b00      	cmp	r3, #0
240175c6:	d00a      	beq.n	240175de <HAL_RCCEx_CRS_IRQHandler+0x56>
240175c8:	687b      	ldr	r3, [r7, #4]
240175ca:	f003 0302 	and.w	r3, r3, #2
240175ce:	2b00      	cmp	r3, #0
240175d0:	d005      	beq.n	240175de <HAL_RCCEx_CRS_IRQHandler+0x56>
  {
    /* Clear CRS SYNCWARN flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
240175d2:	4b23      	ldr	r3, [pc, #140]	; (24017660 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
240175d4:	2202      	movs	r2, #2
240175d6:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncWarnCallback();
240175d8:	f000 f84b 	bl	24017672 <HAL_RCCEx_CRS_SyncWarnCallback>
240175dc:	e03b      	b.n	24017656 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Expected SYNC flag  */
  else if (((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
240175de:	68bb      	ldr	r3, [r7, #8]
240175e0:	f003 0308 	and.w	r3, r3, #8
240175e4:	2b00      	cmp	r3, #0
240175e6:	d00a      	beq.n	240175fe <HAL_RCCEx_CRS_IRQHandler+0x76>
240175e8:	687b      	ldr	r3, [r7, #4]
240175ea:	f003 0308 	and.w	r3, r3, #8
240175ee:	2b00      	cmp	r3, #0
240175f0:	d005      	beq.n	240175fe <HAL_RCCEx_CRS_IRQHandler+0x76>
  {
    /* frequency error counter reached a zero value */
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
240175f2:	4b1b      	ldr	r3, [pc, #108]	; (24017660 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
240175f4:	2208      	movs	r2, #8
240175f6:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_ExpectedSyncCallback();
240175f8:	f000 f842 	bl	24017680 <HAL_RCCEx_CRS_ExpectedSyncCallback>
240175fc:	e02b      	b.n	24017656 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Error flags  */
  else
  {
    if (((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
240175fe:	68bb      	ldr	r3, [r7, #8]
24017600:	f003 0304 	and.w	r3, r3, #4
24017604:	2b00      	cmp	r3, #0
24017606:	d026      	beq.n	24017656 <HAL_RCCEx_CRS_IRQHandler+0xce>
24017608:	687b      	ldr	r3, [r7, #4]
2401760a:	f003 0304 	and.w	r3, r3, #4
2401760e:	2b00      	cmp	r3, #0
24017610:	d021      	beq.n	24017656 <HAL_RCCEx_CRS_IRQHandler+0xce>
    {
      if ((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
24017612:	68bb      	ldr	r3, [r7, #8]
24017614:	f403 7380 	and.w	r3, r3, #256	; 0x100
24017618:	2b00      	cmp	r3, #0
2401761a:	d003      	beq.n	24017624 <HAL_RCCEx_CRS_IRQHandler+0x9c>
      {
        crserror |= RCC_CRS_SYNCERR;
2401761c:	68fb      	ldr	r3, [r7, #12]
2401761e:	f043 0308 	orr.w	r3, r3, #8
24017622:	60fb      	str	r3, [r7, #12]
      }
      if ((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
24017624:	68bb      	ldr	r3, [r7, #8]
24017626:	f403 7300 	and.w	r3, r3, #512	; 0x200
2401762a:	2b00      	cmp	r3, #0
2401762c:	d003      	beq.n	24017636 <HAL_RCCEx_CRS_IRQHandler+0xae>
      {
        crserror |= RCC_CRS_SYNCMISS;
2401762e:	68fb      	ldr	r3, [r7, #12]
24017630:	f043 0310 	orr.w	r3, r3, #16
24017634:	60fb      	str	r3, [r7, #12]
      }
      if ((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
24017636:	68bb      	ldr	r3, [r7, #8]
24017638:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2401763c:	2b00      	cmp	r3, #0
2401763e:	d003      	beq.n	24017648 <HAL_RCCEx_CRS_IRQHandler+0xc0>
      {
        crserror |= RCC_CRS_TRIMOVF;
24017640:	68fb      	ldr	r3, [r7, #12]
24017642:	f043 0320 	orr.w	r3, r3, #32
24017646:	60fb      	str	r3, [r7, #12]
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
24017648:	4b05      	ldr	r3, [pc, #20]	; (24017660 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2401764a:	2204      	movs	r2, #4
2401764c:	60da      	str	r2, [r3, #12]

      /* user error callback */
      HAL_RCCEx_CRS_ErrorCallback(crserror);
2401764e:	68f8      	ldr	r0, [r7, #12]
24017650:	f000 f81d 	bl	2401768e <HAL_RCCEx_CRS_ErrorCallback>
    }
  }
}
24017654:	e7ff      	b.n	24017656 <HAL_RCCEx_CRS_IRQHandler+0xce>
24017656:	bf00      	nop
24017658:	3710      	adds	r7, #16
2401765a:	46bd      	mov	sp, r7
2401765c:	bd80      	pop	{r7, pc}
2401765e:	bf00      	nop
24017660:	40008400 	.word	0x40008400

24017664 <HAL_RCCEx_CRS_SyncOkCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCOK interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncOkCallback(void)
{
24017664:	b480      	push	{r7}
24017666:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
   */
}
24017668:	bf00      	nop
2401766a:	46bd      	mov	sp, r7
2401766c:	f85d 7b04 	ldr.w	r7, [sp], #4
24017670:	4770      	bx	lr

24017672 <HAL_RCCEx_CRS_SyncWarnCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCWARN interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
{
24017672:	b480      	push	{r7}
24017674:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
   */
}
24017676:	bf00      	nop
24017678:	46bd      	mov	sp, r7
2401767a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401767e:	4770      	bx	lr

24017680 <HAL_RCCEx_CRS_ExpectedSyncCallback>:
/**
  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
{
24017680:	b480      	push	{r7}
24017682:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
   */
}
24017684:	bf00      	nop
24017686:	46bd      	mov	sp, r7
24017688:	f85d 7b04 	ldr.w	r7, [sp], #4
2401768c:	4770      	bx	lr

2401768e <HAL_RCCEx_CRS_ErrorCallback>:
  *           @arg @ref RCC_CRS_SYNCMISS
  *           @arg @ref RCC_CRS_TRIMOVF
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
{
2401768e:	b480      	push	{r7}
24017690:	b083      	sub	sp, #12
24017692:	af00      	add	r7, sp, #0
24017694:	6078      	str	r0, [r7, #4]
  UNUSED(Error);

  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
   */
}
24017696:	bf00      	nop
24017698:	370c      	adds	r7, #12
2401769a:	46bd      	mov	sp, r7
2401769c:	f85d 7b04 	ldr.w	r7, [sp], #4
240176a0:	4770      	bx	lr
	...

240176a4 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
240176a4:	b580      	push	{r7, lr}
240176a6:	b084      	sub	sp, #16
240176a8:	af00      	add	r7, sp, #0
240176aa:	6078      	str	r0, [r7, #4]
240176ac:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
240176ae:	2300      	movs	r3, #0
240176b0:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
240176b2:	4b53      	ldr	r3, [pc, #332]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240176b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240176b6:	f003 0303 	and.w	r3, r3, #3
240176ba:	2b03      	cmp	r3, #3
240176bc:	d101      	bne.n	240176c2 <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
240176be:	2301      	movs	r3, #1
240176c0:	e099      	b.n	240177f6 <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
240176c2:	4b4f      	ldr	r3, [pc, #316]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240176c4:	681b      	ldr	r3, [r3, #0]
240176c6:	4a4e      	ldr	r2, [pc, #312]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240176c8:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
240176cc:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
240176ce:	f7ea fca5 	bl	2400201c <HAL_GetTick>
240176d2:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
240176d4:	e008      	b.n	240176e8 <RCCEx_PLL2_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
240176d6:	f7ea fca1 	bl	2400201c <HAL_GetTick>
240176da:	4602      	mov	r2, r0
240176dc:	68bb      	ldr	r3, [r7, #8]
240176de:	1ad3      	subs	r3, r2, r3
240176e0:	2b02      	cmp	r3, #2
240176e2:	d901      	bls.n	240176e8 <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
240176e4:	2303      	movs	r3, #3
240176e6:	e086      	b.n	240177f6 <RCCEx_PLL2_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
240176e8:	4b45      	ldr	r3, [pc, #276]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240176ea:	681b      	ldr	r3, [r3, #0]
240176ec:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
240176f0:	2b00      	cmp	r3, #0
240176f2:	d1f0      	bne.n	240176d6 <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
240176f4:	4b42      	ldr	r3, [pc, #264]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240176f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240176f8:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
240176fc:	687b      	ldr	r3, [r7, #4]
240176fe:	681b      	ldr	r3, [r3, #0]
24017700:	031b      	lsls	r3, r3, #12
24017702:	493f      	ldr	r1, [pc, #252]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017704:	4313      	orrs	r3, r2
24017706:	628b      	str	r3, [r1, #40]	; 0x28
24017708:	687b      	ldr	r3, [r7, #4]
2401770a:	685b      	ldr	r3, [r3, #4]
2401770c:	3b01      	subs	r3, #1
2401770e:	f3c3 0208 	ubfx	r2, r3, #0, #9
24017712:	687b      	ldr	r3, [r7, #4]
24017714:	689b      	ldr	r3, [r3, #8]
24017716:	3b01      	subs	r3, #1
24017718:	025b      	lsls	r3, r3, #9
2401771a:	b29b      	uxth	r3, r3
2401771c:	431a      	orrs	r2, r3
2401771e:	687b      	ldr	r3, [r7, #4]
24017720:	68db      	ldr	r3, [r3, #12]
24017722:	3b01      	subs	r3, #1
24017724:	041b      	lsls	r3, r3, #16
24017726:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
2401772a:	431a      	orrs	r2, r3
2401772c:	687b      	ldr	r3, [r7, #4]
2401772e:	691b      	ldr	r3, [r3, #16]
24017730:	3b01      	subs	r3, #1
24017732:	061b      	lsls	r3, r3, #24
24017734:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
24017738:	4931      	ldr	r1, [pc, #196]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
2401773a:	4313      	orrs	r3, r2
2401773c:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
2401773e:	4b30      	ldr	r3, [pc, #192]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017740:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24017742:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
24017746:	687b      	ldr	r3, [r7, #4]
24017748:	695b      	ldr	r3, [r3, #20]
2401774a:	492d      	ldr	r1, [pc, #180]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
2401774c:	4313      	orrs	r3, r2
2401774e:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
24017750:	4b2b      	ldr	r3, [pc, #172]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017752:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24017754:	f023 0220 	bic.w	r2, r3, #32
24017758:	687b      	ldr	r3, [r7, #4]
2401775a:	699b      	ldr	r3, [r3, #24]
2401775c:	4928      	ldr	r1, [pc, #160]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
2401775e:	4313      	orrs	r3, r2
24017760:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
24017762:	4b27      	ldr	r3, [pc, #156]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017764:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24017766:	4a26      	ldr	r2, [pc, #152]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017768:	f023 0310 	bic.w	r3, r3, #16
2401776c:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
2401776e:	4b24      	ldr	r3, [pc, #144]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017770:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24017772:	4b24      	ldr	r3, [pc, #144]	; (24017804 <RCCEx_PLL2_Config+0x160>)
24017774:	4013      	ands	r3, r2
24017776:	687a      	ldr	r2, [r7, #4]
24017778:	69d2      	ldr	r2, [r2, #28]
2401777a:	00d2      	lsls	r2, r2, #3
2401777c:	4920      	ldr	r1, [pc, #128]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
2401777e:	4313      	orrs	r3, r2
24017780:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
24017782:	4b1f      	ldr	r3, [pc, #124]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017784:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24017786:	4a1e      	ldr	r2, [pc, #120]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017788:	f043 0310 	orr.w	r3, r3, #16
2401778c:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if (Divider == DIVIDER_P_UPDATE)
2401778e:	683b      	ldr	r3, [r7, #0]
24017790:	2b00      	cmp	r3, #0
24017792:	d106      	bne.n	240177a2 <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
24017794:	4b1a      	ldr	r3, [pc, #104]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
24017796:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24017798:	4a19      	ldr	r2, [pc, #100]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
2401779a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
2401779e:	62d3      	str	r3, [r2, #44]	; 0x2c
240177a0:	e00f      	b.n	240177c2 <RCCEx_PLL2_Config+0x11e>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
240177a2:	683b      	ldr	r3, [r7, #0]
240177a4:	2b01      	cmp	r3, #1
240177a6:	d106      	bne.n	240177b6 <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
240177a8:	4b15      	ldr	r3, [pc, #84]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240177aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240177ac:	4a14      	ldr	r2, [pc, #80]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240177ae:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
240177b2:	62d3      	str	r3, [r2, #44]	; 0x2c
240177b4:	e005      	b.n	240177c2 <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
240177b6:	4b12      	ldr	r3, [pc, #72]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240177b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240177ba:	4a11      	ldr	r2, [pc, #68]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240177bc:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
240177c0:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
240177c2:	4b0f      	ldr	r3, [pc, #60]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240177c4:	681b      	ldr	r3, [r3, #0]
240177c6:	4a0e      	ldr	r2, [pc, #56]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240177c8:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
240177cc:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
240177ce:	f7ea fc25 	bl	2400201c <HAL_GetTick>
240177d2:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
240177d4:	e008      	b.n	240177e8 <RCCEx_PLL2_Config+0x144>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
240177d6:	f7ea fc21 	bl	2400201c <HAL_GetTick>
240177da:	4602      	mov	r2, r0
240177dc:	68bb      	ldr	r3, [r7, #8]
240177de:	1ad3      	subs	r3, r2, r3
240177e0:	2b02      	cmp	r3, #2
240177e2:	d901      	bls.n	240177e8 <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
240177e4:	2303      	movs	r3, #3
240177e6:	e006      	b.n	240177f6 <RCCEx_PLL2_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
240177e8:	4b05      	ldr	r3, [pc, #20]	; (24017800 <RCCEx_PLL2_Config+0x15c>)
240177ea:	681b      	ldr	r3, [r3, #0]
240177ec:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
240177f0:	2b00      	cmp	r3, #0
240177f2:	d0f0      	beq.n	240177d6 <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
240177f4:	7bfb      	ldrb	r3, [r7, #15]
}
240177f6:	4618      	mov	r0, r3
240177f8:	3710      	adds	r7, #16
240177fa:	46bd      	mov	sp, r7
240177fc:	bd80      	pop	{r7, pc}
240177fe:	bf00      	nop
24017800:	58024400 	.word	0x58024400
24017804:	ffff0007 	.word	0xffff0007

24017808 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
24017808:	b580      	push	{r7, lr}
2401780a:	b084      	sub	sp, #16
2401780c:	af00      	add	r7, sp, #0
2401780e:	6078      	str	r0, [r7, #4]
24017810:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
24017812:	2300      	movs	r3, #0
24017814:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
24017816:	4b53      	ldr	r3, [pc, #332]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
24017818:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401781a:	f003 0303 	and.w	r3, r3, #3
2401781e:	2b03      	cmp	r3, #3
24017820:	d101      	bne.n	24017826 <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
24017822:	2301      	movs	r3, #1
24017824:	e099      	b.n	2401795a <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
24017826:	4b4f      	ldr	r3, [pc, #316]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
24017828:	681b      	ldr	r3, [r3, #0]
2401782a:	4a4e      	ldr	r2, [pc, #312]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
2401782c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
24017830:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24017832:	f7ea fbf3 	bl	2400201c <HAL_GetTick>
24017836:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
24017838:	e008      	b.n	2401784c <RCCEx_PLL3_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
2401783a:	f7ea fbef 	bl	2400201c <HAL_GetTick>
2401783e:	4602      	mov	r2, r0
24017840:	68bb      	ldr	r3, [r7, #8]
24017842:	1ad3      	subs	r3, r2, r3
24017844:	2b02      	cmp	r3, #2
24017846:	d901      	bls.n	2401784c <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
24017848:	2303      	movs	r3, #3
2401784a:	e086      	b.n	2401795a <RCCEx_PLL3_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
2401784c:	4b45      	ldr	r3, [pc, #276]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
2401784e:	681b      	ldr	r3, [r3, #0]
24017850:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24017854:	2b00      	cmp	r3, #0
24017856:	d1f0      	bne.n	2401783a <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
24017858:	4b42      	ldr	r3, [pc, #264]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
2401785a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401785c:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
24017860:	687b      	ldr	r3, [r7, #4]
24017862:	681b      	ldr	r3, [r3, #0]
24017864:	051b      	lsls	r3, r3, #20
24017866:	493f      	ldr	r1, [pc, #252]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
24017868:	4313      	orrs	r3, r2
2401786a:	628b      	str	r3, [r1, #40]	; 0x28
2401786c:	687b      	ldr	r3, [r7, #4]
2401786e:	685b      	ldr	r3, [r3, #4]
24017870:	3b01      	subs	r3, #1
24017872:	f3c3 0208 	ubfx	r2, r3, #0, #9
24017876:	687b      	ldr	r3, [r7, #4]
24017878:	689b      	ldr	r3, [r3, #8]
2401787a:	3b01      	subs	r3, #1
2401787c:	025b      	lsls	r3, r3, #9
2401787e:	b29b      	uxth	r3, r3
24017880:	431a      	orrs	r2, r3
24017882:	687b      	ldr	r3, [r7, #4]
24017884:	68db      	ldr	r3, [r3, #12]
24017886:	3b01      	subs	r3, #1
24017888:	041b      	lsls	r3, r3, #16
2401788a:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
2401788e:	431a      	orrs	r2, r3
24017890:	687b      	ldr	r3, [r7, #4]
24017892:	691b      	ldr	r3, [r3, #16]
24017894:	3b01      	subs	r3, #1
24017896:	061b      	lsls	r3, r3, #24
24017898:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
2401789c:	4931      	ldr	r1, [pc, #196]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
2401789e:	4313      	orrs	r3, r2
240178a0:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
240178a2:	4b30      	ldr	r3, [pc, #192]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240178a6:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
240178aa:	687b      	ldr	r3, [r7, #4]
240178ac:	695b      	ldr	r3, [r3, #20]
240178ae:	492d      	ldr	r1, [pc, #180]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178b0:	4313      	orrs	r3, r2
240178b2:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
240178b4:	4b2b      	ldr	r3, [pc, #172]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240178b8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
240178bc:	687b      	ldr	r3, [r7, #4]
240178be:	699b      	ldr	r3, [r3, #24]
240178c0:	4928      	ldr	r1, [pc, #160]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178c2:	4313      	orrs	r3, r2
240178c4:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
240178c6:	4b27      	ldr	r3, [pc, #156]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240178ca:	4a26      	ldr	r2, [pc, #152]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178cc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
240178d0:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
240178d2:	4b24      	ldr	r3, [pc, #144]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178d4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
240178d6:	4b24      	ldr	r3, [pc, #144]	; (24017968 <RCCEx_PLL3_Config+0x160>)
240178d8:	4013      	ands	r3, r2
240178da:	687a      	ldr	r2, [r7, #4]
240178dc:	69d2      	ldr	r2, [r2, #28]
240178de:	00d2      	lsls	r2, r2, #3
240178e0:	4920      	ldr	r1, [pc, #128]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178e2:	4313      	orrs	r3, r2
240178e4:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
240178e6:	4b1f      	ldr	r3, [pc, #124]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240178ea:	4a1e      	ldr	r2, [pc, #120]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178ec:	f443 7380 	orr.w	r3, r3, #256	; 0x100
240178f0:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if (Divider == DIVIDER_P_UPDATE)
240178f2:	683b      	ldr	r3, [r7, #0]
240178f4:	2b00      	cmp	r3, #0
240178f6:	d106      	bne.n	24017906 <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
240178f8:	4b1a      	ldr	r3, [pc, #104]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240178fc:	4a19      	ldr	r2, [pc, #100]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
240178fe:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24017902:	62d3      	str	r3, [r2, #44]	; 0x2c
24017904:	e00f      	b.n	24017926 <RCCEx_PLL3_Config+0x11e>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
24017906:	683b      	ldr	r3, [r7, #0]
24017908:	2b01      	cmp	r3, #1
2401790a:	d106      	bne.n	2401791a <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2401790c:	4b15      	ldr	r3, [pc, #84]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
2401790e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24017910:	4a14      	ldr	r2, [pc, #80]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
24017912:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
24017916:	62d3      	str	r3, [r2, #44]	; 0x2c
24017918:	e005      	b.n	24017926 <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2401791a:	4b12      	ldr	r3, [pc, #72]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
2401791c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401791e:	4a11      	ldr	r2, [pc, #68]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
24017920:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
24017924:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
24017926:	4b0f      	ldr	r3, [pc, #60]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
24017928:	681b      	ldr	r3, [r3, #0]
2401792a:	4a0e      	ldr	r2, [pc, #56]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
2401792c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
24017930:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24017932:	f7ea fb73 	bl	2400201c <HAL_GetTick>
24017936:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
24017938:	e008      	b.n	2401794c <RCCEx_PLL3_Config+0x144>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
2401793a:	f7ea fb6f 	bl	2400201c <HAL_GetTick>
2401793e:	4602      	mov	r2, r0
24017940:	68bb      	ldr	r3, [r7, #8]
24017942:	1ad3      	subs	r3, r2, r3
24017944:	2b02      	cmp	r3, #2
24017946:	d901      	bls.n	2401794c <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
24017948:	2303      	movs	r3, #3
2401794a:	e006      	b.n	2401795a <RCCEx_PLL3_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
2401794c:	4b05      	ldr	r3, [pc, #20]	; (24017964 <RCCEx_PLL3_Config+0x15c>)
2401794e:	681b      	ldr	r3, [r3, #0]
24017950:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24017954:	2b00      	cmp	r3, #0
24017956:	d0f0      	beq.n	2401793a <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
24017958:	7bfb      	ldrb	r3, [r7, #15]
}
2401795a:	4618      	mov	r0, r3
2401795c:	3710      	adds	r7, #16
2401795e:	46bd      	mov	sp, r7
24017960:	bd80      	pop	{r7, pc}
24017962:	bf00      	nop
24017964:	58024400 	.word	0x58024400
24017968:	ffff0007 	.word	0xffff0007

2401796c <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
2401796c:	b580      	push	{r7, lr}
2401796e:	af00      	add	r7, sp, #0
  /* Check RCC LSE CSSF flag  */
  if (__HAL_RCC_GET_IT(RCC_IT_LSECSS))
24017970:	4b07      	ldr	r3, [pc, #28]	; (24017990 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
24017972:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24017974:	f403 7300 	and.w	r3, r3, #512	; 0x200
24017978:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2401797c:	d105      	bne.n	2401798a <HAL_RCCEx_LSECSS_IRQHandler+0x1e>
  {

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
2401797e:	4b04      	ldr	r3, [pc, #16]	; (24017990 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
24017980:	f44f 7200 	mov.w	r2, #512	; 0x200
24017984:	669a      	str	r2, [r3, #104]	; 0x68

    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
24017986:	f000 f805 	bl	24017994 <HAL_RCCEx_LSECSS_Callback>

  }
}
2401798a:	bf00      	nop
2401798c:	bd80      	pop	{r7, pc}
2401798e:	bf00      	nop
24017990:	58024400 	.word	0x58024400

24017994 <HAL_RCCEx_LSECSS_Callback>:
/**
  * @brief  RCCEx LSE Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_LSECSS_Callback(void)
{
24017994:	b480      	push	{r7}
24017996:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
  */
}
24017998:	bf00      	nop
2401799a:	46bd      	mov	sp, r7
2401799c:	f85d 7b04 	ldr.w	r7, [sp], #4
240179a0:	4770      	bx	lr

240179a2 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
240179a2:	b580      	push	{r7, lr}
240179a4:	b082      	sub	sp, #8
240179a6:	af00      	add	r7, sp, #0
240179a8:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
240179aa:	687b      	ldr	r3, [r7, #4]
240179ac:	2b00      	cmp	r3, #0
240179ae:	d101      	bne.n	240179b4 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
240179b0:	2301      	movs	r3, #1
240179b2:	e049      	b.n	24017a48 <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
240179b4:	687b      	ldr	r3, [r7, #4]
240179b6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
240179ba:	b2db      	uxtb	r3, r3
240179bc:	2b00      	cmp	r3, #0
240179be:	d106      	bne.n	240179ce <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
240179c0:	687b      	ldr	r3, [r7, #4]
240179c2:	2200      	movs	r2, #0
240179c4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
240179c8:	6878      	ldr	r0, [r7, #4]
240179ca:	f000 f89d 	bl	24017b08 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
240179ce:	687b      	ldr	r3, [r7, #4]
240179d0:	2202      	movs	r2, #2
240179d2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
240179d6:	687b      	ldr	r3, [r7, #4]
240179d8:	681a      	ldr	r2, [r3, #0]
240179da:	687b      	ldr	r3, [r7, #4]
240179dc:	3304      	adds	r3, #4
240179de:	4619      	mov	r1, r3
240179e0:	4610      	mov	r0, r2
240179e2:	f005 ff9f 	bl	2401d924 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
240179e6:	687b      	ldr	r3, [r7, #4]
240179e8:	2201      	movs	r2, #1
240179ea:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
240179ee:	687b      	ldr	r3, [r7, #4]
240179f0:	2201      	movs	r2, #1
240179f2:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
240179f6:	687b      	ldr	r3, [r7, #4]
240179f8:	2201      	movs	r2, #1
240179fa:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
240179fe:	687b      	ldr	r3, [r7, #4]
24017a00:	2201      	movs	r2, #1
24017a02:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24017a06:	687b      	ldr	r3, [r7, #4]
24017a08:	2201      	movs	r2, #1
24017a0a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24017a0e:	687b      	ldr	r3, [r7, #4]
24017a10:	2201      	movs	r2, #1
24017a12:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24017a16:	687b      	ldr	r3, [r7, #4]
24017a18:	2201      	movs	r2, #1
24017a1a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
24017a1e:	687b      	ldr	r3, [r7, #4]
24017a20:	2201      	movs	r2, #1
24017a22:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24017a26:	687b      	ldr	r3, [r7, #4]
24017a28:	2201      	movs	r2, #1
24017a2a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24017a2e:	687b      	ldr	r3, [r7, #4]
24017a30:	2201      	movs	r2, #1
24017a32:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
24017a36:	687b      	ldr	r3, [r7, #4]
24017a38:	2201      	movs	r2, #1
24017a3a:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
24017a3e:	687b      	ldr	r3, [r7, #4]
24017a40:	2201      	movs	r2, #1
24017a42:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
24017a46:	2300      	movs	r3, #0
}
24017a48:	4618      	mov	r0, r3
24017a4a:	3708      	adds	r7, #8
24017a4c:	46bd      	mov	sp, r7
24017a4e:	bd80      	pop	{r7, pc}

24017a50 <HAL_TIM_Base_DeInit>:
  * @brief  DeInitializes the TIM Base peripheral
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
{
24017a50:	b580      	push	{r7, lr}
24017a52:	b082      	sub	sp, #8
24017a54:	af00      	add	r7, sp, #0
24017a56:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
24017a58:	687b      	ldr	r3, [r7, #4]
24017a5a:	2202      	movs	r2, #2
24017a5c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
24017a60:	687b      	ldr	r3, [r7, #4]
24017a62:	681b      	ldr	r3, [r3, #0]
24017a64:	6a1a      	ldr	r2, [r3, #32]
24017a66:	f241 1311 	movw	r3, #4369	; 0x1111
24017a6a:	4013      	ands	r3, r2
24017a6c:	2b00      	cmp	r3, #0
24017a6e:	d10f      	bne.n	24017a90 <HAL_TIM_Base_DeInit+0x40>
24017a70:	687b      	ldr	r3, [r7, #4]
24017a72:	681b      	ldr	r3, [r3, #0]
24017a74:	6a1a      	ldr	r2, [r3, #32]
24017a76:	f240 4344 	movw	r3, #1092	; 0x444
24017a7a:	4013      	ands	r3, r2
24017a7c:	2b00      	cmp	r3, #0
24017a7e:	d107      	bne.n	24017a90 <HAL_TIM_Base_DeInit+0x40>
24017a80:	687b      	ldr	r3, [r7, #4]
24017a82:	681b      	ldr	r3, [r3, #0]
24017a84:	681a      	ldr	r2, [r3, #0]
24017a86:	687b      	ldr	r3, [r7, #4]
24017a88:	681b      	ldr	r3, [r3, #0]
24017a8a:	f022 0201 	bic.w	r2, r2, #1
24017a8e:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->Base_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Base_MspDeInit(htim);
24017a90:	6878      	ldr	r0, [r7, #4]
24017a92:	f000 f843 	bl	24017b1c <HAL_TIM_Base_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
24017a96:	687b      	ldr	r3, [r7, #4]
24017a98:	2200      	movs	r2, #0
24017a9a:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Change the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
24017a9e:	687b      	ldr	r3, [r7, #4]
24017aa0:	2200      	movs	r2, #0
24017aa2:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24017aa6:	687b      	ldr	r3, [r7, #4]
24017aa8:	2200      	movs	r2, #0
24017aaa:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24017aae:	687b      	ldr	r3, [r7, #4]
24017ab0:	2200      	movs	r2, #0
24017ab2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24017ab6:	687b      	ldr	r3, [r7, #4]
24017ab8:	2200      	movs	r2, #0
24017aba:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24017abe:	687b      	ldr	r3, [r7, #4]
24017ac0:	2200      	movs	r2, #0
24017ac2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24017ac6:	687b      	ldr	r3, [r7, #4]
24017ac8:	2200      	movs	r2, #0
24017aca:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
24017ace:	687b      	ldr	r3, [r7, #4]
24017ad0:	2200      	movs	r2, #0
24017ad2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24017ad6:	687b      	ldr	r3, [r7, #4]
24017ad8:	2200      	movs	r2, #0
24017ada:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24017ade:	687b      	ldr	r3, [r7, #4]
24017ae0:	2200      	movs	r2, #0
24017ae2:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
24017ae6:	687b      	ldr	r3, [r7, #4]
24017ae8:	2200      	movs	r2, #0
24017aea:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
24017aee:	687b      	ldr	r3, [r7, #4]
24017af0:	2200      	movs	r2, #0
24017af2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
24017af6:	687b      	ldr	r3, [r7, #4]
24017af8:	2200      	movs	r2, #0
24017afa:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24017afe:	2300      	movs	r3, #0
}
24017b00:	4618      	mov	r0, r3
24017b02:	3708      	adds	r7, #8
24017b04:	46bd      	mov	sp, r7
24017b06:	bd80      	pop	{r7, pc}

24017b08 <HAL_TIM_Base_MspInit>:
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
24017b08:	b480      	push	{r7}
24017b0a:	b083      	sub	sp, #12
24017b0c:	af00      	add	r7, sp, #0
24017b0e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
24017b10:	bf00      	nop
24017b12:	370c      	adds	r7, #12
24017b14:	46bd      	mov	sp, r7
24017b16:	f85d 7b04 	ldr.w	r7, [sp], #4
24017b1a:	4770      	bx	lr

24017b1c <HAL_TIM_Base_MspDeInit>:
  * @brief  DeInitializes TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */
__weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
{
24017b1c:	b480      	push	{r7}
24017b1e:	b083      	sub	sp, #12
24017b20:	af00      	add	r7, sp, #0
24017b22:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspDeInit could be implemented in the user file
   */
}
24017b24:	bf00      	nop
24017b26:	370c      	adds	r7, #12
24017b28:	46bd      	mov	sp, r7
24017b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
24017b2e:	4770      	bx	lr

24017b30 <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
24017b30:	b480      	push	{r7}
24017b32:	b085      	sub	sp, #20
24017b34:	af00      	add	r7, sp, #0
24017b36:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
24017b38:	687b      	ldr	r3, [r7, #4]
24017b3a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24017b3e:	b2db      	uxtb	r3, r3
24017b40:	2b01      	cmp	r3, #1
24017b42:	d001      	beq.n	24017b48 <HAL_TIM_Base_Start+0x18>
  {
    return HAL_ERROR;
24017b44:	2301      	movs	r3, #1
24017b46:	e04c      	b.n	24017be2 <HAL_TIM_Base_Start+0xb2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
24017b48:	687b      	ldr	r3, [r7, #4]
24017b4a:	2202      	movs	r2, #2
24017b4c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
24017b50:	687b      	ldr	r3, [r7, #4]
24017b52:	681b      	ldr	r3, [r3, #0]
24017b54:	4a26      	ldr	r2, [pc, #152]	; (24017bf0 <HAL_TIM_Base_Start+0xc0>)
24017b56:	4293      	cmp	r3, r2
24017b58:	d022      	beq.n	24017ba0 <HAL_TIM_Base_Start+0x70>
24017b5a:	687b      	ldr	r3, [r7, #4]
24017b5c:	681b      	ldr	r3, [r3, #0]
24017b5e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24017b62:	d01d      	beq.n	24017ba0 <HAL_TIM_Base_Start+0x70>
24017b64:	687b      	ldr	r3, [r7, #4]
24017b66:	681b      	ldr	r3, [r3, #0]
24017b68:	4a22      	ldr	r2, [pc, #136]	; (24017bf4 <HAL_TIM_Base_Start+0xc4>)
24017b6a:	4293      	cmp	r3, r2
24017b6c:	d018      	beq.n	24017ba0 <HAL_TIM_Base_Start+0x70>
24017b6e:	687b      	ldr	r3, [r7, #4]
24017b70:	681b      	ldr	r3, [r3, #0]
24017b72:	4a21      	ldr	r2, [pc, #132]	; (24017bf8 <HAL_TIM_Base_Start+0xc8>)
24017b74:	4293      	cmp	r3, r2
24017b76:	d013      	beq.n	24017ba0 <HAL_TIM_Base_Start+0x70>
24017b78:	687b      	ldr	r3, [r7, #4]
24017b7a:	681b      	ldr	r3, [r3, #0]
24017b7c:	4a1f      	ldr	r2, [pc, #124]	; (24017bfc <HAL_TIM_Base_Start+0xcc>)
24017b7e:	4293      	cmp	r3, r2
24017b80:	d00e      	beq.n	24017ba0 <HAL_TIM_Base_Start+0x70>
24017b82:	687b      	ldr	r3, [r7, #4]
24017b84:	681b      	ldr	r3, [r3, #0]
24017b86:	4a1e      	ldr	r2, [pc, #120]	; (24017c00 <HAL_TIM_Base_Start+0xd0>)
24017b88:	4293      	cmp	r3, r2
24017b8a:	d009      	beq.n	24017ba0 <HAL_TIM_Base_Start+0x70>
24017b8c:	687b      	ldr	r3, [r7, #4]
24017b8e:	681b      	ldr	r3, [r3, #0]
24017b90:	4a1c      	ldr	r2, [pc, #112]	; (24017c04 <HAL_TIM_Base_Start+0xd4>)
24017b92:	4293      	cmp	r3, r2
24017b94:	d004      	beq.n	24017ba0 <HAL_TIM_Base_Start+0x70>
24017b96:	687b      	ldr	r3, [r7, #4]
24017b98:	681b      	ldr	r3, [r3, #0]
24017b9a:	4a1b      	ldr	r2, [pc, #108]	; (24017c08 <HAL_TIM_Base_Start+0xd8>)
24017b9c:	4293      	cmp	r3, r2
24017b9e:	d115      	bne.n	24017bcc <HAL_TIM_Base_Start+0x9c>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
24017ba0:	687b      	ldr	r3, [r7, #4]
24017ba2:	681b      	ldr	r3, [r3, #0]
24017ba4:	689a      	ldr	r2, [r3, #8]
24017ba6:	4b19      	ldr	r3, [pc, #100]	; (24017c0c <HAL_TIM_Base_Start+0xdc>)
24017ba8:	4013      	ands	r3, r2
24017baa:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017bac:	68fb      	ldr	r3, [r7, #12]
24017bae:	2b06      	cmp	r3, #6
24017bb0:	d015      	beq.n	24017bde <HAL_TIM_Base_Start+0xae>
24017bb2:	68fb      	ldr	r3, [r7, #12]
24017bb4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24017bb8:	d011      	beq.n	24017bde <HAL_TIM_Base_Start+0xae>
    {
      __HAL_TIM_ENABLE(htim);
24017bba:	687b      	ldr	r3, [r7, #4]
24017bbc:	681b      	ldr	r3, [r3, #0]
24017bbe:	681a      	ldr	r2, [r3, #0]
24017bc0:	687b      	ldr	r3, [r7, #4]
24017bc2:	681b      	ldr	r3, [r3, #0]
24017bc4:	f042 0201 	orr.w	r2, r2, #1
24017bc8:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017bca:	e008      	b.n	24017bde <HAL_TIM_Base_Start+0xae>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
24017bcc:	687b      	ldr	r3, [r7, #4]
24017bce:	681b      	ldr	r3, [r3, #0]
24017bd0:	681a      	ldr	r2, [r3, #0]
24017bd2:	687b      	ldr	r3, [r7, #4]
24017bd4:	681b      	ldr	r3, [r3, #0]
24017bd6:	f042 0201 	orr.w	r2, r2, #1
24017bda:	601a      	str	r2, [r3, #0]
24017bdc:	e000      	b.n	24017be0 <HAL_TIM_Base_Start+0xb0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017bde:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
24017be0:	2300      	movs	r3, #0
}
24017be2:	4618      	mov	r0, r3
24017be4:	3714      	adds	r7, #20
24017be6:	46bd      	mov	sp, r7
24017be8:	f85d 7b04 	ldr.w	r7, [sp], #4
24017bec:	4770      	bx	lr
24017bee:	bf00      	nop
24017bf0:	40010000 	.word	0x40010000
24017bf4:	40000400 	.word	0x40000400
24017bf8:	40000800 	.word	0x40000800
24017bfc:	40000c00 	.word	0x40000c00
24017c00:	40010400 	.word	0x40010400
24017c04:	40001800 	.word	0x40001800
24017c08:	40014000 	.word	0x40014000
24017c0c:	00010007 	.word	0x00010007

24017c10 <HAL_TIM_Base_Stop>:
  * @brief  Stops the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
{
24017c10:	b480      	push	{r7}
24017c12:	b083      	sub	sp, #12
24017c14:	af00      	add	r7, sp, #0
24017c16:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
24017c18:	687b      	ldr	r3, [r7, #4]
24017c1a:	681b      	ldr	r3, [r3, #0]
24017c1c:	6a1a      	ldr	r2, [r3, #32]
24017c1e:	f241 1311 	movw	r3, #4369	; 0x1111
24017c22:	4013      	ands	r3, r2
24017c24:	2b00      	cmp	r3, #0
24017c26:	d10f      	bne.n	24017c48 <HAL_TIM_Base_Stop+0x38>
24017c28:	687b      	ldr	r3, [r7, #4]
24017c2a:	681b      	ldr	r3, [r3, #0]
24017c2c:	6a1a      	ldr	r2, [r3, #32]
24017c2e:	f240 4344 	movw	r3, #1092	; 0x444
24017c32:	4013      	ands	r3, r2
24017c34:	2b00      	cmp	r3, #0
24017c36:	d107      	bne.n	24017c48 <HAL_TIM_Base_Stop+0x38>
24017c38:	687b      	ldr	r3, [r7, #4]
24017c3a:	681b      	ldr	r3, [r3, #0]
24017c3c:	681a      	ldr	r2, [r3, #0]
24017c3e:	687b      	ldr	r3, [r7, #4]
24017c40:	681b      	ldr	r3, [r3, #0]
24017c42:	f022 0201 	bic.w	r2, r2, #1
24017c46:	601a      	str	r2, [r3, #0]

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_READY;
24017c48:	687b      	ldr	r3, [r7, #4]
24017c4a:	2201      	movs	r2, #1
24017c4c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
24017c50:	2300      	movs	r3, #0
}
24017c52:	4618      	mov	r0, r3
24017c54:	370c      	adds	r7, #12
24017c56:	46bd      	mov	sp, r7
24017c58:	f85d 7b04 	ldr.w	r7, [sp], #4
24017c5c:	4770      	bx	lr
	...

24017c60 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
24017c60:	b480      	push	{r7}
24017c62:	b085      	sub	sp, #20
24017c64:	af00      	add	r7, sp, #0
24017c66:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
24017c68:	687b      	ldr	r3, [r7, #4]
24017c6a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24017c6e:	b2db      	uxtb	r3, r3
24017c70:	2b01      	cmp	r3, #1
24017c72:	d001      	beq.n	24017c78 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
24017c74:	2301      	movs	r3, #1
24017c76:	e054      	b.n	24017d22 <HAL_TIM_Base_Start_IT+0xc2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
24017c78:	687b      	ldr	r3, [r7, #4]
24017c7a:	2202      	movs	r2, #2
24017c7c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
24017c80:	687b      	ldr	r3, [r7, #4]
24017c82:	681b      	ldr	r3, [r3, #0]
24017c84:	68da      	ldr	r2, [r3, #12]
24017c86:	687b      	ldr	r3, [r7, #4]
24017c88:	681b      	ldr	r3, [r3, #0]
24017c8a:	f042 0201 	orr.w	r2, r2, #1
24017c8e:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
24017c90:	687b      	ldr	r3, [r7, #4]
24017c92:	681b      	ldr	r3, [r3, #0]
24017c94:	4a26      	ldr	r2, [pc, #152]	; (24017d30 <HAL_TIM_Base_Start_IT+0xd0>)
24017c96:	4293      	cmp	r3, r2
24017c98:	d022      	beq.n	24017ce0 <HAL_TIM_Base_Start_IT+0x80>
24017c9a:	687b      	ldr	r3, [r7, #4]
24017c9c:	681b      	ldr	r3, [r3, #0]
24017c9e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24017ca2:	d01d      	beq.n	24017ce0 <HAL_TIM_Base_Start_IT+0x80>
24017ca4:	687b      	ldr	r3, [r7, #4]
24017ca6:	681b      	ldr	r3, [r3, #0]
24017ca8:	4a22      	ldr	r2, [pc, #136]	; (24017d34 <HAL_TIM_Base_Start_IT+0xd4>)
24017caa:	4293      	cmp	r3, r2
24017cac:	d018      	beq.n	24017ce0 <HAL_TIM_Base_Start_IT+0x80>
24017cae:	687b      	ldr	r3, [r7, #4]
24017cb0:	681b      	ldr	r3, [r3, #0]
24017cb2:	4a21      	ldr	r2, [pc, #132]	; (24017d38 <HAL_TIM_Base_Start_IT+0xd8>)
24017cb4:	4293      	cmp	r3, r2
24017cb6:	d013      	beq.n	24017ce0 <HAL_TIM_Base_Start_IT+0x80>
24017cb8:	687b      	ldr	r3, [r7, #4]
24017cba:	681b      	ldr	r3, [r3, #0]
24017cbc:	4a1f      	ldr	r2, [pc, #124]	; (24017d3c <HAL_TIM_Base_Start_IT+0xdc>)
24017cbe:	4293      	cmp	r3, r2
24017cc0:	d00e      	beq.n	24017ce0 <HAL_TIM_Base_Start_IT+0x80>
24017cc2:	687b      	ldr	r3, [r7, #4]
24017cc4:	681b      	ldr	r3, [r3, #0]
24017cc6:	4a1e      	ldr	r2, [pc, #120]	; (24017d40 <HAL_TIM_Base_Start_IT+0xe0>)
24017cc8:	4293      	cmp	r3, r2
24017cca:	d009      	beq.n	24017ce0 <HAL_TIM_Base_Start_IT+0x80>
24017ccc:	687b      	ldr	r3, [r7, #4]
24017cce:	681b      	ldr	r3, [r3, #0]
24017cd0:	4a1c      	ldr	r2, [pc, #112]	; (24017d44 <HAL_TIM_Base_Start_IT+0xe4>)
24017cd2:	4293      	cmp	r3, r2
24017cd4:	d004      	beq.n	24017ce0 <HAL_TIM_Base_Start_IT+0x80>
24017cd6:	687b      	ldr	r3, [r7, #4]
24017cd8:	681b      	ldr	r3, [r3, #0]
24017cda:	4a1b      	ldr	r2, [pc, #108]	; (24017d48 <HAL_TIM_Base_Start_IT+0xe8>)
24017cdc:	4293      	cmp	r3, r2
24017cde:	d115      	bne.n	24017d0c <HAL_TIM_Base_Start_IT+0xac>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
24017ce0:	687b      	ldr	r3, [r7, #4]
24017ce2:	681b      	ldr	r3, [r3, #0]
24017ce4:	689a      	ldr	r2, [r3, #8]
24017ce6:	4b19      	ldr	r3, [pc, #100]	; (24017d4c <HAL_TIM_Base_Start_IT+0xec>)
24017ce8:	4013      	ands	r3, r2
24017cea:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017cec:	68fb      	ldr	r3, [r7, #12]
24017cee:	2b06      	cmp	r3, #6
24017cf0:	d015      	beq.n	24017d1e <HAL_TIM_Base_Start_IT+0xbe>
24017cf2:	68fb      	ldr	r3, [r7, #12]
24017cf4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24017cf8:	d011      	beq.n	24017d1e <HAL_TIM_Base_Start_IT+0xbe>
    {
      __HAL_TIM_ENABLE(htim);
24017cfa:	687b      	ldr	r3, [r7, #4]
24017cfc:	681b      	ldr	r3, [r3, #0]
24017cfe:	681a      	ldr	r2, [r3, #0]
24017d00:	687b      	ldr	r3, [r7, #4]
24017d02:	681b      	ldr	r3, [r3, #0]
24017d04:	f042 0201 	orr.w	r2, r2, #1
24017d08:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017d0a:	e008      	b.n	24017d1e <HAL_TIM_Base_Start_IT+0xbe>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
24017d0c:	687b      	ldr	r3, [r7, #4]
24017d0e:	681b      	ldr	r3, [r3, #0]
24017d10:	681a      	ldr	r2, [r3, #0]
24017d12:	687b      	ldr	r3, [r7, #4]
24017d14:	681b      	ldr	r3, [r3, #0]
24017d16:	f042 0201 	orr.w	r2, r2, #1
24017d1a:	601a      	str	r2, [r3, #0]
24017d1c:	e000      	b.n	24017d20 <HAL_TIM_Base_Start_IT+0xc0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017d1e:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
24017d20:	2300      	movs	r3, #0
}
24017d22:	4618      	mov	r0, r3
24017d24:	3714      	adds	r7, #20
24017d26:	46bd      	mov	sp, r7
24017d28:	f85d 7b04 	ldr.w	r7, [sp], #4
24017d2c:	4770      	bx	lr
24017d2e:	bf00      	nop
24017d30:	40010000 	.word	0x40010000
24017d34:	40000400 	.word	0x40000400
24017d38:	40000800 	.word	0x40000800
24017d3c:	40000c00 	.word	0x40000c00
24017d40:	40010400 	.word	0x40010400
24017d44:	40001800 	.word	0x40001800
24017d48:	40014000 	.word	0x40014000
24017d4c:	00010007 	.word	0x00010007

24017d50 <HAL_TIM_Base_Stop_IT>:
  * @brief  Stops the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
{
24017d50:	b480      	push	{r7}
24017d52:	b083      	sub	sp, #12
24017d54:	af00      	add	r7, sp, #0
24017d56:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Disable the TIM Update interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
24017d58:	687b      	ldr	r3, [r7, #4]
24017d5a:	681b      	ldr	r3, [r3, #0]
24017d5c:	68da      	ldr	r2, [r3, #12]
24017d5e:	687b      	ldr	r3, [r7, #4]
24017d60:	681b      	ldr	r3, [r3, #0]
24017d62:	f022 0201 	bic.w	r2, r2, #1
24017d66:	60da      	str	r2, [r3, #12]

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
24017d68:	687b      	ldr	r3, [r7, #4]
24017d6a:	681b      	ldr	r3, [r3, #0]
24017d6c:	6a1a      	ldr	r2, [r3, #32]
24017d6e:	f241 1311 	movw	r3, #4369	; 0x1111
24017d72:	4013      	ands	r3, r2
24017d74:	2b00      	cmp	r3, #0
24017d76:	d10f      	bne.n	24017d98 <HAL_TIM_Base_Stop_IT+0x48>
24017d78:	687b      	ldr	r3, [r7, #4]
24017d7a:	681b      	ldr	r3, [r3, #0]
24017d7c:	6a1a      	ldr	r2, [r3, #32]
24017d7e:	f240 4344 	movw	r3, #1092	; 0x444
24017d82:	4013      	ands	r3, r2
24017d84:	2b00      	cmp	r3, #0
24017d86:	d107      	bne.n	24017d98 <HAL_TIM_Base_Stop_IT+0x48>
24017d88:	687b      	ldr	r3, [r7, #4]
24017d8a:	681b      	ldr	r3, [r3, #0]
24017d8c:	681a      	ldr	r2, [r3, #0]
24017d8e:	687b      	ldr	r3, [r7, #4]
24017d90:	681b      	ldr	r3, [r3, #0]
24017d92:	f022 0201 	bic.w	r2, r2, #1
24017d96:	601a      	str	r2, [r3, #0]

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_READY;
24017d98:	687b      	ldr	r3, [r7, #4]
24017d9a:	2201      	movs	r2, #1
24017d9c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
24017da0:	2300      	movs	r3, #0
}
24017da2:	4618      	mov	r0, r3
24017da4:	370c      	adds	r7, #12
24017da6:	46bd      	mov	sp, r7
24017da8:	f85d 7b04 	ldr.w	r7, [sp], #4
24017dac:	4770      	bx	lr
	...

24017db0 <HAL_TIM_Base_Start_DMA>:
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, const uint32_t *pData, uint16_t Length)
{
24017db0:	b580      	push	{r7, lr}
24017db2:	b086      	sub	sp, #24
24017db4:	af00      	add	r7, sp, #0
24017db6:	60f8      	str	r0, [r7, #12]
24017db8:	60b9      	str	r1, [r7, #8]
24017dba:	4613      	mov	r3, r2
24017dbc:	80fb      	strh	r3, [r7, #6]

  /* Check the parameters */
  assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));

  /* Set the TIM state */
  if (htim->State == HAL_TIM_STATE_BUSY)
24017dbe:	68fb      	ldr	r3, [r7, #12]
24017dc0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24017dc4:	b2db      	uxtb	r3, r3
24017dc6:	2b02      	cmp	r3, #2
24017dc8:	d101      	bne.n	24017dce <HAL_TIM_Base_Start_DMA+0x1e>
  {
    return HAL_BUSY;
24017dca:	2302      	movs	r3, #2
24017dcc:	e080      	b.n	24017ed0 <HAL_TIM_Base_Start_DMA+0x120>
  }
  else if (htim->State == HAL_TIM_STATE_READY)
24017dce:	68fb      	ldr	r3, [r7, #12]
24017dd0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24017dd4:	b2db      	uxtb	r3, r3
24017dd6:	2b01      	cmp	r3, #1
24017dd8:	d125      	bne.n	24017e26 <HAL_TIM_Base_Start_DMA+0x76>
  {
    if ((pData == NULL) || (Length == 0U))
24017dda:	68bb      	ldr	r3, [r7, #8]
24017ddc:	2b00      	cmp	r3, #0
24017dde:	d002      	beq.n	24017de6 <HAL_TIM_Base_Start_DMA+0x36>
24017de0:	88fb      	ldrh	r3, [r7, #6]
24017de2:	2b00      	cmp	r3, #0
24017de4:	d101      	bne.n	24017dea <HAL_TIM_Base_Start_DMA+0x3a>
    {
      return HAL_ERROR;
24017de6:	2301      	movs	r3, #1
24017de8:	e072      	b.n	24017ed0 <HAL_TIM_Base_Start_DMA+0x120>
    }
    else
    {
      htim->State = HAL_TIM_STATE_BUSY;
24017dea:	68fb      	ldr	r3, [r7, #12]
24017dec:	2202      	movs	r2, #2
24017dee:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  {
    return HAL_ERROR;
  }

  /* Set the DMA Period elapsed callbacks */
  htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
24017df2:	68fb      	ldr	r3, [r7, #12]
24017df4:	6a1b      	ldr	r3, [r3, #32]
24017df6:	4a38      	ldr	r2, [pc, #224]	; (24017ed8 <HAL_TIM_Base_Start_DMA+0x128>)
24017df8:	63da      	str	r2, [r3, #60]	; 0x3c
  htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
24017dfa:	68fb      	ldr	r3, [r7, #12]
24017dfc:	6a1b      	ldr	r3, [r3, #32]
24017dfe:	4a37      	ldr	r2, [pc, #220]	; (24017edc <HAL_TIM_Base_Start_DMA+0x12c>)
24017e00:	641a      	str	r2, [r3, #64]	; 0x40

  /* Set the DMA error callback */
  htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
24017e02:	68fb      	ldr	r3, [r7, #12]
24017e04:	6a1b      	ldr	r3, [r3, #32]
24017e06:	4a36      	ldr	r2, [pc, #216]	; (24017ee0 <HAL_TIM_Base_Start_DMA+0x130>)
24017e08:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Enable the DMA stream */
  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR,
24017e0a:	68fb      	ldr	r3, [r7, #12]
24017e0c:	6a18      	ldr	r0, [r3, #32]
24017e0e:	68b9      	ldr	r1, [r7, #8]
24017e10:	68fb      	ldr	r3, [r7, #12]
24017e12:	681b      	ldr	r3, [r3, #0]
24017e14:	332c      	adds	r3, #44	; 0x2c
24017e16:	461a      	mov	r2, r3
24017e18:	88fb      	ldrh	r3, [r7, #6]
24017e1a:	f7eb fe99 	bl	24003b50 <HAL_DMA_Start_IT>
24017e1e:	4603      	mov	r3, r0
24017e20:	2b00      	cmp	r3, #0
24017e22:	d004      	beq.n	24017e2e <HAL_TIM_Base_Start_DMA+0x7e>
24017e24:	e001      	b.n	24017e2a <HAL_TIM_Base_Start_DMA+0x7a>
    return HAL_ERROR;
24017e26:	2301      	movs	r3, #1
24017e28:	e052      	b.n	24017ed0 <HAL_TIM_Base_Start_DMA+0x120>
                       Length) != HAL_OK)
  {
    /* Return error status */
    return HAL_ERROR;
24017e2a:	2301      	movs	r3, #1
24017e2c:	e050      	b.n	24017ed0 <HAL_TIM_Base_Start_DMA+0x120>
  }

  /* Enable the TIM Update DMA request */
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
24017e2e:	68fb      	ldr	r3, [r7, #12]
24017e30:	681b      	ldr	r3, [r3, #0]
24017e32:	68da      	ldr	r2, [r3, #12]
24017e34:	68fb      	ldr	r3, [r7, #12]
24017e36:	681b      	ldr	r3, [r3, #0]
24017e38:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24017e3c:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
24017e3e:	68fb      	ldr	r3, [r7, #12]
24017e40:	681b      	ldr	r3, [r3, #0]
24017e42:	4a28      	ldr	r2, [pc, #160]	; (24017ee4 <HAL_TIM_Base_Start_DMA+0x134>)
24017e44:	4293      	cmp	r3, r2
24017e46:	d022      	beq.n	24017e8e <HAL_TIM_Base_Start_DMA+0xde>
24017e48:	68fb      	ldr	r3, [r7, #12]
24017e4a:	681b      	ldr	r3, [r3, #0]
24017e4c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24017e50:	d01d      	beq.n	24017e8e <HAL_TIM_Base_Start_DMA+0xde>
24017e52:	68fb      	ldr	r3, [r7, #12]
24017e54:	681b      	ldr	r3, [r3, #0]
24017e56:	4a24      	ldr	r2, [pc, #144]	; (24017ee8 <HAL_TIM_Base_Start_DMA+0x138>)
24017e58:	4293      	cmp	r3, r2
24017e5a:	d018      	beq.n	24017e8e <HAL_TIM_Base_Start_DMA+0xde>
24017e5c:	68fb      	ldr	r3, [r7, #12]
24017e5e:	681b      	ldr	r3, [r3, #0]
24017e60:	4a22      	ldr	r2, [pc, #136]	; (24017eec <HAL_TIM_Base_Start_DMA+0x13c>)
24017e62:	4293      	cmp	r3, r2
24017e64:	d013      	beq.n	24017e8e <HAL_TIM_Base_Start_DMA+0xde>
24017e66:	68fb      	ldr	r3, [r7, #12]
24017e68:	681b      	ldr	r3, [r3, #0]
24017e6a:	4a21      	ldr	r2, [pc, #132]	; (24017ef0 <HAL_TIM_Base_Start_DMA+0x140>)
24017e6c:	4293      	cmp	r3, r2
24017e6e:	d00e      	beq.n	24017e8e <HAL_TIM_Base_Start_DMA+0xde>
24017e70:	68fb      	ldr	r3, [r7, #12]
24017e72:	681b      	ldr	r3, [r3, #0]
24017e74:	4a1f      	ldr	r2, [pc, #124]	; (24017ef4 <HAL_TIM_Base_Start_DMA+0x144>)
24017e76:	4293      	cmp	r3, r2
24017e78:	d009      	beq.n	24017e8e <HAL_TIM_Base_Start_DMA+0xde>
24017e7a:	68fb      	ldr	r3, [r7, #12]
24017e7c:	681b      	ldr	r3, [r3, #0]
24017e7e:	4a1e      	ldr	r2, [pc, #120]	; (24017ef8 <HAL_TIM_Base_Start_DMA+0x148>)
24017e80:	4293      	cmp	r3, r2
24017e82:	d004      	beq.n	24017e8e <HAL_TIM_Base_Start_DMA+0xde>
24017e84:	68fb      	ldr	r3, [r7, #12]
24017e86:	681b      	ldr	r3, [r3, #0]
24017e88:	4a1c      	ldr	r2, [pc, #112]	; (24017efc <HAL_TIM_Base_Start_DMA+0x14c>)
24017e8a:	4293      	cmp	r3, r2
24017e8c:	d115      	bne.n	24017eba <HAL_TIM_Base_Start_DMA+0x10a>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
24017e8e:	68fb      	ldr	r3, [r7, #12]
24017e90:	681b      	ldr	r3, [r3, #0]
24017e92:	689a      	ldr	r2, [r3, #8]
24017e94:	4b1a      	ldr	r3, [pc, #104]	; (24017f00 <HAL_TIM_Base_Start_DMA+0x150>)
24017e96:	4013      	ands	r3, r2
24017e98:	617b      	str	r3, [r7, #20]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017e9a:	697b      	ldr	r3, [r7, #20]
24017e9c:	2b06      	cmp	r3, #6
24017e9e:	d015      	beq.n	24017ecc <HAL_TIM_Base_Start_DMA+0x11c>
24017ea0:	697b      	ldr	r3, [r7, #20]
24017ea2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24017ea6:	d011      	beq.n	24017ecc <HAL_TIM_Base_Start_DMA+0x11c>
    {
      __HAL_TIM_ENABLE(htim);
24017ea8:	68fb      	ldr	r3, [r7, #12]
24017eaa:	681b      	ldr	r3, [r3, #0]
24017eac:	681a      	ldr	r2, [r3, #0]
24017eae:	68fb      	ldr	r3, [r7, #12]
24017eb0:	681b      	ldr	r3, [r3, #0]
24017eb2:	f042 0201 	orr.w	r2, r2, #1
24017eb6:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017eb8:	e008      	b.n	24017ecc <HAL_TIM_Base_Start_DMA+0x11c>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
24017eba:	68fb      	ldr	r3, [r7, #12]
24017ebc:	681b      	ldr	r3, [r3, #0]
24017ebe:	681a      	ldr	r2, [r3, #0]
24017ec0:	68fb      	ldr	r3, [r7, #12]
24017ec2:	681b      	ldr	r3, [r3, #0]
24017ec4:	f042 0201 	orr.w	r2, r2, #1
24017ec8:	601a      	str	r2, [r3, #0]
24017eca:	e000      	b.n	24017ece <HAL_TIM_Base_Start_DMA+0x11e>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24017ecc:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
24017ece:	2300      	movs	r3, #0
}
24017ed0:	4618      	mov	r0, r3
24017ed2:	3718      	adds	r7, #24
24017ed4:	46bd      	mov	sp, r7
24017ed6:	bd80      	pop	{r7, pc}
24017ed8:	2401d891 	.word	0x2401d891
24017edc:	2401d8bf 	.word	0x2401d8bf
24017ee0:	2401d5bf 	.word	0x2401d5bf
24017ee4:	40010000 	.word	0x40010000
24017ee8:	40000400 	.word	0x40000400
24017eec:	40000800 	.word	0x40000800
24017ef0:	40000c00 	.word	0x40000c00
24017ef4:	40010400 	.word	0x40010400
24017ef8:	40001800 	.word	0x40001800
24017efc:	40014000 	.word	0x40014000
24017f00:	00010007 	.word	0x00010007

24017f04 <HAL_TIM_Base_Stop_DMA>:
  * @brief  Stops the TIM Base generation in DMA mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
{
24017f04:	b580      	push	{r7, lr}
24017f06:	b082      	sub	sp, #8
24017f08:	af00      	add	r7, sp, #0
24017f0a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));

  /* Disable the TIM Update DMA request */
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
24017f0c:	687b      	ldr	r3, [r7, #4]
24017f0e:	681b      	ldr	r3, [r3, #0]
24017f10:	68da      	ldr	r2, [r3, #12]
24017f12:	687b      	ldr	r3, [r7, #4]
24017f14:	681b      	ldr	r3, [r3, #0]
24017f16:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24017f1a:	60da      	str	r2, [r3, #12]

  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
24017f1c:	687b      	ldr	r3, [r7, #4]
24017f1e:	6a1b      	ldr	r3, [r3, #32]
24017f20:	4618      	mov	r0, r3
24017f22:	f7ec fb9d 	bl	24004660 <HAL_DMA_Abort_IT>

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
24017f26:	687b      	ldr	r3, [r7, #4]
24017f28:	681b      	ldr	r3, [r3, #0]
24017f2a:	6a1a      	ldr	r2, [r3, #32]
24017f2c:	f241 1311 	movw	r3, #4369	; 0x1111
24017f30:	4013      	ands	r3, r2
24017f32:	2b00      	cmp	r3, #0
24017f34:	d10f      	bne.n	24017f56 <HAL_TIM_Base_Stop_DMA+0x52>
24017f36:	687b      	ldr	r3, [r7, #4]
24017f38:	681b      	ldr	r3, [r3, #0]
24017f3a:	6a1a      	ldr	r2, [r3, #32]
24017f3c:	f240 4344 	movw	r3, #1092	; 0x444
24017f40:	4013      	ands	r3, r2
24017f42:	2b00      	cmp	r3, #0
24017f44:	d107      	bne.n	24017f56 <HAL_TIM_Base_Stop_DMA+0x52>
24017f46:	687b      	ldr	r3, [r7, #4]
24017f48:	681b      	ldr	r3, [r3, #0]
24017f4a:	681a      	ldr	r2, [r3, #0]
24017f4c:	687b      	ldr	r3, [r7, #4]
24017f4e:	681b      	ldr	r3, [r3, #0]
24017f50:	f022 0201 	bic.w	r2, r2, #1
24017f54:	601a      	str	r2, [r3, #0]

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_READY;
24017f56:	687b      	ldr	r3, [r7, #4]
24017f58:	2201      	movs	r2, #1
24017f5a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
24017f5e:	2300      	movs	r3, #0
}
24017f60:	4618      	mov	r0, r3
24017f62:	3708      	adds	r7, #8
24017f64:	46bd      	mov	sp, r7
24017f66:	bd80      	pop	{r7, pc}

24017f68 <HAL_TIM_OC_Init>:
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
{
24017f68:	b580      	push	{r7, lr}
24017f6a:	b082      	sub	sp, #8
24017f6c:	af00      	add	r7, sp, #0
24017f6e:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
24017f70:	687b      	ldr	r3, [r7, #4]
24017f72:	2b00      	cmp	r3, #0
24017f74:	d101      	bne.n	24017f7a <HAL_TIM_OC_Init+0x12>
  {
    return HAL_ERROR;
24017f76:	2301      	movs	r3, #1
24017f78:	e049      	b.n	2401800e <HAL_TIM_OC_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
24017f7a:	687b      	ldr	r3, [r7, #4]
24017f7c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24017f80:	b2db      	uxtb	r3, r3
24017f82:	2b00      	cmp	r3, #0
24017f84:	d106      	bne.n	24017f94 <HAL_TIM_OC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
24017f86:	687b      	ldr	r3, [r7, #4]
24017f88:	2200      	movs	r2, #0
24017f8a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->OC_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_OC_MspInit(htim);
24017f8e:	6878      	ldr	r0, [r7, #4]
24017f90:	f000 f89d 	bl	240180ce <HAL_TIM_OC_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
24017f94:	687b      	ldr	r3, [r7, #4]
24017f96:	2202      	movs	r2, #2
24017f98:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the Output Compare */
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
24017f9c:	687b      	ldr	r3, [r7, #4]
24017f9e:	681a      	ldr	r2, [r3, #0]
24017fa0:	687b      	ldr	r3, [r7, #4]
24017fa2:	3304      	adds	r3, #4
24017fa4:	4619      	mov	r1, r3
24017fa6:	4610      	mov	r0, r2
24017fa8:	f005 fcbc 	bl	2401d924 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
24017fac:	687b      	ldr	r3, [r7, #4]
24017fae:	2201      	movs	r2, #1
24017fb0:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
24017fb4:	687b      	ldr	r3, [r7, #4]
24017fb6:	2201      	movs	r2, #1
24017fb8:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24017fbc:	687b      	ldr	r3, [r7, #4]
24017fbe:	2201      	movs	r2, #1
24017fc0:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24017fc4:	687b      	ldr	r3, [r7, #4]
24017fc6:	2201      	movs	r2, #1
24017fc8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24017fcc:	687b      	ldr	r3, [r7, #4]
24017fce:	2201      	movs	r2, #1
24017fd0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24017fd4:	687b      	ldr	r3, [r7, #4]
24017fd6:	2201      	movs	r2, #1
24017fd8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24017fdc:	687b      	ldr	r3, [r7, #4]
24017fde:	2201      	movs	r2, #1
24017fe0:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
24017fe4:	687b      	ldr	r3, [r7, #4]
24017fe6:	2201      	movs	r2, #1
24017fe8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24017fec:	687b      	ldr	r3, [r7, #4]
24017fee:	2201      	movs	r2, #1
24017ff0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24017ff4:	687b      	ldr	r3, [r7, #4]
24017ff6:	2201      	movs	r2, #1
24017ff8:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
24017ffc:	687b      	ldr	r3, [r7, #4]
24017ffe:	2201      	movs	r2, #1
24018000:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
24018004:	687b      	ldr	r3, [r7, #4]
24018006:	2201      	movs	r2, #1
24018008:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
2401800c:	2300      	movs	r3, #0
}
2401800e:	4618      	mov	r0, r3
24018010:	3708      	adds	r7, #8
24018012:	46bd      	mov	sp, r7
24018014:	bd80      	pop	{r7, pc}

24018016 <HAL_TIM_OC_DeInit>:
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
{
24018016:	b580      	push	{r7, lr}
24018018:	b082      	sub	sp, #8
2401801a:	af00      	add	r7, sp, #0
2401801c:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
2401801e:	687b      	ldr	r3, [r7, #4]
24018020:	2202      	movs	r2, #2
24018022:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
24018026:	687b      	ldr	r3, [r7, #4]
24018028:	681b      	ldr	r3, [r3, #0]
2401802a:	6a1a      	ldr	r2, [r3, #32]
2401802c:	f241 1311 	movw	r3, #4369	; 0x1111
24018030:	4013      	ands	r3, r2
24018032:	2b00      	cmp	r3, #0
24018034:	d10f      	bne.n	24018056 <HAL_TIM_OC_DeInit+0x40>
24018036:	687b      	ldr	r3, [r7, #4]
24018038:	681b      	ldr	r3, [r3, #0]
2401803a:	6a1a      	ldr	r2, [r3, #32]
2401803c:	f240 4344 	movw	r3, #1092	; 0x444
24018040:	4013      	ands	r3, r2
24018042:	2b00      	cmp	r3, #0
24018044:	d107      	bne.n	24018056 <HAL_TIM_OC_DeInit+0x40>
24018046:	687b      	ldr	r3, [r7, #4]
24018048:	681b      	ldr	r3, [r3, #0]
2401804a:	681a      	ldr	r2, [r3, #0]
2401804c:	687b      	ldr	r3, [r7, #4]
2401804e:	681b      	ldr	r3, [r3, #0]
24018050:	f022 0201 	bic.w	r2, r2, #1
24018054:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->OC_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_OC_MspDeInit(htim);
24018056:	6878      	ldr	r0, [r7, #4]
24018058:	f000 f843 	bl	240180e2 <HAL_TIM_OC_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
2401805c:	687b      	ldr	r3, [r7, #4]
2401805e:	2200      	movs	r2, #0
24018060:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Change the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
24018064:	687b      	ldr	r3, [r7, #4]
24018066:	2200      	movs	r2, #0
24018068:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401806c:	687b      	ldr	r3, [r7, #4]
2401806e:	2200      	movs	r2, #0
24018070:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24018074:	687b      	ldr	r3, [r7, #4]
24018076:	2200      	movs	r2, #0
24018078:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401807c:	687b      	ldr	r3, [r7, #4]
2401807e:	2200      	movs	r2, #0
24018080:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24018084:	687b      	ldr	r3, [r7, #4]
24018086:	2200      	movs	r2, #0
24018088:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401808c:	687b      	ldr	r3, [r7, #4]
2401808e:	2200      	movs	r2, #0
24018090:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
24018094:	687b      	ldr	r3, [r7, #4]
24018096:	2200      	movs	r2, #0
24018098:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401809c:	687b      	ldr	r3, [r7, #4]
2401809e:	2200      	movs	r2, #0
240180a0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
240180a4:	687b      	ldr	r3, [r7, #4]
240180a6:	2200      	movs	r2, #0
240180a8:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
240180ac:	687b      	ldr	r3, [r7, #4]
240180ae:	2200      	movs	r2, #0
240180b0:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
240180b4:	687b      	ldr	r3, [r7, #4]
240180b6:	2200      	movs	r2, #0
240180b8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
240180bc:	687b      	ldr	r3, [r7, #4]
240180be:	2200      	movs	r2, #0
240180c0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
240180c4:	2300      	movs	r3, #0
}
240180c6:	4618      	mov	r0, r3
240180c8:	3708      	adds	r7, #8
240180ca:	46bd      	mov	sp, r7
240180cc:	bd80      	pop	{r7, pc}

240180ce <HAL_TIM_OC_MspInit>:
  * @brief  Initializes the TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  */
__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
{
240180ce:	b480      	push	{r7}
240180d0:	b083      	sub	sp, #12
240180d2:	af00      	add	r7, sp, #0
240180d4:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspInit could be implemented in the user file
   */
}
240180d6:	bf00      	nop
240180d8:	370c      	adds	r7, #12
240180da:	46bd      	mov	sp, r7
240180dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240180e0:	4770      	bx	lr

240180e2 <HAL_TIM_OC_MspDeInit>:
  * @brief  DeInitializes TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  */
__weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
{
240180e2:	b480      	push	{r7}
240180e4:	b083      	sub	sp, #12
240180e6:	af00      	add	r7, sp, #0
240180e8:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspDeInit could be implemented in the user file
   */
}
240180ea:	bf00      	nop
240180ec:	370c      	adds	r7, #12
240180ee:	46bd      	mov	sp, r7
240180f0:	f85d 7b04 	ldr.w	r7, [sp], #4
240180f4:	4770      	bx	lr
	...

240180f8 <HAL_TIM_OC_Start>:
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
240180f8:	b580      	push	{r7, lr}
240180fa:	b084      	sub	sp, #16
240180fc:	af00      	add	r7, sp, #0
240180fe:	6078      	str	r0, [r7, #4]
24018100:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
24018102:	683b      	ldr	r3, [r7, #0]
24018104:	2b00      	cmp	r3, #0
24018106:	d109      	bne.n	2401811c <HAL_TIM_OC_Start+0x24>
24018108:	687b      	ldr	r3, [r7, #4]
2401810a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401810e:	b2db      	uxtb	r3, r3
24018110:	2b01      	cmp	r3, #1
24018112:	bf14      	ite	ne
24018114:	2301      	movne	r3, #1
24018116:	2300      	moveq	r3, #0
24018118:	b2db      	uxtb	r3, r3
2401811a:	e03c      	b.n	24018196 <HAL_TIM_OC_Start+0x9e>
2401811c:	683b      	ldr	r3, [r7, #0]
2401811e:	2b04      	cmp	r3, #4
24018120:	d109      	bne.n	24018136 <HAL_TIM_OC_Start+0x3e>
24018122:	687b      	ldr	r3, [r7, #4]
24018124:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
24018128:	b2db      	uxtb	r3, r3
2401812a:	2b01      	cmp	r3, #1
2401812c:	bf14      	ite	ne
2401812e:	2301      	movne	r3, #1
24018130:	2300      	moveq	r3, #0
24018132:	b2db      	uxtb	r3, r3
24018134:	e02f      	b.n	24018196 <HAL_TIM_OC_Start+0x9e>
24018136:	683b      	ldr	r3, [r7, #0]
24018138:	2b08      	cmp	r3, #8
2401813a:	d109      	bne.n	24018150 <HAL_TIM_OC_Start+0x58>
2401813c:	687b      	ldr	r3, [r7, #4]
2401813e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24018142:	b2db      	uxtb	r3, r3
24018144:	2b01      	cmp	r3, #1
24018146:	bf14      	ite	ne
24018148:	2301      	movne	r3, #1
2401814a:	2300      	moveq	r3, #0
2401814c:	b2db      	uxtb	r3, r3
2401814e:	e022      	b.n	24018196 <HAL_TIM_OC_Start+0x9e>
24018150:	683b      	ldr	r3, [r7, #0]
24018152:	2b0c      	cmp	r3, #12
24018154:	d109      	bne.n	2401816a <HAL_TIM_OC_Start+0x72>
24018156:	687b      	ldr	r3, [r7, #4]
24018158:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401815c:	b2db      	uxtb	r3, r3
2401815e:	2b01      	cmp	r3, #1
24018160:	bf14      	ite	ne
24018162:	2301      	movne	r3, #1
24018164:	2300      	moveq	r3, #0
24018166:	b2db      	uxtb	r3, r3
24018168:	e015      	b.n	24018196 <HAL_TIM_OC_Start+0x9e>
2401816a:	683b      	ldr	r3, [r7, #0]
2401816c:	2b10      	cmp	r3, #16
2401816e:	d109      	bne.n	24018184 <HAL_TIM_OC_Start+0x8c>
24018170:	687b      	ldr	r3, [r7, #4]
24018172:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
24018176:	b2db      	uxtb	r3, r3
24018178:	2b01      	cmp	r3, #1
2401817a:	bf14      	ite	ne
2401817c:	2301      	movne	r3, #1
2401817e:	2300      	moveq	r3, #0
24018180:	b2db      	uxtb	r3, r3
24018182:	e008      	b.n	24018196 <HAL_TIM_OC_Start+0x9e>
24018184:	687b      	ldr	r3, [r7, #4]
24018186:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
2401818a:	b2db      	uxtb	r3, r3
2401818c:	2b01      	cmp	r3, #1
2401818e:	bf14      	ite	ne
24018190:	2301      	movne	r3, #1
24018192:	2300      	moveq	r3, #0
24018194:	b2db      	uxtb	r3, r3
24018196:	2b00      	cmp	r3, #0
24018198:	d001      	beq.n	2401819e <HAL_TIM_OC_Start+0xa6>
  {
    return HAL_ERROR;
2401819a:	2301      	movs	r3, #1
2401819c:	e0a1      	b.n	240182e2 <HAL_TIM_OC_Start+0x1ea>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401819e:	683b      	ldr	r3, [r7, #0]
240181a0:	2b00      	cmp	r3, #0
240181a2:	d104      	bne.n	240181ae <HAL_TIM_OC_Start+0xb6>
240181a4:	687b      	ldr	r3, [r7, #4]
240181a6:	2202      	movs	r2, #2
240181a8:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
240181ac:	e023      	b.n	240181f6 <HAL_TIM_OC_Start+0xfe>
240181ae:	683b      	ldr	r3, [r7, #0]
240181b0:	2b04      	cmp	r3, #4
240181b2:	d104      	bne.n	240181be <HAL_TIM_OC_Start+0xc6>
240181b4:	687b      	ldr	r3, [r7, #4]
240181b6:	2202      	movs	r2, #2
240181b8:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
240181bc:	e01b      	b.n	240181f6 <HAL_TIM_OC_Start+0xfe>
240181be:	683b      	ldr	r3, [r7, #0]
240181c0:	2b08      	cmp	r3, #8
240181c2:	d104      	bne.n	240181ce <HAL_TIM_OC_Start+0xd6>
240181c4:	687b      	ldr	r3, [r7, #4]
240181c6:	2202      	movs	r2, #2
240181c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240181cc:	e013      	b.n	240181f6 <HAL_TIM_OC_Start+0xfe>
240181ce:	683b      	ldr	r3, [r7, #0]
240181d0:	2b0c      	cmp	r3, #12
240181d2:	d104      	bne.n	240181de <HAL_TIM_OC_Start+0xe6>
240181d4:	687b      	ldr	r3, [r7, #4]
240181d6:	2202      	movs	r2, #2
240181d8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
240181dc:	e00b      	b.n	240181f6 <HAL_TIM_OC_Start+0xfe>
240181de:	683b      	ldr	r3, [r7, #0]
240181e0:	2b10      	cmp	r3, #16
240181e2:	d104      	bne.n	240181ee <HAL_TIM_OC_Start+0xf6>
240181e4:	687b      	ldr	r3, [r7, #4]
240181e6:	2202      	movs	r2, #2
240181e8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
240181ec:	e003      	b.n	240181f6 <HAL_TIM_OC_Start+0xfe>
240181ee:	687b      	ldr	r3, [r7, #4]
240181f0:	2202      	movs	r2, #2
240181f2:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  /* Enable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
240181f6:	687b      	ldr	r3, [r7, #4]
240181f8:	681b      	ldr	r3, [r3, #0]
240181fa:	2201      	movs	r2, #1
240181fc:	6839      	ldr	r1, [r7, #0]
240181fe:	4618      	mov	r0, r3
24018200:	f006 f9b2 	bl	2401e568 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
24018204:	687b      	ldr	r3, [r7, #4]
24018206:	681b      	ldr	r3, [r3, #0]
24018208:	4a38      	ldr	r2, [pc, #224]	; (240182ec <HAL_TIM_OC_Start+0x1f4>)
2401820a:	4293      	cmp	r3, r2
2401820c:	d013      	beq.n	24018236 <HAL_TIM_OC_Start+0x13e>
2401820e:	687b      	ldr	r3, [r7, #4]
24018210:	681b      	ldr	r3, [r3, #0]
24018212:	4a37      	ldr	r2, [pc, #220]	; (240182f0 <HAL_TIM_OC_Start+0x1f8>)
24018214:	4293      	cmp	r3, r2
24018216:	d00e      	beq.n	24018236 <HAL_TIM_OC_Start+0x13e>
24018218:	687b      	ldr	r3, [r7, #4]
2401821a:	681b      	ldr	r3, [r3, #0]
2401821c:	4a35      	ldr	r2, [pc, #212]	; (240182f4 <HAL_TIM_OC_Start+0x1fc>)
2401821e:	4293      	cmp	r3, r2
24018220:	d009      	beq.n	24018236 <HAL_TIM_OC_Start+0x13e>
24018222:	687b      	ldr	r3, [r7, #4]
24018224:	681b      	ldr	r3, [r3, #0]
24018226:	4a34      	ldr	r2, [pc, #208]	; (240182f8 <HAL_TIM_OC_Start+0x200>)
24018228:	4293      	cmp	r3, r2
2401822a:	d004      	beq.n	24018236 <HAL_TIM_OC_Start+0x13e>
2401822c:	687b      	ldr	r3, [r7, #4]
2401822e:	681b      	ldr	r3, [r3, #0]
24018230:	4a32      	ldr	r2, [pc, #200]	; (240182fc <HAL_TIM_OC_Start+0x204>)
24018232:	4293      	cmp	r3, r2
24018234:	d101      	bne.n	2401823a <HAL_TIM_OC_Start+0x142>
24018236:	2301      	movs	r3, #1
24018238:	e000      	b.n	2401823c <HAL_TIM_OC_Start+0x144>
2401823a:	2300      	movs	r3, #0
2401823c:	2b00      	cmp	r3, #0
2401823e:	d007      	beq.n	24018250 <HAL_TIM_OC_Start+0x158>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
24018240:	687b      	ldr	r3, [r7, #4]
24018242:	681b      	ldr	r3, [r3, #0]
24018244:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24018246:	687b      	ldr	r3, [r7, #4]
24018248:	681b      	ldr	r3, [r3, #0]
2401824a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401824e:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
24018250:	687b      	ldr	r3, [r7, #4]
24018252:	681b      	ldr	r3, [r3, #0]
24018254:	4a25      	ldr	r2, [pc, #148]	; (240182ec <HAL_TIM_OC_Start+0x1f4>)
24018256:	4293      	cmp	r3, r2
24018258:	d022      	beq.n	240182a0 <HAL_TIM_OC_Start+0x1a8>
2401825a:	687b      	ldr	r3, [r7, #4]
2401825c:	681b      	ldr	r3, [r3, #0]
2401825e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24018262:	d01d      	beq.n	240182a0 <HAL_TIM_OC_Start+0x1a8>
24018264:	687b      	ldr	r3, [r7, #4]
24018266:	681b      	ldr	r3, [r3, #0]
24018268:	4a25      	ldr	r2, [pc, #148]	; (24018300 <HAL_TIM_OC_Start+0x208>)
2401826a:	4293      	cmp	r3, r2
2401826c:	d018      	beq.n	240182a0 <HAL_TIM_OC_Start+0x1a8>
2401826e:	687b      	ldr	r3, [r7, #4]
24018270:	681b      	ldr	r3, [r3, #0]
24018272:	4a24      	ldr	r2, [pc, #144]	; (24018304 <HAL_TIM_OC_Start+0x20c>)
24018274:	4293      	cmp	r3, r2
24018276:	d013      	beq.n	240182a0 <HAL_TIM_OC_Start+0x1a8>
24018278:	687b      	ldr	r3, [r7, #4]
2401827a:	681b      	ldr	r3, [r3, #0]
2401827c:	4a22      	ldr	r2, [pc, #136]	; (24018308 <HAL_TIM_OC_Start+0x210>)
2401827e:	4293      	cmp	r3, r2
24018280:	d00e      	beq.n	240182a0 <HAL_TIM_OC_Start+0x1a8>
24018282:	687b      	ldr	r3, [r7, #4]
24018284:	681b      	ldr	r3, [r3, #0]
24018286:	4a1a      	ldr	r2, [pc, #104]	; (240182f0 <HAL_TIM_OC_Start+0x1f8>)
24018288:	4293      	cmp	r3, r2
2401828a:	d009      	beq.n	240182a0 <HAL_TIM_OC_Start+0x1a8>
2401828c:	687b      	ldr	r3, [r7, #4]
2401828e:	681b      	ldr	r3, [r3, #0]
24018290:	4a1e      	ldr	r2, [pc, #120]	; (2401830c <HAL_TIM_OC_Start+0x214>)
24018292:	4293      	cmp	r3, r2
24018294:	d004      	beq.n	240182a0 <HAL_TIM_OC_Start+0x1a8>
24018296:	687b      	ldr	r3, [r7, #4]
24018298:	681b      	ldr	r3, [r3, #0]
2401829a:	4a16      	ldr	r2, [pc, #88]	; (240182f4 <HAL_TIM_OC_Start+0x1fc>)
2401829c:	4293      	cmp	r3, r2
2401829e:	d115      	bne.n	240182cc <HAL_TIM_OC_Start+0x1d4>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
240182a0:	687b      	ldr	r3, [r7, #4]
240182a2:	681b      	ldr	r3, [r3, #0]
240182a4:	689a      	ldr	r2, [r3, #8]
240182a6:	4b1a      	ldr	r3, [pc, #104]	; (24018310 <HAL_TIM_OC_Start+0x218>)
240182a8:	4013      	ands	r3, r2
240182aa:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
240182ac:	68fb      	ldr	r3, [r7, #12]
240182ae:	2b06      	cmp	r3, #6
240182b0:	d015      	beq.n	240182de <HAL_TIM_OC_Start+0x1e6>
240182b2:	68fb      	ldr	r3, [r7, #12]
240182b4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240182b8:	d011      	beq.n	240182de <HAL_TIM_OC_Start+0x1e6>
    {
      __HAL_TIM_ENABLE(htim);
240182ba:	687b      	ldr	r3, [r7, #4]
240182bc:	681b      	ldr	r3, [r3, #0]
240182be:	681a      	ldr	r2, [r3, #0]
240182c0:	687b      	ldr	r3, [r7, #4]
240182c2:	681b      	ldr	r3, [r3, #0]
240182c4:	f042 0201 	orr.w	r2, r2, #1
240182c8:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
240182ca:	e008      	b.n	240182de <HAL_TIM_OC_Start+0x1e6>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
240182cc:	687b      	ldr	r3, [r7, #4]
240182ce:	681b      	ldr	r3, [r3, #0]
240182d0:	681a      	ldr	r2, [r3, #0]
240182d2:	687b      	ldr	r3, [r7, #4]
240182d4:	681b      	ldr	r3, [r3, #0]
240182d6:	f042 0201 	orr.w	r2, r2, #1
240182da:	601a      	str	r2, [r3, #0]
240182dc:	e000      	b.n	240182e0 <HAL_TIM_OC_Start+0x1e8>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
240182de:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
240182e0:	2300      	movs	r3, #0
}
240182e2:	4618      	mov	r0, r3
240182e4:	3710      	adds	r7, #16
240182e6:	46bd      	mov	sp, r7
240182e8:	bd80      	pop	{r7, pc}
240182ea:	bf00      	nop
240182ec:	40010000 	.word	0x40010000
240182f0:	40010400 	.word	0x40010400
240182f4:	40014000 	.word	0x40014000
240182f8:	40014400 	.word	0x40014400
240182fc:	40014800 	.word	0x40014800
24018300:	40000400 	.word	0x40000400
24018304:	40000800 	.word	0x40000800
24018308:	40000c00 	.word	0x40000c00
2401830c:	40001800 	.word	0x40001800
24018310:	00010007 	.word	0x00010007

24018314 <HAL_TIM_OC_Stop>:
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
{
24018314:	b580      	push	{r7, lr}
24018316:	b082      	sub	sp, #8
24018318:	af00      	add	r7, sp, #0
2401831a:	6078      	str	r0, [r7, #4]
2401831c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2401831e:	687b      	ldr	r3, [r7, #4]
24018320:	681b      	ldr	r3, [r3, #0]
24018322:	2200      	movs	r2, #0
24018324:	6839      	ldr	r1, [r7, #0]
24018326:	4618      	mov	r0, r3
24018328:	f006 f91e 	bl	2401e568 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2401832c:	687b      	ldr	r3, [r7, #4]
2401832e:	681b      	ldr	r3, [r3, #0]
24018330:	4a3e      	ldr	r2, [pc, #248]	; (2401842c <HAL_TIM_OC_Stop+0x118>)
24018332:	4293      	cmp	r3, r2
24018334:	d013      	beq.n	2401835e <HAL_TIM_OC_Stop+0x4a>
24018336:	687b      	ldr	r3, [r7, #4]
24018338:	681b      	ldr	r3, [r3, #0]
2401833a:	4a3d      	ldr	r2, [pc, #244]	; (24018430 <HAL_TIM_OC_Stop+0x11c>)
2401833c:	4293      	cmp	r3, r2
2401833e:	d00e      	beq.n	2401835e <HAL_TIM_OC_Stop+0x4a>
24018340:	687b      	ldr	r3, [r7, #4]
24018342:	681b      	ldr	r3, [r3, #0]
24018344:	4a3b      	ldr	r2, [pc, #236]	; (24018434 <HAL_TIM_OC_Stop+0x120>)
24018346:	4293      	cmp	r3, r2
24018348:	d009      	beq.n	2401835e <HAL_TIM_OC_Stop+0x4a>
2401834a:	687b      	ldr	r3, [r7, #4]
2401834c:	681b      	ldr	r3, [r3, #0]
2401834e:	4a3a      	ldr	r2, [pc, #232]	; (24018438 <HAL_TIM_OC_Stop+0x124>)
24018350:	4293      	cmp	r3, r2
24018352:	d004      	beq.n	2401835e <HAL_TIM_OC_Stop+0x4a>
24018354:	687b      	ldr	r3, [r7, #4]
24018356:	681b      	ldr	r3, [r3, #0]
24018358:	4a38      	ldr	r2, [pc, #224]	; (2401843c <HAL_TIM_OC_Stop+0x128>)
2401835a:	4293      	cmp	r3, r2
2401835c:	d101      	bne.n	24018362 <HAL_TIM_OC_Stop+0x4e>
2401835e:	2301      	movs	r3, #1
24018360:	e000      	b.n	24018364 <HAL_TIM_OC_Stop+0x50>
24018362:	2300      	movs	r3, #0
24018364:	2b00      	cmp	r3, #0
24018366:	d017      	beq.n	24018398 <HAL_TIM_OC_Stop+0x84>
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
24018368:	687b      	ldr	r3, [r7, #4]
2401836a:	681b      	ldr	r3, [r3, #0]
2401836c:	6a1a      	ldr	r2, [r3, #32]
2401836e:	f241 1311 	movw	r3, #4369	; 0x1111
24018372:	4013      	ands	r3, r2
24018374:	2b00      	cmp	r3, #0
24018376:	d10f      	bne.n	24018398 <HAL_TIM_OC_Stop+0x84>
24018378:	687b      	ldr	r3, [r7, #4]
2401837a:	681b      	ldr	r3, [r3, #0]
2401837c:	6a1a      	ldr	r2, [r3, #32]
2401837e:	f240 4344 	movw	r3, #1092	; 0x444
24018382:	4013      	ands	r3, r2
24018384:	2b00      	cmp	r3, #0
24018386:	d107      	bne.n	24018398 <HAL_TIM_OC_Stop+0x84>
24018388:	687b      	ldr	r3, [r7, #4]
2401838a:	681b      	ldr	r3, [r3, #0]
2401838c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401838e:	687b      	ldr	r3, [r7, #4]
24018390:	681b      	ldr	r3, [r3, #0]
24018392:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24018396:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
24018398:	687b      	ldr	r3, [r7, #4]
2401839a:	681b      	ldr	r3, [r3, #0]
2401839c:	6a1a      	ldr	r2, [r3, #32]
2401839e:	f241 1311 	movw	r3, #4369	; 0x1111
240183a2:	4013      	ands	r3, r2
240183a4:	2b00      	cmp	r3, #0
240183a6:	d10f      	bne.n	240183c8 <HAL_TIM_OC_Stop+0xb4>
240183a8:	687b      	ldr	r3, [r7, #4]
240183aa:	681b      	ldr	r3, [r3, #0]
240183ac:	6a1a      	ldr	r2, [r3, #32]
240183ae:	f240 4344 	movw	r3, #1092	; 0x444
240183b2:	4013      	ands	r3, r2
240183b4:	2b00      	cmp	r3, #0
240183b6:	d107      	bne.n	240183c8 <HAL_TIM_OC_Stop+0xb4>
240183b8:	687b      	ldr	r3, [r7, #4]
240183ba:	681b      	ldr	r3, [r3, #0]
240183bc:	681a      	ldr	r2, [r3, #0]
240183be:	687b      	ldr	r3, [r7, #4]
240183c0:	681b      	ldr	r3, [r3, #0]
240183c2:	f022 0201 	bic.w	r2, r2, #1
240183c6:	601a      	str	r2, [r3, #0]

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
240183c8:	683b      	ldr	r3, [r7, #0]
240183ca:	2b00      	cmp	r3, #0
240183cc:	d104      	bne.n	240183d8 <HAL_TIM_OC_Stop+0xc4>
240183ce:	687b      	ldr	r3, [r7, #4]
240183d0:	2201      	movs	r2, #1
240183d2:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
240183d6:	e023      	b.n	24018420 <HAL_TIM_OC_Stop+0x10c>
240183d8:	683b      	ldr	r3, [r7, #0]
240183da:	2b04      	cmp	r3, #4
240183dc:	d104      	bne.n	240183e8 <HAL_TIM_OC_Stop+0xd4>
240183de:	687b      	ldr	r3, [r7, #4]
240183e0:	2201      	movs	r2, #1
240183e2:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
240183e6:	e01b      	b.n	24018420 <HAL_TIM_OC_Stop+0x10c>
240183e8:	683b      	ldr	r3, [r7, #0]
240183ea:	2b08      	cmp	r3, #8
240183ec:	d104      	bne.n	240183f8 <HAL_TIM_OC_Stop+0xe4>
240183ee:	687b      	ldr	r3, [r7, #4]
240183f0:	2201      	movs	r2, #1
240183f2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240183f6:	e013      	b.n	24018420 <HAL_TIM_OC_Stop+0x10c>
240183f8:	683b      	ldr	r3, [r7, #0]
240183fa:	2b0c      	cmp	r3, #12
240183fc:	d104      	bne.n	24018408 <HAL_TIM_OC_Stop+0xf4>
240183fe:	687b      	ldr	r3, [r7, #4]
24018400:	2201      	movs	r2, #1
24018402:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24018406:	e00b      	b.n	24018420 <HAL_TIM_OC_Stop+0x10c>
24018408:	683b      	ldr	r3, [r7, #0]
2401840a:	2b10      	cmp	r3, #16
2401840c:	d104      	bne.n	24018418 <HAL_TIM_OC_Stop+0x104>
2401840e:	687b      	ldr	r3, [r7, #4]
24018410:	2201      	movs	r2, #1
24018412:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24018416:	e003      	b.n	24018420 <HAL_TIM_OC_Stop+0x10c>
24018418:	687b      	ldr	r3, [r7, #4]
2401841a:	2201      	movs	r2, #1
2401841c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  /* Return function status */
  return HAL_OK;
24018420:	2300      	movs	r3, #0
}
24018422:	4618      	mov	r0, r3
24018424:	3708      	adds	r7, #8
24018426:	46bd      	mov	sp, r7
24018428:	bd80      	pop	{r7, pc}
2401842a:	bf00      	nop
2401842c:	40010000 	.word	0x40010000
24018430:	40010400 	.word	0x40010400
24018434:	40014000 	.word	0x40014000
24018438:	40014400 	.word	0x40014400
2401843c:	40014800 	.word	0x40014800

24018440 <HAL_TIM_OC_Start_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
24018440:	b580      	push	{r7, lr}
24018442:	b084      	sub	sp, #16
24018444:	af00      	add	r7, sp, #0
24018446:	6078      	str	r0, [r7, #4]
24018448:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401844a:	2300      	movs	r3, #0
2401844c:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
2401844e:	683b      	ldr	r3, [r7, #0]
24018450:	2b00      	cmp	r3, #0
24018452:	d109      	bne.n	24018468 <HAL_TIM_OC_Start_IT+0x28>
24018454:	687b      	ldr	r3, [r7, #4]
24018456:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401845a:	b2db      	uxtb	r3, r3
2401845c:	2b01      	cmp	r3, #1
2401845e:	bf14      	ite	ne
24018460:	2301      	movne	r3, #1
24018462:	2300      	moveq	r3, #0
24018464:	b2db      	uxtb	r3, r3
24018466:	e03c      	b.n	240184e2 <HAL_TIM_OC_Start_IT+0xa2>
24018468:	683b      	ldr	r3, [r7, #0]
2401846a:	2b04      	cmp	r3, #4
2401846c:	d109      	bne.n	24018482 <HAL_TIM_OC_Start_IT+0x42>
2401846e:	687b      	ldr	r3, [r7, #4]
24018470:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
24018474:	b2db      	uxtb	r3, r3
24018476:	2b01      	cmp	r3, #1
24018478:	bf14      	ite	ne
2401847a:	2301      	movne	r3, #1
2401847c:	2300      	moveq	r3, #0
2401847e:	b2db      	uxtb	r3, r3
24018480:	e02f      	b.n	240184e2 <HAL_TIM_OC_Start_IT+0xa2>
24018482:	683b      	ldr	r3, [r7, #0]
24018484:	2b08      	cmp	r3, #8
24018486:	d109      	bne.n	2401849c <HAL_TIM_OC_Start_IT+0x5c>
24018488:	687b      	ldr	r3, [r7, #4]
2401848a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401848e:	b2db      	uxtb	r3, r3
24018490:	2b01      	cmp	r3, #1
24018492:	bf14      	ite	ne
24018494:	2301      	movne	r3, #1
24018496:	2300      	moveq	r3, #0
24018498:	b2db      	uxtb	r3, r3
2401849a:	e022      	b.n	240184e2 <HAL_TIM_OC_Start_IT+0xa2>
2401849c:	683b      	ldr	r3, [r7, #0]
2401849e:	2b0c      	cmp	r3, #12
240184a0:	d109      	bne.n	240184b6 <HAL_TIM_OC_Start_IT+0x76>
240184a2:	687b      	ldr	r3, [r7, #4]
240184a4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240184a8:	b2db      	uxtb	r3, r3
240184aa:	2b01      	cmp	r3, #1
240184ac:	bf14      	ite	ne
240184ae:	2301      	movne	r3, #1
240184b0:	2300      	moveq	r3, #0
240184b2:	b2db      	uxtb	r3, r3
240184b4:	e015      	b.n	240184e2 <HAL_TIM_OC_Start_IT+0xa2>
240184b6:	683b      	ldr	r3, [r7, #0]
240184b8:	2b10      	cmp	r3, #16
240184ba:	d109      	bne.n	240184d0 <HAL_TIM_OC_Start_IT+0x90>
240184bc:	687b      	ldr	r3, [r7, #4]
240184be:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
240184c2:	b2db      	uxtb	r3, r3
240184c4:	2b01      	cmp	r3, #1
240184c6:	bf14      	ite	ne
240184c8:	2301      	movne	r3, #1
240184ca:	2300      	moveq	r3, #0
240184cc:	b2db      	uxtb	r3, r3
240184ce:	e008      	b.n	240184e2 <HAL_TIM_OC_Start_IT+0xa2>
240184d0:	687b      	ldr	r3, [r7, #4]
240184d2:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
240184d6:	b2db      	uxtb	r3, r3
240184d8:	2b01      	cmp	r3, #1
240184da:	bf14      	ite	ne
240184dc:	2301      	movne	r3, #1
240184de:	2300      	moveq	r3, #0
240184e0:	b2db      	uxtb	r3, r3
240184e2:	2b00      	cmp	r3, #0
240184e4:	d001      	beq.n	240184ea <HAL_TIM_OC_Start_IT+0xaa>
  {
    return HAL_ERROR;
240184e6:	2301      	movs	r3, #1
240184e8:	e0ec      	b.n	240186c4 <HAL_TIM_OC_Start_IT+0x284>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
240184ea:	683b      	ldr	r3, [r7, #0]
240184ec:	2b00      	cmp	r3, #0
240184ee:	d104      	bne.n	240184fa <HAL_TIM_OC_Start_IT+0xba>
240184f0:	687b      	ldr	r3, [r7, #4]
240184f2:	2202      	movs	r2, #2
240184f4:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
240184f8:	e023      	b.n	24018542 <HAL_TIM_OC_Start_IT+0x102>
240184fa:	683b      	ldr	r3, [r7, #0]
240184fc:	2b04      	cmp	r3, #4
240184fe:	d104      	bne.n	2401850a <HAL_TIM_OC_Start_IT+0xca>
24018500:	687b      	ldr	r3, [r7, #4]
24018502:	2202      	movs	r2, #2
24018504:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24018508:	e01b      	b.n	24018542 <HAL_TIM_OC_Start_IT+0x102>
2401850a:	683b      	ldr	r3, [r7, #0]
2401850c:	2b08      	cmp	r3, #8
2401850e:	d104      	bne.n	2401851a <HAL_TIM_OC_Start_IT+0xda>
24018510:	687b      	ldr	r3, [r7, #4]
24018512:	2202      	movs	r2, #2
24018514:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24018518:	e013      	b.n	24018542 <HAL_TIM_OC_Start_IT+0x102>
2401851a:	683b      	ldr	r3, [r7, #0]
2401851c:	2b0c      	cmp	r3, #12
2401851e:	d104      	bne.n	2401852a <HAL_TIM_OC_Start_IT+0xea>
24018520:	687b      	ldr	r3, [r7, #4]
24018522:	2202      	movs	r2, #2
24018524:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24018528:	e00b      	b.n	24018542 <HAL_TIM_OC_Start_IT+0x102>
2401852a:	683b      	ldr	r3, [r7, #0]
2401852c:	2b10      	cmp	r3, #16
2401852e:	d104      	bne.n	2401853a <HAL_TIM_OC_Start_IT+0xfa>
24018530:	687b      	ldr	r3, [r7, #4]
24018532:	2202      	movs	r2, #2
24018534:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24018538:	e003      	b.n	24018542 <HAL_TIM_OC_Start_IT+0x102>
2401853a:	687b      	ldr	r3, [r7, #4]
2401853c:	2202      	movs	r2, #2
2401853e:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  switch (Channel)
24018542:	683b      	ldr	r3, [r7, #0]
24018544:	2b0c      	cmp	r3, #12
24018546:	d841      	bhi.n	240185cc <HAL_TIM_OC_Start_IT+0x18c>
24018548:	a201      	add	r2, pc, #4	; (adr r2, 24018550 <HAL_TIM_OC_Start_IT+0x110>)
2401854a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401854e:	bf00      	nop
24018550:	24018585 	.word	0x24018585
24018554:	240185cd 	.word	0x240185cd
24018558:	240185cd 	.word	0x240185cd
2401855c:	240185cd 	.word	0x240185cd
24018560:	24018597 	.word	0x24018597
24018564:	240185cd 	.word	0x240185cd
24018568:	240185cd 	.word	0x240185cd
2401856c:	240185cd 	.word	0x240185cd
24018570:	240185a9 	.word	0x240185a9
24018574:	240185cd 	.word	0x240185cd
24018578:	240185cd 	.word	0x240185cd
2401857c:	240185cd 	.word	0x240185cd
24018580:	240185bb 	.word	0x240185bb
  {
    case TIM_CHANNEL_1:
    {
      /* Enable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
24018584:	687b      	ldr	r3, [r7, #4]
24018586:	681b      	ldr	r3, [r3, #0]
24018588:	68da      	ldr	r2, [r3, #12]
2401858a:	687b      	ldr	r3, [r7, #4]
2401858c:	681b      	ldr	r3, [r3, #0]
2401858e:	f042 0202 	orr.w	r2, r2, #2
24018592:	60da      	str	r2, [r3, #12]
      break;
24018594:	e01d      	b.n	240185d2 <HAL_TIM_OC_Start_IT+0x192>
    }

    case TIM_CHANNEL_2:
    {
      /* Enable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
24018596:	687b      	ldr	r3, [r7, #4]
24018598:	681b      	ldr	r3, [r3, #0]
2401859a:	68da      	ldr	r2, [r3, #12]
2401859c:	687b      	ldr	r3, [r7, #4]
2401859e:	681b      	ldr	r3, [r3, #0]
240185a0:	f042 0204 	orr.w	r2, r2, #4
240185a4:	60da      	str	r2, [r3, #12]
      break;
240185a6:	e014      	b.n	240185d2 <HAL_TIM_OC_Start_IT+0x192>
    }

    case TIM_CHANNEL_3:
    {
      /* Enable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
240185a8:	687b      	ldr	r3, [r7, #4]
240185aa:	681b      	ldr	r3, [r3, #0]
240185ac:	68da      	ldr	r2, [r3, #12]
240185ae:	687b      	ldr	r3, [r7, #4]
240185b0:	681b      	ldr	r3, [r3, #0]
240185b2:	f042 0208 	orr.w	r2, r2, #8
240185b6:	60da      	str	r2, [r3, #12]
      break;
240185b8:	e00b      	b.n	240185d2 <HAL_TIM_OC_Start_IT+0x192>
    }

    case TIM_CHANNEL_4:
    {
      /* Enable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
240185ba:	687b      	ldr	r3, [r7, #4]
240185bc:	681b      	ldr	r3, [r3, #0]
240185be:	68da      	ldr	r2, [r3, #12]
240185c0:	687b      	ldr	r3, [r7, #4]
240185c2:	681b      	ldr	r3, [r3, #0]
240185c4:	f042 0210 	orr.w	r2, r2, #16
240185c8:	60da      	str	r2, [r3, #12]
      break;
240185ca:	e002      	b.n	240185d2 <HAL_TIM_OC_Start_IT+0x192>
    }

    default:
      status = HAL_ERROR;
240185cc:	2301      	movs	r3, #1
240185ce:	73fb      	strb	r3, [r7, #15]
      break;
240185d0:	bf00      	nop
  }

  if (status == HAL_OK)
240185d2:	7bfb      	ldrb	r3, [r7, #15]
240185d4:	2b00      	cmp	r3, #0
240185d6:	d174      	bne.n	240186c2 <HAL_TIM_OC_Start_IT+0x282>
  {
    /* Enable the Output compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
240185d8:	687b      	ldr	r3, [r7, #4]
240185da:	681b      	ldr	r3, [r3, #0]
240185dc:	2201      	movs	r2, #1
240185de:	6839      	ldr	r1, [r7, #0]
240185e0:	4618      	mov	r0, r3
240185e2:	f005 ffc1 	bl	2401e568 <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
240185e6:	687b      	ldr	r3, [r7, #4]
240185e8:	681b      	ldr	r3, [r3, #0]
240185ea:	4a38      	ldr	r2, [pc, #224]	; (240186cc <HAL_TIM_OC_Start_IT+0x28c>)
240185ec:	4293      	cmp	r3, r2
240185ee:	d013      	beq.n	24018618 <HAL_TIM_OC_Start_IT+0x1d8>
240185f0:	687b      	ldr	r3, [r7, #4]
240185f2:	681b      	ldr	r3, [r3, #0]
240185f4:	4a36      	ldr	r2, [pc, #216]	; (240186d0 <HAL_TIM_OC_Start_IT+0x290>)
240185f6:	4293      	cmp	r3, r2
240185f8:	d00e      	beq.n	24018618 <HAL_TIM_OC_Start_IT+0x1d8>
240185fa:	687b      	ldr	r3, [r7, #4]
240185fc:	681b      	ldr	r3, [r3, #0]
240185fe:	4a35      	ldr	r2, [pc, #212]	; (240186d4 <HAL_TIM_OC_Start_IT+0x294>)
24018600:	4293      	cmp	r3, r2
24018602:	d009      	beq.n	24018618 <HAL_TIM_OC_Start_IT+0x1d8>
24018604:	687b      	ldr	r3, [r7, #4]
24018606:	681b      	ldr	r3, [r3, #0]
24018608:	4a33      	ldr	r2, [pc, #204]	; (240186d8 <HAL_TIM_OC_Start_IT+0x298>)
2401860a:	4293      	cmp	r3, r2
2401860c:	d004      	beq.n	24018618 <HAL_TIM_OC_Start_IT+0x1d8>
2401860e:	687b      	ldr	r3, [r7, #4]
24018610:	681b      	ldr	r3, [r3, #0]
24018612:	4a32      	ldr	r2, [pc, #200]	; (240186dc <HAL_TIM_OC_Start_IT+0x29c>)
24018614:	4293      	cmp	r3, r2
24018616:	d101      	bne.n	2401861c <HAL_TIM_OC_Start_IT+0x1dc>
24018618:	2301      	movs	r3, #1
2401861a:	e000      	b.n	2401861e <HAL_TIM_OC_Start_IT+0x1de>
2401861c:	2300      	movs	r3, #0
2401861e:	2b00      	cmp	r3, #0
24018620:	d007      	beq.n	24018632 <HAL_TIM_OC_Start_IT+0x1f2>
    {
      /* Enable the main output */
      __HAL_TIM_MOE_ENABLE(htim);
24018622:	687b      	ldr	r3, [r7, #4]
24018624:	681b      	ldr	r3, [r3, #0]
24018626:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24018628:	687b      	ldr	r3, [r7, #4]
2401862a:	681b      	ldr	r3, [r3, #0]
2401862c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24018630:	645a      	str	r2, [r3, #68]	; 0x44
    }

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
24018632:	687b      	ldr	r3, [r7, #4]
24018634:	681b      	ldr	r3, [r3, #0]
24018636:	4a25      	ldr	r2, [pc, #148]	; (240186cc <HAL_TIM_OC_Start_IT+0x28c>)
24018638:	4293      	cmp	r3, r2
2401863a:	d022      	beq.n	24018682 <HAL_TIM_OC_Start_IT+0x242>
2401863c:	687b      	ldr	r3, [r7, #4]
2401863e:	681b      	ldr	r3, [r3, #0]
24018640:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24018644:	d01d      	beq.n	24018682 <HAL_TIM_OC_Start_IT+0x242>
24018646:	687b      	ldr	r3, [r7, #4]
24018648:	681b      	ldr	r3, [r3, #0]
2401864a:	4a25      	ldr	r2, [pc, #148]	; (240186e0 <HAL_TIM_OC_Start_IT+0x2a0>)
2401864c:	4293      	cmp	r3, r2
2401864e:	d018      	beq.n	24018682 <HAL_TIM_OC_Start_IT+0x242>
24018650:	687b      	ldr	r3, [r7, #4]
24018652:	681b      	ldr	r3, [r3, #0]
24018654:	4a23      	ldr	r2, [pc, #140]	; (240186e4 <HAL_TIM_OC_Start_IT+0x2a4>)
24018656:	4293      	cmp	r3, r2
24018658:	d013      	beq.n	24018682 <HAL_TIM_OC_Start_IT+0x242>
2401865a:	687b      	ldr	r3, [r7, #4]
2401865c:	681b      	ldr	r3, [r3, #0]
2401865e:	4a22      	ldr	r2, [pc, #136]	; (240186e8 <HAL_TIM_OC_Start_IT+0x2a8>)
24018660:	4293      	cmp	r3, r2
24018662:	d00e      	beq.n	24018682 <HAL_TIM_OC_Start_IT+0x242>
24018664:	687b      	ldr	r3, [r7, #4]
24018666:	681b      	ldr	r3, [r3, #0]
24018668:	4a19      	ldr	r2, [pc, #100]	; (240186d0 <HAL_TIM_OC_Start_IT+0x290>)
2401866a:	4293      	cmp	r3, r2
2401866c:	d009      	beq.n	24018682 <HAL_TIM_OC_Start_IT+0x242>
2401866e:	687b      	ldr	r3, [r7, #4]
24018670:	681b      	ldr	r3, [r3, #0]
24018672:	4a1e      	ldr	r2, [pc, #120]	; (240186ec <HAL_TIM_OC_Start_IT+0x2ac>)
24018674:	4293      	cmp	r3, r2
24018676:	d004      	beq.n	24018682 <HAL_TIM_OC_Start_IT+0x242>
24018678:	687b      	ldr	r3, [r7, #4]
2401867a:	681b      	ldr	r3, [r3, #0]
2401867c:	4a15      	ldr	r2, [pc, #84]	; (240186d4 <HAL_TIM_OC_Start_IT+0x294>)
2401867e:	4293      	cmp	r3, r2
24018680:	d115      	bne.n	240186ae <HAL_TIM_OC_Start_IT+0x26e>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
24018682:	687b      	ldr	r3, [r7, #4]
24018684:	681b      	ldr	r3, [r3, #0]
24018686:	689a      	ldr	r2, [r3, #8]
24018688:	4b19      	ldr	r3, [pc, #100]	; (240186f0 <HAL_TIM_OC_Start_IT+0x2b0>)
2401868a:	4013      	ands	r3, r2
2401868c:	60bb      	str	r3, [r7, #8]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401868e:	68bb      	ldr	r3, [r7, #8]
24018690:	2b06      	cmp	r3, #6
24018692:	d015      	beq.n	240186c0 <HAL_TIM_OC_Start_IT+0x280>
24018694:	68bb      	ldr	r3, [r7, #8]
24018696:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401869a:	d011      	beq.n	240186c0 <HAL_TIM_OC_Start_IT+0x280>
      {
        __HAL_TIM_ENABLE(htim);
2401869c:	687b      	ldr	r3, [r7, #4]
2401869e:	681b      	ldr	r3, [r3, #0]
240186a0:	681a      	ldr	r2, [r3, #0]
240186a2:	687b      	ldr	r3, [r7, #4]
240186a4:	681b      	ldr	r3, [r3, #0]
240186a6:	f042 0201 	orr.w	r2, r2, #1
240186aa:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
240186ac:	e008      	b.n	240186c0 <HAL_TIM_OC_Start_IT+0x280>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
240186ae:	687b      	ldr	r3, [r7, #4]
240186b0:	681b      	ldr	r3, [r3, #0]
240186b2:	681a      	ldr	r2, [r3, #0]
240186b4:	687b      	ldr	r3, [r7, #4]
240186b6:	681b      	ldr	r3, [r3, #0]
240186b8:	f042 0201 	orr.w	r2, r2, #1
240186bc:	601a      	str	r2, [r3, #0]
240186be:	e000      	b.n	240186c2 <HAL_TIM_OC_Start_IT+0x282>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
240186c0:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
240186c2:	7bfb      	ldrb	r3, [r7, #15]
}
240186c4:	4618      	mov	r0, r3
240186c6:	3710      	adds	r7, #16
240186c8:	46bd      	mov	sp, r7
240186ca:	bd80      	pop	{r7, pc}
240186cc:	40010000 	.word	0x40010000
240186d0:	40010400 	.word	0x40010400
240186d4:	40014000 	.word	0x40014000
240186d8:	40014400 	.word	0x40014400
240186dc:	40014800 	.word	0x40014800
240186e0:	40000400 	.word	0x40000400
240186e4:	40000800 	.word	0x40000800
240186e8:	40000c00 	.word	0x40000c00
240186ec:	40001800 	.word	0x40001800
240186f0:	00010007 	.word	0x00010007

240186f4 <HAL_TIM_OC_Stop_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
240186f4:	b580      	push	{r7, lr}
240186f6:	b084      	sub	sp, #16
240186f8:	af00      	add	r7, sp, #0
240186fa:	6078      	str	r0, [r7, #4]
240186fc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
240186fe:	2300      	movs	r3, #0
24018700:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
24018702:	683b      	ldr	r3, [r7, #0]
24018704:	2b0c      	cmp	r3, #12
24018706:	d841      	bhi.n	2401878c <HAL_TIM_OC_Stop_IT+0x98>
24018708:	a201      	add	r2, pc, #4	; (adr r2, 24018710 <HAL_TIM_OC_Stop_IT+0x1c>)
2401870a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401870e:	bf00      	nop
24018710:	24018745 	.word	0x24018745
24018714:	2401878d 	.word	0x2401878d
24018718:	2401878d 	.word	0x2401878d
2401871c:	2401878d 	.word	0x2401878d
24018720:	24018757 	.word	0x24018757
24018724:	2401878d 	.word	0x2401878d
24018728:	2401878d 	.word	0x2401878d
2401872c:	2401878d 	.word	0x2401878d
24018730:	24018769 	.word	0x24018769
24018734:	2401878d 	.word	0x2401878d
24018738:	2401878d 	.word	0x2401878d
2401873c:	2401878d 	.word	0x2401878d
24018740:	2401877b 	.word	0x2401877b
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
24018744:	687b      	ldr	r3, [r7, #4]
24018746:	681b      	ldr	r3, [r3, #0]
24018748:	68da      	ldr	r2, [r3, #12]
2401874a:	687b      	ldr	r3, [r7, #4]
2401874c:	681b      	ldr	r3, [r3, #0]
2401874e:	f022 0202 	bic.w	r2, r2, #2
24018752:	60da      	str	r2, [r3, #12]
      break;
24018754:	e01d      	b.n	24018792 <HAL_TIM_OC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
24018756:	687b      	ldr	r3, [r7, #4]
24018758:	681b      	ldr	r3, [r3, #0]
2401875a:	68da      	ldr	r2, [r3, #12]
2401875c:	687b      	ldr	r3, [r7, #4]
2401875e:	681b      	ldr	r3, [r3, #0]
24018760:	f022 0204 	bic.w	r2, r2, #4
24018764:	60da      	str	r2, [r3, #12]
      break;
24018766:	e014      	b.n	24018792 <HAL_TIM_OC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
24018768:	687b      	ldr	r3, [r7, #4]
2401876a:	681b      	ldr	r3, [r3, #0]
2401876c:	68da      	ldr	r2, [r3, #12]
2401876e:	687b      	ldr	r3, [r7, #4]
24018770:	681b      	ldr	r3, [r3, #0]
24018772:	f022 0208 	bic.w	r2, r2, #8
24018776:	60da      	str	r2, [r3, #12]
      break;
24018778:	e00b      	b.n	24018792 <HAL_TIM_OC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_4:
    {
      /* Disable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
2401877a:	687b      	ldr	r3, [r7, #4]
2401877c:	681b      	ldr	r3, [r3, #0]
2401877e:	68da      	ldr	r2, [r3, #12]
24018780:	687b      	ldr	r3, [r7, #4]
24018782:	681b      	ldr	r3, [r3, #0]
24018784:	f022 0210 	bic.w	r2, r2, #16
24018788:	60da      	str	r2, [r3, #12]
      break;
2401878a:	e002      	b.n	24018792 <HAL_TIM_OC_Stop_IT+0x9e>
    }

    default:
      status = HAL_ERROR;
2401878c:	2301      	movs	r3, #1
2401878e:	73fb      	strb	r3, [r7, #15]
      break;
24018790:	bf00      	nop
  }

  if (status == HAL_OK)
24018792:	7bfb      	ldrb	r3, [r7, #15]
24018794:	2b00      	cmp	r3, #0
24018796:	f040 8081 	bne.w	2401889c <HAL_TIM_OC_Stop_IT+0x1a8>
  {
    /* Disable the Output compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2401879a:	687b      	ldr	r3, [r7, #4]
2401879c:	681b      	ldr	r3, [r3, #0]
2401879e:	2200      	movs	r2, #0
240187a0:	6839      	ldr	r1, [r7, #0]
240187a2:	4618      	mov	r0, r3
240187a4:	f005 fee0 	bl	2401e568 <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
240187a8:	687b      	ldr	r3, [r7, #4]
240187aa:	681b      	ldr	r3, [r3, #0]
240187ac:	4a3e      	ldr	r2, [pc, #248]	; (240188a8 <HAL_TIM_OC_Stop_IT+0x1b4>)
240187ae:	4293      	cmp	r3, r2
240187b0:	d013      	beq.n	240187da <HAL_TIM_OC_Stop_IT+0xe6>
240187b2:	687b      	ldr	r3, [r7, #4]
240187b4:	681b      	ldr	r3, [r3, #0]
240187b6:	4a3d      	ldr	r2, [pc, #244]	; (240188ac <HAL_TIM_OC_Stop_IT+0x1b8>)
240187b8:	4293      	cmp	r3, r2
240187ba:	d00e      	beq.n	240187da <HAL_TIM_OC_Stop_IT+0xe6>
240187bc:	687b      	ldr	r3, [r7, #4]
240187be:	681b      	ldr	r3, [r3, #0]
240187c0:	4a3b      	ldr	r2, [pc, #236]	; (240188b0 <HAL_TIM_OC_Stop_IT+0x1bc>)
240187c2:	4293      	cmp	r3, r2
240187c4:	d009      	beq.n	240187da <HAL_TIM_OC_Stop_IT+0xe6>
240187c6:	687b      	ldr	r3, [r7, #4]
240187c8:	681b      	ldr	r3, [r3, #0]
240187ca:	4a3a      	ldr	r2, [pc, #232]	; (240188b4 <HAL_TIM_OC_Stop_IT+0x1c0>)
240187cc:	4293      	cmp	r3, r2
240187ce:	d004      	beq.n	240187da <HAL_TIM_OC_Stop_IT+0xe6>
240187d0:	687b      	ldr	r3, [r7, #4]
240187d2:	681b      	ldr	r3, [r3, #0]
240187d4:	4a38      	ldr	r2, [pc, #224]	; (240188b8 <HAL_TIM_OC_Stop_IT+0x1c4>)
240187d6:	4293      	cmp	r3, r2
240187d8:	d101      	bne.n	240187de <HAL_TIM_OC_Stop_IT+0xea>
240187da:	2301      	movs	r3, #1
240187dc:	e000      	b.n	240187e0 <HAL_TIM_OC_Stop_IT+0xec>
240187de:	2300      	movs	r3, #0
240187e0:	2b00      	cmp	r3, #0
240187e2:	d017      	beq.n	24018814 <HAL_TIM_OC_Stop_IT+0x120>
    {
      /* Disable the Main Output */
      __HAL_TIM_MOE_DISABLE(htim);
240187e4:	687b      	ldr	r3, [r7, #4]
240187e6:	681b      	ldr	r3, [r3, #0]
240187e8:	6a1a      	ldr	r2, [r3, #32]
240187ea:	f241 1311 	movw	r3, #4369	; 0x1111
240187ee:	4013      	ands	r3, r2
240187f0:	2b00      	cmp	r3, #0
240187f2:	d10f      	bne.n	24018814 <HAL_TIM_OC_Stop_IT+0x120>
240187f4:	687b      	ldr	r3, [r7, #4]
240187f6:	681b      	ldr	r3, [r3, #0]
240187f8:	6a1a      	ldr	r2, [r3, #32]
240187fa:	f240 4344 	movw	r3, #1092	; 0x444
240187fe:	4013      	ands	r3, r2
24018800:	2b00      	cmp	r3, #0
24018802:	d107      	bne.n	24018814 <HAL_TIM_OC_Stop_IT+0x120>
24018804:	687b      	ldr	r3, [r7, #4]
24018806:	681b      	ldr	r3, [r3, #0]
24018808:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401880a:	687b      	ldr	r3, [r7, #4]
2401880c:	681b      	ldr	r3, [r3, #0]
2401880e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24018812:	645a      	str	r2, [r3, #68]	; 0x44
    }

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
24018814:	687b      	ldr	r3, [r7, #4]
24018816:	681b      	ldr	r3, [r3, #0]
24018818:	6a1a      	ldr	r2, [r3, #32]
2401881a:	f241 1311 	movw	r3, #4369	; 0x1111
2401881e:	4013      	ands	r3, r2
24018820:	2b00      	cmp	r3, #0
24018822:	d10f      	bne.n	24018844 <HAL_TIM_OC_Stop_IT+0x150>
24018824:	687b      	ldr	r3, [r7, #4]
24018826:	681b      	ldr	r3, [r3, #0]
24018828:	6a1a      	ldr	r2, [r3, #32]
2401882a:	f240 4344 	movw	r3, #1092	; 0x444
2401882e:	4013      	ands	r3, r2
24018830:	2b00      	cmp	r3, #0
24018832:	d107      	bne.n	24018844 <HAL_TIM_OC_Stop_IT+0x150>
24018834:	687b      	ldr	r3, [r7, #4]
24018836:	681b      	ldr	r3, [r3, #0]
24018838:	681a      	ldr	r2, [r3, #0]
2401883a:	687b      	ldr	r3, [r7, #4]
2401883c:	681b      	ldr	r3, [r3, #0]
2401883e:	f022 0201 	bic.w	r2, r2, #1
24018842:	601a      	str	r2, [r3, #0]

    /* Set the TIM channel state */
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
24018844:	683b      	ldr	r3, [r7, #0]
24018846:	2b00      	cmp	r3, #0
24018848:	d104      	bne.n	24018854 <HAL_TIM_OC_Stop_IT+0x160>
2401884a:	687b      	ldr	r3, [r7, #4]
2401884c:	2201      	movs	r2, #1
2401884e:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24018852:	e023      	b.n	2401889c <HAL_TIM_OC_Stop_IT+0x1a8>
24018854:	683b      	ldr	r3, [r7, #0]
24018856:	2b04      	cmp	r3, #4
24018858:	d104      	bne.n	24018864 <HAL_TIM_OC_Stop_IT+0x170>
2401885a:	687b      	ldr	r3, [r7, #4]
2401885c:	2201      	movs	r2, #1
2401885e:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24018862:	e01b      	b.n	2401889c <HAL_TIM_OC_Stop_IT+0x1a8>
24018864:	683b      	ldr	r3, [r7, #0]
24018866:	2b08      	cmp	r3, #8
24018868:	d104      	bne.n	24018874 <HAL_TIM_OC_Stop_IT+0x180>
2401886a:	687b      	ldr	r3, [r7, #4]
2401886c:	2201      	movs	r2, #1
2401886e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24018872:	e013      	b.n	2401889c <HAL_TIM_OC_Stop_IT+0x1a8>
24018874:	683b      	ldr	r3, [r7, #0]
24018876:	2b0c      	cmp	r3, #12
24018878:	d104      	bne.n	24018884 <HAL_TIM_OC_Stop_IT+0x190>
2401887a:	687b      	ldr	r3, [r7, #4]
2401887c:	2201      	movs	r2, #1
2401887e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24018882:	e00b      	b.n	2401889c <HAL_TIM_OC_Stop_IT+0x1a8>
24018884:	683b      	ldr	r3, [r7, #0]
24018886:	2b10      	cmp	r3, #16
24018888:	d104      	bne.n	24018894 <HAL_TIM_OC_Stop_IT+0x1a0>
2401888a:	687b      	ldr	r3, [r7, #4]
2401888c:	2201      	movs	r2, #1
2401888e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24018892:	e003      	b.n	2401889c <HAL_TIM_OC_Stop_IT+0x1a8>
24018894:	687b      	ldr	r3, [r7, #4]
24018896:	2201      	movs	r2, #1
24018898:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  }

  /* Return function status */
  return status;
2401889c:	7bfb      	ldrb	r3, [r7, #15]
}
2401889e:	4618      	mov	r0, r3
240188a0:	3710      	adds	r7, #16
240188a2:	46bd      	mov	sp, r7
240188a4:	bd80      	pop	{r7, pc}
240188a6:	bf00      	nop
240188a8:	40010000 	.word	0x40010000
240188ac:	40010400 	.word	0x40010400
240188b0:	40014000 	.word	0x40014000
240188b4:	40014400 	.word	0x40014400
240188b8:	40014800 	.word	0x40014800

240188bc <HAL_TIM_OC_Start_DMA>:
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
                                       uint16_t Length)
{
240188bc:	b580      	push	{r7, lr}
240188be:	b086      	sub	sp, #24
240188c0:	af00      	add	r7, sp, #0
240188c2:	60f8      	str	r0, [r7, #12]
240188c4:	60b9      	str	r1, [r7, #8]
240188c6:	607a      	str	r2, [r7, #4]
240188c8:	807b      	strh	r3, [r7, #2]
  HAL_StatusTypeDef status = HAL_OK;
240188ca:	2300      	movs	r3, #0
240188cc:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Set the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
240188ce:	68bb      	ldr	r3, [r7, #8]
240188d0:	2b00      	cmp	r3, #0
240188d2:	d109      	bne.n	240188e8 <HAL_TIM_OC_Start_DMA+0x2c>
240188d4:	68fb      	ldr	r3, [r7, #12]
240188d6:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
240188da:	b2db      	uxtb	r3, r3
240188dc:	2b02      	cmp	r3, #2
240188de:	bf0c      	ite	eq
240188e0:	2301      	moveq	r3, #1
240188e2:	2300      	movne	r3, #0
240188e4:	b2db      	uxtb	r3, r3
240188e6:	e03c      	b.n	24018962 <HAL_TIM_OC_Start_DMA+0xa6>
240188e8:	68bb      	ldr	r3, [r7, #8]
240188ea:	2b04      	cmp	r3, #4
240188ec:	d109      	bne.n	24018902 <HAL_TIM_OC_Start_DMA+0x46>
240188ee:	68fb      	ldr	r3, [r7, #12]
240188f0:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
240188f4:	b2db      	uxtb	r3, r3
240188f6:	2b02      	cmp	r3, #2
240188f8:	bf0c      	ite	eq
240188fa:	2301      	moveq	r3, #1
240188fc:	2300      	movne	r3, #0
240188fe:	b2db      	uxtb	r3, r3
24018900:	e02f      	b.n	24018962 <HAL_TIM_OC_Start_DMA+0xa6>
24018902:	68bb      	ldr	r3, [r7, #8]
24018904:	2b08      	cmp	r3, #8
24018906:	d109      	bne.n	2401891c <HAL_TIM_OC_Start_DMA+0x60>
24018908:	68fb      	ldr	r3, [r7, #12]
2401890a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401890e:	b2db      	uxtb	r3, r3
24018910:	2b02      	cmp	r3, #2
24018912:	bf0c      	ite	eq
24018914:	2301      	moveq	r3, #1
24018916:	2300      	movne	r3, #0
24018918:	b2db      	uxtb	r3, r3
2401891a:	e022      	b.n	24018962 <HAL_TIM_OC_Start_DMA+0xa6>
2401891c:	68bb      	ldr	r3, [r7, #8]
2401891e:	2b0c      	cmp	r3, #12
24018920:	d109      	bne.n	24018936 <HAL_TIM_OC_Start_DMA+0x7a>
24018922:	68fb      	ldr	r3, [r7, #12]
24018924:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24018928:	b2db      	uxtb	r3, r3
2401892a:	2b02      	cmp	r3, #2
2401892c:	bf0c      	ite	eq
2401892e:	2301      	moveq	r3, #1
24018930:	2300      	movne	r3, #0
24018932:	b2db      	uxtb	r3, r3
24018934:	e015      	b.n	24018962 <HAL_TIM_OC_Start_DMA+0xa6>
24018936:	68bb      	ldr	r3, [r7, #8]
24018938:	2b10      	cmp	r3, #16
2401893a:	d109      	bne.n	24018950 <HAL_TIM_OC_Start_DMA+0x94>
2401893c:	68fb      	ldr	r3, [r7, #12]
2401893e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
24018942:	b2db      	uxtb	r3, r3
24018944:	2b02      	cmp	r3, #2
24018946:	bf0c      	ite	eq
24018948:	2301      	moveq	r3, #1
2401894a:	2300      	movne	r3, #0
2401894c:	b2db      	uxtb	r3, r3
2401894e:	e008      	b.n	24018962 <HAL_TIM_OC_Start_DMA+0xa6>
24018950:	68fb      	ldr	r3, [r7, #12]
24018952:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
24018956:	b2db      	uxtb	r3, r3
24018958:	2b02      	cmp	r3, #2
2401895a:	bf0c      	ite	eq
2401895c:	2301      	moveq	r3, #1
2401895e:	2300      	movne	r3, #0
24018960:	b2db      	uxtb	r3, r3
24018962:	2b00      	cmp	r3, #0
24018964:	d001      	beq.n	2401896a <HAL_TIM_OC_Start_DMA+0xae>
  {
    return HAL_BUSY;
24018966:	2302      	movs	r3, #2
24018968:	e1b0      	b.n	24018ccc <HAL_TIM_OC_Start_DMA+0x410>
  }
  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
2401896a:	68bb      	ldr	r3, [r7, #8]
2401896c:	2b00      	cmp	r3, #0
2401896e:	d109      	bne.n	24018984 <HAL_TIM_OC_Start_DMA+0xc8>
24018970:	68fb      	ldr	r3, [r7, #12]
24018972:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
24018976:	b2db      	uxtb	r3, r3
24018978:	2b01      	cmp	r3, #1
2401897a:	bf0c      	ite	eq
2401897c:	2301      	moveq	r3, #1
2401897e:	2300      	movne	r3, #0
24018980:	b2db      	uxtb	r3, r3
24018982:	e03c      	b.n	240189fe <HAL_TIM_OC_Start_DMA+0x142>
24018984:	68bb      	ldr	r3, [r7, #8]
24018986:	2b04      	cmp	r3, #4
24018988:	d109      	bne.n	2401899e <HAL_TIM_OC_Start_DMA+0xe2>
2401898a:	68fb      	ldr	r3, [r7, #12]
2401898c:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
24018990:	b2db      	uxtb	r3, r3
24018992:	2b01      	cmp	r3, #1
24018994:	bf0c      	ite	eq
24018996:	2301      	moveq	r3, #1
24018998:	2300      	movne	r3, #0
2401899a:	b2db      	uxtb	r3, r3
2401899c:	e02f      	b.n	240189fe <HAL_TIM_OC_Start_DMA+0x142>
2401899e:	68bb      	ldr	r3, [r7, #8]
240189a0:	2b08      	cmp	r3, #8
240189a2:	d109      	bne.n	240189b8 <HAL_TIM_OC_Start_DMA+0xfc>
240189a4:	68fb      	ldr	r3, [r7, #12]
240189a6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240189aa:	b2db      	uxtb	r3, r3
240189ac:	2b01      	cmp	r3, #1
240189ae:	bf0c      	ite	eq
240189b0:	2301      	moveq	r3, #1
240189b2:	2300      	movne	r3, #0
240189b4:	b2db      	uxtb	r3, r3
240189b6:	e022      	b.n	240189fe <HAL_TIM_OC_Start_DMA+0x142>
240189b8:	68bb      	ldr	r3, [r7, #8]
240189ba:	2b0c      	cmp	r3, #12
240189bc:	d109      	bne.n	240189d2 <HAL_TIM_OC_Start_DMA+0x116>
240189be:	68fb      	ldr	r3, [r7, #12]
240189c0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240189c4:	b2db      	uxtb	r3, r3
240189c6:	2b01      	cmp	r3, #1
240189c8:	bf0c      	ite	eq
240189ca:	2301      	moveq	r3, #1
240189cc:	2300      	movne	r3, #0
240189ce:	b2db      	uxtb	r3, r3
240189d0:	e015      	b.n	240189fe <HAL_TIM_OC_Start_DMA+0x142>
240189d2:	68bb      	ldr	r3, [r7, #8]
240189d4:	2b10      	cmp	r3, #16
240189d6:	d109      	bne.n	240189ec <HAL_TIM_OC_Start_DMA+0x130>
240189d8:	68fb      	ldr	r3, [r7, #12]
240189da:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
240189de:	b2db      	uxtb	r3, r3
240189e0:	2b01      	cmp	r3, #1
240189e2:	bf0c      	ite	eq
240189e4:	2301      	moveq	r3, #1
240189e6:	2300      	movne	r3, #0
240189e8:	b2db      	uxtb	r3, r3
240189ea:	e008      	b.n	240189fe <HAL_TIM_OC_Start_DMA+0x142>
240189ec:	68fb      	ldr	r3, [r7, #12]
240189ee:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
240189f2:	b2db      	uxtb	r3, r3
240189f4:	2b01      	cmp	r3, #1
240189f6:	bf0c      	ite	eq
240189f8:	2301      	moveq	r3, #1
240189fa:	2300      	movne	r3, #0
240189fc:	b2db      	uxtb	r3, r3
240189fe:	2b00      	cmp	r3, #0
24018a00:	d034      	beq.n	24018a6c <HAL_TIM_OC_Start_DMA+0x1b0>
  {
    if ((pData == NULL) || (Length == 0U))
24018a02:	687b      	ldr	r3, [r7, #4]
24018a04:	2b00      	cmp	r3, #0
24018a06:	d002      	beq.n	24018a0e <HAL_TIM_OC_Start_DMA+0x152>
24018a08:	887b      	ldrh	r3, [r7, #2]
24018a0a:	2b00      	cmp	r3, #0
24018a0c:	d101      	bne.n	24018a12 <HAL_TIM_OC_Start_DMA+0x156>
    {
      return HAL_ERROR;
24018a0e:	2301      	movs	r3, #1
24018a10:	e15c      	b.n	24018ccc <HAL_TIM_OC_Start_DMA+0x410>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
24018a12:	68bb      	ldr	r3, [r7, #8]
24018a14:	2b00      	cmp	r3, #0
24018a16:	d104      	bne.n	24018a22 <HAL_TIM_OC_Start_DMA+0x166>
24018a18:	68fb      	ldr	r3, [r7, #12]
24018a1a:	2202      	movs	r2, #2
24018a1c:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24018a20:	e026      	b.n	24018a70 <HAL_TIM_OC_Start_DMA+0x1b4>
24018a22:	68bb      	ldr	r3, [r7, #8]
24018a24:	2b04      	cmp	r3, #4
24018a26:	d104      	bne.n	24018a32 <HAL_TIM_OC_Start_DMA+0x176>
24018a28:	68fb      	ldr	r3, [r7, #12]
24018a2a:	2202      	movs	r2, #2
24018a2c:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24018a30:	e01e      	b.n	24018a70 <HAL_TIM_OC_Start_DMA+0x1b4>
24018a32:	68bb      	ldr	r3, [r7, #8]
24018a34:	2b08      	cmp	r3, #8
24018a36:	d104      	bne.n	24018a42 <HAL_TIM_OC_Start_DMA+0x186>
24018a38:	68fb      	ldr	r3, [r7, #12]
24018a3a:	2202      	movs	r2, #2
24018a3c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24018a40:	e016      	b.n	24018a70 <HAL_TIM_OC_Start_DMA+0x1b4>
24018a42:	68bb      	ldr	r3, [r7, #8]
24018a44:	2b0c      	cmp	r3, #12
24018a46:	d104      	bne.n	24018a52 <HAL_TIM_OC_Start_DMA+0x196>
24018a48:	68fb      	ldr	r3, [r7, #12]
24018a4a:	2202      	movs	r2, #2
24018a4c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24018a50:	e00e      	b.n	24018a70 <HAL_TIM_OC_Start_DMA+0x1b4>
24018a52:	68bb      	ldr	r3, [r7, #8]
24018a54:	2b10      	cmp	r3, #16
24018a56:	d104      	bne.n	24018a62 <HAL_TIM_OC_Start_DMA+0x1a6>
24018a58:	68fb      	ldr	r3, [r7, #12]
24018a5a:	2202      	movs	r2, #2
24018a5c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24018a60:	e006      	b.n	24018a70 <HAL_TIM_OC_Start_DMA+0x1b4>
24018a62:	68fb      	ldr	r3, [r7, #12]
24018a64:	2202      	movs	r2, #2
24018a66:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
24018a6a:	e001      	b.n	24018a70 <HAL_TIM_OC_Start_DMA+0x1b4>
    }
  }
  else
  {
    return HAL_ERROR;
24018a6c:	2301      	movs	r3, #1
24018a6e:	e12d      	b.n	24018ccc <HAL_TIM_OC_Start_DMA+0x410>
  }

  switch (Channel)
24018a70:	68bb      	ldr	r3, [r7, #8]
24018a72:	2b0c      	cmp	r3, #12
24018a74:	f200 80ae 	bhi.w	24018bd4 <HAL_TIM_OC_Start_DMA+0x318>
24018a78:	a201      	add	r2, pc, #4	; (adr r2, 24018a80 <HAL_TIM_OC_Start_DMA+0x1c4>)
24018a7a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24018a7e:	bf00      	nop
24018a80:	24018ab5 	.word	0x24018ab5
24018a84:	24018bd5 	.word	0x24018bd5
24018a88:	24018bd5 	.word	0x24018bd5
24018a8c:	24018bd5 	.word	0x24018bd5
24018a90:	24018afd 	.word	0x24018afd
24018a94:	24018bd5 	.word	0x24018bd5
24018a98:	24018bd5 	.word	0x24018bd5
24018a9c:	24018bd5 	.word	0x24018bd5
24018aa0:	24018b45 	.word	0x24018b45
24018aa4:	24018bd5 	.word	0x24018bd5
24018aa8:	24018bd5 	.word	0x24018bd5
24018aac:	24018bd5 	.word	0x24018bd5
24018ab0:	24018b8d 	.word	0x24018b8d
  {
    case TIM_CHANNEL_1:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
24018ab4:	68fb      	ldr	r3, [r7, #12]
24018ab6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24018ab8:	4a86      	ldr	r2, [pc, #536]	; (24018cd4 <HAL_TIM_OC_Start_DMA+0x418>)
24018aba:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
24018abc:	68fb      	ldr	r3, [r7, #12]
24018abe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24018ac0:	4a85      	ldr	r2, [pc, #532]	; (24018cd8 <HAL_TIM_OC_Start_DMA+0x41c>)
24018ac2:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
24018ac4:	68fb      	ldr	r3, [r7, #12]
24018ac6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24018ac8:	4a84      	ldr	r2, [pc, #528]	; (24018cdc <HAL_TIM_OC_Start_DMA+0x420>)
24018aca:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
24018acc:	68fb      	ldr	r3, [r7, #12]
24018ace:	6a58      	ldr	r0, [r3, #36]	; 0x24
24018ad0:	6879      	ldr	r1, [r7, #4]
24018ad2:	68fb      	ldr	r3, [r7, #12]
24018ad4:	681b      	ldr	r3, [r3, #0]
24018ad6:	3334      	adds	r3, #52	; 0x34
24018ad8:	461a      	mov	r2, r3
24018ada:	887b      	ldrh	r3, [r7, #2]
24018adc:	f7eb f838 	bl	24003b50 <HAL_DMA_Start_IT>
24018ae0:	4603      	mov	r3, r0
24018ae2:	2b00      	cmp	r3, #0
24018ae4:	d001      	beq.n	24018aea <HAL_TIM_OC_Start_DMA+0x22e>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
24018ae6:	2301      	movs	r3, #1
24018ae8:	e0f0      	b.n	24018ccc <HAL_TIM_OC_Start_DMA+0x410>
      }

      /* Enable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
24018aea:	68fb      	ldr	r3, [r7, #12]
24018aec:	681b      	ldr	r3, [r3, #0]
24018aee:	68da      	ldr	r2, [r3, #12]
24018af0:	68fb      	ldr	r3, [r7, #12]
24018af2:	681b      	ldr	r3, [r3, #0]
24018af4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
24018af8:	60da      	str	r2, [r3, #12]
      break;
24018afa:	e06e      	b.n	24018bda <HAL_TIM_OC_Start_DMA+0x31e>
    }

    case TIM_CHANNEL_2:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
24018afc:	68fb      	ldr	r3, [r7, #12]
24018afe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24018b00:	4a74      	ldr	r2, [pc, #464]	; (24018cd4 <HAL_TIM_OC_Start_DMA+0x418>)
24018b02:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
24018b04:	68fb      	ldr	r3, [r7, #12]
24018b06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24018b08:	4a73      	ldr	r2, [pc, #460]	; (24018cd8 <HAL_TIM_OC_Start_DMA+0x41c>)
24018b0a:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
24018b0c:	68fb      	ldr	r3, [r7, #12]
24018b0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24018b10:	4a72      	ldr	r2, [pc, #456]	; (24018cdc <HAL_TIM_OC_Start_DMA+0x420>)
24018b12:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
24018b14:	68fb      	ldr	r3, [r7, #12]
24018b16:	6a98      	ldr	r0, [r3, #40]	; 0x28
24018b18:	6879      	ldr	r1, [r7, #4]
24018b1a:	68fb      	ldr	r3, [r7, #12]
24018b1c:	681b      	ldr	r3, [r3, #0]
24018b1e:	3338      	adds	r3, #56	; 0x38
24018b20:	461a      	mov	r2, r3
24018b22:	887b      	ldrh	r3, [r7, #2]
24018b24:	f7eb f814 	bl	24003b50 <HAL_DMA_Start_IT>
24018b28:	4603      	mov	r3, r0
24018b2a:	2b00      	cmp	r3, #0
24018b2c:	d001      	beq.n	24018b32 <HAL_TIM_OC_Start_DMA+0x276>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
24018b2e:	2301      	movs	r3, #1
24018b30:	e0cc      	b.n	24018ccc <HAL_TIM_OC_Start_DMA+0x410>
      }

      /* Enable the TIM Capture/Compare 2 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
24018b32:	68fb      	ldr	r3, [r7, #12]
24018b34:	681b      	ldr	r3, [r3, #0]
24018b36:	68da      	ldr	r2, [r3, #12]
24018b38:	68fb      	ldr	r3, [r7, #12]
24018b3a:	681b      	ldr	r3, [r3, #0]
24018b3c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
24018b40:	60da      	str	r2, [r3, #12]
      break;
24018b42:	e04a      	b.n	24018bda <HAL_TIM_OC_Start_DMA+0x31e>
    }

    case TIM_CHANNEL_3:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
24018b44:	68fb      	ldr	r3, [r7, #12]
24018b46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24018b48:	4a62      	ldr	r2, [pc, #392]	; (24018cd4 <HAL_TIM_OC_Start_DMA+0x418>)
24018b4a:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
24018b4c:	68fb      	ldr	r3, [r7, #12]
24018b4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24018b50:	4a61      	ldr	r2, [pc, #388]	; (24018cd8 <HAL_TIM_OC_Start_DMA+0x41c>)
24018b52:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
24018b54:	68fb      	ldr	r3, [r7, #12]
24018b56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24018b58:	4a60      	ldr	r2, [pc, #384]	; (24018cdc <HAL_TIM_OC_Start_DMA+0x420>)
24018b5a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
24018b5c:	68fb      	ldr	r3, [r7, #12]
24018b5e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
24018b60:	6879      	ldr	r1, [r7, #4]
24018b62:	68fb      	ldr	r3, [r7, #12]
24018b64:	681b      	ldr	r3, [r3, #0]
24018b66:	333c      	adds	r3, #60	; 0x3c
24018b68:	461a      	mov	r2, r3
24018b6a:	887b      	ldrh	r3, [r7, #2]
24018b6c:	f7ea fff0 	bl	24003b50 <HAL_DMA_Start_IT>
24018b70:	4603      	mov	r3, r0
24018b72:	2b00      	cmp	r3, #0
24018b74:	d001      	beq.n	24018b7a <HAL_TIM_OC_Start_DMA+0x2be>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
24018b76:	2301      	movs	r3, #1
24018b78:	e0a8      	b.n	24018ccc <HAL_TIM_OC_Start_DMA+0x410>
      }
      /* Enable the TIM Capture/Compare 3 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
24018b7a:	68fb      	ldr	r3, [r7, #12]
24018b7c:	681b      	ldr	r3, [r3, #0]
24018b7e:	68da      	ldr	r2, [r3, #12]
24018b80:	68fb      	ldr	r3, [r7, #12]
24018b82:	681b      	ldr	r3, [r3, #0]
24018b84:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
24018b88:	60da      	str	r2, [r3, #12]
      break;
24018b8a:	e026      	b.n	24018bda <HAL_TIM_OC_Start_DMA+0x31e>
    }

    case TIM_CHANNEL_4:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
24018b8c:	68fb      	ldr	r3, [r7, #12]
24018b8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24018b90:	4a50      	ldr	r2, [pc, #320]	; (24018cd4 <HAL_TIM_OC_Start_DMA+0x418>)
24018b92:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
24018b94:	68fb      	ldr	r3, [r7, #12]
24018b96:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24018b98:	4a4f      	ldr	r2, [pc, #316]	; (24018cd8 <HAL_TIM_OC_Start_DMA+0x41c>)
24018b9a:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
24018b9c:	68fb      	ldr	r3, [r7, #12]
24018b9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24018ba0:	4a4e      	ldr	r2, [pc, #312]	; (24018cdc <HAL_TIM_OC_Start_DMA+0x420>)
24018ba2:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,
24018ba4:	68fb      	ldr	r3, [r7, #12]
24018ba6:	6b18      	ldr	r0, [r3, #48]	; 0x30
24018ba8:	6879      	ldr	r1, [r7, #4]
24018baa:	68fb      	ldr	r3, [r7, #12]
24018bac:	681b      	ldr	r3, [r3, #0]
24018bae:	3340      	adds	r3, #64	; 0x40
24018bb0:	461a      	mov	r2, r3
24018bb2:	887b      	ldrh	r3, [r7, #2]
24018bb4:	f7ea ffcc 	bl	24003b50 <HAL_DMA_Start_IT>
24018bb8:	4603      	mov	r3, r0
24018bba:	2b00      	cmp	r3, #0
24018bbc:	d001      	beq.n	24018bc2 <HAL_TIM_OC_Start_DMA+0x306>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
24018bbe:	2301      	movs	r3, #1
24018bc0:	e084      	b.n	24018ccc <HAL_TIM_OC_Start_DMA+0x410>
      }
      /* Enable the TIM Capture/Compare 4 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
24018bc2:	68fb      	ldr	r3, [r7, #12]
24018bc4:	681b      	ldr	r3, [r3, #0]
24018bc6:	68da      	ldr	r2, [r3, #12]
24018bc8:	68fb      	ldr	r3, [r7, #12]
24018bca:	681b      	ldr	r3, [r3, #0]
24018bcc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
24018bd0:	60da      	str	r2, [r3, #12]
      break;
24018bd2:	e002      	b.n	24018bda <HAL_TIM_OC_Start_DMA+0x31e>
    }

    default:
      status = HAL_ERROR;
24018bd4:	2301      	movs	r3, #1
24018bd6:	75fb      	strb	r3, [r7, #23]
      break;
24018bd8:	bf00      	nop
  }

  if (status == HAL_OK)
24018bda:	7dfb      	ldrb	r3, [r7, #23]
24018bdc:	2b00      	cmp	r3, #0
24018bde:	d174      	bne.n	24018cca <HAL_TIM_OC_Start_DMA+0x40e>
  {
    /* Enable the Output compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
24018be0:	68fb      	ldr	r3, [r7, #12]
24018be2:	681b      	ldr	r3, [r3, #0]
24018be4:	2201      	movs	r2, #1
24018be6:	68b9      	ldr	r1, [r7, #8]
24018be8:	4618      	mov	r0, r3
24018bea:	f005 fcbd 	bl	2401e568 <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
24018bee:	68fb      	ldr	r3, [r7, #12]
24018bf0:	681b      	ldr	r3, [r3, #0]
24018bf2:	4a3b      	ldr	r2, [pc, #236]	; (24018ce0 <HAL_TIM_OC_Start_DMA+0x424>)
24018bf4:	4293      	cmp	r3, r2
24018bf6:	d013      	beq.n	24018c20 <HAL_TIM_OC_Start_DMA+0x364>
24018bf8:	68fb      	ldr	r3, [r7, #12]
24018bfa:	681b      	ldr	r3, [r3, #0]
24018bfc:	4a39      	ldr	r2, [pc, #228]	; (24018ce4 <HAL_TIM_OC_Start_DMA+0x428>)
24018bfe:	4293      	cmp	r3, r2
24018c00:	d00e      	beq.n	24018c20 <HAL_TIM_OC_Start_DMA+0x364>
24018c02:	68fb      	ldr	r3, [r7, #12]
24018c04:	681b      	ldr	r3, [r3, #0]
24018c06:	4a38      	ldr	r2, [pc, #224]	; (24018ce8 <HAL_TIM_OC_Start_DMA+0x42c>)
24018c08:	4293      	cmp	r3, r2
24018c0a:	d009      	beq.n	24018c20 <HAL_TIM_OC_Start_DMA+0x364>
24018c0c:	68fb      	ldr	r3, [r7, #12]
24018c0e:	681b      	ldr	r3, [r3, #0]
24018c10:	4a36      	ldr	r2, [pc, #216]	; (24018cec <HAL_TIM_OC_Start_DMA+0x430>)
24018c12:	4293      	cmp	r3, r2
24018c14:	d004      	beq.n	24018c20 <HAL_TIM_OC_Start_DMA+0x364>
24018c16:	68fb      	ldr	r3, [r7, #12]
24018c18:	681b      	ldr	r3, [r3, #0]
24018c1a:	4a35      	ldr	r2, [pc, #212]	; (24018cf0 <HAL_TIM_OC_Start_DMA+0x434>)
24018c1c:	4293      	cmp	r3, r2
24018c1e:	d101      	bne.n	24018c24 <HAL_TIM_OC_Start_DMA+0x368>
24018c20:	2301      	movs	r3, #1
24018c22:	e000      	b.n	24018c26 <HAL_TIM_OC_Start_DMA+0x36a>
24018c24:	2300      	movs	r3, #0
24018c26:	2b00      	cmp	r3, #0
24018c28:	d007      	beq.n	24018c3a <HAL_TIM_OC_Start_DMA+0x37e>
    {
      /* Enable the main output */
      __HAL_TIM_MOE_ENABLE(htim);
24018c2a:	68fb      	ldr	r3, [r7, #12]
24018c2c:	681b      	ldr	r3, [r3, #0]
24018c2e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24018c30:	68fb      	ldr	r3, [r7, #12]
24018c32:	681b      	ldr	r3, [r3, #0]
24018c34:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24018c38:	645a      	str	r2, [r3, #68]	; 0x44
    }

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
24018c3a:	68fb      	ldr	r3, [r7, #12]
24018c3c:	681b      	ldr	r3, [r3, #0]
24018c3e:	4a28      	ldr	r2, [pc, #160]	; (24018ce0 <HAL_TIM_OC_Start_DMA+0x424>)
24018c40:	4293      	cmp	r3, r2
24018c42:	d022      	beq.n	24018c8a <HAL_TIM_OC_Start_DMA+0x3ce>
24018c44:	68fb      	ldr	r3, [r7, #12]
24018c46:	681b      	ldr	r3, [r3, #0]
24018c48:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24018c4c:	d01d      	beq.n	24018c8a <HAL_TIM_OC_Start_DMA+0x3ce>
24018c4e:	68fb      	ldr	r3, [r7, #12]
24018c50:	681b      	ldr	r3, [r3, #0]
24018c52:	4a28      	ldr	r2, [pc, #160]	; (24018cf4 <HAL_TIM_OC_Start_DMA+0x438>)
24018c54:	4293      	cmp	r3, r2
24018c56:	d018      	beq.n	24018c8a <HAL_TIM_OC_Start_DMA+0x3ce>
24018c58:	68fb      	ldr	r3, [r7, #12]
24018c5a:	681b      	ldr	r3, [r3, #0]
24018c5c:	4a26      	ldr	r2, [pc, #152]	; (24018cf8 <HAL_TIM_OC_Start_DMA+0x43c>)
24018c5e:	4293      	cmp	r3, r2
24018c60:	d013      	beq.n	24018c8a <HAL_TIM_OC_Start_DMA+0x3ce>
24018c62:	68fb      	ldr	r3, [r7, #12]
24018c64:	681b      	ldr	r3, [r3, #0]
24018c66:	4a25      	ldr	r2, [pc, #148]	; (24018cfc <HAL_TIM_OC_Start_DMA+0x440>)
24018c68:	4293      	cmp	r3, r2
24018c6a:	d00e      	beq.n	24018c8a <HAL_TIM_OC_Start_DMA+0x3ce>
24018c6c:	68fb      	ldr	r3, [r7, #12]
24018c6e:	681b      	ldr	r3, [r3, #0]
24018c70:	4a1c      	ldr	r2, [pc, #112]	; (24018ce4 <HAL_TIM_OC_Start_DMA+0x428>)
24018c72:	4293      	cmp	r3, r2
24018c74:	d009      	beq.n	24018c8a <HAL_TIM_OC_Start_DMA+0x3ce>
24018c76:	68fb      	ldr	r3, [r7, #12]
24018c78:	681b      	ldr	r3, [r3, #0]
24018c7a:	4a21      	ldr	r2, [pc, #132]	; (24018d00 <HAL_TIM_OC_Start_DMA+0x444>)
24018c7c:	4293      	cmp	r3, r2
24018c7e:	d004      	beq.n	24018c8a <HAL_TIM_OC_Start_DMA+0x3ce>
24018c80:	68fb      	ldr	r3, [r7, #12]
24018c82:	681b      	ldr	r3, [r3, #0]
24018c84:	4a18      	ldr	r2, [pc, #96]	; (24018ce8 <HAL_TIM_OC_Start_DMA+0x42c>)
24018c86:	4293      	cmp	r3, r2
24018c88:	d115      	bne.n	24018cb6 <HAL_TIM_OC_Start_DMA+0x3fa>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
24018c8a:	68fb      	ldr	r3, [r7, #12]
24018c8c:	681b      	ldr	r3, [r3, #0]
24018c8e:	689a      	ldr	r2, [r3, #8]
24018c90:	4b1c      	ldr	r3, [pc, #112]	; (24018d04 <HAL_TIM_OC_Start_DMA+0x448>)
24018c92:	4013      	ands	r3, r2
24018c94:	613b      	str	r3, [r7, #16]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24018c96:	693b      	ldr	r3, [r7, #16]
24018c98:	2b06      	cmp	r3, #6
24018c9a:	d015      	beq.n	24018cc8 <HAL_TIM_OC_Start_DMA+0x40c>
24018c9c:	693b      	ldr	r3, [r7, #16]
24018c9e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24018ca2:	d011      	beq.n	24018cc8 <HAL_TIM_OC_Start_DMA+0x40c>
      {
        __HAL_TIM_ENABLE(htim);
24018ca4:	68fb      	ldr	r3, [r7, #12]
24018ca6:	681b      	ldr	r3, [r3, #0]
24018ca8:	681a      	ldr	r2, [r3, #0]
24018caa:	68fb      	ldr	r3, [r7, #12]
24018cac:	681b      	ldr	r3, [r3, #0]
24018cae:	f042 0201 	orr.w	r2, r2, #1
24018cb2:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24018cb4:	e008      	b.n	24018cc8 <HAL_TIM_OC_Start_DMA+0x40c>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
24018cb6:	68fb      	ldr	r3, [r7, #12]
24018cb8:	681b      	ldr	r3, [r3, #0]
24018cba:	681a      	ldr	r2, [r3, #0]
24018cbc:	68fb      	ldr	r3, [r7, #12]
24018cbe:	681b      	ldr	r3, [r3, #0]
24018cc0:	f042 0201 	orr.w	r2, r2, #1
24018cc4:	601a      	str	r2, [r3, #0]
24018cc6:	e000      	b.n	24018cca <HAL_TIM_OC_Start_DMA+0x40e>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24018cc8:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
24018cca:	7dfb      	ldrb	r3, [r7, #23]
}
24018ccc:	4618      	mov	r0, r3
24018cce:	3718      	adds	r7, #24
24018cd0:	46bd      	mov	sp, r7
24018cd2:	bd80      	pop	{r7, pc}
24018cd4:	2401d651 	.word	0x2401d651
24018cd8:	2401d6f9 	.word	0x2401d6f9
24018cdc:	2401d5bf 	.word	0x2401d5bf
24018ce0:	40010000 	.word	0x40010000
24018ce4:	40010400 	.word	0x40010400
24018ce8:	40014000 	.word	0x40014000
24018cec:	40014400 	.word	0x40014400
24018cf0:	40014800 	.word	0x40014800
24018cf4:	40000400 	.word	0x40000400
24018cf8:	40000800 	.word	0x40000800
24018cfc:	40000c00 	.word	0x40000c00
24018d00:	40001800 	.word	0x40001800
24018d04:	00010007 	.word	0x00010007

24018d08 <HAL_TIM_OC_Stop_DMA>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
{
24018d08:	b580      	push	{r7, lr}
24018d0a:	b084      	sub	sp, #16
24018d0c:	af00      	add	r7, sp, #0
24018d0e:	6078      	str	r0, [r7, #4]
24018d10:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24018d12:	2300      	movs	r3, #0
24018d14:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
24018d16:	683b      	ldr	r3, [r7, #0]
24018d18:	2b0c      	cmp	r3, #12
24018d1a:	d855      	bhi.n	24018dc8 <HAL_TIM_OC_Stop_DMA+0xc0>
24018d1c:	a201      	add	r2, pc, #4	; (adr r2, 24018d24 <HAL_TIM_OC_Stop_DMA+0x1c>)
24018d1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24018d22:	bf00      	nop
24018d24:	24018d59 	.word	0x24018d59
24018d28:	24018dc9 	.word	0x24018dc9
24018d2c:	24018dc9 	.word	0x24018dc9
24018d30:	24018dc9 	.word	0x24018dc9
24018d34:	24018d75 	.word	0x24018d75
24018d38:	24018dc9 	.word	0x24018dc9
24018d3c:	24018dc9 	.word	0x24018dc9
24018d40:	24018dc9 	.word	0x24018dc9
24018d44:	24018d91 	.word	0x24018d91
24018d48:	24018dc9 	.word	0x24018dc9
24018d4c:	24018dc9 	.word	0x24018dc9
24018d50:	24018dc9 	.word	0x24018dc9
24018d54:	24018dad 	.word	0x24018dad
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
24018d58:	687b      	ldr	r3, [r7, #4]
24018d5a:	681b      	ldr	r3, [r3, #0]
24018d5c:	68da      	ldr	r2, [r3, #12]
24018d5e:	687b      	ldr	r3, [r7, #4]
24018d60:	681b      	ldr	r3, [r3, #0]
24018d62:	f422 7200 	bic.w	r2, r2, #512	; 0x200
24018d66:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
24018d68:	687b      	ldr	r3, [r7, #4]
24018d6a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24018d6c:	4618      	mov	r0, r3
24018d6e:	f7eb fc77 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
24018d72:	e02c      	b.n	24018dce <HAL_TIM_OC_Stop_DMA+0xc6>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
24018d74:	687b      	ldr	r3, [r7, #4]
24018d76:	681b      	ldr	r3, [r3, #0]
24018d78:	68da      	ldr	r2, [r3, #12]
24018d7a:	687b      	ldr	r3, [r7, #4]
24018d7c:	681b      	ldr	r3, [r3, #0]
24018d7e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
24018d82:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
24018d84:	687b      	ldr	r3, [r7, #4]
24018d86:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24018d88:	4618      	mov	r0, r3
24018d8a:	f7eb fc69 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
24018d8e:	e01e      	b.n	24018dce <HAL_TIM_OC_Stop_DMA+0xc6>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
24018d90:	687b      	ldr	r3, [r7, #4]
24018d92:	681b      	ldr	r3, [r3, #0]
24018d94:	68da      	ldr	r2, [r3, #12]
24018d96:	687b      	ldr	r3, [r7, #4]
24018d98:	681b      	ldr	r3, [r3, #0]
24018d9a:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
24018d9e:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
24018da0:	687b      	ldr	r3, [r7, #4]
24018da2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24018da4:	4618      	mov	r0, r3
24018da6:	f7eb fc5b 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
24018daa:	e010      	b.n	24018dce <HAL_TIM_OC_Stop_DMA+0xc6>
    }

    case TIM_CHANNEL_4:
    {
      /* Disable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
24018dac:	687b      	ldr	r3, [r7, #4]
24018dae:	681b      	ldr	r3, [r3, #0]
24018db0:	68da      	ldr	r2, [r3, #12]
24018db2:	687b      	ldr	r3, [r7, #4]
24018db4:	681b      	ldr	r3, [r3, #0]
24018db6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
24018dba:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
24018dbc:	687b      	ldr	r3, [r7, #4]
24018dbe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24018dc0:	4618      	mov	r0, r3
24018dc2:	f7eb fc4d 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
24018dc6:	e002      	b.n	24018dce <HAL_TIM_OC_Stop_DMA+0xc6>
    }

    default:
      status = HAL_ERROR;
24018dc8:	2301      	movs	r3, #1
24018dca:	73fb      	strb	r3, [r7, #15]
      break;
24018dcc:	bf00      	nop
  }

  if (status == HAL_OK)
24018dce:	7bfb      	ldrb	r3, [r7, #15]
24018dd0:	2b00      	cmp	r3, #0
24018dd2:	f040 8081 	bne.w	24018ed8 <HAL_TIM_OC_Stop_DMA+0x1d0>
  {
    /* Disable the Output compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
24018dd6:	687b      	ldr	r3, [r7, #4]
24018dd8:	681b      	ldr	r3, [r3, #0]
24018dda:	2200      	movs	r2, #0
24018ddc:	6839      	ldr	r1, [r7, #0]
24018dde:	4618      	mov	r0, r3
24018de0:	f005 fbc2 	bl	2401e568 <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
24018de4:	687b      	ldr	r3, [r7, #4]
24018de6:	681b      	ldr	r3, [r3, #0]
24018de8:	4a3e      	ldr	r2, [pc, #248]	; (24018ee4 <HAL_TIM_OC_Stop_DMA+0x1dc>)
24018dea:	4293      	cmp	r3, r2
24018dec:	d013      	beq.n	24018e16 <HAL_TIM_OC_Stop_DMA+0x10e>
24018dee:	687b      	ldr	r3, [r7, #4]
24018df0:	681b      	ldr	r3, [r3, #0]
24018df2:	4a3d      	ldr	r2, [pc, #244]	; (24018ee8 <HAL_TIM_OC_Stop_DMA+0x1e0>)
24018df4:	4293      	cmp	r3, r2
24018df6:	d00e      	beq.n	24018e16 <HAL_TIM_OC_Stop_DMA+0x10e>
24018df8:	687b      	ldr	r3, [r7, #4]
24018dfa:	681b      	ldr	r3, [r3, #0]
24018dfc:	4a3b      	ldr	r2, [pc, #236]	; (24018eec <HAL_TIM_OC_Stop_DMA+0x1e4>)
24018dfe:	4293      	cmp	r3, r2
24018e00:	d009      	beq.n	24018e16 <HAL_TIM_OC_Stop_DMA+0x10e>
24018e02:	687b      	ldr	r3, [r7, #4]
24018e04:	681b      	ldr	r3, [r3, #0]
24018e06:	4a3a      	ldr	r2, [pc, #232]	; (24018ef0 <HAL_TIM_OC_Stop_DMA+0x1e8>)
24018e08:	4293      	cmp	r3, r2
24018e0a:	d004      	beq.n	24018e16 <HAL_TIM_OC_Stop_DMA+0x10e>
24018e0c:	687b      	ldr	r3, [r7, #4]
24018e0e:	681b      	ldr	r3, [r3, #0]
24018e10:	4a38      	ldr	r2, [pc, #224]	; (24018ef4 <HAL_TIM_OC_Stop_DMA+0x1ec>)
24018e12:	4293      	cmp	r3, r2
24018e14:	d101      	bne.n	24018e1a <HAL_TIM_OC_Stop_DMA+0x112>
24018e16:	2301      	movs	r3, #1
24018e18:	e000      	b.n	24018e1c <HAL_TIM_OC_Stop_DMA+0x114>
24018e1a:	2300      	movs	r3, #0
24018e1c:	2b00      	cmp	r3, #0
24018e1e:	d017      	beq.n	24018e50 <HAL_TIM_OC_Stop_DMA+0x148>
    {
      /* Disable the Main Output */
      __HAL_TIM_MOE_DISABLE(htim);
24018e20:	687b      	ldr	r3, [r7, #4]
24018e22:	681b      	ldr	r3, [r3, #0]
24018e24:	6a1a      	ldr	r2, [r3, #32]
24018e26:	f241 1311 	movw	r3, #4369	; 0x1111
24018e2a:	4013      	ands	r3, r2
24018e2c:	2b00      	cmp	r3, #0
24018e2e:	d10f      	bne.n	24018e50 <HAL_TIM_OC_Stop_DMA+0x148>
24018e30:	687b      	ldr	r3, [r7, #4]
24018e32:	681b      	ldr	r3, [r3, #0]
24018e34:	6a1a      	ldr	r2, [r3, #32]
24018e36:	f240 4344 	movw	r3, #1092	; 0x444
24018e3a:	4013      	ands	r3, r2
24018e3c:	2b00      	cmp	r3, #0
24018e3e:	d107      	bne.n	24018e50 <HAL_TIM_OC_Stop_DMA+0x148>
24018e40:	687b      	ldr	r3, [r7, #4]
24018e42:	681b      	ldr	r3, [r3, #0]
24018e44:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24018e46:	687b      	ldr	r3, [r7, #4]
24018e48:	681b      	ldr	r3, [r3, #0]
24018e4a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24018e4e:	645a      	str	r2, [r3, #68]	; 0x44
    }

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
24018e50:	687b      	ldr	r3, [r7, #4]
24018e52:	681b      	ldr	r3, [r3, #0]
24018e54:	6a1a      	ldr	r2, [r3, #32]
24018e56:	f241 1311 	movw	r3, #4369	; 0x1111
24018e5a:	4013      	ands	r3, r2
24018e5c:	2b00      	cmp	r3, #0
24018e5e:	d10f      	bne.n	24018e80 <HAL_TIM_OC_Stop_DMA+0x178>
24018e60:	687b      	ldr	r3, [r7, #4]
24018e62:	681b      	ldr	r3, [r3, #0]
24018e64:	6a1a      	ldr	r2, [r3, #32]
24018e66:	f240 4344 	movw	r3, #1092	; 0x444
24018e6a:	4013      	ands	r3, r2
24018e6c:	2b00      	cmp	r3, #0
24018e6e:	d107      	bne.n	24018e80 <HAL_TIM_OC_Stop_DMA+0x178>
24018e70:	687b      	ldr	r3, [r7, #4]
24018e72:	681b      	ldr	r3, [r3, #0]
24018e74:	681a      	ldr	r2, [r3, #0]
24018e76:	687b      	ldr	r3, [r7, #4]
24018e78:	681b      	ldr	r3, [r3, #0]
24018e7a:	f022 0201 	bic.w	r2, r2, #1
24018e7e:	601a      	str	r2, [r3, #0]

    /* Set the TIM channel state */
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
24018e80:	683b      	ldr	r3, [r7, #0]
24018e82:	2b00      	cmp	r3, #0
24018e84:	d104      	bne.n	24018e90 <HAL_TIM_OC_Stop_DMA+0x188>
24018e86:	687b      	ldr	r3, [r7, #4]
24018e88:	2201      	movs	r2, #1
24018e8a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24018e8e:	e023      	b.n	24018ed8 <HAL_TIM_OC_Stop_DMA+0x1d0>
24018e90:	683b      	ldr	r3, [r7, #0]
24018e92:	2b04      	cmp	r3, #4
24018e94:	d104      	bne.n	24018ea0 <HAL_TIM_OC_Stop_DMA+0x198>
24018e96:	687b      	ldr	r3, [r7, #4]
24018e98:	2201      	movs	r2, #1
24018e9a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24018e9e:	e01b      	b.n	24018ed8 <HAL_TIM_OC_Stop_DMA+0x1d0>
24018ea0:	683b      	ldr	r3, [r7, #0]
24018ea2:	2b08      	cmp	r3, #8
24018ea4:	d104      	bne.n	24018eb0 <HAL_TIM_OC_Stop_DMA+0x1a8>
24018ea6:	687b      	ldr	r3, [r7, #4]
24018ea8:	2201      	movs	r2, #1
24018eaa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24018eae:	e013      	b.n	24018ed8 <HAL_TIM_OC_Stop_DMA+0x1d0>
24018eb0:	683b      	ldr	r3, [r7, #0]
24018eb2:	2b0c      	cmp	r3, #12
24018eb4:	d104      	bne.n	24018ec0 <HAL_TIM_OC_Stop_DMA+0x1b8>
24018eb6:	687b      	ldr	r3, [r7, #4]
24018eb8:	2201      	movs	r2, #1
24018eba:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24018ebe:	e00b      	b.n	24018ed8 <HAL_TIM_OC_Stop_DMA+0x1d0>
24018ec0:	683b      	ldr	r3, [r7, #0]
24018ec2:	2b10      	cmp	r3, #16
24018ec4:	d104      	bne.n	24018ed0 <HAL_TIM_OC_Stop_DMA+0x1c8>
24018ec6:	687b      	ldr	r3, [r7, #4]
24018ec8:	2201      	movs	r2, #1
24018eca:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24018ece:	e003      	b.n	24018ed8 <HAL_TIM_OC_Stop_DMA+0x1d0>
24018ed0:	687b      	ldr	r3, [r7, #4]
24018ed2:	2201      	movs	r2, #1
24018ed4:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  }

  /* Return function status */
  return status;
24018ed8:	7bfb      	ldrb	r3, [r7, #15]
}
24018eda:	4618      	mov	r0, r3
24018edc:	3710      	adds	r7, #16
24018ede:	46bd      	mov	sp, r7
24018ee0:	bd80      	pop	{r7, pc}
24018ee2:	bf00      	nop
24018ee4:	40010000 	.word	0x40010000
24018ee8:	40010400 	.word	0x40010400
24018eec:	40014000 	.word	0x40014000
24018ef0:	40014400 	.word	0x40014400
24018ef4:	40014800 	.word	0x40014800

24018ef8 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
24018ef8:	b580      	push	{r7, lr}
24018efa:	b082      	sub	sp, #8
24018efc:	af00      	add	r7, sp, #0
24018efe:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
24018f00:	687b      	ldr	r3, [r7, #4]
24018f02:	2b00      	cmp	r3, #0
24018f04:	d101      	bne.n	24018f0a <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
24018f06:	2301      	movs	r3, #1
24018f08:	e049      	b.n	24018f9e <HAL_TIM_PWM_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
24018f0a:	687b      	ldr	r3, [r7, #4]
24018f0c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24018f10:	b2db      	uxtb	r3, r3
24018f12:	2b00      	cmp	r3, #0
24018f14:	d106      	bne.n	24018f24 <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
24018f16:	687b      	ldr	r3, [r7, #4]
24018f18:	2200      	movs	r2, #0
24018f1a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
24018f1e:	6878      	ldr	r0, [r7, #4]
24018f20:	f000 f89d 	bl	2401905e <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
24018f24:	687b      	ldr	r3, [r7, #4]
24018f26:	2202      	movs	r2, #2
24018f28:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
24018f2c:	687b      	ldr	r3, [r7, #4]
24018f2e:	681a      	ldr	r2, [r3, #0]
24018f30:	687b      	ldr	r3, [r7, #4]
24018f32:	3304      	adds	r3, #4
24018f34:	4619      	mov	r1, r3
24018f36:	4610      	mov	r0, r2
24018f38:	f004 fcf4 	bl	2401d924 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
24018f3c:	687b      	ldr	r3, [r7, #4]
24018f3e:	2201      	movs	r2, #1
24018f40:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
24018f44:	687b      	ldr	r3, [r7, #4]
24018f46:	2201      	movs	r2, #1
24018f48:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24018f4c:	687b      	ldr	r3, [r7, #4]
24018f4e:	2201      	movs	r2, #1
24018f50:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24018f54:	687b      	ldr	r3, [r7, #4]
24018f56:	2201      	movs	r2, #1
24018f58:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24018f5c:	687b      	ldr	r3, [r7, #4]
24018f5e:	2201      	movs	r2, #1
24018f60:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24018f64:	687b      	ldr	r3, [r7, #4]
24018f66:	2201      	movs	r2, #1
24018f68:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24018f6c:	687b      	ldr	r3, [r7, #4]
24018f6e:	2201      	movs	r2, #1
24018f70:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
24018f74:	687b      	ldr	r3, [r7, #4]
24018f76:	2201      	movs	r2, #1
24018f78:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24018f7c:	687b      	ldr	r3, [r7, #4]
24018f7e:	2201      	movs	r2, #1
24018f80:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24018f84:	687b      	ldr	r3, [r7, #4]
24018f86:	2201      	movs	r2, #1
24018f88:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
24018f8c:	687b      	ldr	r3, [r7, #4]
24018f8e:	2201      	movs	r2, #1
24018f90:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
24018f94:	687b      	ldr	r3, [r7, #4]
24018f96:	2201      	movs	r2, #1
24018f98:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
24018f9c:	2300      	movs	r3, #0
}
24018f9e:	4618      	mov	r0, r3
24018fa0:	3708      	adds	r7, #8
24018fa2:	46bd      	mov	sp, r7
24018fa4:	bd80      	pop	{r7, pc}

24018fa6 <HAL_TIM_PWM_DeInit>:
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
{
24018fa6:	b580      	push	{r7, lr}
24018fa8:	b082      	sub	sp, #8
24018faa:	af00      	add	r7, sp, #0
24018fac:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
24018fae:	687b      	ldr	r3, [r7, #4]
24018fb0:	2202      	movs	r2, #2
24018fb2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
24018fb6:	687b      	ldr	r3, [r7, #4]
24018fb8:	681b      	ldr	r3, [r3, #0]
24018fba:	6a1a      	ldr	r2, [r3, #32]
24018fbc:	f241 1311 	movw	r3, #4369	; 0x1111
24018fc0:	4013      	ands	r3, r2
24018fc2:	2b00      	cmp	r3, #0
24018fc4:	d10f      	bne.n	24018fe6 <HAL_TIM_PWM_DeInit+0x40>
24018fc6:	687b      	ldr	r3, [r7, #4]
24018fc8:	681b      	ldr	r3, [r3, #0]
24018fca:	6a1a      	ldr	r2, [r3, #32]
24018fcc:	f240 4344 	movw	r3, #1092	; 0x444
24018fd0:	4013      	ands	r3, r2
24018fd2:	2b00      	cmp	r3, #0
24018fd4:	d107      	bne.n	24018fe6 <HAL_TIM_PWM_DeInit+0x40>
24018fd6:	687b      	ldr	r3, [r7, #4]
24018fd8:	681b      	ldr	r3, [r3, #0]
24018fda:	681a      	ldr	r2, [r3, #0]
24018fdc:	687b      	ldr	r3, [r7, #4]
24018fde:	681b      	ldr	r3, [r3, #0]
24018fe0:	f022 0201 	bic.w	r2, r2, #1
24018fe4:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->PWM_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_PWM_MspDeInit(htim);
24018fe6:	6878      	ldr	r0, [r7, #4]
24018fe8:	f000 f843 	bl	24019072 <HAL_TIM_PWM_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
24018fec:	687b      	ldr	r3, [r7, #4]
24018fee:	2200      	movs	r2, #0
24018ff0:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Change the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
24018ff4:	687b      	ldr	r3, [r7, #4]
24018ff6:	2200      	movs	r2, #0
24018ff8:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24018ffc:	687b      	ldr	r3, [r7, #4]
24018ffe:	2200      	movs	r2, #0
24019000:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24019004:	687b      	ldr	r3, [r7, #4]
24019006:	2200      	movs	r2, #0
24019008:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401900c:	687b      	ldr	r3, [r7, #4]
2401900e:	2200      	movs	r2, #0
24019010:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24019014:	687b      	ldr	r3, [r7, #4]
24019016:	2200      	movs	r2, #0
24019018:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401901c:	687b      	ldr	r3, [r7, #4]
2401901e:	2200      	movs	r2, #0
24019020:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
24019024:	687b      	ldr	r3, [r7, #4]
24019026:	2200      	movs	r2, #0
24019028:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401902c:	687b      	ldr	r3, [r7, #4]
2401902e:	2200      	movs	r2, #0
24019030:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24019034:	687b      	ldr	r3, [r7, #4]
24019036:	2200      	movs	r2, #0
24019038:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401903c:	687b      	ldr	r3, [r7, #4]
2401903e:	2200      	movs	r2, #0
24019040:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
24019044:	687b      	ldr	r3, [r7, #4]
24019046:	2200      	movs	r2, #0
24019048:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
2401904c:	687b      	ldr	r3, [r7, #4]
2401904e:	2200      	movs	r2, #0
24019050:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24019054:	2300      	movs	r3, #0
}
24019056:	4618      	mov	r0, r3
24019058:	3708      	adds	r7, #8
2401905a:	46bd      	mov	sp, r7
2401905c:	bd80      	pop	{r7, pc}

2401905e <HAL_TIM_PWM_MspInit>:
  * @brief  Initializes the TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
2401905e:	b480      	push	{r7}
24019060:	b083      	sub	sp, #12
24019062:	af00      	add	r7, sp, #0
24019064:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspInit could be implemented in the user file
   */
}
24019066:	bf00      	nop
24019068:	370c      	adds	r7, #12
2401906a:	46bd      	mov	sp, r7
2401906c:	f85d 7b04 	ldr.w	r7, [sp], #4
24019070:	4770      	bx	lr

24019072 <HAL_TIM_PWM_MspDeInit>:
  * @brief  DeInitializes TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
{
24019072:	b480      	push	{r7}
24019074:	b083      	sub	sp, #12
24019076:	af00      	add	r7, sp, #0
24019078:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   */
}
2401907a:	bf00      	nop
2401907c:	370c      	adds	r7, #12
2401907e:	46bd      	mov	sp, r7
24019080:	f85d 7b04 	ldr.w	r7, [sp], #4
24019084:	4770      	bx	lr
	...

24019088 <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
24019088:	b580      	push	{r7, lr}
2401908a:	b084      	sub	sp, #16
2401908c:	af00      	add	r7, sp, #0
2401908e:	6078      	str	r0, [r7, #4]
24019090:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
24019092:	683b      	ldr	r3, [r7, #0]
24019094:	2b00      	cmp	r3, #0
24019096:	d109      	bne.n	240190ac <HAL_TIM_PWM_Start+0x24>
24019098:	687b      	ldr	r3, [r7, #4]
2401909a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401909e:	b2db      	uxtb	r3, r3
240190a0:	2b01      	cmp	r3, #1
240190a2:	bf14      	ite	ne
240190a4:	2301      	movne	r3, #1
240190a6:	2300      	moveq	r3, #0
240190a8:	b2db      	uxtb	r3, r3
240190aa:	e03c      	b.n	24019126 <HAL_TIM_PWM_Start+0x9e>
240190ac:	683b      	ldr	r3, [r7, #0]
240190ae:	2b04      	cmp	r3, #4
240190b0:	d109      	bne.n	240190c6 <HAL_TIM_PWM_Start+0x3e>
240190b2:	687b      	ldr	r3, [r7, #4]
240190b4:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
240190b8:	b2db      	uxtb	r3, r3
240190ba:	2b01      	cmp	r3, #1
240190bc:	bf14      	ite	ne
240190be:	2301      	movne	r3, #1
240190c0:	2300      	moveq	r3, #0
240190c2:	b2db      	uxtb	r3, r3
240190c4:	e02f      	b.n	24019126 <HAL_TIM_PWM_Start+0x9e>
240190c6:	683b      	ldr	r3, [r7, #0]
240190c8:	2b08      	cmp	r3, #8
240190ca:	d109      	bne.n	240190e0 <HAL_TIM_PWM_Start+0x58>
240190cc:	687b      	ldr	r3, [r7, #4]
240190ce:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240190d2:	b2db      	uxtb	r3, r3
240190d4:	2b01      	cmp	r3, #1
240190d6:	bf14      	ite	ne
240190d8:	2301      	movne	r3, #1
240190da:	2300      	moveq	r3, #0
240190dc:	b2db      	uxtb	r3, r3
240190de:	e022      	b.n	24019126 <HAL_TIM_PWM_Start+0x9e>
240190e0:	683b      	ldr	r3, [r7, #0]
240190e2:	2b0c      	cmp	r3, #12
240190e4:	d109      	bne.n	240190fa <HAL_TIM_PWM_Start+0x72>
240190e6:	687b      	ldr	r3, [r7, #4]
240190e8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240190ec:	b2db      	uxtb	r3, r3
240190ee:	2b01      	cmp	r3, #1
240190f0:	bf14      	ite	ne
240190f2:	2301      	movne	r3, #1
240190f4:	2300      	moveq	r3, #0
240190f6:	b2db      	uxtb	r3, r3
240190f8:	e015      	b.n	24019126 <HAL_TIM_PWM_Start+0x9e>
240190fa:	683b      	ldr	r3, [r7, #0]
240190fc:	2b10      	cmp	r3, #16
240190fe:	d109      	bne.n	24019114 <HAL_TIM_PWM_Start+0x8c>
24019100:	687b      	ldr	r3, [r7, #4]
24019102:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
24019106:	b2db      	uxtb	r3, r3
24019108:	2b01      	cmp	r3, #1
2401910a:	bf14      	ite	ne
2401910c:	2301      	movne	r3, #1
2401910e:	2300      	moveq	r3, #0
24019110:	b2db      	uxtb	r3, r3
24019112:	e008      	b.n	24019126 <HAL_TIM_PWM_Start+0x9e>
24019114:	687b      	ldr	r3, [r7, #4]
24019116:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
2401911a:	b2db      	uxtb	r3, r3
2401911c:	2b01      	cmp	r3, #1
2401911e:	bf14      	ite	ne
24019120:	2301      	movne	r3, #1
24019122:	2300      	moveq	r3, #0
24019124:	b2db      	uxtb	r3, r3
24019126:	2b00      	cmp	r3, #0
24019128:	d001      	beq.n	2401912e <HAL_TIM_PWM_Start+0xa6>
  {
    return HAL_ERROR;
2401912a:	2301      	movs	r3, #1
2401912c:	e0a1      	b.n	24019272 <HAL_TIM_PWM_Start+0x1ea>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401912e:	683b      	ldr	r3, [r7, #0]
24019130:	2b00      	cmp	r3, #0
24019132:	d104      	bne.n	2401913e <HAL_TIM_PWM_Start+0xb6>
24019134:	687b      	ldr	r3, [r7, #4]
24019136:	2202      	movs	r2, #2
24019138:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401913c:	e023      	b.n	24019186 <HAL_TIM_PWM_Start+0xfe>
2401913e:	683b      	ldr	r3, [r7, #0]
24019140:	2b04      	cmp	r3, #4
24019142:	d104      	bne.n	2401914e <HAL_TIM_PWM_Start+0xc6>
24019144:	687b      	ldr	r3, [r7, #4]
24019146:	2202      	movs	r2, #2
24019148:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401914c:	e01b      	b.n	24019186 <HAL_TIM_PWM_Start+0xfe>
2401914e:	683b      	ldr	r3, [r7, #0]
24019150:	2b08      	cmp	r3, #8
24019152:	d104      	bne.n	2401915e <HAL_TIM_PWM_Start+0xd6>
24019154:	687b      	ldr	r3, [r7, #4]
24019156:	2202      	movs	r2, #2
24019158:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401915c:	e013      	b.n	24019186 <HAL_TIM_PWM_Start+0xfe>
2401915e:	683b      	ldr	r3, [r7, #0]
24019160:	2b0c      	cmp	r3, #12
24019162:	d104      	bne.n	2401916e <HAL_TIM_PWM_Start+0xe6>
24019164:	687b      	ldr	r3, [r7, #4]
24019166:	2202      	movs	r2, #2
24019168:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401916c:	e00b      	b.n	24019186 <HAL_TIM_PWM_Start+0xfe>
2401916e:	683b      	ldr	r3, [r7, #0]
24019170:	2b10      	cmp	r3, #16
24019172:	d104      	bne.n	2401917e <HAL_TIM_PWM_Start+0xf6>
24019174:	687b      	ldr	r3, [r7, #4]
24019176:	2202      	movs	r2, #2
24019178:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401917c:	e003      	b.n	24019186 <HAL_TIM_PWM_Start+0xfe>
2401917e:	687b      	ldr	r3, [r7, #4]
24019180:	2202      	movs	r2, #2
24019182:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
24019186:	687b      	ldr	r3, [r7, #4]
24019188:	681b      	ldr	r3, [r3, #0]
2401918a:	2201      	movs	r2, #1
2401918c:	6839      	ldr	r1, [r7, #0]
2401918e:	4618      	mov	r0, r3
24019190:	f005 f9ea 	bl	2401e568 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
24019194:	687b      	ldr	r3, [r7, #4]
24019196:	681b      	ldr	r3, [r3, #0]
24019198:	4a38      	ldr	r2, [pc, #224]	; (2401927c <HAL_TIM_PWM_Start+0x1f4>)
2401919a:	4293      	cmp	r3, r2
2401919c:	d013      	beq.n	240191c6 <HAL_TIM_PWM_Start+0x13e>
2401919e:	687b      	ldr	r3, [r7, #4]
240191a0:	681b      	ldr	r3, [r3, #0]
240191a2:	4a37      	ldr	r2, [pc, #220]	; (24019280 <HAL_TIM_PWM_Start+0x1f8>)
240191a4:	4293      	cmp	r3, r2
240191a6:	d00e      	beq.n	240191c6 <HAL_TIM_PWM_Start+0x13e>
240191a8:	687b      	ldr	r3, [r7, #4]
240191aa:	681b      	ldr	r3, [r3, #0]
240191ac:	4a35      	ldr	r2, [pc, #212]	; (24019284 <HAL_TIM_PWM_Start+0x1fc>)
240191ae:	4293      	cmp	r3, r2
240191b0:	d009      	beq.n	240191c6 <HAL_TIM_PWM_Start+0x13e>
240191b2:	687b      	ldr	r3, [r7, #4]
240191b4:	681b      	ldr	r3, [r3, #0]
240191b6:	4a34      	ldr	r2, [pc, #208]	; (24019288 <HAL_TIM_PWM_Start+0x200>)
240191b8:	4293      	cmp	r3, r2
240191ba:	d004      	beq.n	240191c6 <HAL_TIM_PWM_Start+0x13e>
240191bc:	687b      	ldr	r3, [r7, #4]
240191be:	681b      	ldr	r3, [r3, #0]
240191c0:	4a32      	ldr	r2, [pc, #200]	; (2401928c <HAL_TIM_PWM_Start+0x204>)
240191c2:	4293      	cmp	r3, r2
240191c4:	d101      	bne.n	240191ca <HAL_TIM_PWM_Start+0x142>
240191c6:	2301      	movs	r3, #1
240191c8:	e000      	b.n	240191cc <HAL_TIM_PWM_Start+0x144>
240191ca:	2300      	movs	r3, #0
240191cc:	2b00      	cmp	r3, #0
240191ce:	d007      	beq.n	240191e0 <HAL_TIM_PWM_Start+0x158>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
240191d0:	687b      	ldr	r3, [r7, #4]
240191d2:	681b      	ldr	r3, [r3, #0]
240191d4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
240191d6:	687b      	ldr	r3, [r7, #4]
240191d8:	681b      	ldr	r3, [r3, #0]
240191da:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
240191de:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
240191e0:	687b      	ldr	r3, [r7, #4]
240191e2:	681b      	ldr	r3, [r3, #0]
240191e4:	4a25      	ldr	r2, [pc, #148]	; (2401927c <HAL_TIM_PWM_Start+0x1f4>)
240191e6:	4293      	cmp	r3, r2
240191e8:	d022      	beq.n	24019230 <HAL_TIM_PWM_Start+0x1a8>
240191ea:	687b      	ldr	r3, [r7, #4]
240191ec:	681b      	ldr	r3, [r3, #0]
240191ee:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240191f2:	d01d      	beq.n	24019230 <HAL_TIM_PWM_Start+0x1a8>
240191f4:	687b      	ldr	r3, [r7, #4]
240191f6:	681b      	ldr	r3, [r3, #0]
240191f8:	4a25      	ldr	r2, [pc, #148]	; (24019290 <HAL_TIM_PWM_Start+0x208>)
240191fa:	4293      	cmp	r3, r2
240191fc:	d018      	beq.n	24019230 <HAL_TIM_PWM_Start+0x1a8>
240191fe:	687b      	ldr	r3, [r7, #4]
24019200:	681b      	ldr	r3, [r3, #0]
24019202:	4a24      	ldr	r2, [pc, #144]	; (24019294 <HAL_TIM_PWM_Start+0x20c>)
24019204:	4293      	cmp	r3, r2
24019206:	d013      	beq.n	24019230 <HAL_TIM_PWM_Start+0x1a8>
24019208:	687b      	ldr	r3, [r7, #4]
2401920a:	681b      	ldr	r3, [r3, #0]
2401920c:	4a22      	ldr	r2, [pc, #136]	; (24019298 <HAL_TIM_PWM_Start+0x210>)
2401920e:	4293      	cmp	r3, r2
24019210:	d00e      	beq.n	24019230 <HAL_TIM_PWM_Start+0x1a8>
24019212:	687b      	ldr	r3, [r7, #4]
24019214:	681b      	ldr	r3, [r3, #0]
24019216:	4a1a      	ldr	r2, [pc, #104]	; (24019280 <HAL_TIM_PWM_Start+0x1f8>)
24019218:	4293      	cmp	r3, r2
2401921a:	d009      	beq.n	24019230 <HAL_TIM_PWM_Start+0x1a8>
2401921c:	687b      	ldr	r3, [r7, #4]
2401921e:	681b      	ldr	r3, [r3, #0]
24019220:	4a1e      	ldr	r2, [pc, #120]	; (2401929c <HAL_TIM_PWM_Start+0x214>)
24019222:	4293      	cmp	r3, r2
24019224:	d004      	beq.n	24019230 <HAL_TIM_PWM_Start+0x1a8>
24019226:	687b      	ldr	r3, [r7, #4]
24019228:	681b      	ldr	r3, [r3, #0]
2401922a:	4a16      	ldr	r2, [pc, #88]	; (24019284 <HAL_TIM_PWM_Start+0x1fc>)
2401922c:	4293      	cmp	r3, r2
2401922e:	d115      	bne.n	2401925c <HAL_TIM_PWM_Start+0x1d4>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
24019230:	687b      	ldr	r3, [r7, #4]
24019232:	681b      	ldr	r3, [r3, #0]
24019234:	689a      	ldr	r2, [r3, #8]
24019236:	4b1a      	ldr	r3, [pc, #104]	; (240192a0 <HAL_TIM_PWM_Start+0x218>)
24019238:	4013      	ands	r3, r2
2401923a:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401923c:	68fb      	ldr	r3, [r7, #12]
2401923e:	2b06      	cmp	r3, #6
24019240:	d015      	beq.n	2401926e <HAL_TIM_PWM_Start+0x1e6>
24019242:	68fb      	ldr	r3, [r7, #12]
24019244:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24019248:	d011      	beq.n	2401926e <HAL_TIM_PWM_Start+0x1e6>
    {
      __HAL_TIM_ENABLE(htim);
2401924a:	687b      	ldr	r3, [r7, #4]
2401924c:	681b      	ldr	r3, [r3, #0]
2401924e:	681a      	ldr	r2, [r3, #0]
24019250:	687b      	ldr	r3, [r7, #4]
24019252:	681b      	ldr	r3, [r3, #0]
24019254:	f042 0201 	orr.w	r2, r2, #1
24019258:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401925a:	e008      	b.n	2401926e <HAL_TIM_PWM_Start+0x1e6>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
2401925c:	687b      	ldr	r3, [r7, #4]
2401925e:	681b      	ldr	r3, [r3, #0]
24019260:	681a      	ldr	r2, [r3, #0]
24019262:	687b      	ldr	r3, [r7, #4]
24019264:	681b      	ldr	r3, [r3, #0]
24019266:	f042 0201 	orr.w	r2, r2, #1
2401926a:	601a      	str	r2, [r3, #0]
2401926c:	e000      	b.n	24019270 <HAL_TIM_PWM_Start+0x1e8>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401926e:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
24019270:	2300      	movs	r3, #0
}
24019272:	4618      	mov	r0, r3
24019274:	3710      	adds	r7, #16
24019276:	46bd      	mov	sp, r7
24019278:	bd80      	pop	{r7, pc}
2401927a:	bf00      	nop
2401927c:	40010000 	.word	0x40010000
24019280:	40010400 	.word	0x40010400
24019284:	40014000 	.word	0x40014000
24019288:	40014400 	.word	0x40014400
2401928c:	40014800 	.word	0x40014800
24019290:	40000400 	.word	0x40000400
24019294:	40000800 	.word	0x40000800
24019298:	40000c00 	.word	0x40000c00
2401929c:	40001800 	.word	0x40001800
240192a0:	00010007 	.word	0x00010007

240192a4 <HAL_TIM_PWM_Stop>:
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
{
240192a4:	b580      	push	{r7, lr}
240192a6:	b082      	sub	sp, #8
240192a8:	af00      	add	r7, sp, #0
240192aa:	6078      	str	r0, [r7, #4]
240192ac:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
240192ae:	687b      	ldr	r3, [r7, #4]
240192b0:	681b      	ldr	r3, [r3, #0]
240192b2:	2200      	movs	r2, #0
240192b4:	6839      	ldr	r1, [r7, #0]
240192b6:	4618      	mov	r0, r3
240192b8:	f005 f956 	bl	2401e568 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
240192bc:	687b      	ldr	r3, [r7, #4]
240192be:	681b      	ldr	r3, [r3, #0]
240192c0:	4a3e      	ldr	r2, [pc, #248]	; (240193bc <HAL_TIM_PWM_Stop+0x118>)
240192c2:	4293      	cmp	r3, r2
240192c4:	d013      	beq.n	240192ee <HAL_TIM_PWM_Stop+0x4a>
240192c6:	687b      	ldr	r3, [r7, #4]
240192c8:	681b      	ldr	r3, [r3, #0]
240192ca:	4a3d      	ldr	r2, [pc, #244]	; (240193c0 <HAL_TIM_PWM_Stop+0x11c>)
240192cc:	4293      	cmp	r3, r2
240192ce:	d00e      	beq.n	240192ee <HAL_TIM_PWM_Stop+0x4a>
240192d0:	687b      	ldr	r3, [r7, #4]
240192d2:	681b      	ldr	r3, [r3, #0]
240192d4:	4a3b      	ldr	r2, [pc, #236]	; (240193c4 <HAL_TIM_PWM_Stop+0x120>)
240192d6:	4293      	cmp	r3, r2
240192d8:	d009      	beq.n	240192ee <HAL_TIM_PWM_Stop+0x4a>
240192da:	687b      	ldr	r3, [r7, #4]
240192dc:	681b      	ldr	r3, [r3, #0]
240192de:	4a3a      	ldr	r2, [pc, #232]	; (240193c8 <HAL_TIM_PWM_Stop+0x124>)
240192e0:	4293      	cmp	r3, r2
240192e2:	d004      	beq.n	240192ee <HAL_TIM_PWM_Stop+0x4a>
240192e4:	687b      	ldr	r3, [r7, #4]
240192e6:	681b      	ldr	r3, [r3, #0]
240192e8:	4a38      	ldr	r2, [pc, #224]	; (240193cc <HAL_TIM_PWM_Stop+0x128>)
240192ea:	4293      	cmp	r3, r2
240192ec:	d101      	bne.n	240192f2 <HAL_TIM_PWM_Stop+0x4e>
240192ee:	2301      	movs	r3, #1
240192f0:	e000      	b.n	240192f4 <HAL_TIM_PWM_Stop+0x50>
240192f2:	2300      	movs	r3, #0
240192f4:	2b00      	cmp	r3, #0
240192f6:	d017      	beq.n	24019328 <HAL_TIM_PWM_Stop+0x84>
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
240192f8:	687b      	ldr	r3, [r7, #4]
240192fa:	681b      	ldr	r3, [r3, #0]
240192fc:	6a1a      	ldr	r2, [r3, #32]
240192fe:	f241 1311 	movw	r3, #4369	; 0x1111
24019302:	4013      	ands	r3, r2
24019304:	2b00      	cmp	r3, #0
24019306:	d10f      	bne.n	24019328 <HAL_TIM_PWM_Stop+0x84>
24019308:	687b      	ldr	r3, [r7, #4]
2401930a:	681b      	ldr	r3, [r3, #0]
2401930c:	6a1a      	ldr	r2, [r3, #32]
2401930e:	f240 4344 	movw	r3, #1092	; 0x444
24019312:	4013      	ands	r3, r2
24019314:	2b00      	cmp	r3, #0
24019316:	d107      	bne.n	24019328 <HAL_TIM_PWM_Stop+0x84>
24019318:	687b      	ldr	r3, [r7, #4]
2401931a:	681b      	ldr	r3, [r3, #0]
2401931c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401931e:	687b      	ldr	r3, [r7, #4]
24019320:	681b      	ldr	r3, [r3, #0]
24019322:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24019326:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
24019328:	687b      	ldr	r3, [r7, #4]
2401932a:	681b      	ldr	r3, [r3, #0]
2401932c:	6a1a      	ldr	r2, [r3, #32]
2401932e:	f241 1311 	movw	r3, #4369	; 0x1111
24019332:	4013      	ands	r3, r2
24019334:	2b00      	cmp	r3, #0
24019336:	d10f      	bne.n	24019358 <HAL_TIM_PWM_Stop+0xb4>
24019338:	687b      	ldr	r3, [r7, #4]
2401933a:	681b      	ldr	r3, [r3, #0]
2401933c:	6a1a      	ldr	r2, [r3, #32]
2401933e:	f240 4344 	movw	r3, #1092	; 0x444
24019342:	4013      	ands	r3, r2
24019344:	2b00      	cmp	r3, #0
24019346:	d107      	bne.n	24019358 <HAL_TIM_PWM_Stop+0xb4>
24019348:	687b      	ldr	r3, [r7, #4]
2401934a:	681b      	ldr	r3, [r3, #0]
2401934c:	681a      	ldr	r2, [r3, #0]
2401934e:	687b      	ldr	r3, [r7, #4]
24019350:	681b      	ldr	r3, [r3, #0]
24019352:	f022 0201 	bic.w	r2, r2, #1
24019356:	601a      	str	r2, [r3, #0]

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
24019358:	683b      	ldr	r3, [r7, #0]
2401935a:	2b00      	cmp	r3, #0
2401935c:	d104      	bne.n	24019368 <HAL_TIM_PWM_Stop+0xc4>
2401935e:	687b      	ldr	r3, [r7, #4]
24019360:	2201      	movs	r2, #1
24019362:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24019366:	e023      	b.n	240193b0 <HAL_TIM_PWM_Stop+0x10c>
24019368:	683b      	ldr	r3, [r7, #0]
2401936a:	2b04      	cmp	r3, #4
2401936c:	d104      	bne.n	24019378 <HAL_TIM_PWM_Stop+0xd4>
2401936e:	687b      	ldr	r3, [r7, #4]
24019370:	2201      	movs	r2, #1
24019372:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24019376:	e01b      	b.n	240193b0 <HAL_TIM_PWM_Stop+0x10c>
24019378:	683b      	ldr	r3, [r7, #0]
2401937a:	2b08      	cmp	r3, #8
2401937c:	d104      	bne.n	24019388 <HAL_TIM_PWM_Stop+0xe4>
2401937e:	687b      	ldr	r3, [r7, #4]
24019380:	2201      	movs	r2, #1
24019382:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24019386:	e013      	b.n	240193b0 <HAL_TIM_PWM_Stop+0x10c>
24019388:	683b      	ldr	r3, [r7, #0]
2401938a:	2b0c      	cmp	r3, #12
2401938c:	d104      	bne.n	24019398 <HAL_TIM_PWM_Stop+0xf4>
2401938e:	687b      	ldr	r3, [r7, #4]
24019390:	2201      	movs	r2, #1
24019392:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24019396:	e00b      	b.n	240193b0 <HAL_TIM_PWM_Stop+0x10c>
24019398:	683b      	ldr	r3, [r7, #0]
2401939a:	2b10      	cmp	r3, #16
2401939c:	d104      	bne.n	240193a8 <HAL_TIM_PWM_Stop+0x104>
2401939e:	687b      	ldr	r3, [r7, #4]
240193a0:	2201      	movs	r2, #1
240193a2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
240193a6:	e003      	b.n	240193b0 <HAL_TIM_PWM_Stop+0x10c>
240193a8:	687b      	ldr	r3, [r7, #4]
240193aa:	2201      	movs	r2, #1
240193ac:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  /* Return function status */
  return HAL_OK;
240193b0:	2300      	movs	r3, #0
}
240193b2:	4618      	mov	r0, r3
240193b4:	3708      	adds	r7, #8
240193b6:	46bd      	mov	sp, r7
240193b8:	bd80      	pop	{r7, pc}
240193ba:	bf00      	nop
240193bc:	40010000 	.word	0x40010000
240193c0:	40010400 	.word	0x40010400
240193c4:	40014000 	.word	0x40014000
240193c8:	40014400 	.word	0x40014400
240193cc:	40014800 	.word	0x40014800

240193d0 <HAL_TIM_PWM_Start_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
240193d0:	b580      	push	{r7, lr}
240193d2:	b084      	sub	sp, #16
240193d4:	af00      	add	r7, sp, #0
240193d6:	6078      	str	r0, [r7, #4]
240193d8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
240193da:	2300      	movs	r3, #0
240193dc:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
240193de:	683b      	ldr	r3, [r7, #0]
240193e0:	2b00      	cmp	r3, #0
240193e2:	d109      	bne.n	240193f8 <HAL_TIM_PWM_Start_IT+0x28>
240193e4:	687b      	ldr	r3, [r7, #4]
240193e6:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
240193ea:	b2db      	uxtb	r3, r3
240193ec:	2b01      	cmp	r3, #1
240193ee:	bf14      	ite	ne
240193f0:	2301      	movne	r3, #1
240193f2:	2300      	moveq	r3, #0
240193f4:	b2db      	uxtb	r3, r3
240193f6:	e03c      	b.n	24019472 <HAL_TIM_PWM_Start_IT+0xa2>
240193f8:	683b      	ldr	r3, [r7, #0]
240193fa:	2b04      	cmp	r3, #4
240193fc:	d109      	bne.n	24019412 <HAL_TIM_PWM_Start_IT+0x42>
240193fe:	687b      	ldr	r3, [r7, #4]
24019400:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
24019404:	b2db      	uxtb	r3, r3
24019406:	2b01      	cmp	r3, #1
24019408:	bf14      	ite	ne
2401940a:	2301      	movne	r3, #1
2401940c:	2300      	moveq	r3, #0
2401940e:	b2db      	uxtb	r3, r3
24019410:	e02f      	b.n	24019472 <HAL_TIM_PWM_Start_IT+0xa2>
24019412:	683b      	ldr	r3, [r7, #0]
24019414:	2b08      	cmp	r3, #8
24019416:	d109      	bne.n	2401942c <HAL_TIM_PWM_Start_IT+0x5c>
24019418:	687b      	ldr	r3, [r7, #4]
2401941a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401941e:	b2db      	uxtb	r3, r3
24019420:	2b01      	cmp	r3, #1
24019422:	bf14      	ite	ne
24019424:	2301      	movne	r3, #1
24019426:	2300      	moveq	r3, #0
24019428:	b2db      	uxtb	r3, r3
2401942a:	e022      	b.n	24019472 <HAL_TIM_PWM_Start_IT+0xa2>
2401942c:	683b      	ldr	r3, [r7, #0]
2401942e:	2b0c      	cmp	r3, #12
24019430:	d109      	bne.n	24019446 <HAL_TIM_PWM_Start_IT+0x76>
24019432:	687b      	ldr	r3, [r7, #4]
24019434:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24019438:	b2db      	uxtb	r3, r3
2401943a:	2b01      	cmp	r3, #1
2401943c:	bf14      	ite	ne
2401943e:	2301      	movne	r3, #1
24019440:	2300      	moveq	r3, #0
24019442:	b2db      	uxtb	r3, r3
24019444:	e015      	b.n	24019472 <HAL_TIM_PWM_Start_IT+0xa2>
24019446:	683b      	ldr	r3, [r7, #0]
24019448:	2b10      	cmp	r3, #16
2401944a:	d109      	bne.n	24019460 <HAL_TIM_PWM_Start_IT+0x90>
2401944c:	687b      	ldr	r3, [r7, #4]
2401944e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
24019452:	b2db      	uxtb	r3, r3
24019454:	2b01      	cmp	r3, #1
24019456:	bf14      	ite	ne
24019458:	2301      	movne	r3, #1
2401945a:	2300      	moveq	r3, #0
2401945c:	b2db      	uxtb	r3, r3
2401945e:	e008      	b.n	24019472 <HAL_TIM_PWM_Start_IT+0xa2>
24019460:	687b      	ldr	r3, [r7, #4]
24019462:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
24019466:	b2db      	uxtb	r3, r3
24019468:	2b01      	cmp	r3, #1
2401946a:	bf14      	ite	ne
2401946c:	2301      	movne	r3, #1
2401946e:	2300      	moveq	r3, #0
24019470:	b2db      	uxtb	r3, r3
24019472:	2b00      	cmp	r3, #0
24019474:	d001      	beq.n	2401947a <HAL_TIM_PWM_Start_IT+0xaa>
  {
    return HAL_ERROR;
24019476:	2301      	movs	r3, #1
24019478:	e0ec      	b.n	24019654 <HAL_TIM_PWM_Start_IT+0x284>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401947a:	683b      	ldr	r3, [r7, #0]
2401947c:	2b00      	cmp	r3, #0
2401947e:	d104      	bne.n	2401948a <HAL_TIM_PWM_Start_IT+0xba>
24019480:	687b      	ldr	r3, [r7, #4]
24019482:	2202      	movs	r2, #2
24019484:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24019488:	e023      	b.n	240194d2 <HAL_TIM_PWM_Start_IT+0x102>
2401948a:	683b      	ldr	r3, [r7, #0]
2401948c:	2b04      	cmp	r3, #4
2401948e:	d104      	bne.n	2401949a <HAL_TIM_PWM_Start_IT+0xca>
24019490:	687b      	ldr	r3, [r7, #4]
24019492:	2202      	movs	r2, #2
24019494:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24019498:	e01b      	b.n	240194d2 <HAL_TIM_PWM_Start_IT+0x102>
2401949a:	683b      	ldr	r3, [r7, #0]
2401949c:	2b08      	cmp	r3, #8
2401949e:	d104      	bne.n	240194aa <HAL_TIM_PWM_Start_IT+0xda>
240194a0:	687b      	ldr	r3, [r7, #4]
240194a2:	2202      	movs	r2, #2
240194a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240194a8:	e013      	b.n	240194d2 <HAL_TIM_PWM_Start_IT+0x102>
240194aa:	683b      	ldr	r3, [r7, #0]
240194ac:	2b0c      	cmp	r3, #12
240194ae:	d104      	bne.n	240194ba <HAL_TIM_PWM_Start_IT+0xea>
240194b0:	687b      	ldr	r3, [r7, #4]
240194b2:	2202      	movs	r2, #2
240194b4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
240194b8:	e00b      	b.n	240194d2 <HAL_TIM_PWM_Start_IT+0x102>
240194ba:	683b      	ldr	r3, [r7, #0]
240194bc:	2b10      	cmp	r3, #16
240194be:	d104      	bne.n	240194ca <HAL_TIM_PWM_Start_IT+0xfa>
240194c0:	687b      	ldr	r3, [r7, #4]
240194c2:	2202      	movs	r2, #2
240194c4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
240194c8:	e003      	b.n	240194d2 <HAL_TIM_PWM_Start_IT+0x102>
240194ca:	687b      	ldr	r3, [r7, #4]
240194cc:	2202      	movs	r2, #2
240194ce:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  switch (Channel)
240194d2:	683b      	ldr	r3, [r7, #0]
240194d4:	2b0c      	cmp	r3, #12
240194d6:	d841      	bhi.n	2401955c <HAL_TIM_PWM_Start_IT+0x18c>
240194d8:	a201      	add	r2, pc, #4	; (adr r2, 240194e0 <HAL_TIM_PWM_Start_IT+0x110>)
240194da:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240194de:	bf00      	nop
240194e0:	24019515 	.word	0x24019515
240194e4:	2401955d 	.word	0x2401955d
240194e8:	2401955d 	.word	0x2401955d
240194ec:	2401955d 	.word	0x2401955d
240194f0:	24019527 	.word	0x24019527
240194f4:	2401955d 	.word	0x2401955d
240194f8:	2401955d 	.word	0x2401955d
240194fc:	2401955d 	.word	0x2401955d
24019500:	24019539 	.word	0x24019539
24019504:	2401955d 	.word	0x2401955d
24019508:	2401955d 	.word	0x2401955d
2401950c:	2401955d 	.word	0x2401955d
24019510:	2401954b 	.word	0x2401954b
  {
    case TIM_CHANNEL_1:
    {
      /* Enable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
24019514:	687b      	ldr	r3, [r7, #4]
24019516:	681b      	ldr	r3, [r3, #0]
24019518:	68da      	ldr	r2, [r3, #12]
2401951a:	687b      	ldr	r3, [r7, #4]
2401951c:	681b      	ldr	r3, [r3, #0]
2401951e:	f042 0202 	orr.w	r2, r2, #2
24019522:	60da      	str	r2, [r3, #12]
      break;
24019524:	e01d      	b.n	24019562 <HAL_TIM_PWM_Start_IT+0x192>
    }

    case TIM_CHANNEL_2:
    {
      /* Enable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
24019526:	687b      	ldr	r3, [r7, #4]
24019528:	681b      	ldr	r3, [r3, #0]
2401952a:	68da      	ldr	r2, [r3, #12]
2401952c:	687b      	ldr	r3, [r7, #4]
2401952e:	681b      	ldr	r3, [r3, #0]
24019530:	f042 0204 	orr.w	r2, r2, #4
24019534:	60da      	str	r2, [r3, #12]
      break;
24019536:	e014      	b.n	24019562 <HAL_TIM_PWM_Start_IT+0x192>
    }

    case TIM_CHANNEL_3:
    {
      /* Enable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
24019538:	687b      	ldr	r3, [r7, #4]
2401953a:	681b      	ldr	r3, [r3, #0]
2401953c:	68da      	ldr	r2, [r3, #12]
2401953e:	687b      	ldr	r3, [r7, #4]
24019540:	681b      	ldr	r3, [r3, #0]
24019542:	f042 0208 	orr.w	r2, r2, #8
24019546:	60da      	str	r2, [r3, #12]
      break;
24019548:	e00b      	b.n	24019562 <HAL_TIM_PWM_Start_IT+0x192>
    }

    case TIM_CHANNEL_4:
    {
      /* Enable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
2401954a:	687b      	ldr	r3, [r7, #4]
2401954c:	681b      	ldr	r3, [r3, #0]
2401954e:	68da      	ldr	r2, [r3, #12]
24019550:	687b      	ldr	r3, [r7, #4]
24019552:	681b      	ldr	r3, [r3, #0]
24019554:	f042 0210 	orr.w	r2, r2, #16
24019558:	60da      	str	r2, [r3, #12]
      break;
2401955a:	e002      	b.n	24019562 <HAL_TIM_PWM_Start_IT+0x192>
    }

    default:
      status = HAL_ERROR;
2401955c:	2301      	movs	r3, #1
2401955e:	73fb      	strb	r3, [r7, #15]
      break;
24019560:	bf00      	nop
  }

  if (status == HAL_OK)
24019562:	7bfb      	ldrb	r3, [r7, #15]
24019564:	2b00      	cmp	r3, #0
24019566:	d174      	bne.n	24019652 <HAL_TIM_PWM_Start_IT+0x282>
  {
    /* Enable the Capture compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
24019568:	687b      	ldr	r3, [r7, #4]
2401956a:	681b      	ldr	r3, [r3, #0]
2401956c:	2201      	movs	r2, #1
2401956e:	6839      	ldr	r1, [r7, #0]
24019570:	4618      	mov	r0, r3
24019572:	f004 fff9 	bl	2401e568 <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
24019576:	687b      	ldr	r3, [r7, #4]
24019578:	681b      	ldr	r3, [r3, #0]
2401957a:	4a38      	ldr	r2, [pc, #224]	; (2401965c <HAL_TIM_PWM_Start_IT+0x28c>)
2401957c:	4293      	cmp	r3, r2
2401957e:	d013      	beq.n	240195a8 <HAL_TIM_PWM_Start_IT+0x1d8>
24019580:	687b      	ldr	r3, [r7, #4]
24019582:	681b      	ldr	r3, [r3, #0]
24019584:	4a36      	ldr	r2, [pc, #216]	; (24019660 <HAL_TIM_PWM_Start_IT+0x290>)
24019586:	4293      	cmp	r3, r2
24019588:	d00e      	beq.n	240195a8 <HAL_TIM_PWM_Start_IT+0x1d8>
2401958a:	687b      	ldr	r3, [r7, #4]
2401958c:	681b      	ldr	r3, [r3, #0]
2401958e:	4a35      	ldr	r2, [pc, #212]	; (24019664 <HAL_TIM_PWM_Start_IT+0x294>)
24019590:	4293      	cmp	r3, r2
24019592:	d009      	beq.n	240195a8 <HAL_TIM_PWM_Start_IT+0x1d8>
24019594:	687b      	ldr	r3, [r7, #4]
24019596:	681b      	ldr	r3, [r3, #0]
24019598:	4a33      	ldr	r2, [pc, #204]	; (24019668 <HAL_TIM_PWM_Start_IT+0x298>)
2401959a:	4293      	cmp	r3, r2
2401959c:	d004      	beq.n	240195a8 <HAL_TIM_PWM_Start_IT+0x1d8>
2401959e:	687b      	ldr	r3, [r7, #4]
240195a0:	681b      	ldr	r3, [r3, #0]
240195a2:	4a32      	ldr	r2, [pc, #200]	; (2401966c <HAL_TIM_PWM_Start_IT+0x29c>)
240195a4:	4293      	cmp	r3, r2
240195a6:	d101      	bne.n	240195ac <HAL_TIM_PWM_Start_IT+0x1dc>
240195a8:	2301      	movs	r3, #1
240195aa:	e000      	b.n	240195ae <HAL_TIM_PWM_Start_IT+0x1de>
240195ac:	2300      	movs	r3, #0
240195ae:	2b00      	cmp	r3, #0
240195b0:	d007      	beq.n	240195c2 <HAL_TIM_PWM_Start_IT+0x1f2>
    {
      /* Enable the main output */
      __HAL_TIM_MOE_ENABLE(htim);
240195b2:	687b      	ldr	r3, [r7, #4]
240195b4:	681b      	ldr	r3, [r3, #0]
240195b6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
240195b8:	687b      	ldr	r3, [r7, #4]
240195ba:	681b      	ldr	r3, [r3, #0]
240195bc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
240195c0:	645a      	str	r2, [r3, #68]	; 0x44
    }

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
240195c2:	687b      	ldr	r3, [r7, #4]
240195c4:	681b      	ldr	r3, [r3, #0]
240195c6:	4a25      	ldr	r2, [pc, #148]	; (2401965c <HAL_TIM_PWM_Start_IT+0x28c>)
240195c8:	4293      	cmp	r3, r2
240195ca:	d022      	beq.n	24019612 <HAL_TIM_PWM_Start_IT+0x242>
240195cc:	687b      	ldr	r3, [r7, #4]
240195ce:	681b      	ldr	r3, [r3, #0]
240195d0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240195d4:	d01d      	beq.n	24019612 <HAL_TIM_PWM_Start_IT+0x242>
240195d6:	687b      	ldr	r3, [r7, #4]
240195d8:	681b      	ldr	r3, [r3, #0]
240195da:	4a25      	ldr	r2, [pc, #148]	; (24019670 <HAL_TIM_PWM_Start_IT+0x2a0>)
240195dc:	4293      	cmp	r3, r2
240195de:	d018      	beq.n	24019612 <HAL_TIM_PWM_Start_IT+0x242>
240195e0:	687b      	ldr	r3, [r7, #4]
240195e2:	681b      	ldr	r3, [r3, #0]
240195e4:	4a23      	ldr	r2, [pc, #140]	; (24019674 <HAL_TIM_PWM_Start_IT+0x2a4>)
240195e6:	4293      	cmp	r3, r2
240195e8:	d013      	beq.n	24019612 <HAL_TIM_PWM_Start_IT+0x242>
240195ea:	687b      	ldr	r3, [r7, #4]
240195ec:	681b      	ldr	r3, [r3, #0]
240195ee:	4a22      	ldr	r2, [pc, #136]	; (24019678 <HAL_TIM_PWM_Start_IT+0x2a8>)
240195f0:	4293      	cmp	r3, r2
240195f2:	d00e      	beq.n	24019612 <HAL_TIM_PWM_Start_IT+0x242>
240195f4:	687b      	ldr	r3, [r7, #4]
240195f6:	681b      	ldr	r3, [r3, #0]
240195f8:	4a19      	ldr	r2, [pc, #100]	; (24019660 <HAL_TIM_PWM_Start_IT+0x290>)
240195fa:	4293      	cmp	r3, r2
240195fc:	d009      	beq.n	24019612 <HAL_TIM_PWM_Start_IT+0x242>
240195fe:	687b      	ldr	r3, [r7, #4]
24019600:	681b      	ldr	r3, [r3, #0]
24019602:	4a1e      	ldr	r2, [pc, #120]	; (2401967c <HAL_TIM_PWM_Start_IT+0x2ac>)
24019604:	4293      	cmp	r3, r2
24019606:	d004      	beq.n	24019612 <HAL_TIM_PWM_Start_IT+0x242>
24019608:	687b      	ldr	r3, [r7, #4]
2401960a:	681b      	ldr	r3, [r3, #0]
2401960c:	4a15      	ldr	r2, [pc, #84]	; (24019664 <HAL_TIM_PWM_Start_IT+0x294>)
2401960e:	4293      	cmp	r3, r2
24019610:	d115      	bne.n	2401963e <HAL_TIM_PWM_Start_IT+0x26e>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
24019612:	687b      	ldr	r3, [r7, #4]
24019614:	681b      	ldr	r3, [r3, #0]
24019616:	689a      	ldr	r2, [r3, #8]
24019618:	4b19      	ldr	r3, [pc, #100]	; (24019680 <HAL_TIM_PWM_Start_IT+0x2b0>)
2401961a:	4013      	ands	r3, r2
2401961c:	60bb      	str	r3, [r7, #8]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401961e:	68bb      	ldr	r3, [r7, #8]
24019620:	2b06      	cmp	r3, #6
24019622:	d015      	beq.n	24019650 <HAL_TIM_PWM_Start_IT+0x280>
24019624:	68bb      	ldr	r3, [r7, #8]
24019626:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401962a:	d011      	beq.n	24019650 <HAL_TIM_PWM_Start_IT+0x280>
      {
        __HAL_TIM_ENABLE(htim);
2401962c:	687b      	ldr	r3, [r7, #4]
2401962e:	681b      	ldr	r3, [r3, #0]
24019630:	681a      	ldr	r2, [r3, #0]
24019632:	687b      	ldr	r3, [r7, #4]
24019634:	681b      	ldr	r3, [r3, #0]
24019636:	f042 0201 	orr.w	r2, r2, #1
2401963a:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401963c:	e008      	b.n	24019650 <HAL_TIM_PWM_Start_IT+0x280>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
2401963e:	687b      	ldr	r3, [r7, #4]
24019640:	681b      	ldr	r3, [r3, #0]
24019642:	681a      	ldr	r2, [r3, #0]
24019644:	687b      	ldr	r3, [r7, #4]
24019646:	681b      	ldr	r3, [r3, #0]
24019648:	f042 0201 	orr.w	r2, r2, #1
2401964c:	601a      	str	r2, [r3, #0]
2401964e:	e000      	b.n	24019652 <HAL_TIM_PWM_Start_IT+0x282>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24019650:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
24019652:	7bfb      	ldrb	r3, [r7, #15]
}
24019654:	4618      	mov	r0, r3
24019656:	3710      	adds	r7, #16
24019658:	46bd      	mov	sp, r7
2401965a:	bd80      	pop	{r7, pc}
2401965c:	40010000 	.word	0x40010000
24019660:	40010400 	.word	0x40010400
24019664:	40014000 	.word	0x40014000
24019668:	40014400 	.word	0x40014400
2401966c:	40014800 	.word	0x40014800
24019670:	40000400 	.word	0x40000400
24019674:	40000800 	.word	0x40000800
24019678:	40000c00 	.word	0x40000c00
2401967c:	40001800 	.word	0x40001800
24019680:	00010007 	.word	0x00010007

24019684 <HAL_TIM_PWM_Stop_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
24019684:	b580      	push	{r7, lr}
24019686:	b084      	sub	sp, #16
24019688:	af00      	add	r7, sp, #0
2401968a:	6078      	str	r0, [r7, #4]
2401968c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401968e:	2300      	movs	r3, #0
24019690:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
24019692:	683b      	ldr	r3, [r7, #0]
24019694:	2b0c      	cmp	r3, #12
24019696:	d841      	bhi.n	2401971c <HAL_TIM_PWM_Stop_IT+0x98>
24019698:	a201      	add	r2, pc, #4	; (adr r2, 240196a0 <HAL_TIM_PWM_Stop_IT+0x1c>)
2401969a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401969e:	bf00      	nop
240196a0:	240196d5 	.word	0x240196d5
240196a4:	2401971d 	.word	0x2401971d
240196a8:	2401971d 	.word	0x2401971d
240196ac:	2401971d 	.word	0x2401971d
240196b0:	240196e7 	.word	0x240196e7
240196b4:	2401971d 	.word	0x2401971d
240196b8:	2401971d 	.word	0x2401971d
240196bc:	2401971d 	.word	0x2401971d
240196c0:	240196f9 	.word	0x240196f9
240196c4:	2401971d 	.word	0x2401971d
240196c8:	2401971d 	.word	0x2401971d
240196cc:	2401971d 	.word	0x2401971d
240196d0:	2401970b 	.word	0x2401970b
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
240196d4:	687b      	ldr	r3, [r7, #4]
240196d6:	681b      	ldr	r3, [r3, #0]
240196d8:	68da      	ldr	r2, [r3, #12]
240196da:	687b      	ldr	r3, [r7, #4]
240196dc:	681b      	ldr	r3, [r3, #0]
240196de:	f022 0202 	bic.w	r2, r2, #2
240196e2:	60da      	str	r2, [r3, #12]
      break;
240196e4:	e01d      	b.n	24019722 <HAL_TIM_PWM_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
240196e6:	687b      	ldr	r3, [r7, #4]
240196e8:	681b      	ldr	r3, [r3, #0]
240196ea:	68da      	ldr	r2, [r3, #12]
240196ec:	687b      	ldr	r3, [r7, #4]
240196ee:	681b      	ldr	r3, [r3, #0]
240196f0:	f022 0204 	bic.w	r2, r2, #4
240196f4:	60da      	str	r2, [r3, #12]
      break;
240196f6:	e014      	b.n	24019722 <HAL_TIM_PWM_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
240196f8:	687b      	ldr	r3, [r7, #4]
240196fa:	681b      	ldr	r3, [r3, #0]
240196fc:	68da      	ldr	r2, [r3, #12]
240196fe:	687b      	ldr	r3, [r7, #4]
24019700:	681b      	ldr	r3, [r3, #0]
24019702:	f022 0208 	bic.w	r2, r2, #8
24019706:	60da      	str	r2, [r3, #12]
      break;
24019708:	e00b      	b.n	24019722 <HAL_TIM_PWM_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_4:
    {
      /* Disable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
2401970a:	687b      	ldr	r3, [r7, #4]
2401970c:	681b      	ldr	r3, [r3, #0]
2401970e:	68da      	ldr	r2, [r3, #12]
24019710:	687b      	ldr	r3, [r7, #4]
24019712:	681b      	ldr	r3, [r3, #0]
24019714:	f022 0210 	bic.w	r2, r2, #16
24019718:	60da      	str	r2, [r3, #12]
      break;
2401971a:	e002      	b.n	24019722 <HAL_TIM_PWM_Stop_IT+0x9e>
    }

    default:
      status = HAL_ERROR;
2401971c:	2301      	movs	r3, #1
2401971e:	73fb      	strb	r3, [r7, #15]
      break;
24019720:	bf00      	nop
  }

  if (status == HAL_OK)
24019722:	7bfb      	ldrb	r3, [r7, #15]
24019724:	2b00      	cmp	r3, #0
24019726:	f040 8081 	bne.w	2401982c <HAL_TIM_PWM_Stop_IT+0x1a8>
  {
    /* Disable the Capture compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2401972a:	687b      	ldr	r3, [r7, #4]
2401972c:	681b      	ldr	r3, [r3, #0]
2401972e:	2200      	movs	r2, #0
24019730:	6839      	ldr	r1, [r7, #0]
24019732:	4618      	mov	r0, r3
24019734:	f004 ff18 	bl	2401e568 <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
24019738:	687b      	ldr	r3, [r7, #4]
2401973a:	681b      	ldr	r3, [r3, #0]
2401973c:	4a3e      	ldr	r2, [pc, #248]	; (24019838 <HAL_TIM_PWM_Stop_IT+0x1b4>)
2401973e:	4293      	cmp	r3, r2
24019740:	d013      	beq.n	2401976a <HAL_TIM_PWM_Stop_IT+0xe6>
24019742:	687b      	ldr	r3, [r7, #4]
24019744:	681b      	ldr	r3, [r3, #0]
24019746:	4a3d      	ldr	r2, [pc, #244]	; (2401983c <HAL_TIM_PWM_Stop_IT+0x1b8>)
24019748:	4293      	cmp	r3, r2
2401974a:	d00e      	beq.n	2401976a <HAL_TIM_PWM_Stop_IT+0xe6>
2401974c:	687b      	ldr	r3, [r7, #4]
2401974e:	681b      	ldr	r3, [r3, #0]
24019750:	4a3b      	ldr	r2, [pc, #236]	; (24019840 <HAL_TIM_PWM_Stop_IT+0x1bc>)
24019752:	4293      	cmp	r3, r2
24019754:	d009      	beq.n	2401976a <HAL_TIM_PWM_Stop_IT+0xe6>
24019756:	687b      	ldr	r3, [r7, #4]
24019758:	681b      	ldr	r3, [r3, #0]
2401975a:	4a3a      	ldr	r2, [pc, #232]	; (24019844 <HAL_TIM_PWM_Stop_IT+0x1c0>)
2401975c:	4293      	cmp	r3, r2
2401975e:	d004      	beq.n	2401976a <HAL_TIM_PWM_Stop_IT+0xe6>
24019760:	687b      	ldr	r3, [r7, #4]
24019762:	681b      	ldr	r3, [r3, #0]
24019764:	4a38      	ldr	r2, [pc, #224]	; (24019848 <HAL_TIM_PWM_Stop_IT+0x1c4>)
24019766:	4293      	cmp	r3, r2
24019768:	d101      	bne.n	2401976e <HAL_TIM_PWM_Stop_IT+0xea>
2401976a:	2301      	movs	r3, #1
2401976c:	e000      	b.n	24019770 <HAL_TIM_PWM_Stop_IT+0xec>
2401976e:	2300      	movs	r3, #0
24019770:	2b00      	cmp	r3, #0
24019772:	d017      	beq.n	240197a4 <HAL_TIM_PWM_Stop_IT+0x120>
    {
      /* Disable the Main Output */
      __HAL_TIM_MOE_DISABLE(htim);
24019774:	687b      	ldr	r3, [r7, #4]
24019776:	681b      	ldr	r3, [r3, #0]
24019778:	6a1a      	ldr	r2, [r3, #32]
2401977a:	f241 1311 	movw	r3, #4369	; 0x1111
2401977e:	4013      	ands	r3, r2
24019780:	2b00      	cmp	r3, #0
24019782:	d10f      	bne.n	240197a4 <HAL_TIM_PWM_Stop_IT+0x120>
24019784:	687b      	ldr	r3, [r7, #4]
24019786:	681b      	ldr	r3, [r3, #0]
24019788:	6a1a      	ldr	r2, [r3, #32]
2401978a:	f240 4344 	movw	r3, #1092	; 0x444
2401978e:	4013      	ands	r3, r2
24019790:	2b00      	cmp	r3, #0
24019792:	d107      	bne.n	240197a4 <HAL_TIM_PWM_Stop_IT+0x120>
24019794:	687b      	ldr	r3, [r7, #4]
24019796:	681b      	ldr	r3, [r3, #0]
24019798:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401979a:	687b      	ldr	r3, [r7, #4]
2401979c:	681b      	ldr	r3, [r3, #0]
2401979e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
240197a2:	645a      	str	r2, [r3, #68]	; 0x44
    }

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
240197a4:	687b      	ldr	r3, [r7, #4]
240197a6:	681b      	ldr	r3, [r3, #0]
240197a8:	6a1a      	ldr	r2, [r3, #32]
240197aa:	f241 1311 	movw	r3, #4369	; 0x1111
240197ae:	4013      	ands	r3, r2
240197b0:	2b00      	cmp	r3, #0
240197b2:	d10f      	bne.n	240197d4 <HAL_TIM_PWM_Stop_IT+0x150>
240197b4:	687b      	ldr	r3, [r7, #4]
240197b6:	681b      	ldr	r3, [r3, #0]
240197b8:	6a1a      	ldr	r2, [r3, #32]
240197ba:	f240 4344 	movw	r3, #1092	; 0x444
240197be:	4013      	ands	r3, r2
240197c0:	2b00      	cmp	r3, #0
240197c2:	d107      	bne.n	240197d4 <HAL_TIM_PWM_Stop_IT+0x150>
240197c4:	687b      	ldr	r3, [r7, #4]
240197c6:	681b      	ldr	r3, [r3, #0]
240197c8:	681a      	ldr	r2, [r3, #0]
240197ca:	687b      	ldr	r3, [r7, #4]
240197cc:	681b      	ldr	r3, [r3, #0]
240197ce:	f022 0201 	bic.w	r2, r2, #1
240197d2:	601a      	str	r2, [r3, #0]

    /* Set the TIM channel state */
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
240197d4:	683b      	ldr	r3, [r7, #0]
240197d6:	2b00      	cmp	r3, #0
240197d8:	d104      	bne.n	240197e4 <HAL_TIM_PWM_Stop_IT+0x160>
240197da:	687b      	ldr	r3, [r7, #4]
240197dc:	2201      	movs	r2, #1
240197de:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
240197e2:	e023      	b.n	2401982c <HAL_TIM_PWM_Stop_IT+0x1a8>
240197e4:	683b      	ldr	r3, [r7, #0]
240197e6:	2b04      	cmp	r3, #4
240197e8:	d104      	bne.n	240197f4 <HAL_TIM_PWM_Stop_IT+0x170>
240197ea:	687b      	ldr	r3, [r7, #4]
240197ec:	2201      	movs	r2, #1
240197ee:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
240197f2:	e01b      	b.n	2401982c <HAL_TIM_PWM_Stop_IT+0x1a8>
240197f4:	683b      	ldr	r3, [r7, #0]
240197f6:	2b08      	cmp	r3, #8
240197f8:	d104      	bne.n	24019804 <HAL_TIM_PWM_Stop_IT+0x180>
240197fa:	687b      	ldr	r3, [r7, #4]
240197fc:	2201      	movs	r2, #1
240197fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24019802:	e013      	b.n	2401982c <HAL_TIM_PWM_Stop_IT+0x1a8>
24019804:	683b      	ldr	r3, [r7, #0]
24019806:	2b0c      	cmp	r3, #12
24019808:	d104      	bne.n	24019814 <HAL_TIM_PWM_Stop_IT+0x190>
2401980a:	687b      	ldr	r3, [r7, #4]
2401980c:	2201      	movs	r2, #1
2401980e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24019812:	e00b      	b.n	2401982c <HAL_TIM_PWM_Stop_IT+0x1a8>
24019814:	683b      	ldr	r3, [r7, #0]
24019816:	2b10      	cmp	r3, #16
24019818:	d104      	bne.n	24019824 <HAL_TIM_PWM_Stop_IT+0x1a0>
2401981a:	687b      	ldr	r3, [r7, #4]
2401981c:	2201      	movs	r2, #1
2401981e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24019822:	e003      	b.n	2401982c <HAL_TIM_PWM_Stop_IT+0x1a8>
24019824:	687b      	ldr	r3, [r7, #4]
24019826:	2201      	movs	r2, #1
24019828:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  }

  /* Return function status */
  return status;
2401982c:	7bfb      	ldrb	r3, [r7, #15]
}
2401982e:	4618      	mov	r0, r3
24019830:	3710      	adds	r7, #16
24019832:	46bd      	mov	sp, r7
24019834:	bd80      	pop	{r7, pc}
24019836:	bf00      	nop
24019838:	40010000 	.word	0x40010000
2401983c:	40010400 	.word	0x40010400
24019840:	40014000 	.word	0x40014000
24019844:	40014400 	.word	0x40014400
24019848:	40014800 	.word	0x40014800

2401984c <HAL_TIM_PWM_Start_DMA>:
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
                                        uint16_t Length)
{
2401984c:	b580      	push	{r7, lr}
2401984e:	b086      	sub	sp, #24
24019850:	af00      	add	r7, sp, #0
24019852:	60f8      	str	r0, [r7, #12]
24019854:	60b9      	str	r1, [r7, #8]
24019856:	607a      	str	r2, [r7, #4]
24019858:	807b      	strh	r3, [r7, #2]
  HAL_StatusTypeDef status = HAL_OK;
2401985a:	2300      	movs	r3, #0
2401985c:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Set the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
2401985e:	68bb      	ldr	r3, [r7, #8]
24019860:	2b00      	cmp	r3, #0
24019862:	d109      	bne.n	24019878 <HAL_TIM_PWM_Start_DMA+0x2c>
24019864:	68fb      	ldr	r3, [r7, #12]
24019866:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401986a:	b2db      	uxtb	r3, r3
2401986c:	2b02      	cmp	r3, #2
2401986e:	bf0c      	ite	eq
24019870:	2301      	moveq	r3, #1
24019872:	2300      	movne	r3, #0
24019874:	b2db      	uxtb	r3, r3
24019876:	e03c      	b.n	240198f2 <HAL_TIM_PWM_Start_DMA+0xa6>
24019878:	68bb      	ldr	r3, [r7, #8]
2401987a:	2b04      	cmp	r3, #4
2401987c:	d109      	bne.n	24019892 <HAL_TIM_PWM_Start_DMA+0x46>
2401987e:	68fb      	ldr	r3, [r7, #12]
24019880:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
24019884:	b2db      	uxtb	r3, r3
24019886:	2b02      	cmp	r3, #2
24019888:	bf0c      	ite	eq
2401988a:	2301      	moveq	r3, #1
2401988c:	2300      	movne	r3, #0
2401988e:	b2db      	uxtb	r3, r3
24019890:	e02f      	b.n	240198f2 <HAL_TIM_PWM_Start_DMA+0xa6>
24019892:	68bb      	ldr	r3, [r7, #8]
24019894:	2b08      	cmp	r3, #8
24019896:	d109      	bne.n	240198ac <HAL_TIM_PWM_Start_DMA+0x60>
24019898:	68fb      	ldr	r3, [r7, #12]
2401989a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401989e:	b2db      	uxtb	r3, r3
240198a0:	2b02      	cmp	r3, #2
240198a2:	bf0c      	ite	eq
240198a4:	2301      	moveq	r3, #1
240198a6:	2300      	movne	r3, #0
240198a8:	b2db      	uxtb	r3, r3
240198aa:	e022      	b.n	240198f2 <HAL_TIM_PWM_Start_DMA+0xa6>
240198ac:	68bb      	ldr	r3, [r7, #8]
240198ae:	2b0c      	cmp	r3, #12
240198b0:	d109      	bne.n	240198c6 <HAL_TIM_PWM_Start_DMA+0x7a>
240198b2:	68fb      	ldr	r3, [r7, #12]
240198b4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240198b8:	b2db      	uxtb	r3, r3
240198ba:	2b02      	cmp	r3, #2
240198bc:	bf0c      	ite	eq
240198be:	2301      	moveq	r3, #1
240198c0:	2300      	movne	r3, #0
240198c2:	b2db      	uxtb	r3, r3
240198c4:	e015      	b.n	240198f2 <HAL_TIM_PWM_Start_DMA+0xa6>
240198c6:	68bb      	ldr	r3, [r7, #8]
240198c8:	2b10      	cmp	r3, #16
240198ca:	d109      	bne.n	240198e0 <HAL_TIM_PWM_Start_DMA+0x94>
240198cc:	68fb      	ldr	r3, [r7, #12]
240198ce:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
240198d2:	b2db      	uxtb	r3, r3
240198d4:	2b02      	cmp	r3, #2
240198d6:	bf0c      	ite	eq
240198d8:	2301      	moveq	r3, #1
240198da:	2300      	movne	r3, #0
240198dc:	b2db      	uxtb	r3, r3
240198de:	e008      	b.n	240198f2 <HAL_TIM_PWM_Start_DMA+0xa6>
240198e0:	68fb      	ldr	r3, [r7, #12]
240198e2:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
240198e6:	b2db      	uxtb	r3, r3
240198e8:	2b02      	cmp	r3, #2
240198ea:	bf0c      	ite	eq
240198ec:	2301      	moveq	r3, #1
240198ee:	2300      	movne	r3, #0
240198f0:	b2db      	uxtb	r3, r3
240198f2:	2b00      	cmp	r3, #0
240198f4:	d001      	beq.n	240198fa <HAL_TIM_PWM_Start_DMA+0xae>
  {
    return HAL_BUSY;
240198f6:	2302      	movs	r3, #2
240198f8:	e1b0      	b.n	24019c5c <HAL_TIM_PWM_Start_DMA+0x410>
  }
  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
240198fa:	68bb      	ldr	r3, [r7, #8]
240198fc:	2b00      	cmp	r3, #0
240198fe:	d109      	bne.n	24019914 <HAL_TIM_PWM_Start_DMA+0xc8>
24019900:	68fb      	ldr	r3, [r7, #12]
24019902:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
24019906:	b2db      	uxtb	r3, r3
24019908:	2b01      	cmp	r3, #1
2401990a:	bf0c      	ite	eq
2401990c:	2301      	moveq	r3, #1
2401990e:	2300      	movne	r3, #0
24019910:	b2db      	uxtb	r3, r3
24019912:	e03c      	b.n	2401998e <HAL_TIM_PWM_Start_DMA+0x142>
24019914:	68bb      	ldr	r3, [r7, #8]
24019916:	2b04      	cmp	r3, #4
24019918:	d109      	bne.n	2401992e <HAL_TIM_PWM_Start_DMA+0xe2>
2401991a:	68fb      	ldr	r3, [r7, #12]
2401991c:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
24019920:	b2db      	uxtb	r3, r3
24019922:	2b01      	cmp	r3, #1
24019924:	bf0c      	ite	eq
24019926:	2301      	moveq	r3, #1
24019928:	2300      	movne	r3, #0
2401992a:	b2db      	uxtb	r3, r3
2401992c:	e02f      	b.n	2401998e <HAL_TIM_PWM_Start_DMA+0x142>
2401992e:	68bb      	ldr	r3, [r7, #8]
24019930:	2b08      	cmp	r3, #8
24019932:	d109      	bne.n	24019948 <HAL_TIM_PWM_Start_DMA+0xfc>
24019934:	68fb      	ldr	r3, [r7, #12]
24019936:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401993a:	b2db      	uxtb	r3, r3
2401993c:	2b01      	cmp	r3, #1
2401993e:	bf0c      	ite	eq
24019940:	2301      	moveq	r3, #1
24019942:	2300      	movne	r3, #0
24019944:	b2db      	uxtb	r3, r3
24019946:	e022      	b.n	2401998e <HAL_TIM_PWM_Start_DMA+0x142>
24019948:	68bb      	ldr	r3, [r7, #8]
2401994a:	2b0c      	cmp	r3, #12
2401994c:	d109      	bne.n	24019962 <HAL_TIM_PWM_Start_DMA+0x116>
2401994e:	68fb      	ldr	r3, [r7, #12]
24019950:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24019954:	b2db      	uxtb	r3, r3
24019956:	2b01      	cmp	r3, #1
24019958:	bf0c      	ite	eq
2401995a:	2301      	moveq	r3, #1
2401995c:	2300      	movne	r3, #0
2401995e:	b2db      	uxtb	r3, r3
24019960:	e015      	b.n	2401998e <HAL_TIM_PWM_Start_DMA+0x142>
24019962:	68bb      	ldr	r3, [r7, #8]
24019964:	2b10      	cmp	r3, #16
24019966:	d109      	bne.n	2401997c <HAL_TIM_PWM_Start_DMA+0x130>
24019968:	68fb      	ldr	r3, [r7, #12]
2401996a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2401996e:	b2db      	uxtb	r3, r3
24019970:	2b01      	cmp	r3, #1
24019972:	bf0c      	ite	eq
24019974:	2301      	moveq	r3, #1
24019976:	2300      	movne	r3, #0
24019978:	b2db      	uxtb	r3, r3
2401997a:	e008      	b.n	2401998e <HAL_TIM_PWM_Start_DMA+0x142>
2401997c:	68fb      	ldr	r3, [r7, #12]
2401997e:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
24019982:	b2db      	uxtb	r3, r3
24019984:	2b01      	cmp	r3, #1
24019986:	bf0c      	ite	eq
24019988:	2301      	moveq	r3, #1
2401998a:	2300      	movne	r3, #0
2401998c:	b2db      	uxtb	r3, r3
2401998e:	2b00      	cmp	r3, #0
24019990:	d034      	beq.n	240199fc <HAL_TIM_PWM_Start_DMA+0x1b0>
  {
    if ((pData == NULL) || (Length == 0U))
24019992:	687b      	ldr	r3, [r7, #4]
24019994:	2b00      	cmp	r3, #0
24019996:	d002      	beq.n	2401999e <HAL_TIM_PWM_Start_DMA+0x152>
24019998:	887b      	ldrh	r3, [r7, #2]
2401999a:	2b00      	cmp	r3, #0
2401999c:	d101      	bne.n	240199a2 <HAL_TIM_PWM_Start_DMA+0x156>
    {
      return HAL_ERROR;
2401999e:	2301      	movs	r3, #1
240199a0:	e15c      	b.n	24019c5c <HAL_TIM_PWM_Start_DMA+0x410>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
240199a2:	68bb      	ldr	r3, [r7, #8]
240199a4:	2b00      	cmp	r3, #0
240199a6:	d104      	bne.n	240199b2 <HAL_TIM_PWM_Start_DMA+0x166>
240199a8:	68fb      	ldr	r3, [r7, #12]
240199aa:	2202      	movs	r2, #2
240199ac:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
240199b0:	e026      	b.n	24019a00 <HAL_TIM_PWM_Start_DMA+0x1b4>
240199b2:	68bb      	ldr	r3, [r7, #8]
240199b4:	2b04      	cmp	r3, #4
240199b6:	d104      	bne.n	240199c2 <HAL_TIM_PWM_Start_DMA+0x176>
240199b8:	68fb      	ldr	r3, [r7, #12]
240199ba:	2202      	movs	r2, #2
240199bc:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
240199c0:	e01e      	b.n	24019a00 <HAL_TIM_PWM_Start_DMA+0x1b4>
240199c2:	68bb      	ldr	r3, [r7, #8]
240199c4:	2b08      	cmp	r3, #8
240199c6:	d104      	bne.n	240199d2 <HAL_TIM_PWM_Start_DMA+0x186>
240199c8:	68fb      	ldr	r3, [r7, #12]
240199ca:	2202      	movs	r2, #2
240199cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240199d0:	e016      	b.n	24019a00 <HAL_TIM_PWM_Start_DMA+0x1b4>
240199d2:	68bb      	ldr	r3, [r7, #8]
240199d4:	2b0c      	cmp	r3, #12
240199d6:	d104      	bne.n	240199e2 <HAL_TIM_PWM_Start_DMA+0x196>
240199d8:	68fb      	ldr	r3, [r7, #12]
240199da:	2202      	movs	r2, #2
240199dc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
240199e0:	e00e      	b.n	24019a00 <HAL_TIM_PWM_Start_DMA+0x1b4>
240199e2:	68bb      	ldr	r3, [r7, #8]
240199e4:	2b10      	cmp	r3, #16
240199e6:	d104      	bne.n	240199f2 <HAL_TIM_PWM_Start_DMA+0x1a6>
240199e8:	68fb      	ldr	r3, [r7, #12]
240199ea:	2202      	movs	r2, #2
240199ec:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
240199f0:	e006      	b.n	24019a00 <HAL_TIM_PWM_Start_DMA+0x1b4>
240199f2:	68fb      	ldr	r3, [r7, #12]
240199f4:	2202      	movs	r2, #2
240199f6:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
240199fa:	e001      	b.n	24019a00 <HAL_TIM_PWM_Start_DMA+0x1b4>
    }
  }
  else
  {
    return HAL_ERROR;
240199fc:	2301      	movs	r3, #1
240199fe:	e12d      	b.n	24019c5c <HAL_TIM_PWM_Start_DMA+0x410>
  }

  switch (Channel)
24019a00:	68bb      	ldr	r3, [r7, #8]
24019a02:	2b0c      	cmp	r3, #12
24019a04:	f200 80ae 	bhi.w	24019b64 <HAL_TIM_PWM_Start_DMA+0x318>
24019a08:	a201      	add	r2, pc, #4	; (adr r2, 24019a10 <HAL_TIM_PWM_Start_DMA+0x1c4>)
24019a0a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24019a0e:	bf00      	nop
24019a10:	24019a45 	.word	0x24019a45
24019a14:	24019b65 	.word	0x24019b65
24019a18:	24019b65 	.word	0x24019b65
24019a1c:	24019b65 	.word	0x24019b65
24019a20:	24019a8d 	.word	0x24019a8d
24019a24:	24019b65 	.word	0x24019b65
24019a28:	24019b65 	.word	0x24019b65
24019a2c:	24019b65 	.word	0x24019b65
24019a30:	24019ad5 	.word	0x24019ad5
24019a34:	24019b65 	.word	0x24019b65
24019a38:	24019b65 	.word	0x24019b65
24019a3c:	24019b65 	.word	0x24019b65
24019a40:	24019b1d 	.word	0x24019b1d
  {
    case TIM_CHANNEL_1:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
24019a44:	68fb      	ldr	r3, [r7, #12]
24019a46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24019a48:	4a86      	ldr	r2, [pc, #536]	; (24019c64 <HAL_TIM_PWM_Start_DMA+0x418>)
24019a4a:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
24019a4c:	68fb      	ldr	r3, [r7, #12]
24019a4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24019a50:	4a85      	ldr	r2, [pc, #532]	; (24019c68 <HAL_TIM_PWM_Start_DMA+0x41c>)
24019a52:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
24019a54:	68fb      	ldr	r3, [r7, #12]
24019a56:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24019a58:	4a84      	ldr	r2, [pc, #528]	; (24019c6c <HAL_TIM_PWM_Start_DMA+0x420>)
24019a5a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
24019a5c:	68fb      	ldr	r3, [r7, #12]
24019a5e:	6a58      	ldr	r0, [r3, #36]	; 0x24
24019a60:	6879      	ldr	r1, [r7, #4]
24019a62:	68fb      	ldr	r3, [r7, #12]
24019a64:	681b      	ldr	r3, [r3, #0]
24019a66:	3334      	adds	r3, #52	; 0x34
24019a68:	461a      	mov	r2, r3
24019a6a:	887b      	ldrh	r3, [r7, #2]
24019a6c:	f7ea f870 	bl	24003b50 <HAL_DMA_Start_IT>
24019a70:	4603      	mov	r3, r0
24019a72:	2b00      	cmp	r3, #0
24019a74:	d001      	beq.n	24019a7a <HAL_TIM_PWM_Start_DMA+0x22e>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
24019a76:	2301      	movs	r3, #1
24019a78:	e0f0      	b.n	24019c5c <HAL_TIM_PWM_Start_DMA+0x410>
      }

      /* Enable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
24019a7a:	68fb      	ldr	r3, [r7, #12]
24019a7c:	681b      	ldr	r3, [r3, #0]
24019a7e:	68da      	ldr	r2, [r3, #12]
24019a80:	68fb      	ldr	r3, [r7, #12]
24019a82:	681b      	ldr	r3, [r3, #0]
24019a84:	f442 7200 	orr.w	r2, r2, #512	; 0x200
24019a88:	60da      	str	r2, [r3, #12]
      break;
24019a8a:	e06e      	b.n	24019b6a <HAL_TIM_PWM_Start_DMA+0x31e>
    }

    case TIM_CHANNEL_2:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
24019a8c:	68fb      	ldr	r3, [r7, #12]
24019a8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24019a90:	4a74      	ldr	r2, [pc, #464]	; (24019c64 <HAL_TIM_PWM_Start_DMA+0x418>)
24019a92:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
24019a94:	68fb      	ldr	r3, [r7, #12]
24019a96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24019a98:	4a73      	ldr	r2, [pc, #460]	; (24019c68 <HAL_TIM_PWM_Start_DMA+0x41c>)
24019a9a:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
24019a9c:	68fb      	ldr	r3, [r7, #12]
24019a9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24019aa0:	4a72      	ldr	r2, [pc, #456]	; (24019c6c <HAL_TIM_PWM_Start_DMA+0x420>)
24019aa2:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
24019aa4:	68fb      	ldr	r3, [r7, #12]
24019aa6:	6a98      	ldr	r0, [r3, #40]	; 0x28
24019aa8:	6879      	ldr	r1, [r7, #4]
24019aaa:	68fb      	ldr	r3, [r7, #12]
24019aac:	681b      	ldr	r3, [r3, #0]
24019aae:	3338      	adds	r3, #56	; 0x38
24019ab0:	461a      	mov	r2, r3
24019ab2:	887b      	ldrh	r3, [r7, #2]
24019ab4:	f7ea f84c 	bl	24003b50 <HAL_DMA_Start_IT>
24019ab8:	4603      	mov	r3, r0
24019aba:	2b00      	cmp	r3, #0
24019abc:	d001      	beq.n	24019ac2 <HAL_TIM_PWM_Start_DMA+0x276>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
24019abe:	2301      	movs	r3, #1
24019ac0:	e0cc      	b.n	24019c5c <HAL_TIM_PWM_Start_DMA+0x410>
      }
      /* Enable the TIM Capture/Compare 2 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
24019ac2:	68fb      	ldr	r3, [r7, #12]
24019ac4:	681b      	ldr	r3, [r3, #0]
24019ac6:	68da      	ldr	r2, [r3, #12]
24019ac8:	68fb      	ldr	r3, [r7, #12]
24019aca:	681b      	ldr	r3, [r3, #0]
24019acc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
24019ad0:	60da      	str	r2, [r3, #12]
      break;
24019ad2:	e04a      	b.n	24019b6a <HAL_TIM_PWM_Start_DMA+0x31e>
    }

    case TIM_CHANNEL_3:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
24019ad4:	68fb      	ldr	r3, [r7, #12]
24019ad6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24019ad8:	4a62      	ldr	r2, [pc, #392]	; (24019c64 <HAL_TIM_PWM_Start_DMA+0x418>)
24019ada:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
24019adc:	68fb      	ldr	r3, [r7, #12]
24019ade:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24019ae0:	4a61      	ldr	r2, [pc, #388]	; (24019c68 <HAL_TIM_PWM_Start_DMA+0x41c>)
24019ae2:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
24019ae4:	68fb      	ldr	r3, [r7, #12]
24019ae6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24019ae8:	4a60      	ldr	r2, [pc, #384]	; (24019c6c <HAL_TIM_PWM_Start_DMA+0x420>)
24019aea:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
24019aec:	68fb      	ldr	r3, [r7, #12]
24019aee:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
24019af0:	6879      	ldr	r1, [r7, #4]
24019af2:	68fb      	ldr	r3, [r7, #12]
24019af4:	681b      	ldr	r3, [r3, #0]
24019af6:	333c      	adds	r3, #60	; 0x3c
24019af8:	461a      	mov	r2, r3
24019afa:	887b      	ldrh	r3, [r7, #2]
24019afc:	f7ea f828 	bl	24003b50 <HAL_DMA_Start_IT>
24019b00:	4603      	mov	r3, r0
24019b02:	2b00      	cmp	r3, #0
24019b04:	d001      	beq.n	24019b0a <HAL_TIM_PWM_Start_DMA+0x2be>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
24019b06:	2301      	movs	r3, #1
24019b08:	e0a8      	b.n	24019c5c <HAL_TIM_PWM_Start_DMA+0x410>
      }
      /* Enable the TIM Output Capture/Compare 3 request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
24019b0a:	68fb      	ldr	r3, [r7, #12]
24019b0c:	681b      	ldr	r3, [r3, #0]
24019b0e:	68da      	ldr	r2, [r3, #12]
24019b10:	68fb      	ldr	r3, [r7, #12]
24019b12:	681b      	ldr	r3, [r3, #0]
24019b14:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
24019b18:	60da      	str	r2, [r3, #12]
      break;
24019b1a:	e026      	b.n	24019b6a <HAL_TIM_PWM_Start_DMA+0x31e>
    }

    case TIM_CHANNEL_4:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
24019b1c:	68fb      	ldr	r3, [r7, #12]
24019b1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24019b20:	4a50      	ldr	r2, [pc, #320]	; (24019c64 <HAL_TIM_PWM_Start_DMA+0x418>)
24019b22:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
24019b24:	68fb      	ldr	r3, [r7, #12]
24019b26:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24019b28:	4a4f      	ldr	r2, [pc, #316]	; (24019c68 <HAL_TIM_PWM_Start_DMA+0x41c>)
24019b2a:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
24019b2c:	68fb      	ldr	r3, [r7, #12]
24019b2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24019b30:	4a4e      	ldr	r2, [pc, #312]	; (24019c6c <HAL_TIM_PWM_Start_DMA+0x420>)
24019b32:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,
24019b34:	68fb      	ldr	r3, [r7, #12]
24019b36:	6b18      	ldr	r0, [r3, #48]	; 0x30
24019b38:	6879      	ldr	r1, [r7, #4]
24019b3a:	68fb      	ldr	r3, [r7, #12]
24019b3c:	681b      	ldr	r3, [r3, #0]
24019b3e:	3340      	adds	r3, #64	; 0x40
24019b40:	461a      	mov	r2, r3
24019b42:	887b      	ldrh	r3, [r7, #2]
24019b44:	f7ea f804 	bl	24003b50 <HAL_DMA_Start_IT>
24019b48:	4603      	mov	r3, r0
24019b4a:	2b00      	cmp	r3, #0
24019b4c:	d001      	beq.n	24019b52 <HAL_TIM_PWM_Start_DMA+0x306>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
24019b4e:	2301      	movs	r3, #1
24019b50:	e084      	b.n	24019c5c <HAL_TIM_PWM_Start_DMA+0x410>
      }
      /* Enable the TIM Capture/Compare 4 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
24019b52:	68fb      	ldr	r3, [r7, #12]
24019b54:	681b      	ldr	r3, [r3, #0]
24019b56:	68da      	ldr	r2, [r3, #12]
24019b58:	68fb      	ldr	r3, [r7, #12]
24019b5a:	681b      	ldr	r3, [r3, #0]
24019b5c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
24019b60:	60da      	str	r2, [r3, #12]
      break;
24019b62:	e002      	b.n	24019b6a <HAL_TIM_PWM_Start_DMA+0x31e>
    }

    default:
      status = HAL_ERROR;
24019b64:	2301      	movs	r3, #1
24019b66:	75fb      	strb	r3, [r7, #23]
      break;
24019b68:	bf00      	nop
  }

  if (status == HAL_OK)
24019b6a:	7dfb      	ldrb	r3, [r7, #23]
24019b6c:	2b00      	cmp	r3, #0
24019b6e:	d174      	bne.n	24019c5a <HAL_TIM_PWM_Start_DMA+0x40e>
  {
    /* Enable the Capture compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
24019b70:	68fb      	ldr	r3, [r7, #12]
24019b72:	681b      	ldr	r3, [r3, #0]
24019b74:	2201      	movs	r2, #1
24019b76:	68b9      	ldr	r1, [r7, #8]
24019b78:	4618      	mov	r0, r3
24019b7a:	f004 fcf5 	bl	2401e568 <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
24019b7e:	68fb      	ldr	r3, [r7, #12]
24019b80:	681b      	ldr	r3, [r3, #0]
24019b82:	4a3b      	ldr	r2, [pc, #236]	; (24019c70 <HAL_TIM_PWM_Start_DMA+0x424>)
24019b84:	4293      	cmp	r3, r2
24019b86:	d013      	beq.n	24019bb0 <HAL_TIM_PWM_Start_DMA+0x364>
24019b88:	68fb      	ldr	r3, [r7, #12]
24019b8a:	681b      	ldr	r3, [r3, #0]
24019b8c:	4a39      	ldr	r2, [pc, #228]	; (24019c74 <HAL_TIM_PWM_Start_DMA+0x428>)
24019b8e:	4293      	cmp	r3, r2
24019b90:	d00e      	beq.n	24019bb0 <HAL_TIM_PWM_Start_DMA+0x364>
24019b92:	68fb      	ldr	r3, [r7, #12]
24019b94:	681b      	ldr	r3, [r3, #0]
24019b96:	4a38      	ldr	r2, [pc, #224]	; (24019c78 <HAL_TIM_PWM_Start_DMA+0x42c>)
24019b98:	4293      	cmp	r3, r2
24019b9a:	d009      	beq.n	24019bb0 <HAL_TIM_PWM_Start_DMA+0x364>
24019b9c:	68fb      	ldr	r3, [r7, #12]
24019b9e:	681b      	ldr	r3, [r3, #0]
24019ba0:	4a36      	ldr	r2, [pc, #216]	; (24019c7c <HAL_TIM_PWM_Start_DMA+0x430>)
24019ba2:	4293      	cmp	r3, r2
24019ba4:	d004      	beq.n	24019bb0 <HAL_TIM_PWM_Start_DMA+0x364>
24019ba6:	68fb      	ldr	r3, [r7, #12]
24019ba8:	681b      	ldr	r3, [r3, #0]
24019baa:	4a35      	ldr	r2, [pc, #212]	; (24019c80 <HAL_TIM_PWM_Start_DMA+0x434>)
24019bac:	4293      	cmp	r3, r2
24019bae:	d101      	bne.n	24019bb4 <HAL_TIM_PWM_Start_DMA+0x368>
24019bb0:	2301      	movs	r3, #1
24019bb2:	e000      	b.n	24019bb6 <HAL_TIM_PWM_Start_DMA+0x36a>
24019bb4:	2300      	movs	r3, #0
24019bb6:	2b00      	cmp	r3, #0
24019bb8:	d007      	beq.n	24019bca <HAL_TIM_PWM_Start_DMA+0x37e>
    {
      /* Enable the main output */
      __HAL_TIM_MOE_ENABLE(htim);
24019bba:	68fb      	ldr	r3, [r7, #12]
24019bbc:	681b      	ldr	r3, [r3, #0]
24019bbe:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24019bc0:	68fb      	ldr	r3, [r7, #12]
24019bc2:	681b      	ldr	r3, [r3, #0]
24019bc4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24019bc8:	645a      	str	r2, [r3, #68]	; 0x44
    }

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
24019bca:	68fb      	ldr	r3, [r7, #12]
24019bcc:	681b      	ldr	r3, [r3, #0]
24019bce:	4a28      	ldr	r2, [pc, #160]	; (24019c70 <HAL_TIM_PWM_Start_DMA+0x424>)
24019bd0:	4293      	cmp	r3, r2
24019bd2:	d022      	beq.n	24019c1a <HAL_TIM_PWM_Start_DMA+0x3ce>
24019bd4:	68fb      	ldr	r3, [r7, #12]
24019bd6:	681b      	ldr	r3, [r3, #0]
24019bd8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24019bdc:	d01d      	beq.n	24019c1a <HAL_TIM_PWM_Start_DMA+0x3ce>
24019bde:	68fb      	ldr	r3, [r7, #12]
24019be0:	681b      	ldr	r3, [r3, #0]
24019be2:	4a28      	ldr	r2, [pc, #160]	; (24019c84 <HAL_TIM_PWM_Start_DMA+0x438>)
24019be4:	4293      	cmp	r3, r2
24019be6:	d018      	beq.n	24019c1a <HAL_TIM_PWM_Start_DMA+0x3ce>
24019be8:	68fb      	ldr	r3, [r7, #12]
24019bea:	681b      	ldr	r3, [r3, #0]
24019bec:	4a26      	ldr	r2, [pc, #152]	; (24019c88 <HAL_TIM_PWM_Start_DMA+0x43c>)
24019bee:	4293      	cmp	r3, r2
24019bf0:	d013      	beq.n	24019c1a <HAL_TIM_PWM_Start_DMA+0x3ce>
24019bf2:	68fb      	ldr	r3, [r7, #12]
24019bf4:	681b      	ldr	r3, [r3, #0]
24019bf6:	4a25      	ldr	r2, [pc, #148]	; (24019c8c <HAL_TIM_PWM_Start_DMA+0x440>)
24019bf8:	4293      	cmp	r3, r2
24019bfa:	d00e      	beq.n	24019c1a <HAL_TIM_PWM_Start_DMA+0x3ce>
24019bfc:	68fb      	ldr	r3, [r7, #12]
24019bfe:	681b      	ldr	r3, [r3, #0]
24019c00:	4a1c      	ldr	r2, [pc, #112]	; (24019c74 <HAL_TIM_PWM_Start_DMA+0x428>)
24019c02:	4293      	cmp	r3, r2
24019c04:	d009      	beq.n	24019c1a <HAL_TIM_PWM_Start_DMA+0x3ce>
24019c06:	68fb      	ldr	r3, [r7, #12]
24019c08:	681b      	ldr	r3, [r3, #0]
24019c0a:	4a21      	ldr	r2, [pc, #132]	; (24019c90 <HAL_TIM_PWM_Start_DMA+0x444>)
24019c0c:	4293      	cmp	r3, r2
24019c0e:	d004      	beq.n	24019c1a <HAL_TIM_PWM_Start_DMA+0x3ce>
24019c10:	68fb      	ldr	r3, [r7, #12]
24019c12:	681b      	ldr	r3, [r3, #0]
24019c14:	4a18      	ldr	r2, [pc, #96]	; (24019c78 <HAL_TIM_PWM_Start_DMA+0x42c>)
24019c16:	4293      	cmp	r3, r2
24019c18:	d115      	bne.n	24019c46 <HAL_TIM_PWM_Start_DMA+0x3fa>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
24019c1a:	68fb      	ldr	r3, [r7, #12]
24019c1c:	681b      	ldr	r3, [r3, #0]
24019c1e:	689a      	ldr	r2, [r3, #8]
24019c20:	4b1c      	ldr	r3, [pc, #112]	; (24019c94 <HAL_TIM_PWM_Start_DMA+0x448>)
24019c22:	4013      	ands	r3, r2
24019c24:	613b      	str	r3, [r7, #16]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24019c26:	693b      	ldr	r3, [r7, #16]
24019c28:	2b06      	cmp	r3, #6
24019c2a:	d015      	beq.n	24019c58 <HAL_TIM_PWM_Start_DMA+0x40c>
24019c2c:	693b      	ldr	r3, [r7, #16]
24019c2e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24019c32:	d011      	beq.n	24019c58 <HAL_TIM_PWM_Start_DMA+0x40c>
      {
        __HAL_TIM_ENABLE(htim);
24019c34:	68fb      	ldr	r3, [r7, #12]
24019c36:	681b      	ldr	r3, [r3, #0]
24019c38:	681a      	ldr	r2, [r3, #0]
24019c3a:	68fb      	ldr	r3, [r7, #12]
24019c3c:	681b      	ldr	r3, [r3, #0]
24019c3e:	f042 0201 	orr.w	r2, r2, #1
24019c42:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24019c44:	e008      	b.n	24019c58 <HAL_TIM_PWM_Start_DMA+0x40c>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
24019c46:	68fb      	ldr	r3, [r7, #12]
24019c48:	681b      	ldr	r3, [r3, #0]
24019c4a:	681a      	ldr	r2, [r3, #0]
24019c4c:	68fb      	ldr	r3, [r7, #12]
24019c4e:	681b      	ldr	r3, [r3, #0]
24019c50:	f042 0201 	orr.w	r2, r2, #1
24019c54:	601a      	str	r2, [r3, #0]
24019c56:	e000      	b.n	24019c5a <HAL_TIM_PWM_Start_DMA+0x40e>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
24019c58:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
24019c5a:	7dfb      	ldrb	r3, [r7, #23]
}
24019c5c:	4618      	mov	r0, r3
24019c5e:	3718      	adds	r7, #24
24019c60:	46bd      	mov	sp, r7
24019c62:	bd80      	pop	{r7, pc}
24019c64:	2401d651 	.word	0x2401d651
24019c68:	2401d6f9 	.word	0x2401d6f9
24019c6c:	2401d5bf 	.word	0x2401d5bf
24019c70:	40010000 	.word	0x40010000
24019c74:	40010400 	.word	0x40010400
24019c78:	40014000 	.word	0x40014000
24019c7c:	40014400 	.word	0x40014400
24019c80:	40014800 	.word	0x40014800
24019c84:	40000400 	.word	0x40000400
24019c88:	40000800 	.word	0x40000800
24019c8c:	40000c00 	.word	0x40000c00
24019c90:	40001800 	.word	0x40001800
24019c94:	00010007 	.word	0x00010007

24019c98 <HAL_TIM_PWM_Stop_DMA>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
{
24019c98:	b580      	push	{r7, lr}
24019c9a:	b084      	sub	sp, #16
24019c9c:	af00      	add	r7, sp, #0
24019c9e:	6078      	str	r0, [r7, #4]
24019ca0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24019ca2:	2300      	movs	r3, #0
24019ca4:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
24019ca6:	683b      	ldr	r3, [r7, #0]
24019ca8:	2b0c      	cmp	r3, #12
24019caa:	d855      	bhi.n	24019d58 <HAL_TIM_PWM_Stop_DMA+0xc0>
24019cac:	a201      	add	r2, pc, #4	; (adr r2, 24019cb4 <HAL_TIM_PWM_Stop_DMA+0x1c>)
24019cae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24019cb2:	bf00      	nop
24019cb4:	24019ce9 	.word	0x24019ce9
24019cb8:	24019d59 	.word	0x24019d59
24019cbc:	24019d59 	.word	0x24019d59
24019cc0:	24019d59 	.word	0x24019d59
24019cc4:	24019d05 	.word	0x24019d05
24019cc8:	24019d59 	.word	0x24019d59
24019ccc:	24019d59 	.word	0x24019d59
24019cd0:	24019d59 	.word	0x24019d59
24019cd4:	24019d21 	.word	0x24019d21
24019cd8:	24019d59 	.word	0x24019d59
24019cdc:	24019d59 	.word	0x24019d59
24019ce0:	24019d59 	.word	0x24019d59
24019ce4:	24019d3d 	.word	0x24019d3d
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
24019ce8:	687b      	ldr	r3, [r7, #4]
24019cea:	681b      	ldr	r3, [r3, #0]
24019cec:	68da      	ldr	r2, [r3, #12]
24019cee:	687b      	ldr	r3, [r7, #4]
24019cf0:	681b      	ldr	r3, [r3, #0]
24019cf2:	f422 7200 	bic.w	r2, r2, #512	; 0x200
24019cf6:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
24019cf8:	687b      	ldr	r3, [r7, #4]
24019cfa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24019cfc:	4618      	mov	r0, r3
24019cfe:	f7ea fcaf 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
24019d02:	e02c      	b.n	24019d5e <HAL_TIM_PWM_Stop_DMA+0xc6>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
24019d04:	687b      	ldr	r3, [r7, #4]
24019d06:	681b      	ldr	r3, [r3, #0]
24019d08:	68da      	ldr	r2, [r3, #12]
24019d0a:	687b      	ldr	r3, [r7, #4]
24019d0c:	681b      	ldr	r3, [r3, #0]
24019d0e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
24019d12:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
24019d14:	687b      	ldr	r3, [r7, #4]
24019d16:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24019d18:	4618      	mov	r0, r3
24019d1a:	f7ea fca1 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
24019d1e:	e01e      	b.n	24019d5e <HAL_TIM_PWM_Stop_DMA+0xc6>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
24019d20:	687b      	ldr	r3, [r7, #4]
24019d22:	681b      	ldr	r3, [r3, #0]
24019d24:	68da      	ldr	r2, [r3, #12]
24019d26:	687b      	ldr	r3, [r7, #4]
24019d28:	681b      	ldr	r3, [r3, #0]
24019d2a:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
24019d2e:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
24019d30:	687b      	ldr	r3, [r7, #4]
24019d32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24019d34:	4618      	mov	r0, r3
24019d36:	f7ea fc93 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
24019d3a:	e010      	b.n	24019d5e <HAL_TIM_PWM_Stop_DMA+0xc6>
    }

    case TIM_CHANNEL_4:
    {
      /* Disable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
24019d3c:	687b      	ldr	r3, [r7, #4]
24019d3e:	681b      	ldr	r3, [r3, #0]
24019d40:	68da      	ldr	r2, [r3, #12]
24019d42:	687b      	ldr	r3, [r7, #4]
24019d44:	681b      	ldr	r3, [r3, #0]
24019d46:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
24019d4a:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
24019d4c:	687b      	ldr	r3, [r7, #4]
24019d4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24019d50:	4618      	mov	r0, r3
24019d52:	f7ea fc85 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
24019d56:	e002      	b.n	24019d5e <HAL_TIM_PWM_Stop_DMA+0xc6>
    }

    default:
      status = HAL_ERROR;
24019d58:	2301      	movs	r3, #1
24019d5a:	73fb      	strb	r3, [r7, #15]
      break;
24019d5c:	bf00      	nop
  }

  if (status == HAL_OK)
24019d5e:	7bfb      	ldrb	r3, [r7, #15]
24019d60:	2b00      	cmp	r3, #0
24019d62:	f040 8081 	bne.w	24019e68 <HAL_TIM_PWM_Stop_DMA+0x1d0>
  {
    /* Disable the Capture compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
24019d66:	687b      	ldr	r3, [r7, #4]
24019d68:	681b      	ldr	r3, [r3, #0]
24019d6a:	2200      	movs	r2, #0
24019d6c:	6839      	ldr	r1, [r7, #0]
24019d6e:	4618      	mov	r0, r3
24019d70:	f004 fbfa 	bl	2401e568 <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
24019d74:	687b      	ldr	r3, [r7, #4]
24019d76:	681b      	ldr	r3, [r3, #0]
24019d78:	4a3e      	ldr	r2, [pc, #248]	; (24019e74 <HAL_TIM_PWM_Stop_DMA+0x1dc>)
24019d7a:	4293      	cmp	r3, r2
24019d7c:	d013      	beq.n	24019da6 <HAL_TIM_PWM_Stop_DMA+0x10e>
24019d7e:	687b      	ldr	r3, [r7, #4]
24019d80:	681b      	ldr	r3, [r3, #0]
24019d82:	4a3d      	ldr	r2, [pc, #244]	; (24019e78 <HAL_TIM_PWM_Stop_DMA+0x1e0>)
24019d84:	4293      	cmp	r3, r2
24019d86:	d00e      	beq.n	24019da6 <HAL_TIM_PWM_Stop_DMA+0x10e>
24019d88:	687b      	ldr	r3, [r7, #4]
24019d8a:	681b      	ldr	r3, [r3, #0]
24019d8c:	4a3b      	ldr	r2, [pc, #236]	; (24019e7c <HAL_TIM_PWM_Stop_DMA+0x1e4>)
24019d8e:	4293      	cmp	r3, r2
24019d90:	d009      	beq.n	24019da6 <HAL_TIM_PWM_Stop_DMA+0x10e>
24019d92:	687b      	ldr	r3, [r7, #4]
24019d94:	681b      	ldr	r3, [r3, #0]
24019d96:	4a3a      	ldr	r2, [pc, #232]	; (24019e80 <HAL_TIM_PWM_Stop_DMA+0x1e8>)
24019d98:	4293      	cmp	r3, r2
24019d9a:	d004      	beq.n	24019da6 <HAL_TIM_PWM_Stop_DMA+0x10e>
24019d9c:	687b      	ldr	r3, [r7, #4]
24019d9e:	681b      	ldr	r3, [r3, #0]
24019da0:	4a38      	ldr	r2, [pc, #224]	; (24019e84 <HAL_TIM_PWM_Stop_DMA+0x1ec>)
24019da2:	4293      	cmp	r3, r2
24019da4:	d101      	bne.n	24019daa <HAL_TIM_PWM_Stop_DMA+0x112>
24019da6:	2301      	movs	r3, #1
24019da8:	e000      	b.n	24019dac <HAL_TIM_PWM_Stop_DMA+0x114>
24019daa:	2300      	movs	r3, #0
24019dac:	2b00      	cmp	r3, #0
24019dae:	d017      	beq.n	24019de0 <HAL_TIM_PWM_Stop_DMA+0x148>
    {
      /* Disable the Main Output */
      __HAL_TIM_MOE_DISABLE(htim);
24019db0:	687b      	ldr	r3, [r7, #4]
24019db2:	681b      	ldr	r3, [r3, #0]
24019db4:	6a1a      	ldr	r2, [r3, #32]
24019db6:	f241 1311 	movw	r3, #4369	; 0x1111
24019dba:	4013      	ands	r3, r2
24019dbc:	2b00      	cmp	r3, #0
24019dbe:	d10f      	bne.n	24019de0 <HAL_TIM_PWM_Stop_DMA+0x148>
24019dc0:	687b      	ldr	r3, [r7, #4]
24019dc2:	681b      	ldr	r3, [r3, #0]
24019dc4:	6a1a      	ldr	r2, [r3, #32]
24019dc6:	f240 4344 	movw	r3, #1092	; 0x444
24019dca:	4013      	ands	r3, r2
24019dcc:	2b00      	cmp	r3, #0
24019dce:	d107      	bne.n	24019de0 <HAL_TIM_PWM_Stop_DMA+0x148>
24019dd0:	687b      	ldr	r3, [r7, #4]
24019dd2:	681b      	ldr	r3, [r3, #0]
24019dd4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24019dd6:	687b      	ldr	r3, [r7, #4]
24019dd8:	681b      	ldr	r3, [r3, #0]
24019dda:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24019dde:	645a      	str	r2, [r3, #68]	; 0x44
    }

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
24019de0:	687b      	ldr	r3, [r7, #4]
24019de2:	681b      	ldr	r3, [r3, #0]
24019de4:	6a1a      	ldr	r2, [r3, #32]
24019de6:	f241 1311 	movw	r3, #4369	; 0x1111
24019dea:	4013      	ands	r3, r2
24019dec:	2b00      	cmp	r3, #0
24019dee:	d10f      	bne.n	24019e10 <HAL_TIM_PWM_Stop_DMA+0x178>
24019df0:	687b      	ldr	r3, [r7, #4]
24019df2:	681b      	ldr	r3, [r3, #0]
24019df4:	6a1a      	ldr	r2, [r3, #32]
24019df6:	f240 4344 	movw	r3, #1092	; 0x444
24019dfa:	4013      	ands	r3, r2
24019dfc:	2b00      	cmp	r3, #0
24019dfe:	d107      	bne.n	24019e10 <HAL_TIM_PWM_Stop_DMA+0x178>
24019e00:	687b      	ldr	r3, [r7, #4]
24019e02:	681b      	ldr	r3, [r3, #0]
24019e04:	681a      	ldr	r2, [r3, #0]
24019e06:	687b      	ldr	r3, [r7, #4]
24019e08:	681b      	ldr	r3, [r3, #0]
24019e0a:	f022 0201 	bic.w	r2, r2, #1
24019e0e:	601a      	str	r2, [r3, #0]

    /* Set the TIM channel state */
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
24019e10:	683b      	ldr	r3, [r7, #0]
24019e12:	2b00      	cmp	r3, #0
24019e14:	d104      	bne.n	24019e20 <HAL_TIM_PWM_Stop_DMA+0x188>
24019e16:	687b      	ldr	r3, [r7, #4]
24019e18:	2201      	movs	r2, #1
24019e1a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24019e1e:	e023      	b.n	24019e68 <HAL_TIM_PWM_Stop_DMA+0x1d0>
24019e20:	683b      	ldr	r3, [r7, #0]
24019e22:	2b04      	cmp	r3, #4
24019e24:	d104      	bne.n	24019e30 <HAL_TIM_PWM_Stop_DMA+0x198>
24019e26:	687b      	ldr	r3, [r7, #4]
24019e28:	2201      	movs	r2, #1
24019e2a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24019e2e:	e01b      	b.n	24019e68 <HAL_TIM_PWM_Stop_DMA+0x1d0>
24019e30:	683b      	ldr	r3, [r7, #0]
24019e32:	2b08      	cmp	r3, #8
24019e34:	d104      	bne.n	24019e40 <HAL_TIM_PWM_Stop_DMA+0x1a8>
24019e36:	687b      	ldr	r3, [r7, #4]
24019e38:	2201      	movs	r2, #1
24019e3a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24019e3e:	e013      	b.n	24019e68 <HAL_TIM_PWM_Stop_DMA+0x1d0>
24019e40:	683b      	ldr	r3, [r7, #0]
24019e42:	2b0c      	cmp	r3, #12
24019e44:	d104      	bne.n	24019e50 <HAL_TIM_PWM_Stop_DMA+0x1b8>
24019e46:	687b      	ldr	r3, [r7, #4]
24019e48:	2201      	movs	r2, #1
24019e4a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24019e4e:	e00b      	b.n	24019e68 <HAL_TIM_PWM_Stop_DMA+0x1d0>
24019e50:	683b      	ldr	r3, [r7, #0]
24019e52:	2b10      	cmp	r3, #16
24019e54:	d104      	bne.n	24019e60 <HAL_TIM_PWM_Stop_DMA+0x1c8>
24019e56:	687b      	ldr	r3, [r7, #4]
24019e58:	2201      	movs	r2, #1
24019e5a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24019e5e:	e003      	b.n	24019e68 <HAL_TIM_PWM_Stop_DMA+0x1d0>
24019e60:	687b      	ldr	r3, [r7, #4]
24019e62:	2201      	movs	r2, #1
24019e64:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  }

  /* Return function status */
  return status;
24019e68:	7bfb      	ldrb	r3, [r7, #15]
}
24019e6a:	4618      	mov	r0, r3
24019e6c:	3710      	adds	r7, #16
24019e6e:	46bd      	mov	sp, r7
24019e70:	bd80      	pop	{r7, pc}
24019e72:	bf00      	nop
24019e74:	40010000 	.word	0x40010000
24019e78:	40010400 	.word	0x40010400
24019e7c:	40014000 	.word	0x40014000
24019e80:	40014400 	.word	0x40014400
24019e84:	40014800 	.word	0x40014800

24019e88 <HAL_TIM_IC_Init>:
  *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
  * @param  htim TIM Input Capture handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
{
24019e88:	b580      	push	{r7, lr}
24019e8a:	b082      	sub	sp, #8
24019e8c:	af00      	add	r7, sp, #0
24019e8e:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
24019e90:	687b      	ldr	r3, [r7, #4]
24019e92:	2b00      	cmp	r3, #0
24019e94:	d101      	bne.n	24019e9a <HAL_TIM_IC_Init+0x12>
  {
    return HAL_ERROR;
24019e96:	2301      	movs	r3, #1
24019e98:	e049      	b.n	24019f2e <HAL_TIM_IC_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
24019e9a:	687b      	ldr	r3, [r7, #4]
24019e9c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24019ea0:	b2db      	uxtb	r3, r3
24019ea2:	2b00      	cmp	r3, #0
24019ea4:	d106      	bne.n	24019eb4 <HAL_TIM_IC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
24019ea6:	687b      	ldr	r3, [r7, #4]
24019ea8:	2200      	movs	r2, #0
24019eaa:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->IC_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_IC_MspInit(htim);
24019eae:	6878      	ldr	r0, [r7, #4]
24019eb0:	f000 f89d 	bl	24019fee <HAL_TIM_IC_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
24019eb4:	687b      	ldr	r3, [r7, #4]
24019eb6:	2202      	movs	r2, #2
24019eb8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the input capture */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
24019ebc:	687b      	ldr	r3, [r7, #4]
24019ebe:	681a      	ldr	r2, [r3, #0]
24019ec0:	687b      	ldr	r3, [r7, #4]
24019ec2:	3304      	adds	r3, #4
24019ec4:	4619      	mov	r1, r3
24019ec6:	4610      	mov	r0, r2
24019ec8:	f003 fd2c 	bl	2401d924 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
24019ecc:	687b      	ldr	r3, [r7, #4]
24019ece:	2201      	movs	r2, #1
24019ed0:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
24019ed4:	687b      	ldr	r3, [r7, #4]
24019ed6:	2201      	movs	r2, #1
24019ed8:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24019edc:	687b      	ldr	r3, [r7, #4]
24019ede:	2201      	movs	r2, #1
24019ee0:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24019ee4:	687b      	ldr	r3, [r7, #4]
24019ee6:	2201      	movs	r2, #1
24019ee8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24019eec:	687b      	ldr	r3, [r7, #4]
24019eee:	2201      	movs	r2, #1
24019ef0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24019ef4:	687b      	ldr	r3, [r7, #4]
24019ef6:	2201      	movs	r2, #1
24019ef8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24019efc:	687b      	ldr	r3, [r7, #4]
24019efe:	2201      	movs	r2, #1
24019f00:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
24019f04:	687b      	ldr	r3, [r7, #4]
24019f06:	2201      	movs	r2, #1
24019f08:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24019f0c:	687b      	ldr	r3, [r7, #4]
24019f0e:	2201      	movs	r2, #1
24019f10:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24019f14:	687b      	ldr	r3, [r7, #4]
24019f16:	2201      	movs	r2, #1
24019f18:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
24019f1c:	687b      	ldr	r3, [r7, #4]
24019f1e:	2201      	movs	r2, #1
24019f20:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
24019f24:	687b      	ldr	r3, [r7, #4]
24019f26:	2201      	movs	r2, #1
24019f28:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
24019f2c:	2300      	movs	r3, #0
}
24019f2e:	4618      	mov	r0, r3
24019f30:	3708      	adds	r7, #8
24019f32:	46bd      	mov	sp, r7
24019f34:	bd80      	pop	{r7, pc}

24019f36 <HAL_TIM_IC_DeInit>:
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM Input Capture handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
{
24019f36:	b580      	push	{r7, lr}
24019f38:	b082      	sub	sp, #8
24019f3a:	af00      	add	r7, sp, #0
24019f3c:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
24019f3e:	687b      	ldr	r3, [r7, #4]
24019f40:	2202      	movs	r2, #2
24019f42:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
24019f46:	687b      	ldr	r3, [r7, #4]
24019f48:	681b      	ldr	r3, [r3, #0]
24019f4a:	6a1a      	ldr	r2, [r3, #32]
24019f4c:	f241 1311 	movw	r3, #4369	; 0x1111
24019f50:	4013      	ands	r3, r2
24019f52:	2b00      	cmp	r3, #0
24019f54:	d10f      	bne.n	24019f76 <HAL_TIM_IC_DeInit+0x40>
24019f56:	687b      	ldr	r3, [r7, #4]
24019f58:	681b      	ldr	r3, [r3, #0]
24019f5a:	6a1a      	ldr	r2, [r3, #32]
24019f5c:	f240 4344 	movw	r3, #1092	; 0x444
24019f60:	4013      	ands	r3, r2
24019f62:	2b00      	cmp	r3, #0
24019f64:	d107      	bne.n	24019f76 <HAL_TIM_IC_DeInit+0x40>
24019f66:	687b      	ldr	r3, [r7, #4]
24019f68:	681b      	ldr	r3, [r3, #0]
24019f6a:	681a      	ldr	r2, [r3, #0]
24019f6c:	687b      	ldr	r3, [r7, #4]
24019f6e:	681b      	ldr	r3, [r3, #0]
24019f70:	f022 0201 	bic.w	r2, r2, #1
24019f74:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->IC_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_IC_MspDeInit(htim);
24019f76:	6878      	ldr	r0, [r7, #4]
24019f78:	f000 f843 	bl	2401a002 <HAL_TIM_IC_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
24019f7c:	687b      	ldr	r3, [r7, #4]
24019f7e:	2200      	movs	r2, #0
24019f80:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Change the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
24019f84:	687b      	ldr	r3, [r7, #4]
24019f86:	2200      	movs	r2, #0
24019f88:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
24019f8c:	687b      	ldr	r3, [r7, #4]
24019f8e:	2200      	movs	r2, #0
24019f90:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
24019f94:	687b      	ldr	r3, [r7, #4]
24019f96:	2200      	movs	r2, #0
24019f98:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24019f9c:	687b      	ldr	r3, [r7, #4]
24019f9e:	2200      	movs	r2, #0
24019fa0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24019fa4:	687b      	ldr	r3, [r7, #4]
24019fa6:	2200      	movs	r2, #0
24019fa8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
24019fac:	687b      	ldr	r3, [r7, #4]
24019fae:	2200      	movs	r2, #0
24019fb0:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
24019fb4:	687b      	ldr	r3, [r7, #4]
24019fb6:	2200      	movs	r2, #0
24019fb8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24019fbc:	687b      	ldr	r3, [r7, #4]
24019fbe:	2200      	movs	r2, #0
24019fc0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24019fc4:	687b      	ldr	r3, [r7, #4]
24019fc6:	2200      	movs	r2, #0
24019fc8:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
24019fcc:	687b      	ldr	r3, [r7, #4]
24019fce:	2200      	movs	r2, #0
24019fd0:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
24019fd4:	687b      	ldr	r3, [r7, #4]
24019fd6:	2200      	movs	r2, #0
24019fd8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
24019fdc:	687b      	ldr	r3, [r7, #4]
24019fde:	2200      	movs	r2, #0
24019fe0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24019fe4:	2300      	movs	r3, #0
}
24019fe6:	4618      	mov	r0, r3
24019fe8:	3708      	adds	r7, #8
24019fea:	46bd      	mov	sp, r7
24019fec:	bd80      	pop	{r7, pc}

24019fee <HAL_TIM_IC_MspInit>:
  * @brief  Initializes the TIM Input Capture MSP.
  * @param  htim TIM Input Capture handle
  * @retval None
  */
__weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
{
24019fee:	b480      	push	{r7}
24019ff0:	b083      	sub	sp, #12
24019ff2:	af00      	add	r7, sp, #0
24019ff4:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspInit could be implemented in the user file
   */
}
24019ff6:	bf00      	nop
24019ff8:	370c      	adds	r7, #12
24019ffa:	46bd      	mov	sp, r7
24019ffc:	f85d 7b04 	ldr.w	r7, [sp], #4
2401a000:	4770      	bx	lr

2401a002 <HAL_TIM_IC_MspDeInit>:
  * @brief  DeInitializes TIM Input Capture MSP.
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
{
2401a002:	b480      	push	{r7}
2401a004:	b083      	sub	sp, #12
2401a006:	af00      	add	r7, sp, #0
2401a008:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspDeInit could be implemented in the user file
   */
}
2401a00a:	bf00      	nop
2401a00c:	370c      	adds	r7, #12
2401a00e:	46bd      	mov	sp, r7
2401a010:	f85d 7b04 	ldr.w	r7, [sp], #4
2401a014:	4770      	bx	lr
	...

2401a018 <HAL_TIM_IC_Start>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401a018:	b580      	push	{r7, lr}
2401a01a:	b084      	sub	sp, #16
2401a01c:	af00      	add	r7, sp, #0
2401a01e:	6078      	str	r0, [r7, #4]
2401a020:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
2401a022:	683b      	ldr	r3, [r7, #0]
2401a024:	2b00      	cmp	r3, #0
2401a026:	d104      	bne.n	2401a032 <HAL_TIM_IC_Start+0x1a>
2401a028:	687b      	ldr	r3, [r7, #4]
2401a02a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401a02e:	b2db      	uxtb	r3, r3
2401a030:	e023      	b.n	2401a07a <HAL_TIM_IC_Start+0x62>
2401a032:	683b      	ldr	r3, [r7, #0]
2401a034:	2b04      	cmp	r3, #4
2401a036:	d104      	bne.n	2401a042 <HAL_TIM_IC_Start+0x2a>
2401a038:	687b      	ldr	r3, [r7, #4]
2401a03a:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401a03e:	b2db      	uxtb	r3, r3
2401a040:	e01b      	b.n	2401a07a <HAL_TIM_IC_Start+0x62>
2401a042:	683b      	ldr	r3, [r7, #0]
2401a044:	2b08      	cmp	r3, #8
2401a046:	d104      	bne.n	2401a052 <HAL_TIM_IC_Start+0x3a>
2401a048:	687b      	ldr	r3, [r7, #4]
2401a04a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401a04e:	b2db      	uxtb	r3, r3
2401a050:	e013      	b.n	2401a07a <HAL_TIM_IC_Start+0x62>
2401a052:	683b      	ldr	r3, [r7, #0]
2401a054:	2b0c      	cmp	r3, #12
2401a056:	d104      	bne.n	2401a062 <HAL_TIM_IC_Start+0x4a>
2401a058:	687b      	ldr	r3, [r7, #4]
2401a05a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401a05e:	b2db      	uxtb	r3, r3
2401a060:	e00b      	b.n	2401a07a <HAL_TIM_IC_Start+0x62>
2401a062:	683b      	ldr	r3, [r7, #0]
2401a064:	2b10      	cmp	r3, #16
2401a066:	d104      	bne.n	2401a072 <HAL_TIM_IC_Start+0x5a>
2401a068:	687b      	ldr	r3, [r7, #4]
2401a06a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2401a06e:	b2db      	uxtb	r3, r3
2401a070:	e003      	b.n	2401a07a <HAL_TIM_IC_Start+0x62>
2401a072:	687b      	ldr	r3, [r7, #4]
2401a074:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
2401a078:	b2db      	uxtb	r3, r3
2401a07a:	73fb      	strb	r3, [r7, #15]
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
2401a07c:	683b      	ldr	r3, [r7, #0]
2401a07e:	2b00      	cmp	r3, #0
2401a080:	d104      	bne.n	2401a08c <HAL_TIM_IC_Start+0x74>
2401a082:	687b      	ldr	r3, [r7, #4]
2401a084:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401a088:	b2db      	uxtb	r3, r3
2401a08a:	e013      	b.n	2401a0b4 <HAL_TIM_IC_Start+0x9c>
2401a08c:	683b      	ldr	r3, [r7, #0]
2401a08e:	2b04      	cmp	r3, #4
2401a090:	d104      	bne.n	2401a09c <HAL_TIM_IC_Start+0x84>
2401a092:	687b      	ldr	r3, [r7, #4]
2401a094:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401a098:	b2db      	uxtb	r3, r3
2401a09a:	e00b      	b.n	2401a0b4 <HAL_TIM_IC_Start+0x9c>
2401a09c:	683b      	ldr	r3, [r7, #0]
2401a09e:	2b08      	cmp	r3, #8
2401a0a0:	d104      	bne.n	2401a0ac <HAL_TIM_IC_Start+0x94>
2401a0a2:	687b      	ldr	r3, [r7, #4]
2401a0a4:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401a0a8:	b2db      	uxtb	r3, r3
2401a0aa:	e003      	b.n	2401a0b4 <HAL_TIM_IC_Start+0x9c>
2401a0ac:	687b      	ldr	r3, [r7, #4]
2401a0ae:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401a0b2:	b2db      	uxtb	r3, r3
2401a0b4:	73bb      	strb	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
2401a0b6:	7bfb      	ldrb	r3, [r7, #15]
2401a0b8:	2b01      	cmp	r3, #1
2401a0ba:	d102      	bne.n	2401a0c2 <HAL_TIM_IC_Start+0xaa>
      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
2401a0bc:	7bbb      	ldrb	r3, [r7, #14]
2401a0be:	2b01      	cmp	r3, #1
2401a0c0:	d001      	beq.n	2401a0c6 <HAL_TIM_IC_Start+0xae>
  {
    return HAL_ERROR;
2401a0c2:	2301      	movs	r3, #1
2401a0c4:	e097      	b.n	2401a1f6 <HAL_TIM_IC_Start+0x1de>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a0c6:	683b      	ldr	r3, [r7, #0]
2401a0c8:	2b00      	cmp	r3, #0
2401a0ca:	d104      	bne.n	2401a0d6 <HAL_TIM_IC_Start+0xbe>
2401a0cc:	687b      	ldr	r3, [r7, #4]
2401a0ce:	2202      	movs	r2, #2
2401a0d0:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401a0d4:	e023      	b.n	2401a11e <HAL_TIM_IC_Start+0x106>
2401a0d6:	683b      	ldr	r3, [r7, #0]
2401a0d8:	2b04      	cmp	r3, #4
2401a0da:	d104      	bne.n	2401a0e6 <HAL_TIM_IC_Start+0xce>
2401a0dc:	687b      	ldr	r3, [r7, #4]
2401a0de:	2202      	movs	r2, #2
2401a0e0:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401a0e4:	e01b      	b.n	2401a11e <HAL_TIM_IC_Start+0x106>
2401a0e6:	683b      	ldr	r3, [r7, #0]
2401a0e8:	2b08      	cmp	r3, #8
2401a0ea:	d104      	bne.n	2401a0f6 <HAL_TIM_IC_Start+0xde>
2401a0ec:	687b      	ldr	r3, [r7, #4]
2401a0ee:	2202      	movs	r2, #2
2401a0f0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401a0f4:	e013      	b.n	2401a11e <HAL_TIM_IC_Start+0x106>
2401a0f6:	683b      	ldr	r3, [r7, #0]
2401a0f8:	2b0c      	cmp	r3, #12
2401a0fa:	d104      	bne.n	2401a106 <HAL_TIM_IC_Start+0xee>
2401a0fc:	687b      	ldr	r3, [r7, #4]
2401a0fe:	2202      	movs	r2, #2
2401a100:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401a104:	e00b      	b.n	2401a11e <HAL_TIM_IC_Start+0x106>
2401a106:	683b      	ldr	r3, [r7, #0]
2401a108:	2b10      	cmp	r3, #16
2401a10a:	d104      	bne.n	2401a116 <HAL_TIM_IC_Start+0xfe>
2401a10c:	687b      	ldr	r3, [r7, #4]
2401a10e:	2202      	movs	r2, #2
2401a110:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401a114:	e003      	b.n	2401a11e <HAL_TIM_IC_Start+0x106>
2401a116:	687b      	ldr	r3, [r7, #4]
2401a118:	2202      	movs	r2, #2
2401a11a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a11e:	683b      	ldr	r3, [r7, #0]
2401a120:	2b00      	cmp	r3, #0
2401a122:	d104      	bne.n	2401a12e <HAL_TIM_IC_Start+0x116>
2401a124:	687b      	ldr	r3, [r7, #4]
2401a126:	2202      	movs	r2, #2
2401a128:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401a12c:	e013      	b.n	2401a156 <HAL_TIM_IC_Start+0x13e>
2401a12e:	683b      	ldr	r3, [r7, #0]
2401a130:	2b04      	cmp	r3, #4
2401a132:	d104      	bne.n	2401a13e <HAL_TIM_IC_Start+0x126>
2401a134:	687b      	ldr	r3, [r7, #4]
2401a136:	2202      	movs	r2, #2
2401a138:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401a13c:	e00b      	b.n	2401a156 <HAL_TIM_IC_Start+0x13e>
2401a13e:	683b      	ldr	r3, [r7, #0]
2401a140:	2b08      	cmp	r3, #8
2401a142:	d104      	bne.n	2401a14e <HAL_TIM_IC_Start+0x136>
2401a144:	687b      	ldr	r3, [r7, #4]
2401a146:	2202      	movs	r2, #2
2401a148:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401a14c:	e003      	b.n	2401a156 <HAL_TIM_IC_Start+0x13e>
2401a14e:	687b      	ldr	r3, [r7, #4]
2401a150:	2202      	movs	r2, #2
2401a152:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Enable the Input Capture channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2401a156:	687b      	ldr	r3, [r7, #4]
2401a158:	681b      	ldr	r3, [r3, #0]
2401a15a:	2201      	movs	r2, #1
2401a15c:	6839      	ldr	r1, [r7, #0]
2401a15e:	4618      	mov	r0, r3
2401a160:	f004 fa02 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401a164:	687b      	ldr	r3, [r7, #4]
2401a166:	681b      	ldr	r3, [r3, #0]
2401a168:	4a25      	ldr	r2, [pc, #148]	; (2401a200 <HAL_TIM_IC_Start+0x1e8>)
2401a16a:	4293      	cmp	r3, r2
2401a16c:	d022      	beq.n	2401a1b4 <HAL_TIM_IC_Start+0x19c>
2401a16e:	687b      	ldr	r3, [r7, #4]
2401a170:	681b      	ldr	r3, [r3, #0]
2401a172:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401a176:	d01d      	beq.n	2401a1b4 <HAL_TIM_IC_Start+0x19c>
2401a178:	687b      	ldr	r3, [r7, #4]
2401a17a:	681b      	ldr	r3, [r3, #0]
2401a17c:	4a21      	ldr	r2, [pc, #132]	; (2401a204 <HAL_TIM_IC_Start+0x1ec>)
2401a17e:	4293      	cmp	r3, r2
2401a180:	d018      	beq.n	2401a1b4 <HAL_TIM_IC_Start+0x19c>
2401a182:	687b      	ldr	r3, [r7, #4]
2401a184:	681b      	ldr	r3, [r3, #0]
2401a186:	4a20      	ldr	r2, [pc, #128]	; (2401a208 <HAL_TIM_IC_Start+0x1f0>)
2401a188:	4293      	cmp	r3, r2
2401a18a:	d013      	beq.n	2401a1b4 <HAL_TIM_IC_Start+0x19c>
2401a18c:	687b      	ldr	r3, [r7, #4]
2401a18e:	681b      	ldr	r3, [r3, #0]
2401a190:	4a1e      	ldr	r2, [pc, #120]	; (2401a20c <HAL_TIM_IC_Start+0x1f4>)
2401a192:	4293      	cmp	r3, r2
2401a194:	d00e      	beq.n	2401a1b4 <HAL_TIM_IC_Start+0x19c>
2401a196:	687b      	ldr	r3, [r7, #4]
2401a198:	681b      	ldr	r3, [r3, #0]
2401a19a:	4a1d      	ldr	r2, [pc, #116]	; (2401a210 <HAL_TIM_IC_Start+0x1f8>)
2401a19c:	4293      	cmp	r3, r2
2401a19e:	d009      	beq.n	2401a1b4 <HAL_TIM_IC_Start+0x19c>
2401a1a0:	687b      	ldr	r3, [r7, #4]
2401a1a2:	681b      	ldr	r3, [r3, #0]
2401a1a4:	4a1b      	ldr	r2, [pc, #108]	; (2401a214 <HAL_TIM_IC_Start+0x1fc>)
2401a1a6:	4293      	cmp	r3, r2
2401a1a8:	d004      	beq.n	2401a1b4 <HAL_TIM_IC_Start+0x19c>
2401a1aa:	687b      	ldr	r3, [r7, #4]
2401a1ac:	681b      	ldr	r3, [r3, #0]
2401a1ae:	4a1a      	ldr	r2, [pc, #104]	; (2401a218 <HAL_TIM_IC_Start+0x200>)
2401a1b0:	4293      	cmp	r3, r2
2401a1b2:	d115      	bne.n	2401a1e0 <HAL_TIM_IC_Start+0x1c8>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401a1b4:	687b      	ldr	r3, [r7, #4]
2401a1b6:	681b      	ldr	r3, [r3, #0]
2401a1b8:	689a      	ldr	r2, [r3, #8]
2401a1ba:	4b18      	ldr	r3, [pc, #96]	; (2401a21c <HAL_TIM_IC_Start+0x204>)
2401a1bc:	4013      	ands	r3, r2
2401a1be:	60bb      	str	r3, [r7, #8]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401a1c0:	68bb      	ldr	r3, [r7, #8]
2401a1c2:	2b06      	cmp	r3, #6
2401a1c4:	d015      	beq.n	2401a1f2 <HAL_TIM_IC_Start+0x1da>
2401a1c6:	68bb      	ldr	r3, [r7, #8]
2401a1c8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401a1cc:	d011      	beq.n	2401a1f2 <HAL_TIM_IC_Start+0x1da>
    {
      __HAL_TIM_ENABLE(htim);
2401a1ce:	687b      	ldr	r3, [r7, #4]
2401a1d0:	681b      	ldr	r3, [r3, #0]
2401a1d2:	681a      	ldr	r2, [r3, #0]
2401a1d4:	687b      	ldr	r3, [r7, #4]
2401a1d6:	681b      	ldr	r3, [r3, #0]
2401a1d8:	f042 0201 	orr.w	r2, r2, #1
2401a1dc:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401a1de:	e008      	b.n	2401a1f2 <HAL_TIM_IC_Start+0x1da>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
2401a1e0:	687b      	ldr	r3, [r7, #4]
2401a1e2:	681b      	ldr	r3, [r3, #0]
2401a1e4:	681a      	ldr	r2, [r3, #0]
2401a1e6:	687b      	ldr	r3, [r7, #4]
2401a1e8:	681b      	ldr	r3, [r3, #0]
2401a1ea:	f042 0201 	orr.w	r2, r2, #1
2401a1ee:	601a      	str	r2, [r3, #0]
2401a1f0:	e000      	b.n	2401a1f4 <HAL_TIM_IC_Start+0x1dc>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401a1f2:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
2401a1f4:	2300      	movs	r3, #0
}
2401a1f6:	4618      	mov	r0, r3
2401a1f8:	3710      	adds	r7, #16
2401a1fa:	46bd      	mov	sp, r7
2401a1fc:	bd80      	pop	{r7, pc}
2401a1fe:	bf00      	nop
2401a200:	40010000 	.word	0x40010000
2401a204:	40000400 	.word	0x40000400
2401a208:	40000800 	.word	0x40000800
2401a20c:	40000c00 	.word	0x40000c00
2401a210:	40010400 	.word	0x40010400
2401a214:	40001800 	.word	0x40001800
2401a218:	40014000 	.word	0x40014000
2401a21c:	00010007 	.word	0x00010007

2401a220 <HAL_TIM_IC_Stop>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401a220:	b580      	push	{r7, lr}
2401a222:	b082      	sub	sp, #8
2401a224:	af00      	add	r7, sp, #0
2401a226:	6078      	str	r0, [r7, #4]
2401a228:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the Input Capture channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2401a22a:	687b      	ldr	r3, [r7, #4]
2401a22c:	681b      	ldr	r3, [r3, #0]
2401a22e:	2200      	movs	r2, #0
2401a230:	6839      	ldr	r1, [r7, #0]
2401a232:	4618      	mov	r0, r3
2401a234:	f004 f998 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401a238:	687b      	ldr	r3, [r7, #4]
2401a23a:	681b      	ldr	r3, [r3, #0]
2401a23c:	6a1a      	ldr	r2, [r3, #32]
2401a23e:	f241 1311 	movw	r3, #4369	; 0x1111
2401a242:	4013      	ands	r3, r2
2401a244:	2b00      	cmp	r3, #0
2401a246:	d10f      	bne.n	2401a268 <HAL_TIM_IC_Stop+0x48>
2401a248:	687b      	ldr	r3, [r7, #4]
2401a24a:	681b      	ldr	r3, [r3, #0]
2401a24c:	6a1a      	ldr	r2, [r3, #32]
2401a24e:	f240 4344 	movw	r3, #1092	; 0x444
2401a252:	4013      	ands	r3, r2
2401a254:	2b00      	cmp	r3, #0
2401a256:	d107      	bne.n	2401a268 <HAL_TIM_IC_Stop+0x48>
2401a258:	687b      	ldr	r3, [r7, #4]
2401a25a:	681b      	ldr	r3, [r3, #0]
2401a25c:	681a      	ldr	r2, [r3, #0]
2401a25e:	687b      	ldr	r3, [r7, #4]
2401a260:	681b      	ldr	r3, [r3, #0]
2401a262:	f022 0201 	bic.w	r2, r2, #1
2401a266:	601a      	str	r2, [r3, #0]

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401a268:	683b      	ldr	r3, [r7, #0]
2401a26a:	2b00      	cmp	r3, #0
2401a26c:	d104      	bne.n	2401a278 <HAL_TIM_IC_Stop+0x58>
2401a26e:	687b      	ldr	r3, [r7, #4]
2401a270:	2201      	movs	r2, #1
2401a272:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401a276:	e023      	b.n	2401a2c0 <HAL_TIM_IC_Stop+0xa0>
2401a278:	683b      	ldr	r3, [r7, #0]
2401a27a:	2b04      	cmp	r3, #4
2401a27c:	d104      	bne.n	2401a288 <HAL_TIM_IC_Stop+0x68>
2401a27e:	687b      	ldr	r3, [r7, #4]
2401a280:	2201      	movs	r2, #1
2401a282:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401a286:	e01b      	b.n	2401a2c0 <HAL_TIM_IC_Stop+0xa0>
2401a288:	683b      	ldr	r3, [r7, #0]
2401a28a:	2b08      	cmp	r3, #8
2401a28c:	d104      	bne.n	2401a298 <HAL_TIM_IC_Stop+0x78>
2401a28e:	687b      	ldr	r3, [r7, #4]
2401a290:	2201      	movs	r2, #1
2401a292:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401a296:	e013      	b.n	2401a2c0 <HAL_TIM_IC_Stop+0xa0>
2401a298:	683b      	ldr	r3, [r7, #0]
2401a29a:	2b0c      	cmp	r3, #12
2401a29c:	d104      	bne.n	2401a2a8 <HAL_TIM_IC_Stop+0x88>
2401a29e:	687b      	ldr	r3, [r7, #4]
2401a2a0:	2201      	movs	r2, #1
2401a2a2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401a2a6:	e00b      	b.n	2401a2c0 <HAL_TIM_IC_Stop+0xa0>
2401a2a8:	683b      	ldr	r3, [r7, #0]
2401a2aa:	2b10      	cmp	r3, #16
2401a2ac:	d104      	bne.n	2401a2b8 <HAL_TIM_IC_Stop+0x98>
2401a2ae:	687b      	ldr	r3, [r7, #4]
2401a2b0:	2201      	movs	r2, #1
2401a2b2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401a2b6:	e003      	b.n	2401a2c0 <HAL_TIM_IC_Stop+0xa0>
2401a2b8:	687b      	ldr	r3, [r7, #4]
2401a2ba:	2201      	movs	r2, #1
2401a2bc:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401a2c0:	683b      	ldr	r3, [r7, #0]
2401a2c2:	2b00      	cmp	r3, #0
2401a2c4:	d104      	bne.n	2401a2d0 <HAL_TIM_IC_Stop+0xb0>
2401a2c6:	687b      	ldr	r3, [r7, #4]
2401a2c8:	2201      	movs	r2, #1
2401a2ca:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401a2ce:	e013      	b.n	2401a2f8 <HAL_TIM_IC_Stop+0xd8>
2401a2d0:	683b      	ldr	r3, [r7, #0]
2401a2d2:	2b04      	cmp	r3, #4
2401a2d4:	d104      	bne.n	2401a2e0 <HAL_TIM_IC_Stop+0xc0>
2401a2d6:	687b      	ldr	r3, [r7, #4]
2401a2d8:	2201      	movs	r2, #1
2401a2da:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401a2de:	e00b      	b.n	2401a2f8 <HAL_TIM_IC_Stop+0xd8>
2401a2e0:	683b      	ldr	r3, [r7, #0]
2401a2e2:	2b08      	cmp	r3, #8
2401a2e4:	d104      	bne.n	2401a2f0 <HAL_TIM_IC_Stop+0xd0>
2401a2e6:	687b      	ldr	r3, [r7, #4]
2401a2e8:	2201      	movs	r2, #1
2401a2ea:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401a2ee:	e003      	b.n	2401a2f8 <HAL_TIM_IC_Stop+0xd8>
2401a2f0:	687b      	ldr	r3, [r7, #4]
2401a2f2:	2201      	movs	r2, #1
2401a2f4:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Return function status */
  return HAL_OK;
2401a2f8:	2300      	movs	r3, #0
}
2401a2fa:	4618      	mov	r0, r3
2401a2fc:	3708      	adds	r7, #8
2401a2fe:	46bd      	mov	sp, r7
2401a300:	bd80      	pop	{r7, pc}
	...

2401a304 <HAL_TIM_IC_Start_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401a304:	b580      	push	{r7, lr}
2401a306:	b084      	sub	sp, #16
2401a308:	af00      	add	r7, sp, #0
2401a30a:	6078      	str	r0, [r7, #4]
2401a30c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401a30e:	2300      	movs	r3, #0
2401a310:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
2401a312:	683b      	ldr	r3, [r7, #0]
2401a314:	2b00      	cmp	r3, #0
2401a316:	d104      	bne.n	2401a322 <HAL_TIM_IC_Start_IT+0x1e>
2401a318:	687b      	ldr	r3, [r7, #4]
2401a31a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401a31e:	b2db      	uxtb	r3, r3
2401a320:	e023      	b.n	2401a36a <HAL_TIM_IC_Start_IT+0x66>
2401a322:	683b      	ldr	r3, [r7, #0]
2401a324:	2b04      	cmp	r3, #4
2401a326:	d104      	bne.n	2401a332 <HAL_TIM_IC_Start_IT+0x2e>
2401a328:	687b      	ldr	r3, [r7, #4]
2401a32a:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401a32e:	b2db      	uxtb	r3, r3
2401a330:	e01b      	b.n	2401a36a <HAL_TIM_IC_Start_IT+0x66>
2401a332:	683b      	ldr	r3, [r7, #0]
2401a334:	2b08      	cmp	r3, #8
2401a336:	d104      	bne.n	2401a342 <HAL_TIM_IC_Start_IT+0x3e>
2401a338:	687b      	ldr	r3, [r7, #4]
2401a33a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401a33e:	b2db      	uxtb	r3, r3
2401a340:	e013      	b.n	2401a36a <HAL_TIM_IC_Start_IT+0x66>
2401a342:	683b      	ldr	r3, [r7, #0]
2401a344:	2b0c      	cmp	r3, #12
2401a346:	d104      	bne.n	2401a352 <HAL_TIM_IC_Start_IT+0x4e>
2401a348:	687b      	ldr	r3, [r7, #4]
2401a34a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401a34e:	b2db      	uxtb	r3, r3
2401a350:	e00b      	b.n	2401a36a <HAL_TIM_IC_Start_IT+0x66>
2401a352:	683b      	ldr	r3, [r7, #0]
2401a354:	2b10      	cmp	r3, #16
2401a356:	d104      	bne.n	2401a362 <HAL_TIM_IC_Start_IT+0x5e>
2401a358:	687b      	ldr	r3, [r7, #4]
2401a35a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2401a35e:	b2db      	uxtb	r3, r3
2401a360:	e003      	b.n	2401a36a <HAL_TIM_IC_Start_IT+0x66>
2401a362:	687b      	ldr	r3, [r7, #4]
2401a364:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
2401a368:	b2db      	uxtb	r3, r3
2401a36a:	73bb      	strb	r3, [r7, #14]
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
2401a36c:	683b      	ldr	r3, [r7, #0]
2401a36e:	2b00      	cmp	r3, #0
2401a370:	d104      	bne.n	2401a37c <HAL_TIM_IC_Start_IT+0x78>
2401a372:	687b      	ldr	r3, [r7, #4]
2401a374:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401a378:	b2db      	uxtb	r3, r3
2401a37a:	e013      	b.n	2401a3a4 <HAL_TIM_IC_Start_IT+0xa0>
2401a37c:	683b      	ldr	r3, [r7, #0]
2401a37e:	2b04      	cmp	r3, #4
2401a380:	d104      	bne.n	2401a38c <HAL_TIM_IC_Start_IT+0x88>
2401a382:	687b      	ldr	r3, [r7, #4]
2401a384:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401a388:	b2db      	uxtb	r3, r3
2401a38a:	e00b      	b.n	2401a3a4 <HAL_TIM_IC_Start_IT+0xa0>
2401a38c:	683b      	ldr	r3, [r7, #0]
2401a38e:	2b08      	cmp	r3, #8
2401a390:	d104      	bne.n	2401a39c <HAL_TIM_IC_Start_IT+0x98>
2401a392:	687b      	ldr	r3, [r7, #4]
2401a394:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401a398:	b2db      	uxtb	r3, r3
2401a39a:	e003      	b.n	2401a3a4 <HAL_TIM_IC_Start_IT+0xa0>
2401a39c:	687b      	ldr	r3, [r7, #4]
2401a39e:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401a3a2:	b2db      	uxtb	r3, r3
2401a3a4:	737b      	strb	r3, [r7, #13]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
2401a3a6:	7bbb      	ldrb	r3, [r7, #14]
2401a3a8:	2b01      	cmp	r3, #1
2401a3aa:	d102      	bne.n	2401a3b2 <HAL_TIM_IC_Start_IT+0xae>
      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
2401a3ac:	7b7b      	ldrb	r3, [r7, #13]
2401a3ae:	2b01      	cmp	r3, #1
2401a3b0:	d001      	beq.n	2401a3b6 <HAL_TIM_IC_Start_IT+0xb2>
  {
    return HAL_ERROR;
2401a3b2:	2301      	movs	r3, #1
2401a3b4:	e0e2      	b.n	2401a57c <HAL_TIM_IC_Start_IT+0x278>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a3b6:	683b      	ldr	r3, [r7, #0]
2401a3b8:	2b00      	cmp	r3, #0
2401a3ba:	d104      	bne.n	2401a3c6 <HAL_TIM_IC_Start_IT+0xc2>
2401a3bc:	687b      	ldr	r3, [r7, #4]
2401a3be:	2202      	movs	r2, #2
2401a3c0:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401a3c4:	e023      	b.n	2401a40e <HAL_TIM_IC_Start_IT+0x10a>
2401a3c6:	683b      	ldr	r3, [r7, #0]
2401a3c8:	2b04      	cmp	r3, #4
2401a3ca:	d104      	bne.n	2401a3d6 <HAL_TIM_IC_Start_IT+0xd2>
2401a3cc:	687b      	ldr	r3, [r7, #4]
2401a3ce:	2202      	movs	r2, #2
2401a3d0:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401a3d4:	e01b      	b.n	2401a40e <HAL_TIM_IC_Start_IT+0x10a>
2401a3d6:	683b      	ldr	r3, [r7, #0]
2401a3d8:	2b08      	cmp	r3, #8
2401a3da:	d104      	bne.n	2401a3e6 <HAL_TIM_IC_Start_IT+0xe2>
2401a3dc:	687b      	ldr	r3, [r7, #4]
2401a3de:	2202      	movs	r2, #2
2401a3e0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401a3e4:	e013      	b.n	2401a40e <HAL_TIM_IC_Start_IT+0x10a>
2401a3e6:	683b      	ldr	r3, [r7, #0]
2401a3e8:	2b0c      	cmp	r3, #12
2401a3ea:	d104      	bne.n	2401a3f6 <HAL_TIM_IC_Start_IT+0xf2>
2401a3ec:	687b      	ldr	r3, [r7, #4]
2401a3ee:	2202      	movs	r2, #2
2401a3f0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401a3f4:	e00b      	b.n	2401a40e <HAL_TIM_IC_Start_IT+0x10a>
2401a3f6:	683b      	ldr	r3, [r7, #0]
2401a3f8:	2b10      	cmp	r3, #16
2401a3fa:	d104      	bne.n	2401a406 <HAL_TIM_IC_Start_IT+0x102>
2401a3fc:	687b      	ldr	r3, [r7, #4]
2401a3fe:	2202      	movs	r2, #2
2401a400:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401a404:	e003      	b.n	2401a40e <HAL_TIM_IC_Start_IT+0x10a>
2401a406:	687b      	ldr	r3, [r7, #4]
2401a408:	2202      	movs	r2, #2
2401a40a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a40e:	683b      	ldr	r3, [r7, #0]
2401a410:	2b00      	cmp	r3, #0
2401a412:	d104      	bne.n	2401a41e <HAL_TIM_IC_Start_IT+0x11a>
2401a414:	687b      	ldr	r3, [r7, #4]
2401a416:	2202      	movs	r2, #2
2401a418:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401a41c:	e013      	b.n	2401a446 <HAL_TIM_IC_Start_IT+0x142>
2401a41e:	683b      	ldr	r3, [r7, #0]
2401a420:	2b04      	cmp	r3, #4
2401a422:	d104      	bne.n	2401a42e <HAL_TIM_IC_Start_IT+0x12a>
2401a424:	687b      	ldr	r3, [r7, #4]
2401a426:	2202      	movs	r2, #2
2401a428:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401a42c:	e00b      	b.n	2401a446 <HAL_TIM_IC_Start_IT+0x142>
2401a42e:	683b      	ldr	r3, [r7, #0]
2401a430:	2b08      	cmp	r3, #8
2401a432:	d104      	bne.n	2401a43e <HAL_TIM_IC_Start_IT+0x13a>
2401a434:	687b      	ldr	r3, [r7, #4]
2401a436:	2202      	movs	r2, #2
2401a438:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401a43c:	e003      	b.n	2401a446 <HAL_TIM_IC_Start_IT+0x142>
2401a43e:	687b      	ldr	r3, [r7, #4]
2401a440:	2202      	movs	r2, #2
2401a442:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  switch (Channel)
2401a446:	683b      	ldr	r3, [r7, #0]
2401a448:	2b0c      	cmp	r3, #12
2401a44a:	d841      	bhi.n	2401a4d0 <HAL_TIM_IC_Start_IT+0x1cc>
2401a44c:	a201      	add	r2, pc, #4	; (adr r2, 2401a454 <HAL_TIM_IC_Start_IT+0x150>)
2401a44e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401a452:	bf00      	nop
2401a454:	2401a489 	.word	0x2401a489
2401a458:	2401a4d1 	.word	0x2401a4d1
2401a45c:	2401a4d1 	.word	0x2401a4d1
2401a460:	2401a4d1 	.word	0x2401a4d1
2401a464:	2401a49b 	.word	0x2401a49b
2401a468:	2401a4d1 	.word	0x2401a4d1
2401a46c:	2401a4d1 	.word	0x2401a4d1
2401a470:	2401a4d1 	.word	0x2401a4d1
2401a474:	2401a4ad 	.word	0x2401a4ad
2401a478:	2401a4d1 	.word	0x2401a4d1
2401a47c:	2401a4d1 	.word	0x2401a4d1
2401a480:	2401a4d1 	.word	0x2401a4d1
2401a484:	2401a4bf 	.word	0x2401a4bf
  {
    case TIM_CHANNEL_1:
    {
      /* Enable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2401a488:	687b      	ldr	r3, [r7, #4]
2401a48a:	681b      	ldr	r3, [r3, #0]
2401a48c:	68da      	ldr	r2, [r3, #12]
2401a48e:	687b      	ldr	r3, [r7, #4]
2401a490:	681b      	ldr	r3, [r3, #0]
2401a492:	f042 0202 	orr.w	r2, r2, #2
2401a496:	60da      	str	r2, [r3, #12]
      break;
2401a498:	e01d      	b.n	2401a4d6 <HAL_TIM_IC_Start_IT+0x1d2>
    }

    case TIM_CHANNEL_2:
    {
      /* Enable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2401a49a:	687b      	ldr	r3, [r7, #4]
2401a49c:	681b      	ldr	r3, [r3, #0]
2401a49e:	68da      	ldr	r2, [r3, #12]
2401a4a0:	687b      	ldr	r3, [r7, #4]
2401a4a2:	681b      	ldr	r3, [r3, #0]
2401a4a4:	f042 0204 	orr.w	r2, r2, #4
2401a4a8:	60da      	str	r2, [r3, #12]
      break;
2401a4aa:	e014      	b.n	2401a4d6 <HAL_TIM_IC_Start_IT+0x1d2>
    }

    case TIM_CHANNEL_3:
    {
      /* Enable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
2401a4ac:	687b      	ldr	r3, [r7, #4]
2401a4ae:	681b      	ldr	r3, [r3, #0]
2401a4b0:	68da      	ldr	r2, [r3, #12]
2401a4b2:	687b      	ldr	r3, [r7, #4]
2401a4b4:	681b      	ldr	r3, [r3, #0]
2401a4b6:	f042 0208 	orr.w	r2, r2, #8
2401a4ba:	60da      	str	r2, [r3, #12]
      break;
2401a4bc:	e00b      	b.n	2401a4d6 <HAL_TIM_IC_Start_IT+0x1d2>
    }

    case TIM_CHANNEL_4:
    {
      /* Enable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
2401a4be:	687b      	ldr	r3, [r7, #4]
2401a4c0:	681b      	ldr	r3, [r3, #0]
2401a4c2:	68da      	ldr	r2, [r3, #12]
2401a4c4:	687b      	ldr	r3, [r7, #4]
2401a4c6:	681b      	ldr	r3, [r3, #0]
2401a4c8:	f042 0210 	orr.w	r2, r2, #16
2401a4cc:	60da      	str	r2, [r3, #12]
      break;
2401a4ce:	e002      	b.n	2401a4d6 <HAL_TIM_IC_Start_IT+0x1d2>
    }

    default:
      status = HAL_ERROR;
2401a4d0:	2301      	movs	r3, #1
2401a4d2:	73fb      	strb	r3, [r7, #15]
      break;
2401a4d4:	bf00      	nop
  }

  if (status == HAL_OK)
2401a4d6:	7bfb      	ldrb	r3, [r7, #15]
2401a4d8:	2b00      	cmp	r3, #0
2401a4da:	d14e      	bne.n	2401a57a <HAL_TIM_IC_Start_IT+0x276>
  {
    /* Enable the Input Capture channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2401a4dc:	687b      	ldr	r3, [r7, #4]
2401a4de:	681b      	ldr	r3, [r3, #0]
2401a4e0:	2201      	movs	r2, #1
2401a4e2:	6839      	ldr	r1, [r7, #0]
2401a4e4:	4618      	mov	r0, r3
2401a4e6:	f004 f83f 	bl	2401e568 <TIM_CCxChannelCmd>

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401a4ea:	687b      	ldr	r3, [r7, #4]
2401a4ec:	681b      	ldr	r3, [r3, #0]
2401a4ee:	4a25      	ldr	r2, [pc, #148]	; (2401a584 <HAL_TIM_IC_Start_IT+0x280>)
2401a4f0:	4293      	cmp	r3, r2
2401a4f2:	d022      	beq.n	2401a53a <HAL_TIM_IC_Start_IT+0x236>
2401a4f4:	687b      	ldr	r3, [r7, #4]
2401a4f6:	681b      	ldr	r3, [r3, #0]
2401a4f8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401a4fc:	d01d      	beq.n	2401a53a <HAL_TIM_IC_Start_IT+0x236>
2401a4fe:	687b      	ldr	r3, [r7, #4]
2401a500:	681b      	ldr	r3, [r3, #0]
2401a502:	4a21      	ldr	r2, [pc, #132]	; (2401a588 <HAL_TIM_IC_Start_IT+0x284>)
2401a504:	4293      	cmp	r3, r2
2401a506:	d018      	beq.n	2401a53a <HAL_TIM_IC_Start_IT+0x236>
2401a508:	687b      	ldr	r3, [r7, #4]
2401a50a:	681b      	ldr	r3, [r3, #0]
2401a50c:	4a1f      	ldr	r2, [pc, #124]	; (2401a58c <HAL_TIM_IC_Start_IT+0x288>)
2401a50e:	4293      	cmp	r3, r2
2401a510:	d013      	beq.n	2401a53a <HAL_TIM_IC_Start_IT+0x236>
2401a512:	687b      	ldr	r3, [r7, #4]
2401a514:	681b      	ldr	r3, [r3, #0]
2401a516:	4a1e      	ldr	r2, [pc, #120]	; (2401a590 <HAL_TIM_IC_Start_IT+0x28c>)
2401a518:	4293      	cmp	r3, r2
2401a51a:	d00e      	beq.n	2401a53a <HAL_TIM_IC_Start_IT+0x236>
2401a51c:	687b      	ldr	r3, [r7, #4]
2401a51e:	681b      	ldr	r3, [r3, #0]
2401a520:	4a1c      	ldr	r2, [pc, #112]	; (2401a594 <HAL_TIM_IC_Start_IT+0x290>)
2401a522:	4293      	cmp	r3, r2
2401a524:	d009      	beq.n	2401a53a <HAL_TIM_IC_Start_IT+0x236>
2401a526:	687b      	ldr	r3, [r7, #4]
2401a528:	681b      	ldr	r3, [r3, #0]
2401a52a:	4a1b      	ldr	r2, [pc, #108]	; (2401a598 <HAL_TIM_IC_Start_IT+0x294>)
2401a52c:	4293      	cmp	r3, r2
2401a52e:	d004      	beq.n	2401a53a <HAL_TIM_IC_Start_IT+0x236>
2401a530:	687b      	ldr	r3, [r7, #4]
2401a532:	681b      	ldr	r3, [r3, #0]
2401a534:	4a19      	ldr	r2, [pc, #100]	; (2401a59c <HAL_TIM_IC_Start_IT+0x298>)
2401a536:	4293      	cmp	r3, r2
2401a538:	d115      	bne.n	2401a566 <HAL_TIM_IC_Start_IT+0x262>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401a53a:	687b      	ldr	r3, [r7, #4]
2401a53c:	681b      	ldr	r3, [r3, #0]
2401a53e:	689a      	ldr	r2, [r3, #8]
2401a540:	4b17      	ldr	r3, [pc, #92]	; (2401a5a0 <HAL_TIM_IC_Start_IT+0x29c>)
2401a542:	4013      	ands	r3, r2
2401a544:	60bb      	str	r3, [r7, #8]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401a546:	68bb      	ldr	r3, [r7, #8]
2401a548:	2b06      	cmp	r3, #6
2401a54a:	d015      	beq.n	2401a578 <HAL_TIM_IC_Start_IT+0x274>
2401a54c:	68bb      	ldr	r3, [r7, #8]
2401a54e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401a552:	d011      	beq.n	2401a578 <HAL_TIM_IC_Start_IT+0x274>
      {
        __HAL_TIM_ENABLE(htim);
2401a554:	687b      	ldr	r3, [r7, #4]
2401a556:	681b      	ldr	r3, [r3, #0]
2401a558:	681a      	ldr	r2, [r3, #0]
2401a55a:	687b      	ldr	r3, [r7, #4]
2401a55c:	681b      	ldr	r3, [r3, #0]
2401a55e:	f042 0201 	orr.w	r2, r2, #1
2401a562:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401a564:	e008      	b.n	2401a578 <HAL_TIM_IC_Start_IT+0x274>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
2401a566:	687b      	ldr	r3, [r7, #4]
2401a568:	681b      	ldr	r3, [r3, #0]
2401a56a:	681a      	ldr	r2, [r3, #0]
2401a56c:	687b      	ldr	r3, [r7, #4]
2401a56e:	681b      	ldr	r3, [r3, #0]
2401a570:	f042 0201 	orr.w	r2, r2, #1
2401a574:	601a      	str	r2, [r3, #0]
2401a576:	e000      	b.n	2401a57a <HAL_TIM_IC_Start_IT+0x276>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401a578:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
2401a57a:	7bfb      	ldrb	r3, [r7, #15]
}
2401a57c:	4618      	mov	r0, r3
2401a57e:	3710      	adds	r7, #16
2401a580:	46bd      	mov	sp, r7
2401a582:	bd80      	pop	{r7, pc}
2401a584:	40010000 	.word	0x40010000
2401a588:	40000400 	.word	0x40000400
2401a58c:	40000800 	.word	0x40000800
2401a590:	40000c00 	.word	0x40000c00
2401a594:	40010400 	.word	0x40010400
2401a598:	40001800 	.word	0x40001800
2401a59c:	40014000 	.word	0x40014000
2401a5a0:	00010007 	.word	0x00010007

2401a5a4 <HAL_TIM_IC_Stop_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401a5a4:	b580      	push	{r7, lr}
2401a5a6:	b084      	sub	sp, #16
2401a5a8:	af00      	add	r7, sp, #0
2401a5aa:	6078      	str	r0, [r7, #4]
2401a5ac:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401a5ae:	2300      	movs	r3, #0
2401a5b0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
2401a5b2:	683b      	ldr	r3, [r7, #0]
2401a5b4:	2b0c      	cmp	r3, #12
2401a5b6:	d841      	bhi.n	2401a63c <HAL_TIM_IC_Stop_IT+0x98>
2401a5b8:	a201      	add	r2, pc, #4	; (adr r2, 2401a5c0 <HAL_TIM_IC_Stop_IT+0x1c>)
2401a5ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401a5be:	bf00      	nop
2401a5c0:	2401a5f5 	.word	0x2401a5f5
2401a5c4:	2401a63d 	.word	0x2401a63d
2401a5c8:	2401a63d 	.word	0x2401a63d
2401a5cc:	2401a63d 	.word	0x2401a63d
2401a5d0:	2401a607 	.word	0x2401a607
2401a5d4:	2401a63d 	.word	0x2401a63d
2401a5d8:	2401a63d 	.word	0x2401a63d
2401a5dc:	2401a63d 	.word	0x2401a63d
2401a5e0:	2401a619 	.word	0x2401a619
2401a5e4:	2401a63d 	.word	0x2401a63d
2401a5e8:	2401a63d 	.word	0x2401a63d
2401a5ec:	2401a63d 	.word	0x2401a63d
2401a5f0:	2401a62b 	.word	0x2401a62b
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2401a5f4:	687b      	ldr	r3, [r7, #4]
2401a5f6:	681b      	ldr	r3, [r3, #0]
2401a5f8:	68da      	ldr	r2, [r3, #12]
2401a5fa:	687b      	ldr	r3, [r7, #4]
2401a5fc:	681b      	ldr	r3, [r3, #0]
2401a5fe:	f022 0202 	bic.w	r2, r2, #2
2401a602:	60da      	str	r2, [r3, #12]
      break;
2401a604:	e01d      	b.n	2401a642 <HAL_TIM_IC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2401a606:	687b      	ldr	r3, [r7, #4]
2401a608:	681b      	ldr	r3, [r3, #0]
2401a60a:	68da      	ldr	r2, [r3, #12]
2401a60c:	687b      	ldr	r3, [r7, #4]
2401a60e:	681b      	ldr	r3, [r3, #0]
2401a610:	f022 0204 	bic.w	r2, r2, #4
2401a614:	60da      	str	r2, [r3, #12]
      break;
2401a616:	e014      	b.n	2401a642 <HAL_TIM_IC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
2401a618:	687b      	ldr	r3, [r7, #4]
2401a61a:	681b      	ldr	r3, [r3, #0]
2401a61c:	68da      	ldr	r2, [r3, #12]
2401a61e:	687b      	ldr	r3, [r7, #4]
2401a620:	681b      	ldr	r3, [r3, #0]
2401a622:	f022 0208 	bic.w	r2, r2, #8
2401a626:	60da      	str	r2, [r3, #12]
      break;
2401a628:	e00b      	b.n	2401a642 <HAL_TIM_IC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_4:
    {
      /* Disable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
2401a62a:	687b      	ldr	r3, [r7, #4]
2401a62c:	681b      	ldr	r3, [r3, #0]
2401a62e:	68da      	ldr	r2, [r3, #12]
2401a630:	687b      	ldr	r3, [r7, #4]
2401a632:	681b      	ldr	r3, [r3, #0]
2401a634:	f022 0210 	bic.w	r2, r2, #16
2401a638:	60da      	str	r2, [r3, #12]
      break;
2401a63a:	e002      	b.n	2401a642 <HAL_TIM_IC_Stop_IT+0x9e>
    }

    default:
      status = HAL_ERROR;
2401a63c:	2301      	movs	r3, #1
2401a63e:	73fb      	strb	r3, [r7, #15]
      break;
2401a640:	bf00      	nop
  }

  if (status == HAL_OK)
2401a642:	7bfb      	ldrb	r3, [r7, #15]
2401a644:	2b00      	cmp	r3, #0
2401a646:	d166      	bne.n	2401a716 <HAL_TIM_IC_Stop_IT+0x172>
  {
    /* Disable the Input Capture channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2401a648:	687b      	ldr	r3, [r7, #4]
2401a64a:	681b      	ldr	r3, [r3, #0]
2401a64c:	2200      	movs	r2, #0
2401a64e:	6839      	ldr	r1, [r7, #0]
2401a650:	4618      	mov	r0, r3
2401a652:	f003 ff89 	bl	2401e568 <TIM_CCxChannelCmd>

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
2401a656:	687b      	ldr	r3, [r7, #4]
2401a658:	681b      	ldr	r3, [r3, #0]
2401a65a:	6a1a      	ldr	r2, [r3, #32]
2401a65c:	f241 1311 	movw	r3, #4369	; 0x1111
2401a660:	4013      	ands	r3, r2
2401a662:	2b00      	cmp	r3, #0
2401a664:	d10f      	bne.n	2401a686 <HAL_TIM_IC_Stop_IT+0xe2>
2401a666:	687b      	ldr	r3, [r7, #4]
2401a668:	681b      	ldr	r3, [r3, #0]
2401a66a:	6a1a      	ldr	r2, [r3, #32]
2401a66c:	f240 4344 	movw	r3, #1092	; 0x444
2401a670:	4013      	ands	r3, r2
2401a672:	2b00      	cmp	r3, #0
2401a674:	d107      	bne.n	2401a686 <HAL_TIM_IC_Stop_IT+0xe2>
2401a676:	687b      	ldr	r3, [r7, #4]
2401a678:	681b      	ldr	r3, [r3, #0]
2401a67a:	681a      	ldr	r2, [r3, #0]
2401a67c:	687b      	ldr	r3, [r7, #4]
2401a67e:	681b      	ldr	r3, [r3, #0]
2401a680:	f022 0201 	bic.w	r2, r2, #1
2401a684:	601a      	str	r2, [r3, #0]

    /* Set the TIM channel state */
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401a686:	683b      	ldr	r3, [r7, #0]
2401a688:	2b00      	cmp	r3, #0
2401a68a:	d104      	bne.n	2401a696 <HAL_TIM_IC_Stop_IT+0xf2>
2401a68c:	687b      	ldr	r3, [r7, #4]
2401a68e:	2201      	movs	r2, #1
2401a690:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401a694:	e023      	b.n	2401a6de <HAL_TIM_IC_Stop_IT+0x13a>
2401a696:	683b      	ldr	r3, [r7, #0]
2401a698:	2b04      	cmp	r3, #4
2401a69a:	d104      	bne.n	2401a6a6 <HAL_TIM_IC_Stop_IT+0x102>
2401a69c:	687b      	ldr	r3, [r7, #4]
2401a69e:	2201      	movs	r2, #1
2401a6a0:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401a6a4:	e01b      	b.n	2401a6de <HAL_TIM_IC_Stop_IT+0x13a>
2401a6a6:	683b      	ldr	r3, [r7, #0]
2401a6a8:	2b08      	cmp	r3, #8
2401a6aa:	d104      	bne.n	2401a6b6 <HAL_TIM_IC_Stop_IT+0x112>
2401a6ac:	687b      	ldr	r3, [r7, #4]
2401a6ae:	2201      	movs	r2, #1
2401a6b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401a6b4:	e013      	b.n	2401a6de <HAL_TIM_IC_Stop_IT+0x13a>
2401a6b6:	683b      	ldr	r3, [r7, #0]
2401a6b8:	2b0c      	cmp	r3, #12
2401a6ba:	d104      	bne.n	2401a6c6 <HAL_TIM_IC_Stop_IT+0x122>
2401a6bc:	687b      	ldr	r3, [r7, #4]
2401a6be:	2201      	movs	r2, #1
2401a6c0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401a6c4:	e00b      	b.n	2401a6de <HAL_TIM_IC_Stop_IT+0x13a>
2401a6c6:	683b      	ldr	r3, [r7, #0]
2401a6c8:	2b10      	cmp	r3, #16
2401a6ca:	d104      	bne.n	2401a6d6 <HAL_TIM_IC_Stop_IT+0x132>
2401a6cc:	687b      	ldr	r3, [r7, #4]
2401a6ce:	2201      	movs	r2, #1
2401a6d0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401a6d4:	e003      	b.n	2401a6de <HAL_TIM_IC_Stop_IT+0x13a>
2401a6d6:	687b      	ldr	r3, [r7, #4]
2401a6d8:	2201      	movs	r2, #1
2401a6da:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401a6de:	683b      	ldr	r3, [r7, #0]
2401a6e0:	2b00      	cmp	r3, #0
2401a6e2:	d104      	bne.n	2401a6ee <HAL_TIM_IC_Stop_IT+0x14a>
2401a6e4:	687b      	ldr	r3, [r7, #4]
2401a6e6:	2201      	movs	r2, #1
2401a6e8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401a6ec:	e013      	b.n	2401a716 <HAL_TIM_IC_Stop_IT+0x172>
2401a6ee:	683b      	ldr	r3, [r7, #0]
2401a6f0:	2b04      	cmp	r3, #4
2401a6f2:	d104      	bne.n	2401a6fe <HAL_TIM_IC_Stop_IT+0x15a>
2401a6f4:	687b      	ldr	r3, [r7, #4]
2401a6f6:	2201      	movs	r2, #1
2401a6f8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401a6fc:	e00b      	b.n	2401a716 <HAL_TIM_IC_Stop_IT+0x172>
2401a6fe:	683b      	ldr	r3, [r7, #0]
2401a700:	2b08      	cmp	r3, #8
2401a702:	d104      	bne.n	2401a70e <HAL_TIM_IC_Stop_IT+0x16a>
2401a704:	687b      	ldr	r3, [r7, #4]
2401a706:	2201      	movs	r2, #1
2401a708:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401a70c:	e003      	b.n	2401a716 <HAL_TIM_IC_Stop_IT+0x172>
2401a70e:	687b      	ldr	r3, [r7, #4]
2401a710:	2201      	movs	r2, #1
2401a712:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  }

  /* Return function status */
  return status;
2401a716:	7bfb      	ldrb	r3, [r7, #15]
}
2401a718:	4618      	mov	r0, r3
2401a71a:	3710      	adds	r7, #16
2401a71c:	46bd      	mov	sp, r7
2401a71e:	bd80      	pop	{r7, pc}

2401a720 <HAL_TIM_IC_Start_DMA>:
  * @param  pData The destination Buffer address.
  * @param  Length The length of data to be transferred from TIM peripheral to memory.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
{
2401a720:	b580      	push	{r7, lr}
2401a722:	b086      	sub	sp, #24
2401a724:	af00      	add	r7, sp, #0
2401a726:	60f8      	str	r0, [r7, #12]
2401a728:	60b9      	str	r1, [r7, #8]
2401a72a:	607a      	str	r2, [r7, #4]
2401a72c:	807b      	strh	r3, [r7, #2]
  HAL_StatusTypeDef status = HAL_OK;
2401a72e:	2300      	movs	r3, #0
2401a730:	75fb      	strb	r3, [r7, #23]
  uint32_t tmpsmcr;

  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
2401a732:	68bb      	ldr	r3, [r7, #8]
2401a734:	2b00      	cmp	r3, #0
2401a736:	d104      	bne.n	2401a742 <HAL_TIM_IC_Start_DMA+0x22>
2401a738:	68fb      	ldr	r3, [r7, #12]
2401a73a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401a73e:	b2db      	uxtb	r3, r3
2401a740:	e023      	b.n	2401a78a <HAL_TIM_IC_Start_DMA+0x6a>
2401a742:	68bb      	ldr	r3, [r7, #8]
2401a744:	2b04      	cmp	r3, #4
2401a746:	d104      	bne.n	2401a752 <HAL_TIM_IC_Start_DMA+0x32>
2401a748:	68fb      	ldr	r3, [r7, #12]
2401a74a:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401a74e:	b2db      	uxtb	r3, r3
2401a750:	e01b      	b.n	2401a78a <HAL_TIM_IC_Start_DMA+0x6a>
2401a752:	68bb      	ldr	r3, [r7, #8]
2401a754:	2b08      	cmp	r3, #8
2401a756:	d104      	bne.n	2401a762 <HAL_TIM_IC_Start_DMA+0x42>
2401a758:	68fb      	ldr	r3, [r7, #12]
2401a75a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401a75e:	b2db      	uxtb	r3, r3
2401a760:	e013      	b.n	2401a78a <HAL_TIM_IC_Start_DMA+0x6a>
2401a762:	68bb      	ldr	r3, [r7, #8]
2401a764:	2b0c      	cmp	r3, #12
2401a766:	d104      	bne.n	2401a772 <HAL_TIM_IC_Start_DMA+0x52>
2401a768:	68fb      	ldr	r3, [r7, #12]
2401a76a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401a76e:	b2db      	uxtb	r3, r3
2401a770:	e00b      	b.n	2401a78a <HAL_TIM_IC_Start_DMA+0x6a>
2401a772:	68bb      	ldr	r3, [r7, #8]
2401a774:	2b10      	cmp	r3, #16
2401a776:	d104      	bne.n	2401a782 <HAL_TIM_IC_Start_DMA+0x62>
2401a778:	68fb      	ldr	r3, [r7, #12]
2401a77a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2401a77e:	b2db      	uxtb	r3, r3
2401a780:	e003      	b.n	2401a78a <HAL_TIM_IC_Start_DMA+0x6a>
2401a782:	68fb      	ldr	r3, [r7, #12]
2401a784:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
2401a788:	b2db      	uxtb	r3, r3
2401a78a:	75bb      	strb	r3, [r7, #22]
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
2401a78c:	68bb      	ldr	r3, [r7, #8]
2401a78e:	2b00      	cmp	r3, #0
2401a790:	d104      	bne.n	2401a79c <HAL_TIM_IC_Start_DMA+0x7c>
2401a792:	68fb      	ldr	r3, [r7, #12]
2401a794:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401a798:	b2db      	uxtb	r3, r3
2401a79a:	e013      	b.n	2401a7c4 <HAL_TIM_IC_Start_DMA+0xa4>
2401a79c:	68bb      	ldr	r3, [r7, #8]
2401a79e:	2b04      	cmp	r3, #4
2401a7a0:	d104      	bne.n	2401a7ac <HAL_TIM_IC_Start_DMA+0x8c>
2401a7a2:	68fb      	ldr	r3, [r7, #12]
2401a7a4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401a7a8:	b2db      	uxtb	r3, r3
2401a7aa:	e00b      	b.n	2401a7c4 <HAL_TIM_IC_Start_DMA+0xa4>
2401a7ac:	68bb      	ldr	r3, [r7, #8]
2401a7ae:	2b08      	cmp	r3, #8
2401a7b0:	d104      	bne.n	2401a7bc <HAL_TIM_IC_Start_DMA+0x9c>
2401a7b2:	68fb      	ldr	r3, [r7, #12]
2401a7b4:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401a7b8:	b2db      	uxtb	r3, r3
2401a7ba:	e003      	b.n	2401a7c4 <HAL_TIM_IC_Start_DMA+0xa4>
2401a7bc:	68fb      	ldr	r3, [r7, #12]
2401a7be:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401a7c2:	b2db      	uxtb	r3, r3
2401a7c4:	757b      	strb	r3, [r7, #21]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));

  /* Set the TIM channel state */
  if ((channel_state == HAL_TIM_CHANNEL_STATE_BUSY)
2401a7c6:	7dbb      	ldrb	r3, [r7, #22]
2401a7c8:	2b02      	cmp	r3, #2
2401a7ca:	d002      	beq.n	2401a7d2 <HAL_TIM_IC_Start_DMA+0xb2>
      || (complementary_channel_state == HAL_TIM_CHANNEL_STATE_BUSY))
2401a7cc:	7d7b      	ldrb	r3, [r7, #21]
2401a7ce:	2b02      	cmp	r3, #2
2401a7d0:	d101      	bne.n	2401a7d6 <HAL_TIM_IC_Start_DMA+0xb6>
  {
    return HAL_BUSY;
2401a7d2:	2302      	movs	r3, #2
2401a7d4:	e15c      	b.n	2401aa90 <HAL_TIM_IC_Start_DMA+0x370>
  }
  else if ((channel_state == HAL_TIM_CHANNEL_STATE_READY)
2401a7d6:	7dbb      	ldrb	r3, [r7, #22]
2401a7d8:	2b01      	cmp	r3, #1
2401a7da:	d153      	bne.n	2401a884 <HAL_TIM_IC_Start_DMA+0x164>
           && (complementary_channel_state == HAL_TIM_CHANNEL_STATE_READY))
2401a7dc:	7d7b      	ldrb	r3, [r7, #21]
2401a7de:	2b01      	cmp	r3, #1
2401a7e0:	d150      	bne.n	2401a884 <HAL_TIM_IC_Start_DMA+0x164>
  {
    if ((pData == NULL) || (Length == 0U))
2401a7e2:	687b      	ldr	r3, [r7, #4]
2401a7e4:	2b00      	cmp	r3, #0
2401a7e6:	d002      	beq.n	2401a7ee <HAL_TIM_IC_Start_DMA+0xce>
2401a7e8:	887b      	ldrh	r3, [r7, #2]
2401a7ea:	2b00      	cmp	r3, #0
2401a7ec:	d101      	bne.n	2401a7f2 <HAL_TIM_IC_Start_DMA+0xd2>
    {
      return HAL_ERROR;
2401a7ee:	2301      	movs	r3, #1
2401a7f0:	e14e      	b.n	2401aa90 <HAL_TIM_IC_Start_DMA+0x370>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a7f2:	68bb      	ldr	r3, [r7, #8]
2401a7f4:	2b00      	cmp	r3, #0
2401a7f6:	d104      	bne.n	2401a802 <HAL_TIM_IC_Start_DMA+0xe2>
2401a7f8:	68fb      	ldr	r3, [r7, #12]
2401a7fa:	2202      	movs	r2, #2
2401a7fc:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401a800:	e023      	b.n	2401a84a <HAL_TIM_IC_Start_DMA+0x12a>
2401a802:	68bb      	ldr	r3, [r7, #8]
2401a804:	2b04      	cmp	r3, #4
2401a806:	d104      	bne.n	2401a812 <HAL_TIM_IC_Start_DMA+0xf2>
2401a808:	68fb      	ldr	r3, [r7, #12]
2401a80a:	2202      	movs	r2, #2
2401a80c:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401a810:	e01b      	b.n	2401a84a <HAL_TIM_IC_Start_DMA+0x12a>
2401a812:	68bb      	ldr	r3, [r7, #8]
2401a814:	2b08      	cmp	r3, #8
2401a816:	d104      	bne.n	2401a822 <HAL_TIM_IC_Start_DMA+0x102>
2401a818:	68fb      	ldr	r3, [r7, #12]
2401a81a:	2202      	movs	r2, #2
2401a81c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401a820:	e013      	b.n	2401a84a <HAL_TIM_IC_Start_DMA+0x12a>
2401a822:	68bb      	ldr	r3, [r7, #8]
2401a824:	2b0c      	cmp	r3, #12
2401a826:	d104      	bne.n	2401a832 <HAL_TIM_IC_Start_DMA+0x112>
2401a828:	68fb      	ldr	r3, [r7, #12]
2401a82a:	2202      	movs	r2, #2
2401a82c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401a830:	e00b      	b.n	2401a84a <HAL_TIM_IC_Start_DMA+0x12a>
2401a832:	68bb      	ldr	r3, [r7, #8]
2401a834:	2b10      	cmp	r3, #16
2401a836:	d104      	bne.n	2401a842 <HAL_TIM_IC_Start_DMA+0x122>
2401a838:	68fb      	ldr	r3, [r7, #12]
2401a83a:	2202      	movs	r2, #2
2401a83c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401a840:	e003      	b.n	2401a84a <HAL_TIM_IC_Start_DMA+0x12a>
2401a842:	68fb      	ldr	r3, [r7, #12]
2401a844:	2202      	movs	r2, #2
2401a846:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a84a:	68bb      	ldr	r3, [r7, #8]
2401a84c:	2b00      	cmp	r3, #0
2401a84e:	d104      	bne.n	2401a85a <HAL_TIM_IC_Start_DMA+0x13a>
2401a850:	68fb      	ldr	r3, [r7, #12]
2401a852:	2202      	movs	r2, #2
2401a854:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    if ((pData == NULL) || (Length == 0U))
2401a858:	e016      	b.n	2401a888 <HAL_TIM_IC_Start_DMA+0x168>
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a85a:	68bb      	ldr	r3, [r7, #8]
2401a85c:	2b04      	cmp	r3, #4
2401a85e:	d104      	bne.n	2401a86a <HAL_TIM_IC_Start_DMA+0x14a>
2401a860:	68fb      	ldr	r3, [r7, #12]
2401a862:	2202      	movs	r2, #2
2401a864:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    if ((pData == NULL) || (Length == 0U))
2401a868:	e00e      	b.n	2401a888 <HAL_TIM_IC_Start_DMA+0x168>
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a86a:	68bb      	ldr	r3, [r7, #8]
2401a86c:	2b08      	cmp	r3, #8
2401a86e:	d104      	bne.n	2401a87a <HAL_TIM_IC_Start_DMA+0x15a>
2401a870:	68fb      	ldr	r3, [r7, #12]
2401a872:	2202      	movs	r2, #2
2401a874:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
    if ((pData == NULL) || (Length == 0U))
2401a878:	e006      	b.n	2401a888 <HAL_TIM_IC_Start_DMA+0x168>
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401a87a:	68fb      	ldr	r3, [r7, #12]
2401a87c:	2202      	movs	r2, #2
2401a87e:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
    if ((pData == NULL) || (Length == 0U))
2401a882:	e001      	b.n	2401a888 <HAL_TIM_IC_Start_DMA+0x168>
    }
  }
  else
  {
    return HAL_ERROR;
2401a884:	2301      	movs	r3, #1
2401a886:	e103      	b.n	2401aa90 <HAL_TIM_IC_Start_DMA+0x370>
  }

  /* Enable the Input Capture channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2401a888:	68fb      	ldr	r3, [r7, #12]
2401a88a:	681b      	ldr	r3, [r3, #0]
2401a88c:	2201      	movs	r2, #1
2401a88e:	68b9      	ldr	r1, [r7, #8]
2401a890:	4618      	mov	r0, r3
2401a892:	f003 fe69 	bl	2401e568 <TIM_CCxChannelCmd>

  switch (Channel)
2401a896:	68bb      	ldr	r3, [r7, #8]
2401a898:	2b0c      	cmp	r3, #12
2401a89a:	f200 80ad 	bhi.w	2401a9f8 <HAL_TIM_IC_Start_DMA+0x2d8>
2401a89e:	a201      	add	r2, pc, #4	; (adr r2, 2401a8a4 <HAL_TIM_IC_Start_DMA+0x184>)
2401a8a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401a8a4:	2401a8d9 	.word	0x2401a8d9
2401a8a8:	2401a9f9 	.word	0x2401a9f9
2401a8ac:	2401a9f9 	.word	0x2401a9f9
2401a8b0:	2401a9f9 	.word	0x2401a9f9
2401a8b4:	2401a921 	.word	0x2401a921
2401a8b8:	2401a9f9 	.word	0x2401a9f9
2401a8bc:	2401a9f9 	.word	0x2401a9f9
2401a8c0:	2401a9f9 	.word	0x2401a9f9
2401a8c4:	2401a969 	.word	0x2401a969
2401a8c8:	2401a9f9 	.word	0x2401a9f9
2401a8cc:	2401a9f9 	.word	0x2401a9f9
2401a8d0:	2401a9f9 	.word	0x2401a9f9
2401a8d4:	2401a9b1 	.word	0x2401a9b1
  {
    case TIM_CHANNEL_1:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2401a8d8:	68fb      	ldr	r3, [r7, #12]
2401a8da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401a8dc:	4a6e      	ldr	r2, [pc, #440]	; (2401aa98 <HAL_TIM_IC_Start_DMA+0x378>)
2401a8de:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401a8e0:	68fb      	ldr	r3, [r7, #12]
2401a8e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401a8e4:	4a6d      	ldr	r2, [pc, #436]	; (2401aa9c <HAL_TIM_IC_Start_DMA+0x37c>)
2401a8e6:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2401a8e8:	68fb      	ldr	r3, [r7, #12]
2401a8ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401a8ec:	4a6c      	ldr	r2, [pc, #432]	; (2401aaa0 <HAL_TIM_IC_Start_DMA+0x380>)
2401a8ee:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData,
2401a8f0:	68fb      	ldr	r3, [r7, #12]
2401a8f2:	6a58      	ldr	r0, [r3, #36]	; 0x24
2401a8f4:	68fb      	ldr	r3, [r7, #12]
2401a8f6:	681b      	ldr	r3, [r3, #0]
2401a8f8:	3334      	adds	r3, #52	; 0x34
2401a8fa:	4619      	mov	r1, r3
2401a8fc:	687a      	ldr	r2, [r7, #4]
2401a8fe:	887b      	ldrh	r3, [r7, #2]
2401a900:	f7e9 f926 	bl	24003b50 <HAL_DMA_Start_IT>
2401a904:	4603      	mov	r3, r0
2401a906:	2b00      	cmp	r3, #0
2401a908:	d001      	beq.n	2401a90e <HAL_TIM_IC_Start_DMA+0x1ee>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401a90a:	2301      	movs	r3, #1
2401a90c:	e0c0      	b.n	2401aa90 <HAL_TIM_IC_Start_DMA+0x370>
      }
      /* Enable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2401a90e:	68fb      	ldr	r3, [r7, #12]
2401a910:	681b      	ldr	r3, [r3, #0]
2401a912:	68da      	ldr	r2, [r3, #12]
2401a914:	68fb      	ldr	r3, [r7, #12]
2401a916:	681b      	ldr	r3, [r3, #0]
2401a918:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2401a91c:	60da      	str	r2, [r3, #12]
      break;
2401a91e:	e06e      	b.n	2401a9fe <HAL_TIM_IC_Start_DMA+0x2de>
    }

    case TIM_CHANNEL_2:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2401a920:	68fb      	ldr	r3, [r7, #12]
2401a922:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401a924:	4a5c      	ldr	r2, [pc, #368]	; (2401aa98 <HAL_TIM_IC_Start_DMA+0x378>)
2401a926:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401a928:	68fb      	ldr	r3, [r7, #12]
2401a92a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401a92c:	4a5b      	ldr	r2, [pc, #364]	; (2401aa9c <HAL_TIM_IC_Start_DMA+0x37c>)
2401a92e:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
2401a930:	68fb      	ldr	r3, [r7, #12]
2401a932:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401a934:	4a5a      	ldr	r2, [pc, #360]	; (2401aaa0 <HAL_TIM_IC_Start_DMA+0x380>)
2401a936:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData,
2401a938:	68fb      	ldr	r3, [r7, #12]
2401a93a:	6a98      	ldr	r0, [r3, #40]	; 0x28
2401a93c:	68fb      	ldr	r3, [r7, #12]
2401a93e:	681b      	ldr	r3, [r3, #0]
2401a940:	3338      	adds	r3, #56	; 0x38
2401a942:	4619      	mov	r1, r3
2401a944:	687a      	ldr	r2, [r7, #4]
2401a946:	887b      	ldrh	r3, [r7, #2]
2401a948:	f7e9 f902 	bl	24003b50 <HAL_DMA_Start_IT>
2401a94c:	4603      	mov	r3, r0
2401a94e:	2b00      	cmp	r3, #0
2401a950:	d001      	beq.n	2401a956 <HAL_TIM_IC_Start_DMA+0x236>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401a952:	2301      	movs	r3, #1
2401a954:	e09c      	b.n	2401aa90 <HAL_TIM_IC_Start_DMA+0x370>
      }
      /* Enable the TIM Capture/Compare 2  DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2401a956:	68fb      	ldr	r3, [r7, #12]
2401a958:	681b      	ldr	r3, [r3, #0]
2401a95a:	68da      	ldr	r2, [r3, #12]
2401a95c:	68fb      	ldr	r3, [r7, #12]
2401a95e:	681b      	ldr	r3, [r3, #0]
2401a960:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
2401a964:	60da      	str	r2, [r3, #12]
      break;
2401a966:	e04a      	b.n	2401a9fe <HAL_TIM_IC_Start_DMA+0x2de>
    }

    case TIM_CHANNEL_3:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
2401a968:	68fb      	ldr	r3, [r7, #12]
2401a96a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401a96c:	4a4a      	ldr	r2, [pc, #296]	; (2401aa98 <HAL_TIM_IC_Start_DMA+0x378>)
2401a96e:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401a970:	68fb      	ldr	r3, [r7, #12]
2401a972:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401a974:	4a49      	ldr	r2, [pc, #292]	; (2401aa9c <HAL_TIM_IC_Start_DMA+0x37c>)
2401a976:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
2401a978:	68fb      	ldr	r3, [r7, #12]
2401a97a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401a97c:	4a48      	ldr	r2, [pc, #288]	; (2401aaa0 <HAL_TIM_IC_Start_DMA+0x380>)
2401a97e:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData,
2401a980:	68fb      	ldr	r3, [r7, #12]
2401a982:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2401a984:	68fb      	ldr	r3, [r7, #12]
2401a986:	681b      	ldr	r3, [r3, #0]
2401a988:	333c      	adds	r3, #60	; 0x3c
2401a98a:	4619      	mov	r1, r3
2401a98c:	687a      	ldr	r2, [r7, #4]
2401a98e:	887b      	ldrh	r3, [r7, #2]
2401a990:	f7e9 f8de 	bl	24003b50 <HAL_DMA_Start_IT>
2401a994:	4603      	mov	r3, r0
2401a996:	2b00      	cmp	r3, #0
2401a998:	d001      	beq.n	2401a99e <HAL_TIM_IC_Start_DMA+0x27e>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401a99a:	2301      	movs	r3, #1
2401a99c:	e078      	b.n	2401aa90 <HAL_TIM_IC_Start_DMA+0x370>
      }
      /* Enable the TIM Capture/Compare 3  DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
2401a99e:	68fb      	ldr	r3, [r7, #12]
2401a9a0:	681b      	ldr	r3, [r3, #0]
2401a9a2:	68da      	ldr	r2, [r3, #12]
2401a9a4:	68fb      	ldr	r3, [r7, #12]
2401a9a6:	681b      	ldr	r3, [r3, #0]
2401a9a8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
2401a9ac:	60da      	str	r2, [r3, #12]
      break;
2401a9ae:	e026      	b.n	2401a9fe <HAL_TIM_IC_Start_DMA+0x2de>
    }

    case TIM_CHANNEL_4:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
2401a9b0:	68fb      	ldr	r3, [r7, #12]
2401a9b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401a9b4:	4a38      	ldr	r2, [pc, #224]	; (2401aa98 <HAL_TIM_IC_Start_DMA+0x378>)
2401a9b6:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401a9b8:	68fb      	ldr	r3, [r7, #12]
2401a9ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401a9bc:	4a37      	ldr	r2, [pc, #220]	; (2401aa9c <HAL_TIM_IC_Start_DMA+0x37c>)
2401a9be:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
2401a9c0:	68fb      	ldr	r3, [r7, #12]
2401a9c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401a9c4:	4a36      	ldr	r2, [pc, #216]	; (2401aaa0 <HAL_TIM_IC_Start_DMA+0x380>)
2401a9c6:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData,
2401a9c8:	68fb      	ldr	r3, [r7, #12]
2401a9ca:	6b18      	ldr	r0, [r3, #48]	; 0x30
2401a9cc:	68fb      	ldr	r3, [r7, #12]
2401a9ce:	681b      	ldr	r3, [r3, #0]
2401a9d0:	3340      	adds	r3, #64	; 0x40
2401a9d2:	4619      	mov	r1, r3
2401a9d4:	687a      	ldr	r2, [r7, #4]
2401a9d6:	887b      	ldrh	r3, [r7, #2]
2401a9d8:	f7e9 f8ba 	bl	24003b50 <HAL_DMA_Start_IT>
2401a9dc:	4603      	mov	r3, r0
2401a9de:	2b00      	cmp	r3, #0
2401a9e0:	d001      	beq.n	2401a9e6 <HAL_TIM_IC_Start_DMA+0x2c6>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401a9e2:	2301      	movs	r3, #1
2401a9e4:	e054      	b.n	2401aa90 <HAL_TIM_IC_Start_DMA+0x370>
      }
      /* Enable the TIM Capture/Compare 4  DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
2401a9e6:	68fb      	ldr	r3, [r7, #12]
2401a9e8:	681b      	ldr	r3, [r3, #0]
2401a9ea:	68da      	ldr	r2, [r3, #12]
2401a9ec:	68fb      	ldr	r3, [r7, #12]
2401a9ee:	681b      	ldr	r3, [r3, #0]
2401a9f0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
2401a9f4:	60da      	str	r2, [r3, #12]
      break;
2401a9f6:	e002      	b.n	2401a9fe <HAL_TIM_IC_Start_DMA+0x2de>
    }

    default:
      status = HAL_ERROR;
2401a9f8:	2301      	movs	r3, #1
2401a9fa:	75fb      	strb	r3, [r7, #23]
      break;
2401a9fc:	bf00      	nop
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401a9fe:	68fb      	ldr	r3, [r7, #12]
2401aa00:	681b      	ldr	r3, [r3, #0]
2401aa02:	4a28      	ldr	r2, [pc, #160]	; (2401aaa4 <HAL_TIM_IC_Start_DMA+0x384>)
2401aa04:	4293      	cmp	r3, r2
2401aa06:	d022      	beq.n	2401aa4e <HAL_TIM_IC_Start_DMA+0x32e>
2401aa08:	68fb      	ldr	r3, [r7, #12]
2401aa0a:	681b      	ldr	r3, [r3, #0]
2401aa0c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401aa10:	d01d      	beq.n	2401aa4e <HAL_TIM_IC_Start_DMA+0x32e>
2401aa12:	68fb      	ldr	r3, [r7, #12]
2401aa14:	681b      	ldr	r3, [r3, #0]
2401aa16:	4a24      	ldr	r2, [pc, #144]	; (2401aaa8 <HAL_TIM_IC_Start_DMA+0x388>)
2401aa18:	4293      	cmp	r3, r2
2401aa1a:	d018      	beq.n	2401aa4e <HAL_TIM_IC_Start_DMA+0x32e>
2401aa1c:	68fb      	ldr	r3, [r7, #12]
2401aa1e:	681b      	ldr	r3, [r3, #0]
2401aa20:	4a22      	ldr	r2, [pc, #136]	; (2401aaac <HAL_TIM_IC_Start_DMA+0x38c>)
2401aa22:	4293      	cmp	r3, r2
2401aa24:	d013      	beq.n	2401aa4e <HAL_TIM_IC_Start_DMA+0x32e>
2401aa26:	68fb      	ldr	r3, [r7, #12]
2401aa28:	681b      	ldr	r3, [r3, #0]
2401aa2a:	4a21      	ldr	r2, [pc, #132]	; (2401aab0 <HAL_TIM_IC_Start_DMA+0x390>)
2401aa2c:	4293      	cmp	r3, r2
2401aa2e:	d00e      	beq.n	2401aa4e <HAL_TIM_IC_Start_DMA+0x32e>
2401aa30:	68fb      	ldr	r3, [r7, #12]
2401aa32:	681b      	ldr	r3, [r3, #0]
2401aa34:	4a1f      	ldr	r2, [pc, #124]	; (2401aab4 <HAL_TIM_IC_Start_DMA+0x394>)
2401aa36:	4293      	cmp	r3, r2
2401aa38:	d009      	beq.n	2401aa4e <HAL_TIM_IC_Start_DMA+0x32e>
2401aa3a:	68fb      	ldr	r3, [r7, #12]
2401aa3c:	681b      	ldr	r3, [r3, #0]
2401aa3e:	4a1e      	ldr	r2, [pc, #120]	; (2401aab8 <HAL_TIM_IC_Start_DMA+0x398>)
2401aa40:	4293      	cmp	r3, r2
2401aa42:	d004      	beq.n	2401aa4e <HAL_TIM_IC_Start_DMA+0x32e>
2401aa44:	68fb      	ldr	r3, [r7, #12]
2401aa46:	681b      	ldr	r3, [r3, #0]
2401aa48:	4a1c      	ldr	r2, [pc, #112]	; (2401aabc <HAL_TIM_IC_Start_DMA+0x39c>)
2401aa4a:	4293      	cmp	r3, r2
2401aa4c:	d115      	bne.n	2401aa7a <HAL_TIM_IC_Start_DMA+0x35a>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401aa4e:	68fb      	ldr	r3, [r7, #12]
2401aa50:	681b      	ldr	r3, [r3, #0]
2401aa52:	689a      	ldr	r2, [r3, #8]
2401aa54:	4b1a      	ldr	r3, [pc, #104]	; (2401aac0 <HAL_TIM_IC_Start_DMA+0x3a0>)
2401aa56:	4013      	ands	r3, r2
2401aa58:	613b      	str	r3, [r7, #16]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401aa5a:	693b      	ldr	r3, [r7, #16]
2401aa5c:	2b06      	cmp	r3, #6
2401aa5e:	d015      	beq.n	2401aa8c <HAL_TIM_IC_Start_DMA+0x36c>
2401aa60:	693b      	ldr	r3, [r7, #16]
2401aa62:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401aa66:	d011      	beq.n	2401aa8c <HAL_TIM_IC_Start_DMA+0x36c>
    {
      __HAL_TIM_ENABLE(htim);
2401aa68:	68fb      	ldr	r3, [r7, #12]
2401aa6a:	681b      	ldr	r3, [r3, #0]
2401aa6c:	681a      	ldr	r2, [r3, #0]
2401aa6e:	68fb      	ldr	r3, [r7, #12]
2401aa70:	681b      	ldr	r3, [r3, #0]
2401aa72:	f042 0201 	orr.w	r2, r2, #1
2401aa76:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401aa78:	e008      	b.n	2401aa8c <HAL_TIM_IC_Start_DMA+0x36c>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
2401aa7a:	68fb      	ldr	r3, [r7, #12]
2401aa7c:	681b      	ldr	r3, [r3, #0]
2401aa7e:	681a      	ldr	r2, [r3, #0]
2401aa80:	68fb      	ldr	r3, [r7, #12]
2401aa82:	681b      	ldr	r3, [r3, #0]
2401aa84:	f042 0201 	orr.w	r2, r2, #1
2401aa88:	601a      	str	r2, [r3, #0]
2401aa8a:	e000      	b.n	2401aa8e <HAL_TIM_IC_Start_DMA+0x36e>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401aa8c:	bf00      	nop
  }

  /* Return function status */
  return status;
2401aa8e:	7dfb      	ldrb	r3, [r7, #23]
}
2401aa90:	4618      	mov	r0, r3
2401aa92:	3718      	adds	r7, #24
2401aa94:	46bd      	mov	sp, r7
2401aa96:	bd80      	pop	{r7, pc}
2401aa98:	2401d761 	.word	0x2401d761
2401aa9c:	2401d829 	.word	0x2401d829
2401aaa0:	2401d5bf 	.word	0x2401d5bf
2401aaa4:	40010000 	.word	0x40010000
2401aaa8:	40000400 	.word	0x40000400
2401aaac:	40000800 	.word	0x40000800
2401aab0:	40000c00 	.word	0x40000c00
2401aab4:	40010400 	.word	0x40010400
2401aab8:	40001800 	.word	0x40001800
2401aabc:	40014000 	.word	0x40014000
2401aac0:	00010007 	.word	0x00010007

2401aac4 <HAL_TIM_IC_Stop_DMA>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401aac4:	b580      	push	{r7, lr}
2401aac6:	b084      	sub	sp, #16
2401aac8:	af00      	add	r7, sp, #0
2401aaca:	6078      	str	r0, [r7, #4]
2401aacc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401aace:	2300      	movs	r3, #0
2401aad0:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));

  /* Disable the Input Capture channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2401aad2:	687b      	ldr	r3, [r7, #4]
2401aad4:	681b      	ldr	r3, [r3, #0]
2401aad6:	2200      	movs	r2, #0
2401aad8:	6839      	ldr	r1, [r7, #0]
2401aada:	4618      	mov	r0, r3
2401aadc:	f003 fd44 	bl	2401e568 <TIM_CCxChannelCmd>

  switch (Channel)
2401aae0:	683b      	ldr	r3, [r7, #0]
2401aae2:	2b0c      	cmp	r3, #12
2401aae4:	d854      	bhi.n	2401ab90 <HAL_TIM_IC_Stop_DMA+0xcc>
2401aae6:	a201      	add	r2, pc, #4	; (adr r2, 2401aaec <HAL_TIM_IC_Stop_DMA+0x28>)
2401aae8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401aaec:	2401ab21 	.word	0x2401ab21
2401aaf0:	2401ab91 	.word	0x2401ab91
2401aaf4:	2401ab91 	.word	0x2401ab91
2401aaf8:	2401ab91 	.word	0x2401ab91
2401aafc:	2401ab3d 	.word	0x2401ab3d
2401ab00:	2401ab91 	.word	0x2401ab91
2401ab04:	2401ab91 	.word	0x2401ab91
2401ab08:	2401ab91 	.word	0x2401ab91
2401ab0c:	2401ab59 	.word	0x2401ab59
2401ab10:	2401ab91 	.word	0x2401ab91
2401ab14:	2401ab91 	.word	0x2401ab91
2401ab18:	2401ab91 	.word	0x2401ab91
2401ab1c:	2401ab75 	.word	0x2401ab75
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2401ab20:	687b      	ldr	r3, [r7, #4]
2401ab22:	681b      	ldr	r3, [r3, #0]
2401ab24:	68da      	ldr	r2, [r3, #12]
2401ab26:	687b      	ldr	r3, [r7, #4]
2401ab28:	681b      	ldr	r3, [r3, #0]
2401ab2a:	f422 7200 	bic.w	r2, r2, #512	; 0x200
2401ab2e:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2401ab30:	687b      	ldr	r3, [r7, #4]
2401ab32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401ab34:	4618      	mov	r0, r3
2401ab36:	f7e9 fd93 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401ab3a:	e02c      	b.n	2401ab96 <HAL_TIM_IC_Stop_DMA+0xd2>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2401ab3c:	687b      	ldr	r3, [r7, #4]
2401ab3e:	681b      	ldr	r3, [r3, #0]
2401ab40:	68da      	ldr	r2, [r3, #12]
2401ab42:	687b      	ldr	r3, [r7, #4]
2401ab44:	681b      	ldr	r3, [r3, #0]
2401ab46:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2401ab4a:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2401ab4c:	687b      	ldr	r3, [r7, #4]
2401ab4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401ab50:	4618      	mov	r0, r3
2401ab52:	f7e9 fd85 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401ab56:	e01e      	b.n	2401ab96 <HAL_TIM_IC_Stop_DMA+0xd2>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3  DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2401ab58:	687b      	ldr	r3, [r7, #4]
2401ab5a:	681b      	ldr	r3, [r3, #0]
2401ab5c:	68da      	ldr	r2, [r3, #12]
2401ab5e:	687b      	ldr	r3, [r7, #4]
2401ab60:	681b      	ldr	r3, [r3, #0]
2401ab62:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
2401ab66:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2401ab68:	687b      	ldr	r3, [r7, #4]
2401ab6a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401ab6c:	4618      	mov	r0, r3
2401ab6e:	f7e9 fd77 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401ab72:	e010      	b.n	2401ab96 <HAL_TIM_IC_Stop_DMA+0xd2>
    }

    case TIM_CHANNEL_4:
    {
      /* Disable the TIM Capture/Compare 4  DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
2401ab74:	687b      	ldr	r3, [r7, #4]
2401ab76:	681b      	ldr	r3, [r3, #0]
2401ab78:	68da      	ldr	r2, [r3, #12]
2401ab7a:	687b      	ldr	r3, [r7, #4]
2401ab7c:	681b      	ldr	r3, [r3, #0]
2401ab7e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2401ab82:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2401ab84:	687b      	ldr	r3, [r7, #4]
2401ab86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401ab88:	4618      	mov	r0, r3
2401ab8a:	f7e9 fd69 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401ab8e:	e002      	b.n	2401ab96 <HAL_TIM_IC_Stop_DMA+0xd2>
    }

    default:
      status = HAL_ERROR;
2401ab90:	2301      	movs	r3, #1
2401ab92:	73fb      	strb	r3, [r7, #15]
      break;
2401ab94:	bf00      	nop
  }

  if (status == HAL_OK)
2401ab96:	7bfb      	ldrb	r3, [r7, #15]
2401ab98:	2b00      	cmp	r3, #0
2401ab9a:	d15f      	bne.n	2401ac5c <HAL_TIM_IC_Stop_DMA+0x198>
  {
    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
2401ab9c:	687b      	ldr	r3, [r7, #4]
2401ab9e:	681b      	ldr	r3, [r3, #0]
2401aba0:	6a1a      	ldr	r2, [r3, #32]
2401aba2:	f241 1311 	movw	r3, #4369	; 0x1111
2401aba6:	4013      	ands	r3, r2
2401aba8:	2b00      	cmp	r3, #0
2401abaa:	d10f      	bne.n	2401abcc <HAL_TIM_IC_Stop_DMA+0x108>
2401abac:	687b      	ldr	r3, [r7, #4]
2401abae:	681b      	ldr	r3, [r3, #0]
2401abb0:	6a1a      	ldr	r2, [r3, #32]
2401abb2:	f240 4344 	movw	r3, #1092	; 0x444
2401abb6:	4013      	ands	r3, r2
2401abb8:	2b00      	cmp	r3, #0
2401abba:	d107      	bne.n	2401abcc <HAL_TIM_IC_Stop_DMA+0x108>
2401abbc:	687b      	ldr	r3, [r7, #4]
2401abbe:	681b      	ldr	r3, [r3, #0]
2401abc0:	681a      	ldr	r2, [r3, #0]
2401abc2:	687b      	ldr	r3, [r7, #4]
2401abc4:	681b      	ldr	r3, [r3, #0]
2401abc6:	f022 0201 	bic.w	r2, r2, #1
2401abca:	601a      	str	r2, [r3, #0]

    /* Set the TIM channel state */
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401abcc:	683b      	ldr	r3, [r7, #0]
2401abce:	2b00      	cmp	r3, #0
2401abd0:	d104      	bne.n	2401abdc <HAL_TIM_IC_Stop_DMA+0x118>
2401abd2:	687b      	ldr	r3, [r7, #4]
2401abd4:	2201      	movs	r2, #1
2401abd6:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401abda:	e023      	b.n	2401ac24 <HAL_TIM_IC_Stop_DMA+0x160>
2401abdc:	683b      	ldr	r3, [r7, #0]
2401abde:	2b04      	cmp	r3, #4
2401abe0:	d104      	bne.n	2401abec <HAL_TIM_IC_Stop_DMA+0x128>
2401abe2:	687b      	ldr	r3, [r7, #4]
2401abe4:	2201      	movs	r2, #1
2401abe6:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401abea:	e01b      	b.n	2401ac24 <HAL_TIM_IC_Stop_DMA+0x160>
2401abec:	683b      	ldr	r3, [r7, #0]
2401abee:	2b08      	cmp	r3, #8
2401abf0:	d104      	bne.n	2401abfc <HAL_TIM_IC_Stop_DMA+0x138>
2401abf2:	687b      	ldr	r3, [r7, #4]
2401abf4:	2201      	movs	r2, #1
2401abf6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401abfa:	e013      	b.n	2401ac24 <HAL_TIM_IC_Stop_DMA+0x160>
2401abfc:	683b      	ldr	r3, [r7, #0]
2401abfe:	2b0c      	cmp	r3, #12
2401ac00:	d104      	bne.n	2401ac0c <HAL_TIM_IC_Stop_DMA+0x148>
2401ac02:	687b      	ldr	r3, [r7, #4]
2401ac04:	2201      	movs	r2, #1
2401ac06:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401ac0a:	e00b      	b.n	2401ac24 <HAL_TIM_IC_Stop_DMA+0x160>
2401ac0c:	683b      	ldr	r3, [r7, #0]
2401ac0e:	2b10      	cmp	r3, #16
2401ac10:	d104      	bne.n	2401ac1c <HAL_TIM_IC_Stop_DMA+0x158>
2401ac12:	687b      	ldr	r3, [r7, #4]
2401ac14:	2201      	movs	r2, #1
2401ac16:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401ac1a:	e003      	b.n	2401ac24 <HAL_TIM_IC_Stop_DMA+0x160>
2401ac1c:	687b      	ldr	r3, [r7, #4]
2401ac1e:	2201      	movs	r2, #1
2401ac20:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401ac24:	683b      	ldr	r3, [r7, #0]
2401ac26:	2b00      	cmp	r3, #0
2401ac28:	d104      	bne.n	2401ac34 <HAL_TIM_IC_Stop_DMA+0x170>
2401ac2a:	687b      	ldr	r3, [r7, #4]
2401ac2c:	2201      	movs	r2, #1
2401ac2e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401ac32:	e013      	b.n	2401ac5c <HAL_TIM_IC_Stop_DMA+0x198>
2401ac34:	683b      	ldr	r3, [r7, #0]
2401ac36:	2b04      	cmp	r3, #4
2401ac38:	d104      	bne.n	2401ac44 <HAL_TIM_IC_Stop_DMA+0x180>
2401ac3a:	687b      	ldr	r3, [r7, #4]
2401ac3c:	2201      	movs	r2, #1
2401ac3e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401ac42:	e00b      	b.n	2401ac5c <HAL_TIM_IC_Stop_DMA+0x198>
2401ac44:	683b      	ldr	r3, [r7, #0]
2401ac46:	2b08      	cmp	r3, #8
2401ac48:	d104      	bne.n	2401ac54 <HAL_TIM_IC_Stop_DMA+0x190>
2401ac4a:	687b      	ldr	r3, [r7, #4]
2401ac4c:	2201      	movs	r2, #1
2401ac4e:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401ac52:	e003      	b.n	2401ac5c <HAL_TIM_IC_Stop_DMA+0x198>
2401ac54:	687b      	ldr	r3, [r7, #4]
2401ac56:	2201      	movs	r2, #1
2401ac58:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  }

  /* Return function status */
  return status;
2401ac5c:	7bfb      	ldrb	r3, [r7, #15]
}
2401ac5e:	4618      	mov	r0, r3
2401ac60:	3710      	adds	r7, #16
2401ac62:	46bd      	mov	sp, r7
2401ac64:	bd80      	pop	{r7, pc}
2401ac66:	bf00      	nop

2401ac68 <HAL_TIM_OnePulse_Init>:
  *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
  *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
{
2401ac68:	b580      	push	{r7, lr}
2401ac6a:	b082      	sub	sp, #8
2401ac6c:	af00      	add	r7, sp, #0
2401ac6e:	6078      	str	r0, [r7, #4]
2401ac70:	6039      	str	r1, [r7, #0]
  /* Check the TIM handle allocation */
  if (htim == NULL)
2401ac72:	687b      	ldr	r3, [r7, #4]
2401ac74:	2b00      	cmp	r3, #0
2401ac76:	d101      	bne.n	2401ac7c <HAL_TIM_OnePulse_Init+0x14>
  {
    return HAL_ERROR;
2401ac78:	2301      	movs	r3, #1
2401ac7a:	e041      	b.n	2401ad00 <HAL_TIM_OnePulse_Init+0x98>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_OPM_MODE(OnePulseMode));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
2401ac7c:	687b      	ldr	r3, [r7, #4]
2401ac7e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401ac82:	b2db      	uxtb	r3, r3
2401ac84:	2b00      	cmp	r3, #0
2401ac86:	d106      	bne.n	2401ac96 <HAL_TIM_OnePulse_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
2401ac88:	687b      	ldr	r3, [r7, #4]
2401ac8a:	2200      	movs	r2, #0
2401ac8c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->OnePulse_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_OnePulse_MspInit(htim);
2401ac90:	6878      	ldr	r0, [r7, #4]
2401ac92:	f000 f87d 	bl	2401ad90 <HAL_TIM_OnePulse_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
2401ac96:	687b      	ldr	r3, [r7, #4]
2401ac98:	2202      	movs	r2, #2
2401ac9a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Configure the Time base in the One Pulse Mode */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2401ac9e:	687b      	ldr	r3, [r7, #4]
2401aca0:	681a      	ldr	r2, [r3, #0]
2401aca2:	687b      	ldr	r3, [r7, #4]
2401aca4:	3304      	adds	r3, #4
2401aca6:	4619      	mov	r1, r3
2401aca8:	4610      	mov	r0, r2
2401acaa:	f002 fe3b 	bl	2401d924 <TIM_Base_SetConfig>

  /* Reset the OPM Bit */
  htim->Instance->CR1 &= ~TIM_CR1_OPM;
2401acae:	687b      	ldr	r3, [r7, #4]
2401acb0:	681b      	ldr	r3, [r3, #0]
2401acb2:	681a      	ldr	r2, [r3, #0]
2401acb4:	687b      	ldr	r3, [r7, #4]
2401acb6:	681b      	ldr	r3, [r3, #0]
2401acb8:	f022 0208 	bic.w	r2, r2, #8
2401acbc:	601a      	str	r2, [r3, #0]

  /* Configure the OPM Mode */
  htim->Instance->CR1 |= OnePulseMode;
2401acbe:	687b      	ldr	r3, [r7, #4]
2401acc0:	681b      	ldr	r3, [r3, #0]
2401acc2:	6819      	ldr	r1, [r3, #0]
2401acc4:	687b      	ldr	r3, [r7, #4]
2401acc6:	681b      	ldr	r3, [r3, #0]
2401acc8:	683a      	ldr	r2, [r7, #0]
2401acca:	430a      	orrs	r2, r1
2401accc:	601a      	str	r2, [r3, #0]

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
2401acce:	687b      	ldr	r3, [r7, #4]
2401acd0:	2201      	movs	r2, #1
2401acd2:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401acd6:	687b      	ldr	r3, [r7, #4]
2401acd8:	2201      	movs	r2, #1
2401acda:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401acde:	687b      	ldr	r3, [r7, #4]
2401ace0:	2201      	movs	r2, #1
2401ace2:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401ace6:	687b      	ldr	r3, [r7, #4]
2401ace8:	2201      	movs	r2, #1
2401acea:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401acee:	687b      	ldr	r3, [r7, #4]
2401acf0:	2201      	movs	r2, #1
2401acf2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
2401acf6:	687b      	ldr	r3, [r7, #4]
2401acf8:	2201      	movs	r2, #1
2401acfa:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
2401acfe:	2300      	movs	r3, #0
}
2401ad00:	4618      	mov	r0, r3
2401ad02:	3708      	adds	r7, #8
2401ad04:	46bd      	mov	sp, r7
2401ad06:	bd80      	pop	{r7, pc}

2401ad08 <HAL_TIM_OnePulse_DeInit>:
  * @brief  DeInitializes the TIM One Pulse
  * @param  htim TIM One Pulse handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
{
2401ad08:	b580      	push	{r7, lr}
2401ad0a:	b082      	sub	sp, #8
2401ad0c:	af00      	add	r7, sp, #0
2401ad0e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
2401ad10:	687b      	ldr	r3, [r7, #4]
2401ad12:	2202      	movs	r2, #2
2401ad14:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
2401ad18:	687b      	ldr	r3, [r7, #4]
2401ad1a:	681b      	ldr	r3, [r3, #0]
2401ad1c:	6a1a      	ldr	r2, [r3, #32]
2401ad1e:	f241 1311 	movw	r3, #4369	; 0x1111
2401ad22:	4013      	ands	r3, r2
2401ad24:	2b00      	cmp	r3, #0
2401ad26:	d10f      	bne.n	2401ad48 <HAL_TIM_OnePulse_DeInit+0x40>
2401ad28:	687b      	ldr	r3, [r7, #4]
2401ad2a:	681b      	ldr	r3, [r3, #0]
2401ad2c:	6a1a      	ldr	r2, [r3, #32]
2401ad2e:	f240 4344 	movw	r3, #1092	; 0x444
2401ad32:	4013      	ands	r3, r2
2401ad34:	2b00      	cmp	r3, #0
2401ad36:	d107      	bne.n	2401ad48 <HAL_TIM_OnePulse_DeInit+0x40>
2401ad38:	687b      	ldr	r3, [r7, #4]
2401ad3a:	681b      	ldr	r3, [r3, #0]
2401ad3c:	681a      	ldr	r2, [r3, #0]
2401ad3e:	687b      	ldr	r3, [r7, #4]
2401ad40:	681b      	ldr	r3, [r3, #0]
2401ad42:	f022 0201 	bic.w	r2, r2, #1
2401ad46:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->OnePulse_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_OnePulse_MspDeInit(htim);
2401ad48:	6878      	ldr	r0, [r7, #4]
2401ad4a:	f000 f82b 	bl	2401ada4 <HAL_TIM_OnePulse_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
2401ad4e:	687b      	ldr	r3, [r7, #4]
2401ad50:	2200      	movs	r2, #0
2401ad52:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
2401ad56:	687b      	ldr	r3, [r7, #4]
2401ad58:	2200      	movs	r2, #0
2401ad5a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
2401ad5e:	687b      	ldr	r3, [r7, #4]
2401ad60:	2200      	movs	r2, #0
2401ad62:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
2401ad66:	687b      	ldr	r3, [r7, #4]
2401ad68:	2200      	movs	r2, #0
2401ad6a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
2401ad6e:	687b      	ldr	r3, [r7, #4]
2401ad70:	2200      	movs	r2, #0
2401ad72:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
2401ad76:	687b      	ldr	r3, [r7, #4]
2401ad78:	2200      	movs	r2, #0
2401ad7a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
2401ad7e:	687b      	ldr	r3, [r7, #4]
2401ad80:	2200      	movs	r2, #0
2401ad82:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2401ad86:	2300      	movs	r3, #0
}
2401ad88:	4618      	mov	r0, r3
2401ad8a:	3708      	adds	r7, #8
2401ad8c:	46bd      	mov	sp, r7
2401ad8e:	bd80      	pop	{r7, pc}

2401ad90 <HAL_TIM_OnePulse_MspInit>:
  * @brief  Initializes the TIM One Pulse MSP.
  * @param  htim TIM One Pulse handle
  * @retval None
  */
__weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
{
2401ad90:	b480      	push	{r7}
2401ad92:	b083      	sub	sp, #12
2401ad94:	af00      	add	r7, sp, #0
2401ad96:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   */
}
2401ad98:	bf00      	nop
2401ad9a:	370c      	adds	r7, #12
2401ad9c:	46bd      	mov	sp, r7
2401ad9e:	f85d 7b04 	ldr.w	r7, [sp], #4
2401ada2:	4770      	bx	lr

2401ada4 <HAL_TIM_OnePulse_MspDeInit>:
  * @brief  DeInitializes TIM One Pulse MSP.
  * @param  htim TIM One Pulse handle
  * @retval None
  */
__weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
{
2401ada4:	b480      	push	{r7}
2401ada6:	b083      	sub	sp, #12
2401ada8:	af00      	add	r7, sp, #0
2401adaa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   */
}
2401adac:	bf00      	nop
2401adae:	370c      	adds	r7, #12
2401adb0:	46bd      	mov	sp, r7
2401adb2:	f85d 7b04 	ldr.w	r7, [sp], #4
2401adb6:	4770      	bx	lr

2401adb8 <HAL_TIM_OnePulse_Start>:
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
2401adb8:	b580      	push	{r7, lr}
2401adba:	b084      	sub	sp, #16
2401adbc:	af00      	add	r7, sp, #0
2401adbe:	6078      	str	r0, [r7, #4]
2401adc0:	6039      	str	r1, [r7, #0]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
2401adc2:	687b      	ldr	r3, [r7, #4]
2401adc4:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401adc8:	73fb      	strb	r3, [r7, #15]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
2401adca:	687b      	ldr	r3, [r7, #4]
2401adcc:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401add0:	73bb      	strb	r3, [r7, #14]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
2401add2:	687b      	ldr	r3, [r7, #4]
2401add4:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401add8:	737b      	strb	r3, [r7, #13]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
2401adda:	687b      	ldr	r3, [r7, #4]
2401addc:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401ade0:	733b      	strb	r3, [r7, #12]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(OutputChannel);

  /* Check the TIM channels state */
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401ade2:	7bfb      	ldrb	r3, [r7, #15]
2401ade4:	2b01      	cmp	r3, #1
2401ade6:	d108      	bne.n	2401adfa <HAL_TIM_OnePulse_Start+0x42>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2401ade8:	7bbb      	ldrb	r3, [r7, #14]
2401adea:	2b01      	cmp	r3, #1
2401adec:	d105      	bne.n	2401adfa <HAL_TIM_OnePulse_Start+0x42>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401adee:	7b7b      	ldrb	r3, [r7, #13]
2401adf0:	2b01      	cmp	r3, #1
2401adf2:	d102      	bne.n	2401adfa <HAL_TIM_OnePulse_Start+0x42>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2401adf4:	7b3b      	ldrb	r3, [r7, #12]
2401adf6:	2b01      	cmp	r3, #1
2401adf8:	d001      	beq.n	2401adfe <HAL_TIM_OnePulse_Start+0x46>
  {
    return HAL_ERROR;
2401adfa:	2301      	movs	r3, #1
2401adfc:	e044      	b.n	2401ae88 <HAL_TIM_OnePulse_Start+0xd0>
  }

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401adfe:	687b      	ldr	r3, [r7, #4]
2401ae00:	2202      	movs	r2, #2
2401ae02:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401ae06:	687b      	ldr	r3, [r7, #4]
2401ae08:	2202      	movs	r2, #2
2401ae0a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401ae0e:	687b      	ldr	r3, [r7, #4]
2401ae10:	2202      	movs	r2, #2
2401ae12:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401ae16:	687b      	ldr	r3, [r7, #4]
2401ae18:	2202      	movs	r2, #2
2401ae1a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together

    No need to enable the counter, it's enabled automatically by hardware
    (the counter starts in response to a stimulus and generate a pulse */

  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401ae1e:	687b      	ldr	r3, [r7, #4]
2401ae20:	681b      	ldr	r3, [r3, #0]
2401ae22:	2201      	movs	r2, #1
2401ae24:	2100      	movs	r1, #0
2401ae26:	4618      	mov	r0, r3
2401ae28:	f003 fb9e 	bl	2401e568 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
2401ae2c:	687b      	ldr	r3, [r7, #4]
2401ae2e:	681b      	ldr	r3, [r3, #0]
2401ae30:	2201      	movs	r2, #1
2401ae32:	2104      	movs	r1, #4
2401ae34:	4618      	mov	r0, r3
2401ae36:	f003 fb97 	bl	2401e568 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2401ae3a:	687b      	ldr	r3, [r7, #4]
2401ae3c:	681b      	ldr	r3, [r3, #0]
2401ae3e:	4a14      	ldr	r2, [pc, #80]	; (2401ae90 <HAL_TIM_OnePulse_Start+0xd8>)
2401ae40:	4293      	cmp	r3, r2
2401ae42:	d013      	beq.n	2401ae6c <HAL_TIM_OnePulse_Start+0xb4>
2401ae44:	687b      	ldr	r3, [r7, #4]
2401ae46:	681b      	ldr	r3, [r3, #0]
2401ae48:	4a12      	ldr	r2, [pc, #72]	; (2401ae94 <HAL_TIM_OnePulse_Start+0xdc>)
2401ae4a:	4293      	cmp	r3, r2
2401ae4c:	d00e      	beq.n	2401ae6c <HAL_TIM_OnePulse_Start+0xb4>
2401ae4e:	687b      	ldr	r3, [r7, #4]
2401ae50:	681b      	ldr	r3, [r3, #0]
2401ae52:	4a11      	ldr	r2, [pc, #68]	; (2401ae98 <HAL_TIM_OnePulse_Start+0xe0>)
2401ae54:	4293      	cmp	r3, r2
2401ae56:	d009      	beq.n	2401ae6c <HAL_TIM_OnePulse_Start+0xb4>
2401ae58:	687b      	ldr	r3, [r7, #4]
2401ae5a:	681b      	ldr	r3, [r3, #0]
2401ae5c:	4a0f      	ldr	r2, [pc, #60]	; (2401ae9c <HAL_TIM_OnePulse_Start+0xe4>)
2401ae5e:	4293      	cmp	r3, r2
2401ae60:	d004      	beq.n	2401ae6c <HAL_TIM_OnePulse_Start+0xb4>
2401ae62:	687b      	ldr	r3, [r7, #4]
2401ae64:	681b      	ldr	r3, [r3, #0]
2401ae66:	4a0e      	ldr	r2, [pc, #56]	; (2401aea0 <HAL_TIM_OnePulse_Start+0xe8>)
2401ae68:	4293      	cmp	r3, r2
2401ae6a:	d101      	bne.n	2401ae70 <HAL_TIM_OnePulse_Start+0xb8>
2401ae6c:	2301      	movs	r3, #1
2401ae6e:	e000      	b.n	2401ae72 <HAL_TIM_OnePulse_Start+0xba>
2401ae70:	2300      	movs	r3, #0
2401ae72:	2b00      	cmp	r3, #0
2401ae74:	d007      	beq.n	2401ae86 <HAL_TIM_OnePulse_Start+0xce>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
2401ae76:	687b      	ldr	r3, [r7, #4]
2401ae78:	681b      	ldr	r3, [r3, #0]
2401ae7a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401ae7c:	687b      	ldr	r3, [r7, #4]
2401ae7e:	681b      	ldr	r3, [r3, #0]
2401ae80:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401ae84:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Return function status */
  return HAL_OK;
2401ae86:	2300      	movs	r3, #0
}
2401ae88:	4618      	mov	r0, r3
2401ae8a:	3710      	adds	r7, #16
2401ae8c:	46bd      	mov	sp, r7
2401ae8e:	bd80      	pop	{r7, pc}
2401ae90:	40010000 	.word	0x40010000
2401ae94:	40010400 	.word	0x40010400
2401ae98:	40014000 	.word	0x40014000
2401ae9c:	40014400 	.word	0x40014400
2401aea0:	40014800 	.word	0x40014800

2401aea4 <HAL_TIM_OnePulse_Stop>:
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
2401aea4:	b580      	push	{r7, lr}
2401aea6:	b082      	sub	sp, #8
2401aea8:	af00      	add	r7, sp, #0
2401aeaa:	6078      	str	r0, [r7, #4]
2401aeac:	6039      	str	r1, [r7, #0]
  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */

  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401aeae:	687b      	ldr	r3, [r7, #4]
2401aeb0:	681b      	ldr	r3, [r3, #0]
2401aeb2:	2200      	movs	r2, #0
2401aeb4:	2100      	movs	r1, #0
2401aeb6:	4618      	mov	r0, r3
2401aeb8:	f003 fb56 	bl	2401e568 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
2401aebc:	687b      	ldr	r3, [r7, #4]
2401aebe:	681b      	ldr	r3, [r3, #0]
2401aec0:	2200      	movs	r2, #0
2401aec2:	2104      	movs	r1, #4
2401aec4:	4618      	mov	r0, r3
2401aec6:	f003 fb4f 	bl	2401e568 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2401aeca:	687b      	ldr	r3, [r7, #4]
2401aecc:	681b      	ldr	r3, [r3, #0]
2401aece:	4a30      	ldr	r2, [pc, #192]	; (2401af90 <HAL_TIM_OnePulse_Stop+0xec>)
2401aed0:	4293      	cmp	r3, r2
2401aed2:	d013      	beq.n	2401aefc <HAL_TIM_OnePulse_Stop+0x58>
2401aed4:	687b      	ldr	r3, [r7, #4]
2401aed6:	681b      	ldr	r3, [r3, #0]
2401aed8:	4a2e      	ldr	r2, [pc, #184]	; (2401af94 <HAL_TIM_OnePulse_Stop+0xf0>)
2401aeda:	4293      	cmp	r3, r2
2401aedc:	d00e      	beq.n	2401aefc <HAL_TIM_OnePulse_Stop+0x58>
2401aede:	687b      	ldr	r3, [r7, #4]
2401aee0:	681b      	ldr	r3, [r3, #0]
2401aee2:	4a2d      	ldr	r2, [pc, #180]	; (2401af98 <HAL_TIM_OnePulse_Stop+0xf4>)
2401aee4:	4293      	cmp	r3, r2
2401aee6:	d009      	beq.n	2401aefc <HAL_TIM_OnePulse_Stop+0x58>
2401aee8:	687b      	ldr	r3, [r7, #4]
2401aeea:	681b      	ldr	r3, [r3, #0]
2401aeec:	4a2b      	ldr	r2, [pc, #172]	; (2401af9c <HAL_TIM_OnePulse_Stop+0xf8>)
2401aeee:	4293      	cmp	r3, r2
2401aef0:	d004      	beq.n	2401aefc <HAL_TIM_OnePulse_Stop+0x58>
2401aef2:	687b      	ldr	r3, [r7, #4]
2401aef4:	681b      	ldr	r3, [r3, #0]
2401aef6:	4a2a      	ldr	r2, [pc, #168]	; (2401afa0 <HAL_TIM_OnePulse_Stop+0xfc>)
2401aef8:	4293      	cmp	r3, r2
2401aefa:	d101      	bne.n	2401af00 <HAL_TIM_OnePulse_Stop+0x5c>
2401aefc:	2301      	movs	r3, #1
2401aefe:	e000      	b.n	2401af02 <HAL_TIM_OnePulse_Stop+0x5e>
2401af00:	2300      	movs	r3, #0
2401af02:	2b00      	cmp	r3, #0
2401af04:	d017      	beq.n	2401af36 <HAL_TIM_OnePulse_Stop+0x92>
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
2401af06:	687b      	ldr	r3, [r7, #4]
2401af08:	681b      	ldr	r3, [r3, #0]
2401af0a:	6a1a      	ldr	r2, [r3, #32]
2401af0c:	f241 1311 	movw	r3, #4369	; 0x1111
2401af10:	4013      	ands	r3, r2
2401af12:	2b00      	cmp	r3, #0
2401af14:	d10f      	bne.n	2401af36 <HAL_TIM_OnePulse_Stop+0x92>
2401af16:	687b      	ldr	r3, [r7, #4]
2401af18:	681b      	ldr	r3, [r3, #0]
2401af1a:	6a1a      	ldr	r2, [r3, #32]
2401af1c:	f240 4344 	movw	r3, #1092	; 0x444
2401af20:	4013      	ands	r3, r2
2401af22:	2b00      	cmp	r3, #0
2401af24:	d107      	bne.n	2401af36 <HAL_TIM_OnePulse_Stop+0x92>
2401af26:	687b      	ldr	r3, [r7, #4]
2401af28:	681b      	ldr	r3, [r3, #0]
2401af2a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401af2c:	687b      	ldr	r3, [r7, #4]
2401af2e:	681b      	ldr	r3, [r3, #0]
2401af30:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401af34:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401af36:	687b      	ldr	r3, [r7, #4]
2401af38:	681b      	ldr	r3, [r3, #0]
2401af3a:	6a1a      	ldr	r2, [r3, #32]
2401af3c:	f241 1311 	movw	r3, #4369	; 0x1111
2401af40:	4013      	ands	r3, r2
2401af42:	2b00      	cmp	r3, #0
2401af44:	d10f      	bne.n	2401af66 <HAL_TIM_OnePulse_Stop+0xc2>
2401af46:	687b      	ldr	r3, [r7, #4]
2401af48:	681b      	ldr	r3, [r3, #0]
2401af4a:	6a1a      	ldr	r2, [r3, #32]
2401af4c:	f240 4344 	movw	r3, #1092	; 0x444
2401af50:	4013      	ands	r3, r2
2401af52:	2b00      	cmp	r3, #0
2401af54:	d107      	bne.n	2401af66 <HAL_TIM_OnePulse_Stop+0xc2>
2401af56:	687b      	ldr	r3, [r7, #4]
2401af58:	681b      	ldr	r3, [r3, #0]
2401af5a:	681a      	ldr	r2, [r3, #0]
2401af5c:	687b      	ldr	r3, [r7, #4]
2401af5e:	681b      	ldr	r3, [r3, #0]
2401af60:	f022 0201 	bic.w	r2, r2, #1
2401af64:	601a      	str	r2, [r3, #0]

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401af66:	687b      	ldr	r3, [r7, #4]
2401af68:	2201      	movs	r2, #1
2401af6a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401af6e:	687b      	ldr	r3, [r7, #4]
2401af70:	2201      	movs	r2, #1
2401af72:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401af76:	687b      	ldr	r3, [r7, #4]
2401af78:	2201      	movs	r2, #1
2401af7a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401af7e:	687b      	ldr	r3, [r7, #4]
2401af80:	2201      	movs	r2, #1
2401af82:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Return function status */
  return HAL_OK;
2401af86:	2300      	movs	r3, #0
}
2401af88:	4618      	mov	r0, r3
2401af8a:	3708      	adds	r7, #8
2401af8c:	46bd      	mov	sp, r7
2401af8e:	bd80      	pop	{r7, pc}
2401af90:	40010000 	.word	0x40010000
2401af94:	40010400 	.word	0x40010400
2401af98:	40014000 	.word	0x40014000
2401af9c:	40014400 	.word	0x40014400
2401afa0:	40014800 	.word	0x40014800

2401afa4 <HAL_TIM_OnePulse_Start_IT>:
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
2401afa4:	b580      	push	{r7, lr}
2401afa6:	b084      	sub	sp, #16
2401afa8:	af00      	add	r7, sp, #0
2401afaa:	6078      	str	r0, [r7, #4]
2401afac:	6039      	str	r1, [r7, #0]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
2401afae:	687b      	ldr	r3, [r7, #4]
2401afb0:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401afb4:	73fb      	strb	r3, [r7, #15]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
2401afb6:	687b      	ldr	r3, [r7, #4]
2401afb8:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401afbc:	73bb      	strb	r3, [r7, #14]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
2401afbe:	687b      	ldr	r3, [r7, #4]
2401afc0:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401afc4:	737b      	strb	r3, [r7, #13]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
2401afc6:	687b      	ldr	r3, [r7, #4]
2401afc8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401afcc:	733b      	strb	r3, [r7, #12]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(OutputChannel);

  /* Check the TIM channels state */
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401afce:	7bfb      	ldrb	r3, [r7, #15]
2401afd0:	2b01      	cmp	r3, #1
2401afd2:	d108      	bne.n	2401afe6 <HAL_TIM_OnePulse_Start_IT+0x42>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2401afd4:	7bbb      	ldrb	r3, [r7, #14]
2401afd6:	2b01      	cmp	r3, #1
2401afd8:	d105      	bne.n	2401afe6 <HAL_TIM_OnePulse_Start_IT+0x42>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401afda:	7b7b      	ldrb	r3, [r7, #13]
2401afdc:	2b01      	cmp	r3, #1
2401afde:	d102      	bne.n	2401afe6 <HAL_TIM_OnePulse_Start_IT+0x42>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2401afe0:	7b3b      	ldrb	r3, [r7, #12]
2401afe2:	2b01      	cmp	r3, #1
2401afe4:	d001      	beq.n	2401afea <HAL_TIM_OnePulse_Start_IT+0x46>
  {
    return HAL_ERROR;
2401afe6:	2301      	movs	r3, #1
2401afe8:	e054      	b.n	2401b094 <HAL_TIM_OnePulse_Start_IT+0xf0>
  }

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401afea:	687b      	ldr	r3, [r7, #4]
2401afec:	2202      	movs	r2, #2
2401afee:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401aff2:	687b      	ldr	r3, [r7, #4]
2401aff4:	2202      	movs	r2, #2
2401aff6:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401affa:	687b      	ldr	r3, [r7, #4]
2401affc:	2202      	movs	r2, #2
2401affe:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b002:	687b      	ldr	r3, [r7, #4]
2401b004:	2202      	movs	r2, #2
2401b006:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

    No need to enable the counter, it's enabled automatically by hardware
    (the counter starts in response to a stimulus and generate a pulse */

  /* Enable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2401b00a:	687b      	ldr	r3, [r7, #4]
2401b00c:	681b      	ldr	r3, [r3, #0]
2401b00e:	68da      	ldr	r2, [r3, #12]
2401b010:	687b      	ldr	r3, [r7, #4]
2401b012:	681b      	ldr	r3, [r3, #0]
2401b014:	f042 0202 	orr.w	r2, r2, #2
2401b018:	60da      	str	r2, [r3, #12]

  /* Enable the TIM Capture/Compare 2 interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2401b01a:	687b      	ldr	r3, [r7, #4]
2401b01c:	681b      	ldr	r3, [r3, #0]
2401b01e:	68da      	ldr	r2, [r3, #12]
2401b020:	687b      	ldr	r3, [r7, #4]
2401b022:	681b      	ldr	r3, [r3, #0]
2401b024:	f042 0204 	orr.w	r2, r2, #4
2401b028:	60da      	str	r2, [r3, #12]

  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401b02a:	687b      	ldr	r3, [r7, #4]
2401b02c:	681b      	ldr	r3, [r3, #0]
2401b02e:	2201      	movs	r2, #1
2401b030:	2100      	movs	r1, #0
2401b032:	4618      	mov	r0, r3
2401b034:	f003 fa98 	bl	2401e568 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
2401b038:	687b      	ldr	r3, [r7, #4]
2401b03a:	681b      	ldr	r3, [r3, #0]
2401b03c:	2201      	movs	r2, #1
2401b03e:	2104      	movs	r1, #4
2401b040:	4618      	mov	r0, r3
2401b042:	f003 fa91 	bl	2401e568 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2401b046:	687b      	ldr	r3, [r7, #4]
2401b048:	681b      	ldr	r3, [r3, #0]
2401b04a:	4a14      	ldr	r2, [pc, #80]	; (2401b09c <HAL_TIM_OnePulse_Start_IT+0xf8>)
2401b04c:	4293      	cmp	r3, r2
2401b04e:	d013      	beq.n	2401b078 <HAL_TIM_OnePulse_Start_IT+0xd4>
2401b050:	687b      	ldr	r3, [r7, #4]
2401b052:	681b      	ldr	r3, [r3, #0]
2401b054:	4a12      	ldr	r2, [pc, #72]	; (2401b0a0 <HAL_TIM_OnePulse_Start_IT+0xfc>)
2401b056:	4293      	cmp	r3, r2
2401b058:	d00e      	beq.n	2401b078 <HAL_TIM_OnePulse_Start_IT+0xd4>
2401b05a:	687b      	ldr	r3, [r7, #4]
2401b05c:	681b      	ldr	r3, [r3, #0]
2401b05e:	4a11      	ldr	r2, [pc, #68]	; (2401b0a4 <HAL_TIM_OnePulse_Start_IT+0x100>)
2401b060:	4293      	cmp	r3, r2
2401b062:	d009      	beq.n	2401b078 <HAL_TIM_OnePulse_Start_IT+0xd4>
2401b064:	687b      	ldr	r3, [r7, #4]
2401b066:	681b      	ldr	r3, [r3, #0]
2401b068:	4a0f      	ldr	r2, [pc, #60]	; (2401b0a8 <HAL_TIM_OnePulse_Start_IT+0x104>)
2401b06a:	4293      	cmp	r3, r2
2401b06c:	d004      	beq.n	2401b078 <HAL_TIM_OnePulse_Start_IT+0xd4>
2401b06e:	687b      	ldr	r3, [r7, #4]
2401b070:	681b      	ldr	r3, [r3, #0]
2401b072:	4a0e      	ldr	r2, [pc, #56]	; (2401b0ac <HAL_TIM_OnePulse_Start_IT+0x108>)
2401b074:	4293      	cmp	r3, r2
2401b076:	d101      	bne.n	2401b07c <HAL_TIM_OnePulse_Start_IT+0xd8>
2401b078:	2301      	movs	r3, #1
2401b07a:	e000      	b.n	2401b07e <HAL_TIM_OnePulse_Start_IT+0xda>
2401b07c:	2300      	movs	r3, #0
2401b07e:	2b00      	cmp	r3, #0
2401b080:	d007      	beq.n	2401b092 <HAL_TIM_OnePulse_Start_IT+0xee>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
2401b082:	687b      	ldr	r3, [r7, #4]
2401b084:	681b      	ldr	r3, [r3, #0]
2401b086:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401b088:	687b      	ldr	r3, [r7, #4]
2401b08a:	681b      	ldr	r3, [r3, #0]
2401b08c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401b090:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Return function status */
  return HAL_OK;
2401b092:	2300      	movs	r3, #0
}
2401b094:	4618      	mov	r0, r3
2401b096:	3710      	adds	r7, #16
2401b098:	46bd      	mov	sp, r7
2401b09a:	bd80      	pop	{r7, pc}
2401b09c:	40010000 	.word	0x40010000
2401b0a0:	40010400 	.word	0x40010400
2401b0a4:	40014000 	.word	0x40014000
2401b0a8:	40014400 	.word	0x40014400
2401b0ac:	40014800 	.word	0x40014800

2401b0b0 <HAL_TIM_OnePulse_Stop_IT>:
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
2401b0b0:	b580      	push	{r7, lr}
2401b0b2:	b082      	sub	sp, #8
2401b0b4:	af00      	add	r7, sp, #0
2401b0b6:	6078      	str	r0, [r7, #4]
2401b0b8:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(OutputChannel);

  /* Disable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2401b0ba:	687b      	ldr	r3, [r7, #4]
2401b0bc:	681b      	ldr	r3, [r3, #0]
2401b0be:	68da      	ldr	r2, [r3, #12]
2401b0c0:	687b      	ldr	r3, [r7, #4]
2401b0c2:	681b      	ldr	r3, [r3, #0]
2401b0c4:	f022 0202 	bic.w	r2, r2, #2
2401b0c8:	60da      	str	r2, [r3, #12]

  /* Disable the TIM Capture/Compare 2 interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2401b0ca:	687b      	ldr	r3, [r7, #4]
2401b0cc:	681b      	ldr	r3, [r3, #0]
2401b0ce:	68da      	ldr	r2, [r3, #12]
2401b0d0:	687b      	ldr	r3, [r7, #4]
2401b0d2:	681b      	ldr	r3, [r3, #0]
2401b0d4:	f022 0204 	bic.w	r2, r2, #4
2401b0d8:	60da      	str	r2, [r3, #12]
  /* Disable the Capture compare and the Input Capture channels
  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401b0da:	687b      	ldr	r3, [r7, #4]
2401b0dc:	681b      	ldr	r3, [r3, #0]
2401b0de:	2200      	movs	r2, #0
2401b0e0:	2100      	movs	r1, #0
2401b0e2:	4618      	mov	r0, r3
2401b0e4:	f003 fa40 	bl	2401e568 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
2401b0e8:	687b      	ldr	r3, [r7, #4]
2401b0ea:	681b      	ldr	r3, [r3, #0]
2401b0ec:	2200      	movs	r2, #0
2401b0ee:	2104      	movs	r1, #4
2401b0f0:	4618      	mov	r0, r3
2401b0f2:	f003 fa39 	bl	2401e568 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2401b0f6:	687b      	ldr	r3, [r7, #4]
2401b0f8:	681b      	ldr	r3, [r3, #0]
2401b0fa:	4a30      	ldr	r2, [pc, #192]	; (2401b1bc <HAL_TIM_OnePulse_Stop_IT+0x10c>)
2401b0fc:	4293      	cmp	r3, r2
2401b0fe:	d013      	beq.n	2401b128 <HAL_TIM_OnePulse_Stop_IT+0x78>
2401b100:	687b      	ldr	r3, [r7, #4]
2401b102:	681b      	ldr	r3, [r3, #0]
2401b104:	4a2e      	ldr	r2, [pc, #184]	; (2401b1c0 <HAL_TIM_OnePulse_Stop_IT+0x110>)
2401b106:	4293      	cmp	r3, r2
2401b108:	d00e      	beq.n	2401b128 <HAL_TIM_OnePulse_Stop_IT+0x78>
2401b10a:	687b      	ldr	r3, [r7, #4]
2401b10c:	681b      	ldr	r3, [r3, #0]
2401b10e:	4a2d      	ldr	r2, [pc, #180]	; (2401b1c4 <HAL_TIM_OnePulse_Stop_IT+0x114>)
2401b110:	4293      	cmp	r3, r2
2401b112:	d009      	beq.n	2401b128 <HAL_TIM_OnePulse_Stop_IT+0x78>
2401b114:	687b      	ldr	r3, [r7, #4]
2401b116:	681b      	ldr	r3, [r3, #0]
2401b118:	4a2b      	ldr	r2, [pc, #172]	; (2401b1c8 <HAL_TIM_OnePulse_Stop_IT+0x118>)
2401b11a:	4293      	cmp	r3, r2
2401b11c:	d004      	beq.n	2401b128 <HAL_TIM_OnePulse_Stop_IT+0x78>
2401b11e:	687b      	ldr	r3, [r7, #4]
2401b120:	681b      	ldr	r3, [r3, #0]
2401b122:	4a2a      	ldr	r2, [pc, #168]	; (2401b1cc <HAL_TIM_OnePulse_Stop_IT+0x11c>)
2401b124:	4293      	cmp	r3, r2
2401b126:	d101      	bne.n	2401b12c <HAL_TIM_OnePulse_Stop_IT+0x7c>
2401b128:	2301      	movs	r3, #1
2401b12a:	e000      	b.n	2401b12e <HAL_TIM_OnePulse_Stop_IT+0x7e>
2401b12c:	2300      	movs	r3, #0
2401b12e:	2b00      	cmp	r3, #0
2401b130:	d017      	beq.n	2401b162 <HAL_TIM_OnePulse_Stop_IT+0xb2>
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
2401b132:	687b      	ldr	r3, [r7, #4]
2401b134:	681b      	ldr	r3, [r3, #0]
2401b136:	6a1a      	ldr	r2, [r3, #32]
2401b138:	f241 1311 	movw	r3, #4369	; 0x1111
2401b13c:	4013      	ands	r3, r2
2401b13e:	2b00      	cmp	r3, #0
2401b140:	d10f      	bne.n	2401b162 <HAL_TIM_OnePulse_Stop_IT+0xb2>
2401b142:	687b      	ldr	r3, [r7, #4]
2401b144:	681b      	ldr	r3, [r3, #0]
2401b146:	6a1a      	ldr	r2, [r3, #32]
2401b148:	f240 4344 	movw	r3, #1092	; 0x444
2401b14c:	4013      	ands	r3, r2
2401b14e:	2b00      	cmp	r3, #0
2401b150:	d107      	bne.n	2401b162 <HAL_TIM_OnePulse_Stop_IT+0xb2>
2401b152:	687b      	ldr	r3, [r7, #4]
2401b154:	681b      	ldr	r3, [r3, #0]
2401b156:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401b158:	687b      	ldr	r3, [r7, #4]
2401b15a:	681b      	ldr	r3, [r3, #0]
2401b15c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401b160:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401b162:	687b      	ldr	r3, [r7, #4]
2401b164:	681b      	ldr	r3, [r3, #0]
2401b166:	6a1a      	ldr	r2, [r3, #32]
2401b168:	f241 1311 	movw	r3, #4369	; 0x1111
2401b16c:	4013      	ands	r3, r2
2401b16e:	2b00      	cmp	r3, #0
2401b170:	d10f      	bne.n	2401b192 <HAL_TIM_OnePulse_Stop_IT+0xe2>
2401b172:	687b      	ldr	r3, [r7, #4]
2401b174:	681b      	ldr	r3, [r3, #0]
2401b176:	6a1a      	ldr	r2, [r3, #32]
2401b178:	f240 4344 	movw	r3, #1092	; 0x444
2401b17c:	4013      	ands	r3, r2
2401b17e:	2b00      	cmp	r3, #0
2401b180:	d107      	bne.n	2401b192 <HAL_TIM_OnePulse_Stop_IT+0xe2>
2401b182:	687b      	ldr	r3, [r7, #4]
2401b184:	681b      	ldr	r3, [r3, #0]
2401b186:	681a      	ldr	r2, [r3, #0]
2401b188:	687b      	ldr	r3, [r7, #4]
2401b18a:	681b      	ldr	r3, [r3, #0]
2401b18c:	f022 0201 	bic.w	r2, r2, #1
2401b190:	601a      	str	r2, [r3, #0]

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401b192:	687b      	ldr	r3, [r7, #4]
2401b194:	2201      	movs	r2, #1
2401b196:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401b19a:	687b      	ldr	r3, [r7, #4]
2401b19c:	2201      	movs	r2, #1
2401b19e:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401b1a2:	687b      	ldr	r3, [r7, #4]
2401b1a4:	2201      	movs	r2, #1
2401b1a6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401b1aa:	687b      	ldr	r3, [r7, #4]
2401b1ac:	2201      	movs	r2, #1
2401b1ae:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Return function status */
  return HAL_OK;
2401b1b2:	2300      	movs	r3, #0
}
2401b1b4:	4618      	mov	r0, r3
2401b1b6:	3708      	adds	r7, #8
2401b1b8:	46bd      	mov	sp, r7
2401b1ba:	bd80      	pop	{r7, pc}
2401b1bc:	40010000 	.word	0x40010000
2401b1c0:	40010400 	.word	0x40010400
2401b1c4:	40014000 	.word	0x40014000
2401b1c8:	40014400 	.word	0x40014400
2401b1cc:	40014800 	.word	0x40014800

2401b1d0 <HAL_TIM_Encoder_Init>:
  * @param  htim TIM Encoder Interface handle
  * @param  sConfig TIM Encoder Interface configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
{
2401b1d0:	b580      	push	{r7, lr}
2401b1d2:	b086      	sub	sp, #24
2401b1d4:	af00      	add	r7, sp, #0
2401b1d6:	6078      	str	r0, [r7, #4]
2401b1d8:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Check the TIM handle allocation */
  if (htim == NULL)
2401b1da:	687b      	ldr	r3, [r7, #4]
2401b1dc:	2b00      	cmp	r3, #0
2401b1de:	d101      	bne.n	2401b1e4 <HAL_TIM_Encoder_Init+0x14>
  {
    return HAL_ERROR;
2401b1e0:	2301      	movs	r3, #1
2401b1e2:	e08f      	b.n	2401b304 <HAL_TIM_Encoder_Init+0x134>
  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));

  if (htim->State == HAL_TIM_STATE_RESET)
2401b1e4:	687b      	ldr	r3, [r7, #4]
2401b1e6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401b1ea:	b2db      	uxtb	r3, r3
2401b1ec:	2b00      	cmp	r3, #0
2401b1ee:	d106      	bne.n	2401b1fe <HAL_TIM_Encoder_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
2401b1f0:	687b      	ldr	r3, [r7, #4]
2401b1f2:	2200      	movs	r2, #0
2401b1f4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Encoder_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_Encoder_MspInit(htim);
2401b1f8:	6878      	ldr	r0, [r7, #4]
2401b1fa:	f000 f8d3 	bl	2401b3a4 <HAL_TIM_Encoder_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
2401b1fe:	687b      	ldr	r3, [r7, #4]
2401b200:	2202      	movs	r2, #2
2401b202:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Reset the SMS and ECE bits */
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
2401b206:	687b      	ldr	r3, [r7, #4]
2401b208:	681b      	ldr	r3, [r3, #0]
2401b20a:	6899      	ldr	r1, [r3, #8]
2401b20c:	687b      	ldr	r3, [r7, #4]
2401b20e:	681a      	ldr	r2, [r3, #0]
2401b210:	4b3e      	ldr	r3, [pc, #248]	; (2401b30c <HAL_TIM_Encoder_Init+0x13c>)
2401b212:	400b      	ands	r3, r1
2401b214:	6093      	str	r3, [r2, #8]

  /* Configure the Time base in the Encoder Mode */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2401b216:	687b      	ldr	r3, [r7, #4]
2401b218:	681a      	ldr	r2, [r3, #0]
2401b21a:	687b      	ldr	r3, [r7, #4]
2401b21c:	3304      	adds	r3, #4
2401b21e:	4619      	mov	r1, r3
2401b220:	4610      	mov	r0, r2
2401b222:	f002 fb7f 	bl	2401d924 <TIM_Base_SetConfig>

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
2401b226:	687b      	ldr	r3, [r7, #4]
2401b228:	681b      	ldr	r3, [r3, #0]
2401b22a:	689b      	ldr	r3, [r3, #8]
2401b22c:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = htim->Instance->CCMR1;
2401b22e:	687b      	ldr	r3, [r7, #4]
2401b230:	681b      	ldr	r3, [r3, #0]
2401b232:	699b      	ldr	r3, [r3, #24]
2401b234:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCER register value */
  tmpccer = htim->Instance->CCER;
2401b236:	687b      	ldr	r3, [r7, #4]
2401b238:	681b      	ldr	r3, [r3, #0]
2401b23a:	6a1b      	ldr	r3, [r3, #32]
2401b23c:	60fb      	str	r3, [r7, #12]

  /* Set the encoder Mode */
  tmpsmcr |= sConfig->EncoderMode;
2401b23e:	683b      	ldr	r3, [r7, #0]
2401b240:	681b      	ldr	r3, [r3, #0]
2401b242:	697a      	ldr	r2, [r7, #20]
2401b244:	4313      	orrs	r3, r2
2401b246:	617b      	str	r3, [r7, #20]

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
2401b248:	693a      	ldr	r2, [r7, #16]
2401b24a:	4b31      	ldr	r3, [pc, #196]	; (2401b310 <HAL_TIM_Encoder_Init+0x140>)
2401b24c:	4013      	ands	r3, r2
2401b24e:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
2401b250:	683b      	ldr	r3, [r7, #0]
2401b252:	689a      	ldr	r2, [r3, #8]
2401b254:	683b      	ldr	r3, [r7, #0]
2401b256:	699b      	ldr	r3, [r3, #24]
2401b258:	021b      	lsls	r3, r3, #8
2401b25a:	4313      	orrs	r3, r2
2401b25c:	693a      	ldr	r2, [r7, #16]
2401b25e:	4313      	orrs	r3, r2
2401b260:	613b      	str	r3, [r7, #16]

  /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
  tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
2401b262:	693a      	ldr	r2, [r7, #16]
2401b264:	4b2b      	ldr	r3, [pc, #172]	; (2401b314 <HAL_TIM_Encoder_Init+0x144>)
2401b266:	4013      	ands	r3, r2
2401b268:	613b      	str	r3, [r7, #16]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
2401b26a:	693a      	ldr	r2, [r7, #16]
2401b26c:	4b2a      	ldr	r3, [pc, #168]	; (2401b318 <HAL_TIM_Encoder_Init+0x148>)
2401b26e:	4013      	ands	r3, r2
2401b270:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
2401b272:	683b      	ldr	r3, [r7, #0]
2401b274:	68da      	ldr	r2, [r3, #12]
2401b276:	683b      	ldr	r3, [r7, #0]
2401b278:	69db      	ldr	r3, [r3, #28]
2401b27a:	021b      	lsls	r3, r3, #8
2401b27c:	4313      	orrs	r3, r2
2401b27e:	693a      	ldr	r2, [r7, #16]
2401b280:	4313      	orrs	r3, r2
2401b282:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
2401b284:	683b      	ldr	r3, [r7, #0]
2401b286:	691b      	ldr	r3, [r3, #16]
2401b288:	011a      	lsls	r2, r3, #4
2401b28a:	683b      	ldr	r3, [r7, #0]
2401b28c:	6a1b      	ldr	r3, [r3, #32]
2401b28e:	031b      	lsls	r3, r3, #12
2401b290:	4313      	orrs	r3, r2
2401b292:	693a      	ldr	r2, [r7, #16]
2401b294:	4313      	orrs	r3, r2
2401b296:	613b      	str	r3, [r7, #16]

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
2401b298:	68fb      	ldr	r3, [r7, #12]
2401b29a:	f023 0322 	bic.w	r3, r3, #34	; 0x22
2401b29e:	60fb      	str	r3, [r7, #12]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
2401b2a0:	68fb      	ldr	r3, [r7, #12]
2401b2a2:	f023 0388 	bic.w	r3, r3, #136	; 0x88
2401b2a6:	60fb      	str	r3, [r7, #12]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
2401b2a8:	683b      	ldr	r3, [r7, #0]
2401b2aa:	685a      	ldr	r2, [r3, #4]
2401b2ac:	683b      	ldr	r3, [r7, #0]
2401b2ae:	695b      	ldr	r3, [r3, #20]
2401b2b0:	011b      	lsls	r3, r3, #4
2401b2b2:	4313      	orrs	r3, r2
2401b2b4:	68fa      	ldr	r2, [r7, #12]
2401b2b6:	4313      	orrs	r3, r2
2401b2b8:	60fb      	str	r3, [r7, #12]

  /* Write to TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
2401b2ba:	687b      	ldr	r3, [r7, #4]
2401b2bc:	681b      	ldr	r3, [r3, #0]
2401b2be:	697a      	ldr	r2, [r7, #20]
2401b2c0:	609a      	str	r2, [r3, #8]

  /* Write to TIMx CCMR1 */
  htim->Instance->CCMR1 = tmpccmr1;
2401b2c2:	687b      	ldr	r3, [r7, #4]
2401b2c4:	681b      	ldr	r3, [r3, #0]
2401b2c6:	693a      	ldr	r2, [r7, #16]
2401b2c8:	619a      	str	r2, [r3, #24]

  /* Write to TIMx CCER */
  htim->Instance->CCER = tmpccer;
2401b2ca:	687b      	ldr	r3, [r7, #4]
2401b2cc:	681b      	ldr	r3, [r3, #0]
2401b2ce:	68fa      	ldr	r2, [r7, #12]
2401b2d0:	621a      	str	r2, [r3, #32]

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
2401b2d2:	687b      	ldr	r3, [r7, #4]
2401b2d4:	2201      	movs	r2, #1
2401b2d6:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401b2da:	687b      	ldr	r3, [r7, #4]
2401b2dc:	2201      	movs	r2, #1
2401b2de:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401b2e2:	687b      	ldr	r3, [r7, #4]
2401b2e4:	2201      	movs	r2, #1
2401b2e6:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401b2ea:	687b      	ldr	r3, [r7, #4]
2401b2ec:	2201      	movs	r2, #1
2401b2ee:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401b2f2:	687b      	ldr	r3, [r7, #4]
2401b2f4:	2201      	movs	r2, #1
2401b2f6:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
2401b2fa:	687b      	ldr	r3, [r7, #4]
2401b2fc:	2201      	movs	r2, #1
2401b2fe:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
2401b302:	2300      	movs	r3, #0
}
2401b304:	4618      	mov	r0, r3
2401b306:	3718      	adds	r7, #24
2401b308:	46bd      	mov	sp, r7
2401b30a:	bd80      	pop	{r7, pc}
2401b30c:	fffebff8 	.word	0xfffebff8
2401b310:	fffffcfc 	.word	0xfffffcfc
2401b314:	fffff3f3 	.word	0xfffff3f3
2401b318:	ffff0f0f 	.word	0xffff0f0f

2401b31c <HAL_TIM_Encoder_DeInit>:
  * @brief  DeInitializes the TIM Encoder interface
  * @param  htim TIM Encoder Interface handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
{
2401b31c:	b580      	push	{r7, lr}
2401b31e:	b082      	sub	sp, #8
2401b320:	af00      	add	r7, sp, #0
2401b322:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
2401b324:	687b      	ldr	r3, [r7, #4]
2401b326:	2202      	movs	r2, #2
2401b328:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
2401b32c:	687b      	ldr	r3, [r7, #4]
2401b32e:	681b      	ldr	r3, [r3, #0]
2401b330:	6a1a      	ldr	r2, [r3, #32]
2401b332:	f241 1311 	movw	r3, #4369	; 0x1111
2401b336:	4013      	ands	r3, r2
2401b338:	2b00      	cmp	r3, #0
2401b33a:	d10f      	bne.n	2401b35c <HAL_TIM_Encoder_DeInit+0x40>
2401b33c:	687b      	ldr	r3, [r7, #4]
2401b33e:	681b      	ldr	r3, [r3, #0]
2401b340:	6a1a      	ldr	r2, [r3, #32]
2401b342:	f240 4344 	movw	r3, #1092	; 0x444
2401b346:	4013      	ands	r3, r2
2401b348:	2b00      	cmp	r3, #0
2401b34a:	d107      	bne.n	2401b35c <HAL_TIM_Encoder_DeInit+0x40>
2401b34c:	687b      	ldr	r3, [r7, #4]
2401b34e:	681b      	ldr	r3, [r3, #0]
2401b350:	681a      	ldr	r2, [r3, #0]
2401b352:	687b      	ldr	r3, [r7, #4]
2401b354:	681b      	ldr	r3, [r3, #0]
2401b356:	f022 0201 	bic.w	r2, r2, #1
2401b35a:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->Encoder_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIM_Encoder_MspDeInit(htim);
2401b35c:	6878      	ldr	r0, [r7, #4]
2401b35e:	f000 f82b 	bl	2401b3b8 <HAL_TIM_Encoder_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
2401b362:	687b      	ldr	r3, [r7, #4]
2401b364:	2200      	movs	r2, #0
2401b366:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
2401b36a:	687b      	ldr	r3, [r7, #4]
2401b36c:	2200      	movs	r2, #0
2401b36e:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
2401b372:	687b      	ldr	r3, [r7, #4]
2401b374:	2200      	movs	r2, #0
2401b376:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
2401b37a:	687b      	ldr	r3, [r7, #4]
2401b37c:	2200      	movs	r2, #0
2401b37e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
2401b382:	687b      	ldr	r3, [r7, #4]
2401b384:	2200      	movs	r2, #0
2401b386:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
2401b38a:	687b      	ldr	r3, [r7, #4]
2401b38c:	2200      	movs	r2, #0
2401b38e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
2401b392:	687b      	ldr	r3, [r7, #4]
2401b394:	2200      	movs	r2, #0
2401b396:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2401b39a:	2300      	movs	r3, #0
}
2401b39c:	4618      	mov	r0, r3
2401b39e:	3708      	adds	r7, #8
2401b3a0:	46bd      	mov	sp, r7
2401b3a2:	bd80      	pop	{r7, pc}

2401b3a4 <HAL_TIM_Encoder_MspInit>:
  * @brief  Initializes the TIM Encoder Interface MSP.
  * @param  htim TIM Encoder Interface handle
  * @retval None
  */
__weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
{
2401b3a4:	b480      	push	{r7}
2401b3a6:	b083      	sub	sp, #12
2401b3a8:	af00      	add	r7, sp, #0
2401b3aa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Encoder_MspInit could be implemented in the user file
   */
}
2401b3ac:	bf00      	nop
2401b3ae:	370c      	adds	r7, #12
2401b3b0:	46bd      	mov	sp, r7
2401b3b2:	f85d 7b04 	ldr.w	r7, [sp], #4
2401b3b6:	4770      	bx	lr

2401b3b8 <HAL_TIM_Encoder_MspDeInit>:
  * @brief  DeInitializes TIM Encoder Interface MSP.
  * @param  htim TIM Encoder Interface handle
  * @retval None
  */
__weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
{
2401b3b8:	b480      	push	{r7}
2401b3ba:	b083      	sub	sp, #12
2401b3bc:	af00      	add	r7, sp, #0
2401b3be:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   */
}
2401b3c0:	bf00      	nop
2401b3c2:	370c      	adds	r7, #12
2401b3c4:	46bd      	mov	sp, r7
2401b3c6:	f85d 7b04 	ldr.w	r7, [sp], #4
2401b3ca:	4770      	bx	lr

2401b3cc <HAL_TIM_Encoder_Start>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401b3cc:	b580      	push	{r7, lr}
2401b3ce:	b084      	sub	sp, #16
2401b3d0:	af00      	add	r7, sp, #0
2401b3d2:	6078      	str	r0, [r7, #4]
2401b3d4:	6039      	str	r1, [r7, #0]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
2401b3d6:	687b      	ldr	r3, [r7, #4]
2401b3d8:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401b3dc:	73fb      	strb	r3, [r7, #15]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
2401b3de:	687b      	ldr	r3, [r7, #4]
2401b3e0:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401b3e4:	73bb      	strb	r3, [r7, #14]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
2401b3e6:	687b      	ldr	r3, [r7, #4]
2401b3e8:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401b3ec:	737b      	strb	r3, [r7, #13]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
2401b3ee:	687b      	ldr	r3, [r7, #4]
2401b3f0:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401b3f4:	733b      	strb	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));

  /* Set the TIM channel(s) state */
  if (Channel == TIM_CHANNEL_1)
2401b3f6:	683b      	ldr	r3, [r7, #0]
2401b3f8:	2b00      	cmp	r3, #0
2401b3fa:	d110      	bne.n	2401b41e <HAL_TIM_Encoder_Start+0x52>
  {
    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401b3fc:	7bfb      	ldrb	r3, [r7, #15]
2401b3fe:	2b01      	cmp	r3, #1
2401b400:	d102      	bne.n	2401b408 <HAL_TIM_Encoder_Start+0x3c>
        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))
2401b402:	7b7b      	ldrb	r3, [r7, #13]
2401b404:	2b01      	cmp	r3, #1
2401b406:	d001      	beq.n	2401b40c <HAL_TIM_Encoder_Start+0x40>
    {
      return HAL_ERROR;
2401b408:	2301      	movs	r3, #1
2401b40a:	e069      	b.n	2401b4e0 <HAL_TIM_Encoder_Start+0x114>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b40c:	687b      	ldr	r3, [r7, #4]
2401b40e:	2202      	movs	r2, #2
2401b410:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b414:	687b      	ldr	r3, [r7, #4]
2401b416:	2202      	movs	r2, #2
2401b418:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401b41c:	e031      	b.n	2401b482 <HAL_TIM_Encoder_Start+0xb6>
    }
  }
  else if (Channel == TIM_CHANNEL_2)
2401b41e:	683b      	ldr	r3, [r7, #0]
2401b420:	2b04      	cmp	r3, #4
2401b422:	d110      	bne.n	2401b446 <HAL_TIM_Encoder_Start+0x7a>
  {
    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2401b424:	7bbb      	ldrb	r3, [r7, #14]
2401b426:	2b01      	cmp	r3, #1
2401b428:	d102      	bne.n	2401b430 <HAL_TIM_Encoder_Start+0x64>
        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2401b42a:	7b3b      	ldrb	r3, [r7, #12]
2401b42c:	2b01      	cmp	r3, #1
2401b42e:	d001      	beq.n	2401b434 <HAL_TIM_Encoder_Start+0x68>
    {
      return HAL_ERROR;
2401b430:	2301      	movs	r3, #1
2401b432:	e055      	b.n	2401b4e0 <HAL_TIM_Encoder_Start+0x114>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b434:	687b      	ldr	r3, [r7, #4]
2401b436:	2202      	movs	r2, #2
2401b438:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b43c:	687b      	ldr	r3, [r7, #4]
2401b43e:	2202      	movs	r2, #2
2401b440:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401b444:	e01d      	b.n	2401b482 <HAL_TIM_Encoder_Start+0xb6>
    }
  }
  else
  {
    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401b446:	7bfb      	ldrb	r3, [r7, #15]
2401b448:	2b01      	cmp	r3, #1
2401b44a:	d108      	bne.n	2401b45e <HAL_TIM_Encoder_Start+0x92>
        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2401b44c:	7bbb      	ldrb	r3, [r7, #14]
2401b44e:	2b01      	cmp	r3, #1
2401b450:	d105      	bne.n	2401b45e <HAL_TIM_Encoder_Start+0x92>
        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401b452:	7b7b      	ldrb	r3, [r7, #13]
2401b454:	2b01      	cmp	r3, #1
2401b456:	d102      	bne.n	2401b45e <HAL_TIM_Encoder_Start+0x92>
        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2401b458:	7b3b      	ldrb	r3, [r7, #12]
2401b45a:	2b01      	cmp	r3, #1
2401b45c:	d001      	beq.n	2401b462 <HAL_TIM_Encoder_Start+0x96>
    {
      return HAL_ERROR;
2401b45e:	2301      	movs	r3, #1
2401b460:	e03e      	b.n	2401b4e0 <HAL_TIM_Encoder_Start+0x114>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b462:	687b      	ldr	r3, [r7, #4]
2401b464:	2202      	movs	r2, #2
2401b466:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b46a:	687b      	ldr	r3, [r7, #4]
2401b46c:	2202      	movs	r2, #2
2401b46e:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b472:	687b      	ldr	r3, [r7, #4]
2401b474:	2202      	movs	r2, #2
2401b476:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b47a:	687b      	ldr	r3, [r7, #4]
2401b47c:	2202      	movs	r2, #2
2401b47e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    }
  }

  /* Enable the encoder interface channels */
  switch (Channel)
2401b482:	683b      	ldr	r3, [r7, #0]
2401b484:	2b00      	cmp	r3, #0
2401b486:	d003      	beq.n	2401b490 <HAL_TIM_Encoder_Start+0xc4>
2401b488:	683b      	ldr	r3, [r7, #0]
2401b48a:	2b04      	cmp	r3, #4
2401b48c:	d008      	beq.n	2401b4a0 <HAL_TIM_Encoder_Start+0xd4>
2401b48e:	e00f      	b.n	2401b4b0 <HAL_TIM_Encoder_Start+0xe4>
  {
    case TIM_CHANNEL_1:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401b490:	687b      	ldr	r3, [r7, #4]
2401b492:	681b      	ldr	r3, [r3, #0]
2401b494:	2201      	movs	r2, #1
2401b496:	2100      	movs	r1, #0
2401b498:	4618      	mov	r0, r3
2401b49a:	f003 f865 	bl	2401e568 <TIM_CCxChannelCmd>
      break;
2401b49e:	e016      	b.n	2401b4ce <HAL_TIM_Encoder_Start+0x102>
    }

    case TIM_CHANNEL_2:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
2401b4a0:	687b      	ldr	r3, [r7, #4]
2401b4a2:	681b      	ldr	r3, [r3, #0]
2401b4a4:	2201      	movs	r2, #1
2401b4a6:	2104      	movs	r1, #4
2401b4a8:	4618      	mov	r0, r3
2401b4aa:	f003 f85d 	bl	2401e568 <TIM_CCxChannelCmd>
      break;
2401b4ae:	e00e      	b.n	2401b4ce <HAL_TIM_Encoder_Start+0x102>
    }

    default :
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401b4b0:	687b      	ldr	r3, [r7, #4]
2401b4b2:	681b      	ldr	r3, [r3, #0]
2401b4b4:	2201      	movs	r2, #1
2401b4b6:	2100      	movs	r1, #0
2401b4b8:	4618      	mov	r0, r3
2401b4ba:	f003 f855 	bl	2401e568 <TIM_CCxChannelCmd>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
2401b4be:	687b      	ldr	r3, [r7, #4]
2401b4c0:	681b      	ldr	r3, [r3, #0]
2401b4c2:	2201      	movs	r2, #1
2401b4c4:	2104      	movs	r1, #4
2401b4c6:	4618      	mov	r0, r3
2401b4c8:	f003 f84e 	bl	2401e568 <TIM_CCxChannelCmd>
      break;
2401b4cc:	bf00      	nop
    }
  }
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
2401b4ce:	687b      	ldr	r3, [r7, #4]
2401b4d0:	681b      	ldr	r3, [r3, #0]
2401b4d2:	681a      	ldr	r2, [r3, #0]
2401b4d4:	687b      	ldr	r3, [r7, #4]
2401b4d6:	681b      	ldr	r3, [r3, #0]
2401b4d8:	f042 0201 	orr.w	r2, r2, #1
2401b4dc:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
2401b4de:	2300      	movs	r3, #0
}
2401b4e0:	4618      	mov	r0, r3
2401b4e2:	3710      	adds	r7, #16
2401b4e4:	46bd      	mov	sp, r7
2401b4e6:	bd80      	pop	{r7, pc}

2401b4e8 <HAL_TIM_Encoder_Stop>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401b4e8:	b580      	push	{r7, lr}
2401b4ea:	b082      	sub	sp, #8
2401b4ec:	af00      	add	r7, sp, #0
2401b4ee:	6078      	str	r0, [r7, #4]
2401b4f0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));

  /* Disable the Input Capture channels 1 and 2
    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
  switch (Channel)
2401b4f2:	683b      	ldr	r3, [r7, #0]
2401b4f4:	2b00      	cmp	r3, #0
2401b4f6:	d003      	beq.n	2401b500 <HAL_TIM_Encoder_Stop+0x18>
2401b4f8:	683b      	ldr	r3, [r7, #0]
2401b4fa:	2b04      	cmp	r3, #4
2401b4fc:	d008      	beq.n	2401b510 <HAL_TIM_Encoder_Stop+0x28>
2401b4fe:	e00f      	b.n	2401b520 <HAL_TIM_Encoder_Stop+0x38>
  {
    case TIM_CHANNEL_1:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401b500:	687b      	ldr	r3, [r7, #4]
2401b502:	681b      	ldr	r3, [r3, #0]
2401b504:	2200      	movs	r2, #0
2401b506:	2100      	movs	r1, #0
2401b508:	4618      	mov	r0, r3
2401b50a:	f003 f82d 	bl	2401e568 <TIM_CCxChannelCmd>
      break;
2401b50e:	e016      	b.n	2401b53e <HAL_TIM_Encoder_Stop+0x56>
    }

    case TIM_CHANNEL_2:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
2401b510:	687b      	ldr	r3, [r7, #4]
2401b512:	681b      	ldr	r3, [r3, #0]
2401b514:	2200      	movs	r2, #0
2401b516:	2104      	movs	r1, #4
2401b518:	4618      	mov	r0, r3
2401b51a:	f003 f825 	bl	2401e568 <TIM_CCxChannelCmd>
      break;
2401b51e:	e00e      	b.n	2401b53e <HAL_TIM_Encoder_Stop+0x56>
    }

    default :
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401b520:	687b      	ldr	r3, [r7, #4]
2401b522:	681b      	ldr	r3, [r3, #0]
2401b524:	2200      	movs	r2, #0
2401b526:	2100      	movs	r1, #0
2401b528:	4618      	mov	r0, r3
2401b52a:	f003 f81d 	bl	2401e568 <TIM_CCxChannelCmd>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
2401b52e:	687b      	ldr	r3, [r7, #4]
2401b530:	681b      	ldr	r3, [r3, #0]
2401b532:	2200      	movs	r2, #0
2401b534:	2104      	movs	r1, #4
2401b536:	4618      	mov	r0, r3
2401b538:	f003 f816 	bl	2401e568 <TIM_CCxChannelCmd>
      break;
2401b53c:	bf00      	nop
    }
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401b53e:	687b      	ldr	r3, [r7, #4]
2401b540:	681b      	ldr	r3, [r3, #0]
2401b542:	6a1a      	ldr	r2, [r3, #32]
2401b544:	f241 1311 	movw	r3, #4369	; 0x1111
2401b548:	4013      	ands	r3, r2
2401b54a:	2b00      	cmp	r3, #0
2401b54c:	d10f      	bne.n	2401b56e <HAL_TIM_Encoder_Stop+0x86>
2401b54e:	687b      	ldr	r3, [r7, #4]
2401b550:	681b      	ldr	r3, [r3, #0]
2401b552:	6a1a      	ldr	r2, [r3, #32]
2401b554:	f240 4344 	movw	r3, #1092	; 0x444
2401b558:	4013      	ands	r3, r2
2401b55a:	2b00      	cmp	r3, #0
2401b55c:	d107      	bne.n	2401b56e <HAL_TIM_Encoder_Stop+0x86>
2401b55e:	687b      	ldr	r3, [r7, #4]
2401b560:	681b      	ldr	r3, [r3, #0]
2401b562:	681a      	ldr	r2, [r3, #0]
2401b564:	687b      	ldr	r3, [r7, #4]
2401b566:	681b      	ldr	r3, [r3, #0]
2401b568:	f022 0201 	bic.w	r2, r2, #1
2401b56c:	601a      	str	r2, [r3, #0]

  /* Set the TIM channel(s) state */
  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
2401b56e:	683b      	ldr	r3, [r7, #0]
2401b570:	2b00      	cmp	r3, #0
2401b572:	d002      	beq.n	2401b57a <HAL_TIM_Encoder_Stop+0x92>
2401b574:	683b      	ldr	r3, [r7, #0]
2401b576:	2b04      	cmp	r3, #4
2401b578:	d148      	bne.n	2401b60c <HAL_TIM_Encoder_Stop+0x124>
  {
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401b57a:	683b      	ldr	r3, [r7, #0]
2401b57c:	2b00      	cmp	r3, #0
2401b57e:	d104      	bne.n	2401b58a <HAL_TIM_Encoder_Stop+0xa2>
2401b580:	687b      	ldr	r3, [r7, #4]
2401b582:	2201      	movs	r2, #1
2401b584:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401b588:	e023      	b.n	2401b5d2 <HAL_TIM_Encoder_Stop+0xea>
2401b58a:	683b      	ldr	r3, [r7, #0]
2401b58c:	2b04      	cmp	r3, #4
2401b58e:	d104      	bne.n	2401b59a <HAL_TIM_Encoder_Stop+0xb2>
2401b590:	687b      	ldr	r3, [r7, #4]
2401b592:	2201      	movs	r2, #1
2401b594:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401b598:	e01b      	b.n	2401b5d2 <HAL_TIM_Encoder_Stop+0xea>
2401b59a:	683b      	ldr	r3, [r7, #0]
2401b59c:	2b08      	cmp	r3, #8
2401b59e:	d104      	bne.n	2401b5aa <HAL_TIM_Encoder_Stop+0xc2>
2401b5a0:	687b      	ldr	r3, [r7, #4]
2401b5a2:	2201      	movs	r2, #1
2401b5a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401b5a8:	e013      	b.n	2401b5d2 <HAL_TIM_Encoder_Stop+0xea>
2401b5aa:	683b      	ldr	r3, [r7, #0]
2401b5ac:	2b0c      	cmp	r3, #12
2401b5ae:	d104      	bne.n	2401b5ba <HAL_TIM_Encoder_Stop+0xd2>
2401b5b0:	687b      	ldr	r3, [r7, #4]
2401b5b2:	2201      	movs	r2, #1
2401b5b4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401b5b8:	e00b      	b.n	2401b5d2 <HAL_TIM_Encoder_Stop+0xea>
2401b5ba:	683b      	ldr	r3, [r7, #0]
2401b5bc:	2b10      	cmp	r3, #16
2401b5be:	d104      	bne.n	2401b5ca <HAL_TIM_Encoder_Stop+0xe2>
2401b5c0:	687b      	ldr	r3, [r7, #4]
2401b5c2:	2201      	movs	r2, #1
2401b5c4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401b5c8:	e003      	b.n	2401b5d2 <HAL_TIM_Encoder_Stop+0xea>
2401b5ca:	687b      	ldr	r3, [r7, #4]
2401b5cc:	2201      	movs	r2, #1
2401b5ce:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401b5d2:	683b      	ldr	r3, [r7, #0]
2401b5d4:	2b00      	cmp	r3, #0
2401b5d6:	d104      	bne.n	2401b5e2 <HAL_TIM_Encoder_Stop+0xfa>
2401b5d8:	687b      	ldr	r3, [r7, #4]
2401b5da:	2201      	movs	r2, #1
2401b5dc:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401b5e0:	e024      	b.n	2401b62c <HAL_TIM_Encoder_Stop+0x144>
2401b5e2:	683b      	ldr	r3, [r7, #0]
2401b5e4:	2b04      	cmp	r3, #4
2401b5e6:	d104      	bne.n	2401b5f2 <HAL_TIM_Encoder_Stop+0x10a>
2401b5e8:	687b      	ldr	r3, [r7, #4]
2401b5ea:	2201      	movs	r2, #1
2401b5ec:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401b5f0:	e01c      	b.n	2401b62c <HAL_TIM_Encoder_Stop+0x144>
2401b5f2:	683b      	ldr	r3, [r7, #0]
2401b5f4:	2b08      	cmp	r3, #8
2401b5f6:	d104      	bne.n	2401b602 <HAL_TIM_Encoder_Stop+0x11a>
2401b5f8:	687b      	ldr	r3, [r7, #4]
2401b5fa:	2201      	movs	r2, #1
2401b5fc:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401b600:	e014      	b.n	2401b62c <HAL_TIM_Encoder_Stop+0x144>
2401b602:	687b      	ldr	r3, [r7, #4]
2401b604:	2201      	movs	r2, #1
2401b606:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
2401b60a:	e00f      	b.n	2401b62c <HAL_TIM_Encoder_Stop+0x144>
  }
  else
  {
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401b60c:	687b      	ldr	r3, [r7, #4]
2401b60e:	2201      	movs	r2, #1
2401b610:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401b614:	687b      	ldr	r3, [r7, #4]
2401b616:	2201      	movs	r2, #1
2401b618:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401b61c:	687b      	ldr	r3, [r7, #4]
2401b61e:	2201      	movs	r2, #1
2401b620:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401b624:	687b      	ldr	r3, [r7, #4]
2401b626:	2201      	movs	r2, #1
2401b628:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  }

  /* Return function status */
  return HAL_OK;
2401b62c:	2300      	movs	r3, #0
}
2401b62e:	4618      	mov	r0, r3
2401b630:	3708      	adds	r7, #8
2401b632:	46bd      	mov	sp, r7
2401b634:	bd80      	pop	{r7, pc}

2401b636 <HAL_TIM_Encoder_Start_IT>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401b636:	b580      	push	{r7, lr}
2401b638:	b084      	sub	sp, #16
2401b63a:	af00      	add	r7, sp, #0
2401b63c:	6078      	str	r0, [r7, #4]
2401b63e:	6039      	str	r1, [r7, #0]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
2401b640:	687b      	ldr	r3, [r7, #4]
2401b642:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401b646:	73fb      	strb	r3, [r7, #15]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
2401b648:	687b      	ldr	r3, [r7, #4]
2401b64a:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401b64e:	73bb      	strb	r3, [r7, #14]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
2401b650:	687b      	ldr	r3, [r7, #4]
2401b652:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401b656:	737b      	strb	r3, [r7, #13]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
2401b658:	687b      	ldr	r3, [r7, #4]
2401b65a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401b65e:	733b      	strb	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));

  /* Set the TIM channel(s) state */
  if (Channel == TIM_CHANNEL_1)
2401b660:	683b      	ldr	r3, [r7, #0]
2401b662:	2b00      	cmp	r3, #0
2401b664:	d110      	bne.n	2401b688 <HAL_TIM_Encoder_Start_IT+0x52>
  {
    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401b666:	7bfb      	ldrb	r3, [r7, #15]
2401b668:	2b01      	cmp	r3, #1
2401b66a:	d102      	bne.n	2401b672 <HAL_TIM_Encoder_Start_IT+0x3c>
        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))
2401b66c:	7b7b      	ldrb	r3, [r7, #13]
2401b66e:	2b01      	cmp	r3, #1
2401b670:	d001      	beq.n	2401b676 <HAL_TIM_Encoder_Start_IT+0x40>
    {
      return HAL_ERROR;
2401b672:	2301      	movs	r3, #1
2401b674:	e089      	b.n	2401b78a <HAL_TIM_Encoder_Start_IT+0x154>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b676:	687b      	ldr	r3, [r7, #4]
2401b678:	2202      	movs	r2, #2
2401b67a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b67e:	687b      	ldr	r3, [r7, #4]
2401b680:	2202      	movs	r2, #2
2401b682:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401b686:	e031      	b.n	2401b6ec <HAL_TIM_Encoder_Start_IT+0xb6>
    }
  }
  else if (Channel == TIM_CHANNEL_2)
2401b688:	683b      	ldr	r3, [r7, #0]
2401b68a:	2b04      	cmp	r3, #4
2401b68c:	d110      	bne.n	2401b6b0 <HAL_TIM_Encoder_Start_IT+0x7a>
  {
    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2401b68e:	7bbb      	ldrb	r3, [r7, #14]
2401b690:	2b01      	cmp	r3, #1
2401b692:	d102      	bne.n	2401b69a <HAL_TIM_Encoder_Start_IT+0x64>
        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2401b694:	7b3b      	ldrb	r3, [r7, #12]
2401b696:	2b01      	cmp	r3, #1
2401b698:	d001      	beq.n	2401b69e <HAL_TIM_Encoder_Start_IT+0x68>
    {
      return HAL_ERROR;
2401b69a:	2301      	movs	r3, #1
2401b69c:	e075      	b.n	2401b78a <HAL_TIM_Encoder_Start_IT+0x154>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b69e:	687b      	ldr	r3, [r7, #4]
2401b6a0:	2202      	movs	r2, #2
2401b6a2:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b6a6:	687b      	ldr	r3, [r7, #4]
2401b6a8:	2202      	movs	r2, #2
2401b6aa:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401b6ae:	e01d      	b.n	2401b6ec <HAL_TIM_Encoder_Start_IT+0xb6>
    }
  }
  else
  {
    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401b6b0:	7bfb      	ldrb	r3, [r7, #15]
2401b6b2:	2b01      	cmp	r3, #1
2401b6b4:	d108      	bne.n	2401b6c8 <HAL_TIM_Encoder_Start_IT+0x92>
        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2401b6b6:	7bbb      	ldrb	r3, [r7, #14]
2401b6b8:	2b01      	cmp	r3, #1
2401b6ba:	d105      	bne.n	2401b6c8 <HAL_TIM_Encoder_Start_IT+0x92>
        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401b6bc:	7b7b      	ldrb	r3, [r7, #13]
2401b6be:	2b01      	cmp	r3, #1
2401b6c0:	d102      	bne.n	2401b6c8 <HAL_TIM_Encoder_Start_IT+0x92>
        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2401b6c2:	7b3b      	ldrb	r3, [r7, #12]
2401b6c4:	2b01      	cmp	r3, #1
2401b6c6:	d001      	beq.n	2401b6cc <HAL_TIM_Encoder_Start_IT+0x96>
    {
      return HAL_ERROR;
2401b6c8:	2301      	movs	r3, #1
2401b6ca:	e05e      	b.n	2401b78a <HAL_TIM_Encoder_Start_IT+0x154>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b6cc:	687b      	ldr	r3, [r7, #4]
2401b6ce:	2202      	movs	r2, #2
2401b6d0:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b6d4:	687b      	ldr	r3, [r7, #4]
2401b6d6:	2202      	movs	r2, #2
2401b6d8:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b6dc:	687b      	ldr	r3, [r7, #4]
2401b6de:	2202      	movs	r2, #2
2401b6e0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b6e4:	687b      	ldr	r3, [r7, #4]
2401b6e6:	2202      	movs	r2, #2
2401b6e8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
    }
  }

  /* Enable the encoder interface channels */
  /* Enable the capture compare Interrupts 1 and/or 2 */
  switch (Channel)
2401b6ec:	683b      	ldr	r3, [r7, #0]
2401b6ee:	2b00      	cmp	r3, #0
2401b6f0:	d003      	beq.n	2401b6fa <HAL_TIM_Encoder_Start_IT+0xc4>
2401b6f2:	683b      	ldr	r3, [r7, #0]
2401b6f4:	2b04      	cmp	r3, #4
2401b6f6:	d010      	beq.n	2401b71a <HAL_TIM_Encoder_Start_IT+0xe4>
2401b6f8:	e01f      	b.n	2401b73a <HAL_TIM_Encoder_Start_IT+0x104>
  {
    case TIM_CHANNEL_1:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401b6fa:	687b      	ldr	r3, [r7, #4]
2401b6fc:	681b      	ldr	r3, [r3, #0]
2401b6fe:	2201      	movs	r2, #1
2401b700:	2100      	movs	r1, #0
2401b702:	4618      	mov	r0, r3
2401b704:	f002 ff30 	bl	2401e568 <TIM_CCxChannelCmd>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2401b708:	687b      	ldr	r3, [r7, #4]
2401b70a:	681b      	ldr	r3, [r3, #0]
2401b70c:	68da      	ldr	r2, [r3, #12]
2401b70e:	687b      	ldr	r3, [r7, #4]
2401b710:	681b      	ldr	r3, [r3, #0]
2401b712:	f042 0202 	orr.w	r2, r2, #2
2401b716:	60da      	str	r2, [r3, #12]
      break;
2401b718:	e02e      	b.n	2401b778 <HAL_TIM_Encoder_Start_IT+0x142>
    }

    case TIM_CHANNEL_2:
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
2401b71a:	687b      	ldr	r3, [r7, #4]
2401b71c:	681b      	ldr	r3, [r3, #0]
2401b71e:	2201      	movs	r2, #1
2401b720:	2104      	movs	r1, #4
2401b722:	4618      	mov	r0, r3
2401b724:	f002 ff20 	bl	2401e568 <TIM_CCxChannelCmd>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2401b728:	687b      	ldr	r3, [r7, #4]
2401b72a:	681b      	ldr	r3, [r3, #0]
2401b72c:	68da      	ldr	r2, [r3, #12]
2401b72e:	687b      	ldr	r3, [r7, #4]
2401b730:	681b      	ldr	r3, [r3, #0]
2401b732:	f042 0204 	orr.w	r2, r2, #4
2401b736:	60da      	str	r2, [r3, #12]
      break;
2401b738:	e01e      	b.n	2401b778 <HAL_TIM_Encoder_Start_IT+0x142>
    }

    default :
    {
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401b73a:	687b      	ldr	r3, [r7, #4]
2401b73c:	681b      	ldr	r3, [r3, #0]
2401b73e:	2201      	movs	r2, #1
2401b740:	2100      	movs	r1, #0
2401b742:	4618      	mov	r0, r3
2401b744:	f002 ff10 	bl	2401e568 <TIM_CCxChannelCmd>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
2401b748:	687b      	ldr	r3, [r7, #4]
2401b74a:	681b      	ldr	r3, [r3, #0]
2401b74c:	2201      	movs	r2, #1
2401b74e:	2104      	movs	r1, #4
2401b750:	4618      	mov	r0, r3
2401b752:	f002 ff09 	bl	2401e568 <TIM_CCxChannelCmd>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2401b756:	687b      	ldr	r3, [r7, #4]
2401b758:	681b      	ldr	r3, [r3, #0]
2401b75a:	68da      	ldr	r2, [r3, #12]
2401b75c:	687b      	ldr	r3, [r7, #4]
2401b75e:	681b      	ldr	r3, [r3, #0]
2401b760:	f042 0202 	orr.w	r2, r2, #2
2401b764:	60da      	str	r2, [r3, #12]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2401b766:	687b      	ldr	r3, [r7, #4]
2401b768:	681b      	ldr	r3, [r3, #0]
2401b76a:	68da      	ldr	r2, [r3, #12]
2401b76c:	687b      	ldr	r3, [r7, #4]
2401b76e:	681b      	ldr	r3, [r3, #0]
2401b770:	f042 0204 	orr.w	r2, r2, #4
2401b774:	60da      	str	r2, [r3, #12]
      break;
2401b776:	bf00      	nop
    }
  }

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
2401b778:	687b      	ldr	r3, [r7, #4]
2401b77a:	681b      	ldr	r3, [r3, #0]
2401b77c:	681a      	ldr	r2, [r3, #0]
2401b77e:	687b      	ldr	r3, [r7, #4]
2401b780:	681b      	ldr	r3, [r3, #0]
2401b782:	f042 0201 	orr.w	r2, r2, #1
2401b786:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
2401b788:	2300      	movs	r3, #0
}
2401b78a:	4618      	mov	r0, r3
2401b78c:	3710      	adds	r7, #16
2401b78e:	46bd      	mov	sp, r7
2401b790:	bd80      	pop	{r7, pc}

2401b792 <HAL_TIM_Encoder_Stop_IT>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401b792:	b580      	push	{r7, lr}
2401b794:	b082      	sub	sp, #8
2401b796:	af00      	add	r7, sp, #0
2401b798:	6078      	str	r0, [r7, #4]
2401b79a:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));

  /* Disable the Input Capture channels 1 and 2
    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
  if (Channel == TIM_CHANNEL_1)
2401b79c:	683b      	ldr	r3, [r7, #0]
2401b79e:	2b00      	cmp	r3, #0
2401b7a0:	d10f      	bne.n	2401b7c2 <HAL_TIM_Encoder_Stop_IT+0x30>
  {
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401b7a2:	687b      	ldr	r3, [r7, #4]
2401b7a4:	681b      	ldr	r3, [r3, #0]
2401b7a6:	2200      	movs	r2, #0
2401b7a8:	2100      	movs	r1, #0
2401b7aa:	4618      	mov	r0, r3
2401b7ac:	f002 fedc 	bl	2401e568 <TIM_CCxChannelCmd>

    /* Disable the capture compare Interrupts 1 */
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2401b7b0:	687b      	ldr	r3, [r7, #4]
2401b7b2:	681b      	ldr	r3, [r3, #0]
2401b7b4:	68da      	ldr	r2, [r3, #12]
2401b7b6:	687b      	ldr	r3, [r7, #4]
2401b7b8:	681b      	ldr	r3, [r3, #0]
2401b7ba:	f022 0202 	bic.w	r2, r2, #2
2401b7be:	60da      	str	r2, [r3, #12]
2401b7c0:	e030      	b.n	2401b824 <HAL_TIM_Encoder_Stop_IT+0x92>
  }
  else if (Channel == TIM_CHANNEL_2)
2401b7c2:	683b      	ldr	r3, [r7, #0]
2401b7c4:	2b04      	cmp	r3, #4
2401b7c6:	d10f      	bne.n	2401b7e8 <HAL_TIM_Encoder_Stop_IT+0x56>
  {
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
2401b7c8:	687b      	ldr	r3, [r7, #4]
2401b7ca:	681b      	ldr	r3, [r3, #0]
2401b7cc:	2200      	movs	r2, #0
2401b7ce:	2104      	movs	r1, #4
2401b7d0:	4618      	mov	r0, r3
2401b7d2:	f002 fec9 	bl	2401e568 <TIM_CCxChannelCmd>

    /* Disable the capture compare Interrupts 2 */
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2401b7d6:	687b      	ldr	r3, [r7, #4]
2401b7d8:	681b      	ldr	r3, [r3, #0]
2401b7da:	68da      	ldr	r2, [r3, #12]
2401b7dc:	687b      	ldr	r3, [r7, #4]
2401b7de:	681b      	ldr	r3, [r3, #0]
2401b7e0:	f022 0204 	bic.w	r2, r2, #4
2401b7e4:	60da      	str	r2, [r3, #12]
2401b7e6:	e01d      	b.n	2401b824 <HAL_TIM_Encoder_Stop_IT+0x92>
  }
  else
  {
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401b7e8:	687b      	ldr	r3, [r7, #4]
2401b7ea:	681b      	ldr	r3, [r3, #0]
2401b7ec:	2200      	movs	r2, #0
2401b7ee:	2100      	movs	r1, #0
2401b7f0:	4618      	mov	r0, r3
2401b7f2:	f002 feb9 	bl	2401e568 <TIM_CCxChannelCmd>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
2401b7f6:	687b      	ldr	r3, [r7, #4]
2401b7f8:	681b      	ldr	r3, [r3, #0]
2401b7fa:	2200      	movs	r2, #0
2401b7fc:	2104      	movs	r1, #4
2401b7fe:	4618      	mov	r0, r3
2401b800:	f002 feb2 	bl	2401e568 <TIM_CCxChannelCmd>

    /* Disable the capture compare Interrupts 1 and 2 */
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2401b804:	687b      	ldr	r3, [r7, #4]
2401b806:	681b      	ldr	r3, [r3, #0]
2401b808:	68da      	ldr	r2, [r3, #12]
2401b80a:	687b      	ldr	r3, [r7, #4]
2401b80c:	681b      	ldr	r3, [r3, #0]
2401b80e:	f022 0202 	bic.w	r2, r2, #2
2401b812:	60da      	str	r2, [r3, #12]
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2401b814:	687b      	ldr	r3, [r7, #4]
2401b816:	681b      	ldr	r3, [r3, #0]
2401b818:	68da      	ldr	r2, [r3, #12]
2401b81a:	687b      	ldr	r3, [r7, #4]
2401b81c:	681b      	ldr	r3, [r3, #0]
2401b81e:	f022 0204 	bic.w	r2, r2, #4
2401b822:	60da      	str	r2, [r3, #12]
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401b824:	687b      	ldr	r3, [r7, #4]
2401b826:	681b      	ldr	r3, [r3, #0]
2401b828:	6a1a      	ldr	r2, [r3, #32]
2401b82a:	f241 1311 	movw	r3, #4369	; 0x1111
2401b82e:	4013      	ands	r3, r2
2401b830:	2b00      	cmp	r3, #0
2401b832:	d10f      	bne.n	2401b854 <HAL_TIM_Encoder_Stop_IT+0xc2>
2401b834:	687b      	ldr	r3, [r7, #4]
2401b836:	681b      	ldr	r3, [r3, #0]
2401b838:	6a1a      	ldr	r2, [r3, #32]
2401b83a:	f240 4344 	movw	r3, #1092	; 0x444
2401b83e:	4013      	ands	r3, r2
2401b840:	2b00      	cmp	r3, #0
2401b842:	d107      	bne.n	2401b854 <HAL_TIM_Encoder_Stop_IT+0xc2>
2401b844:	687b      	ldr	r3, [r7, #4]
2401b846:	681b      	ldr	r3, [r3, #0]
2401b848:	681a      	ldr	r2, [r3, #0]
2401b84a:	687b      	ldr	r3, [r7, #4]
2401b84c:	681b      	ldr	r3, [r3, #0]
2401b84e:	f022 0201 	bic.w	r2, r2, #1
2401b852:	601a      	str	r2, [r3, #0]

  /* Set the TIM channel(s) state */
  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
2401b854:	683b      	ldr	r3, [r7, #0]
2401b856:	2b00      	cmp	r3, #0
2401b858:	d002      	beq.n	2401b860 <HAL_TIM_Encoder_Stop_IT+0xce>
2401b85a:	683b      	ldr	r3, [r7, #0]
2401b85c:	2b04      	cmp	r3, #4
2401b85e:	d148      	bne.n	2401b8f2 <HAL_TIM_Encoder_Stop_IT+0x160>
  {
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401b860:	683b      	ldr	r3, [r7, #0]
2401b862:	2b00      	cmp	r3, #0
2401b864:	d104      	bne.n	2401b870 <HAL_TIM_Encoder_Stop_IT+0xde>
2401b866:	687b      	ldr	r3, [r7, #4]
2401b868:	2201      	movs	r2, #1
2401b86a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401b86e:	e023      	b.n	2401b8b8 <HAL_TIM_Encoder_Stop_IT+0x126>
2401b870:	683b      	ldr	r3, [r7, #0]
2401b872:	2b04      	cmp	r3, #4
2401b874:	d104      	bne.n	2401b880 <HAL_TIM_Encoder_Stop_IT+0xee>
2401b876:	687b      	ldr	r3, [r7, #4]
2401b878:	2201      	movs	r2, #1
2401b87a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401b87e:	e01b      	b.n	2401b8b8 <HAL_TIM_Encoder_Stop_IT+0x126>
2401b880:	683b      	ldr	r3, [r7, #0]
2401b882:	2b08      	cmp	r3, #8
2401b884:	d104      	bne.n	2401b890 <HAL_TIM_Encoder_Stop_IT+0xfe>
2401b886:	687b      	ldr	r3, [r7, #4]
2401b888:	2201      	movs	r2, #1
2401b88a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401b88e:	e013      	b.n	2401b8b8 <HAL_TIM_Encoder_Stop_IT+0x126>
2401b890:	683b      	ldr	r3, [r7, #0]
2401b892:	2b0c      	cmp	r3, #12
2401b894:	d104      	bne.n	2401b8a0 <HAL_TIM_Encoder_Stop_IT+0x10e>
2401b896:	687b      	ldr	r3, [r7, #4]
2401b898:	2201      	movs	r2, #1
2401b89a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401b89e:	e00b      	b.n	2401b8b8 <HAL_TIM_Encoder_Stop_IT+0x126>
2401b8a0:	683b      	ldr	r3, [r7, #0]
2401b8a2:	2b10      	cmp	r3, #16
2401b8a4:	d104      	bne.n	2401b8b0 <HAL_TIM_Encoder_Stop_IT+0x11e>
2401b8a6:	687b      	ldr	r3, [r7, #4]
2401b8a8:	2201      	movs	r2, #1
2401b8aa:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401b8ae:	e003      	b.n	2401b8b8 <HAL_TIM_Encoder_Stop_IT+0x126>
2401b8b0:	687b      	ldr	r3, [r7, #4]
2401b8b2:	2201      	movs	r2, #1
2401b8b4:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401b8b8:	683b      	ldr	r3, [r7, #0]
2401b8ba:	2b00      	cmp	r3, #0
2401b8bc:	d104      	bne.n	2401b8c8 <HAL_TIM_Encoder_Stop_IT+0x136>
2401b8be:	687b      	ldr	r3, [r7, #4]
2401b8c0:	2201      	movs	r2, #1
2401b8c2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401b8c6:	e024      	b.n	2401b912 <HAL_TIM_Encoder_Stop_IT+0x180>
2401b8c8:	683b      	ldr	r3, [r7, #0]
2401b8ca:	2b04      	cmp	r3, #4
2401b8cc:	d104      	bne.n	2401b8d8 <HAL_TIM_Encoder_Stop_IT+0x146>
2401b8ce:	687b      	ldr	r3, [r7, #4]
2401b8d0:	2201      	movs	r2, #1
2401b8d2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401b8d6:	e01c      	b.n	2401b912 <HAL_TIM_Encoder_Stop_IT+0x180>
2401b8d8:	683b      	ldr	r3, [r7, #0]
2401b8da:	2b08      	cmp	r3, #8
2401b8dc:	d104      	bne.n	2401b8e8 <HAL_TIM_Encoder_Stop_IT+0x156>
2401b8de:	687b      	ldr	r3, [r7, #4]
2401b8e0:	2201      	movs	r2, #1
2401b8e2:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401b8e6:	e014      	b.n	2401b912 <HAL_TIM_Encoder_Stop_IT+0x180>
2401b8e8:	687b      	ldr	r3, [r7, #4]
2401b8ea:	2201      	movs	r2, #1
2401b8ec:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
2401b8f0:	e00f      	b.n	2401b912 <HAL_TIM_Encoder_Stop_IT+0x180>
  }
  else
  {
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401b8f2:	687b      	ldr	r3, [r7, #4]
2401b8f4:	2201      	movs	r2, #1
2401b8f6:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401b8fa:	687b      	ldr	r3, [r7, #4]
2401b8fc:	2201      	movs	r2, #1
2401b8fe:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401b902:	687b      	ldr	r3, [r7, #4]
2401b904:	2201      	movs	r2, #1
2401b906:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401b90a:	687b      	ldr	r3, [r7, #4]
2401b90c:	2201      	movs	r2, #1
2401b90e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  }

  /* Return function status */
  return HAL_OK;
2401b912:	2300      	movs	r3, #0
}
2401b914:	4618      	mov	r0, r3
2401b916:	3708      	adds	r7, #8
2401b918:	46bd      	mov	sp, r7
2401b91a:	bd80      	pop	{r7, pc}

2401b91c <HAL_TIM_Encoder_Start_DMA>:
  * @param  Length The length of data to be transferred from TIM peripheral to memory.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
                                            uint32_t *pData2, uint16_t Length)
{
2401b91c:	b580      	push	{r7, lr}
2401b91e:	b086      	sub	sp, #24
2401b920:	af00      	add	r7, sp, #0
2401b922:	60f8      	str	r0, [r7, #12]
2401b924:	60b9      	str	r1, [r7, #8]
2401b926:	607a      	str	r2, [r7, #4]
2401b928:	603b      	str	r3, [r7, #0]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
2401b92a:	68fb      	ldr	r3, [r7, #12]
2401b92c:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401b930:	75fb      	strb	r3, [r7, #23]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
2401b932:	68fb      	ldr	r3, [r7, #12]
2401b934:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401b938:	75bb      	strb	r3, [r7, #22]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
2401b93a:	68fb      	ldr	r3, [r7, #12]
2401b93c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401b940:	757b      	strb	r3, [r7, #21]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
2401b942:	68fb      	ldr	r3, [r7, #12]
2401b944:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401b948:	753b      	strb	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));

  /* Set the TIM channel(s) state */
  if (Channel == TIM_CHANNEL_1)
2401b94a:	68bb      	ldr	r3, [r7, #8]
2401b94c:	2b00      	cmp	r3, #0
2401b94e:	d120      	bne.n	2401b992 <HAL_TIM_Encoder_Start_DMA+0x76>
  {
    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
2401b950:	7dfb      	ldrb	r3, [r7, #23]
2401b952:	2b02      	cmp	r3, #2
2401b954:	d002      	beq.n	2401b95c <HAL_TIM_Encoder_Start_DMA+0x40>
        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))
2401b956:	7d7b      	ldrb	r3, [r7, #21]
2401b958:	2b02      	cmp	r3, #2
2401b95a:	d101      	bne.n	2401b960 <HAL_TIM_Encoder_Start_DMA+0x44>
    {
      return HAL_BUSY;
2401b95c:	2302      	movs	r3, #2
2401b95e:	e13f      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
    }
    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
2401b960:	7dfb      	ldrb	r3, [r7, #23]
2401b962:	2b01      	cmp	r3, #1
2401b964:	d113      	bne.n	2401b98e <HAL_TIM_Encoder_Start_DMA+0x72>
             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))
2401b966:	7d7b      	ldrb	r3, [r7, #21]
2401b968:	2b01      	cmp	r3, #1
2401b96a:	d110      	bne.n	2401b98e <HAL_TIM_Encoder_Start_DMA+0x72>
    {
      if ((pData1 == NULL) || (Length == 0U))
2401b96c:	687b      	ldr	r3, [r7, #4]
2401b96e:	2b00      	cmp	r3, #0
2401b970:	d002      	beq.n	2401b978 <HAL_TIM_Encoder_Start_DMA+0x5c>
2401b972:	8c3b      	ldrh	r3, [r7, #32]
2401b974:	2b00      	cmp	r3, #0
2401b976:	d101      	bne.n	2401b97c <HAL_TIM_Encoder_Start_DMA+0x60>
      {
        return HAL_ERROR;
2401b978:	2301      	movs	r3, #1
2401b97a:	e131      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
      }
      else
      {
        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b97c:	68fb      	ldr	r3, [r7, #12]
2401b97e:	2202      	movs	r2, #2
2401b980:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401b984:	68fb      	ldr	r3, [r7, #12]
2401b986:	2202      	movs	r2, #2
2401b988:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
      if ((pData1 == NULL) || (Length == 0U))
2401b98c:	e05d      	b.n	2401ba4a <HAL_TIM_Encoder_Start_DMA+0x12e>
      }
    }
    else
    {
      return HAL_ERROR;
2401b98e:	2301      	movs	r3, #1
2401b990:	e126      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
    }
  }
  else if (Channel == TIM_CHANNEL_2)
2401b992:	68bb      	ldr	r3, [r7, #8]
2401b994:	2b04      	cmp	r3, #4
2401b996:	d120      	bne.n	2401b9da <HAL_TIM_Encoder_Start_DMA+0xbe>
  {
    if ((channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)
2401b998:	7dbb      	ldrb	r3, [r7, #22]
2401b99a:	2b02      	cmp	r3, #2
2401b99c:	d002      	beq.n	2401b9a4 <HAL_TIM_Encoder_Start_DMA+0x88>
        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))
2401b99e:	7d3b      	ldrb	r3, [r7, #20]
2401b9a0:	2b02      	cmp	r3, #2
2401b9a2:	d101      	bne.n	2401b9a8 <HAL_TIM_Encoder_Start_DMA+0x8c>
    {
      return HAL_BUSY;
2401b9a4:	2302      	movs	r3, #2
2401b9a6:	e11b      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
    }
    else if ((channel_2_state == HAL_TIM_CHANNEL_STATE_READY)
2401b9a8:	7dbb      	ldrb	r3, [r7, #22]
2401b9aa:	2b01      	cmp	r3, #1
2401b9ac:	d113      	bne.n	2401b9d6 <HAL_TIM_Encoder_Start_DMA+0xba>
             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))
2401b9ae:	7d3b      	ldrb	r3, [r7, #20]
2401b9b0:	2b01      	cmp	r3, #1
2401b9b2:	d110      	bne.n	2401b9d6 <HAL_TIM_Encoder_Start_DMA+0xba>
    {
      if ((pData2 == NULL) || (Length == 0U))
2401b9b4:	683b      	ldr	r3, [r7, #0]
2401b9b6:	2b00      	cmp	r3, #0
2401b9b8:	d002      	beq.n	2401b9c0 <HAL_TIM_Encoder_Start_DMA+0xa4>
2401b9ba:	8c3b      	ldrh	r3, [r7, #32]
2401b9bc:	2b00      	cmp	r3, #0
2401b9be:	d101      	bne.n	2401b9c4 <HAL_TIM_Encoder_Start_DMA+0xa8>
      {
        return HAL_ERROR;
2401b9c0:	2301      	movs	r3, #1
2401b9c2:	e10d      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
      }
      else
      {
        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b9c4:	68fb      	ldr	r3, [r7, #12]
2401b9c6:	2202      	movs	r2, #2
2401b9c8:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401b9cc:	68fb      	ldr	r3, [r7, #12]
2401b9ce:	2202      	movs	r2, #2
2401b9d0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
      if ((pData2 == NULL) || (Length == 0U))
2401b9d4:	e039      	b.n	2401ba4a <HAL_TIM_Encoder_Start_DMA+0x12e>
      }
    }
    else
    {
      return HAL_ERROR;
2401b9d6:	2301      	movs	r3, #1
2401b9d8:	e102      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
    }
  }
  else
  {
    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
2401b9da:	7dfb      	ldrb	r3, [r7, #23]
2401b9dc:	2b02      	cmp	r3, #2
2401b9de:	d008      	beq.n	2401b9f2 <HAL_TIM_Encoder_Start_DMA+0xd6>
        || (channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)
2401b9e0:	7dbb      	ldrb	r3, [r7, #22]
2401b9e2:	2b02      	cmp	r3, #2
2401b9e4:	d005      	beq.n	2401b9f2 <HAL_TIM_Encoder_Start_DMA+0xd6>
        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
2401b9e6:	7d7b      	ldrb	r3, [r7, #21]
2401b9e8:	2b02      	cmp	r3, #2
2401b9ea:	d002      	beq.n	2401b9f2 <HAL_TIM_Encoder_Start_DMA+0xd6>
        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))
2401b9ec:	7d3b      	ldrb	r3, [r7, #20]
2401b9ee:	2b02      	cmp	r3, #2
2401b9f0:	d101      	bne.n	2401b9f6 <HAL_TIM_Encoder_Start_DMA+0xda>
    {
      return HAL_BUSY;
2401b9f2:	2302      	movs	r3, #2
2401b9f4:	e0f4      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
    }
    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
2401b9f6:	7dfb      	ldrb	r3, [r7, #23]
2401b9f8:	2b01      	cmp	r3, #1
2401b9fa:	d124      	bne.n	2401ba46 <HAL_TIM_Encoder_Start_DMA+0x12a>
             && (channel_2_state == HAL_TIM_CHANNEL_STATE_READY)
2401b9fc:	7dbb      	ldrb	r3, [r7, #22]
2401b9fe:	2b01      	cmp	r3, #1
2401ba00:	d121      	bne.n	2401ba46 <HAL_TIM_Encoder_Start_DMA+0x12a>
             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
2401ba02:	7d7b      	ldrb	r3, [r7, #21]
2401ba04:	2b01      	cmp	r3, #1
2401ba06:	d11e      	bne.n	2401ba46 <HAL_TIM_Encoder_Start_DMA+0x12a>
             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))
2401ba08:	7d3b      	ldrb	r3, [r7, #20]
2401ba0a:	2b01      	cmp	r3, #1
2401ba0c:	d11b      	bne.n	2401ba46 <HAL_TIM_Encoder_Start_DMA+0x12a>
    {
      if ((((pData1 == NULL) || (pData2 == NULL))) || (Length == 0U))
2401ba0e:	687b      	ldr	r3, [r7, #4]
2401ba10:	2b00      	cmp	r3, #0
2401ba12:	d005      	beq.n	2401ba20 <HAL_TIM_Encoder_Start_DMA+0x104>
2401ba14:	683b      	ldr	r3, [r7, #0]
2401ba16:	2b00      	cmp	r3, #0
2401ba18:	d002      	beq.n	2401ba20 <HAL_TIM_Encoder_Start_DMA+0x104>
2401ba1a:	8c3b      	ldrh	r3, [r7, #32]
2401ba1c:	2b00      	cmp	r3, #0
2401ba1e:	d101      	bne.n	2401ba24 <HAL_TIM_Encoder_Start_DMA+0x108>
      {
        return HAL_ERROR;
2401ba20:	2301      	movs	r3, #1
2401ba22:	e0dd      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
      }
      else
      {
        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401ba24:	68fb      	ldr	r3, [r7, #12]
2401ba26:	2202      	movs	r2, #2
2401ba28:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401ba2c:	68fb      	ldr	r3, [r7, #12]
2401ba2e:	2202      	movs	r2, #2
2401ba30:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401ba34:	68fb      	ldr	r3, [r7, #12]
2401ba36:	2202      	movs	r2, #2
2401ba38:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401ba3c:	68fb      	ldr	r3, [r7, #12]
2401ba3e:	2202      	movs	r2, #2
2401ba40:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
      if ((((pData1 == NULL) || (pData2 == NULL))) || (Length == 0U))
2401ba44:	e001      	b.n	2401ba4a <HAL_TIM_Encoder_Start_DMA+0x12e>
      }
    }
    else
    {
      return HAL_ERROR;
2401ba46:	2301      	movs	r3, #1
2401ba48:	e0ca      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
    }
  }

  switch (Channel)
2401ba4a:	68bb      	ldr	r3, [r7, #8]
2401ba4c:	2b00      	cmp	r3, #0
2401ba4e:	d003      	beq.n	2401ba58 <HAL_TIM_Encoder_Start_DMA+0x13c>
2401ba50:	68bb      	ldr	r3, [r7, #8]
2401ba52:	2b04      	cmp	r3, #4
2401ba54:	d033      	beq.n	2401babe <HAL_TIM_Encoder_Start_DMA+0x1a2>
2401ba56:	e065      	b.n	2401bb24 <HAL_TIM_Encoder_Start_DMA+0x208>
  {
    case TIM_CHANNEL_1:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2401ba58:	68fb      	ldr	r3, [r7, #12]
2401ba5a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401ba5c:	4a62      	ldr	r2, [pc, #392]	; (2401bbe8 <HAL_TIM_Encoder_Start_DMA+0x2cc>)
2401ba5e:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401ba60:	68fb      	ldr	r3, [r7, #12]
2401ba62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401ba64:	4a61      	ldr	r2, [pc, #388]	; (2401bbec <HAL_TIM_Encoder_Start_DMA+0x2d0>)
2401ba66:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2401ba68:	68fb      	ldr	r3, [r7, #12]
2401ba6a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401ba6c:	4a60      	ldr	r2, [pc, #384]	; (2401bbf0 <HAL_TIM_Encoder_Start_DMA+0x2d4>)
2401ba6e:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,
2401ba70:	68fb      	ldr	r3, [r7, #12]
2401ba72:	6a58      	ldr	r0, [r3, #36]	; 0x24
2401ba74:	68fb      	ldr	r3, [r7, #12]
2401ba76:	681b      	ldr	r3, [r3, #0]
2401ba78:	3334      	adds	r3, #52	; 0x34
2401ba7a:	4619      	mov	r1, r3
2401ba7c:	687a      	ldr	r2, [r7, #4]
2401ba7e:	8c3b      	ldrh	r3, [r7, #32]
2401ba80:	f7e8 f866 	bl	24003b50 <HAL_DMA_Start_IT>
2401ba84:	4603      	mov	r3, r0
2401ba86:	2b00      	cmp	r3, #0
2401ba88:	d001      	beq.n	2401ba8e <HAL_TIM_Encoder_Start_DMA+0x172>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401ba8a:	2301      	movs	r3, #1
2401ba8c:	e0a8      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
      }
      /* Enable the TIM Input Capture DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2401ba8e:	68fb      	ldr	r3, [r7, #12]
2401ba90:	681b      	ldr	r3, [r3, #0]
2401ba92:	68da      	ldr	r2, [r3, #12]
2401ba94:	68fb      	ldr	r3, [r7, #12]
2401ba96:	681b      	ldr	r3, [r3, #0]
2401ba98:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2401ba9c:	60da      	str	r2, [r3, #12]

      /* Enable the Capture compare channel */
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401ba9e:	68fb      	ldr	r3, [r7, #12]
2401baa0:	681b      	ldr	r3, [r3, #0]
2401baa2:	2201      	movs	r2, #1
2401baa4:	2100      	movs	r1, #0
2401baa6:	4618      	mov	r0, r3
2401baa8:	f002 fd5e 	bl	2401e568 <TIM_CCxChannelCmd>

      /* Enable the Peripheral */
      __HAL_TIM_ENABLE(htim);
2401baac:	68fb      	ldr	r3, [r7, #12]
2401baae:	681b      	ldr	r3, [r3, #0]
2401bab0:	681a      	ldr	r2, [r3, #0]
2401bab2:	68fb      	ldr	r3, [r7, #12]
2401bab4:	681b      	ldr	r3, [r3, #0]
2401bab6:	f042 0201 	orr.w	r2, r2, #1
2401baba:	601a      	str	r2, [r3, #0]

      break;
2401babc:	e08f      	b.n	2401bbde <HAL_TIM_Encoder_Start_DMA+0x2c2>
    }

    case TIM_CHANNEL_2:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2401babe:	68fb      	ldr	r3, [r7, #12]
2401bac0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401bac2:	4a49      	ldr	r2, [pc, #292]	; (2401bbe8 <HAL_TIM_Encoder_Start_DMA+0x2cc>)
2401bac4:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401bac6:	68fb      	ldr	r3, [r7, #12]
2401bac8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401baca:	4a48      	ldr	r2, [pc, #288]	; (2401bbec <HAL_TIM_Encoder_Start_DMA+0x2d0>)
2401bacc:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
2401bace:	68fb      	ldr	r3, [r7, #12]
2401bad0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401bad2:	4a47      	ldr	r2, [pc, #284]	; (2401bbf0 <HAL_TIM_Encoder_Start_DMA+0x2d4>)
2401bad4:	64da      	str	r2, [r3, #76]	; 0x4c
      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,
2401bad6:	68fb      	ldr	r3, [r7, #12]
2401bad8:	6a98      	ldr	r0, [r3, #40]	; 0x28
2401bada:	68fb      	ldr	r3, [r7, #12]
2401badc:	681b      	ldr	r3, [r3, #0]
2401bade:	3338      	adds	r3, #56	; 0x38
2401bae0:	4619      	mov	r1, r3
2401bae2:	683a      	ldr	r2, [r7, #0]
2401bae4:	8c3b      	ldrh	r3, [r7, #32]
2401bae6:	f7e8 f833 	bl	24003b50 <HAL_DMA_Start_IT>
2401baea:	4603      	mov	r3, r0
2401baec:	2b00      	cmp	r3, #0
2401baee:	d001      	beq.n	2401baf4 <HAL_TIM_Encoder_Start_DMA+0x1d8>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401baf0:	2301      	movs	r3, #1
2401baf2:	e075      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
      }
      /* Enable the TIM Input Capture  DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2401baf4:	68fb      	ldr	r3, [r7, #12]
2401baf6:	681b      	ldr	r3, [r3, #0]
2401baf8:	68da      	ldr	r2, [r3, #12]
2401bafa:	68fb      	ldr	r3, [r7, #12]
2401bafc:	681b      	ldr	r3, [r3, #0]
2401bafe:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
2401bb02:	60da      	str	r2, [r3, #12]

      /* Enable the Capture compare channel */
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
2401bb04:	68fb      	ldr	r3, [r7, #12]
2401bb06:	681b      	ldr	r3, [r3, #0]
2401bb08:	2201      	movs	r2, #1
2401bb0a:	2104      	movs	r1, #4
2401bb0c:	4618      	mov	r0, r3
2401bb0e:	f002 fd2b 	bl	2401e568 <TIM_CCxChannelCmd>

      /* Enable the Peripheral */
      __HAL_TIM_ENABLE(htim);
2401bb12:	68fb      	ldr	r3, [r7, #12]
2401bb14:	681b      	ldr	r3, [r3, #0]
2401bb16:	681a      	ldr	r2, [r3, #0]
2401bb18:	68fb      	ldr	r3, [r7, #12]
2401bb1a:	681b      	ldr	r3, [r3, #0]
2401bb1c:	f042 0201 	orr.w	r2, r2, #1
2401bb20:	601a      	str	r2, [r3, #0]

      break;
2401bb22:	e05c      	b.n	2401bbde <HAL_TIM_Encoder_Start_DMA+0x2c2>
    }

    default:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2401bb24:	68fb      	ldr	r3, [r7, #12]
2401bb26:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401bb28:	4a2f      	ldr	r2, [pc, #188]	; (2401bbe8 <HAL_TIM_Encoder_Start_DMA+0x2cc>)
2401bb2a:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401bb2c:	68fb      	ldr	r3, [r7, #12]
2401bb2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401bb30:	4a2e      	ldr	r2, [pc, #184]	; (2401bbec <HAL_TIM_Encoder_Start_DMA+0x2d0>)
2401bb32:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2401bb34:	68fb      	ldr	r3, [r7, #12]
2401bb36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401bb38:	4a2d      	ldr	r2, [pc, #180]	; (2401bbf0 <HAL_TIM_Encoder_Start_DMA+0x2d4>)
2401bb3a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,
2401bb3c:	68fb      	ldr	r3, [r7, #12]
2401bb3e:	6a58      	ldr	r0, [r3, #36]	; 0x24
2401bb40:	68fb      	ldr	r3, [r7, #12]
2401bb42:	681b      	ldr	r3, [r3, #0]
2401bb44:	3334      	adds	r3, #52	; 0x34
2401bb46:	4619      	mov	r1, r3
2401bb48:	687a      	ldr	r2, [r7, #4]
2401bb4a:	8c3b      	ldrh	r3, [r7, #32]
2401bb4c:	f7e8 f800 	bl	24003b50 <HAL_DMA_Start_IT>
2401bb50:	4603      	mov	r3, r0
2401bb52:	2b00      	cmp	r3, #0
2401bb54:	d001      	beq.n	2401bb5a <HAL_TIM_Encoder_Start_DMA+0x23e>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401bb56:	2301      	movs	r3, #1
2401bb58:	e042      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
      }

      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2401bb5a:	68fb      	ldr	r3, [r7, #12]
2401bb5c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401bb5e:	4a22      	ldr	r2, [pc, #136]	; (2401bbe8 <HAL_TIM_Encoder_Start_DMA+0x2cc>)
2401bb60:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401bb62:	68fb      	ldr	r3, [r7, #12]
2401bb64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401bb66:	4a21      	ldr	r2, [pc, #132]	; (2401bbec <HAL_TIM_Encoder_Start_DMA+0x2d0>)
2401bb68:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
2401bb6a:	68fb      	ldr	r3, [r7, #12]
2401bb6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401bb6e:	4a20      	ldr	r2, [pc, #128]	; (2401bbf0 <HAL_TIM_Encoder_Start_DMA+0x2d4>)
2401bb70:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,
2401bb72:	68fb      	ldr	r3, [r7, #12]
2401bb74:	6a98      	ldr	r0, [r3, #40]	; 0x28
2401bb76:	68fb      	ldr	r3, [r7, #12]
2401bb78:	681b      	ldr	r3, [r3, #0]
2401bb7a:	3338      	adds	r3, #56	; 0x38
2401bb7c:	4619      	mov	r1, r3
2401bb7e:	683a      	ldr	r2, [r7, #0]
2401bb80:	8c3b      	ldrh	r3, [r7, #32]
2401bb82:	f7e7 ffe5 	bl	24003b50 <HAL_DMA_Start_IT>
2401bb86:	4603      	mov	r3, r0
2401bb88:	2b00      	cmp	r3, #0
2401bb8a:	d001      	beq.n	2401bb90 <HAL_TIM_Encoder_Start_DMA+0x274>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401bb8c:	2301      	movs	r3, #1
2401bb8e:	e027      	b.n	2401bbe0 <HAL_TIM_Encoder_Start_DMA+0x2c4>
      }

      /* Enable the TIM Input Capture  DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2401bb90:	68fb      	ldr	r3, [r7, #12]
2401bb92:	681b      	ldr	r3, [r3, #0]
2401bb94:	68da      	ldr	r2, [r3, #12]
2401bb96:	68fb      	ldr	r3, [r7, #12]
2401bb98:	681b      	ldr	r3, [r3, #0]
2401bb9a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2401bb9e:	60da      	str	r2, [r3, #12]
      /* Enable the TIM Input Capture  DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2401bba0:	68fb      	ldr	r3, [r7, #12]
2401bba2:	681b      	ldr	r3, [r3, #0]
2401bba4:	68da      	ldr	r2, [r3, #12]
2401bba6:	68fb      	ldr	r3, [r7, #12]
2401bba8:	681b      	ldr	r3, [r3, #0]
2401bbaa:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
2401bbae:	60da      	str	r2, [r3, #12]

      /* Enable the Capture compare channel */
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401bbb0:	68fb      	ldr	r3, [r7, #12]
2401bbb2:	681b      	ldr	r3, [r3, #0]
2401bbb4:	2201      	movs	r2, #1
2401bbb6:	2100      	movs	r1, #0
2401bbb8:	4618      	mov	r0, r3
2401bbba:	f002 fcd5 	bl	2401e568 <TIM_CCxChannelCmd>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
2401bbbe:	68fb      	ldr	r3, [r7, #12]
2401bbc0:	681b      	ldr	r3, [r3, #0]
2401bbc2:	2201      	movs	r2, #1
2401bbc4:	2104      	movs	r1, #4
2401bbc6:	4618      	mov	r0, r3
2401bbc8:	f002 fcce 	bl	2401e568 <TIM_CCxChannelCmd>

      /* Enable the Peripheral */
      __HAL_TIM_ENABLE(htim);
2401bbcc:	68fb      	ldr	r3, [r7, #12]
2401bbce:	681b      	ldr	r3, [r3, #0]
2401bbd0:	681a      	ldr	r2, [r3, #0]
2401bbd2:	68fb      	ldr	r3, [r7, #12]
2401bbd4:	681b      	ldr	r3, [r3, #0]
2401bbd6:	f042 0201 	orr.w	r2, r2, #1
2401bbda:	601a      	str	r2, [r3, #0]

      break;
2401bbdc:	bf00      	nop
    }
  }

  /* Return function status */
  return HAL_OK;
2401bbde:	2300      	movs	r3, #0
}
2401bbe0:	4618      	mov	r0, r3
2401bbe2:	3718      	adds	r7, #24
2401bbe4:	46bd      	mov	sp, r7
2401bbe6:	bd80      	pop	{r7, pc}
2401bbe8:	2401d761 	.word	0x2401d761
2401bbec:	2401d829 	.word	0x2401d829
2401bbf0:	2401d5bf 	.word	0x2401d5bf

2401bbf4 <HAL_TIM_Encoder_Stop_DMA>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401bbf4:	b580      	push	{r7, lr}
2401bbf6:	b082      	sub	sp, #8
2401bbf8:	af00      	add	r7, sp, #0
2401bbfa:	6078      	str	r0, [r7, #4]
2401bbfc:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));

  /* Disable the Input Capture channels 1 and 2
    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
  if (Channel == TIM_CHANNEL_1)
2401bbfe:	683b      	ldr	r3, [r7, #0]
2401bc00:	2b00      	cmp	r3, #0
2401bc02:	d114      	bne.n	2401bc2e <HAL_TIM_Encoder_Stop_DMA+0x3a>
  {
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401bc04:	687b      	ldr	r3, [r7, #4]
2401bc06:	681b      	ldr	r3, [r3, #0]
2401bc08:	2200      	movs	r2, #0
2401bc0a:	2100      	movs	r1, #0
2401bc0c:	4618      	mov	r0, r3
2401bc0e:	f002 fcab 	bl	2401e568 <TIM_CCxChannelCmd>

    /* Disable the capture compare DMA Request 1 */
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2401bc12:	687b      	ldr	r3, [r7, #4]
2401bc14:	681b      	ldr	r3, [r3, #0]
2401bc16:	68da      	ldr	r2, [r3, #12]
2401bc18:	687b      	ldr	r3, [r7, #4]
2401bc1a:	681b      	ldr	r3, [r3, #0]
2401bc1c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
2401bc20:	60da      	str	r2, [r3, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2401bc22:	687b      	ldr	r3, [r7, #4]
2401bc24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401bc26:	4618      	mov	r0, r3
2401bc28:	f7e8 fd1a 	bl	24004660 <HAL_DMA_Abort_IT>
2401bc2c:	e03f      	b.n	2401bcae <HAL_TIM_Encoder_Stop_DMA+0xba>
  }
  else if (Channel == TIM_CHANNEL_2)
2401bc2e:	683b      	ldr	r3, [r7, #0]
2401bc30:	2b04      	cmp	r3, #4
2401bc32:	d114      	bne.n	2401bc5e <HAL_TIM_Encoder_Stop_DMA+0x6a>
  {
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
2401bc34:	687b      	ldr	r3, [r7, #4]
2401bc36:	681b      	ldr	r3, [r3, #0]
2401bc38:	2200      	movs	r2, #0
2401bc3a:	2104      	movs	r1, #4
2401bc3c:	4618      	mov	r0, r3
2401bc3e:	f002 fc93 	bl	2401e568 <TIM_CCxChannelCmd>

    /* Disable the capture compare DMA Request 2 */
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2401bc42:	687b      	ldr	r3, [r7, #4]
2401bc44:	681b      	ldr	r3, [r3, #0]
2401bc46:	68da      	ldr	r2, [r3, #12]
2401bc48:	687b      	ldr	r3, [r7, #4]
2401bc4a:	681b      	ldr	r3, [r3, #0]
2401bc4c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2401bc50:	60da      	str	r2, [r3, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2401bc52:	687b      	ldr	r3, [r7, #4]
2401bc54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401bc56:	4618      	mov	r0, r3
2401bc58:	f7e8 fd02 	bl	24004660 <HAL_DMA_Abort_IT>
2401bc5c:	e027      	b.n	2401bcae <HAL_TIM_Encoder_Stop_DMA+0xba>
  }
  else
  {
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401bc5e:	687b      	ldr	r3, [r7, #4]
2401bc60:	681b      	ldr	r3, [r3, #0]
2401bc62:	2200      	movs	r2, #0
2401bc64:	2100      	movs	r1, #0
2401bc66:	4618      	mov	r0, r3
2401bc68:	f002 fc7e 	bl	2401e568 <TIM_CCxChannelCmd>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
2401bc6c:	687b      	ldr	r3, [r7, #4]
2401bc6e:	681b      	ldr	r3, [r3, #0]
2401bc70:	2200      	movs	r2, #0
2401bc72:	2104      	movs	r1, #4
2401bc74:	4618      	mov	r0, r3
2401bc76:	f002 fc77 	bl	2401e568 <TIM_CCxChannelCmd>

    /* Disable the capture compare DMA Request 1 and 2 */
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2401bc7a:	687b      	ldr	r3, [r7, #4]
2401bc7c:	681b      	ldr	r3, [r3, #0]
2401bc7e:	68da      	ldr	r2, [r3, #12]
2401bc80:	687b      	ldr	r3, [r7, #4]
2401bc82:	681b      	ldr	r3, [r3, #0]
2401bc84:	f422 7200 	bic.w	r2, r2, #512	; 0x200
2401bc88:	60da      	str	r2, [r3, #12]
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2401bc8a:	687b      	ldr	r3, [r7, #4]
2401bc8c:	681b      	ldr	r3, [r3, #0]
2401bc8e:	68da      	ldr	r2, [r3, #12]
2401bc90:	687b      	ldr	r3, [r7, #4]
2401bc92:	681b      	ldr	r3, [r3, #0]
2401bc94:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2401bc98:	60da      	str	r2, [r3, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2401bc9a:	687b      	ldr	r3, [r7, #4]
2401bc9c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401bc9e:	4618      	mov	r0, r3
2401bca0:	f7e8 fcde 	bl	24004660 <HAL_DMA_Abort_IT>
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2401bca4:	687b      	ldr	r3, [r7, #4]
2401bca6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401bca8:	4618      	mov	r0, r3
2401bcaa:	f7e8 fcd9 	bl	24004660 <HAL_DMA_Abort_IT>
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401bcae:	687b      	ldr	r3, [r7, #4]
2401bcb0:	681b      	ldr	r3, [r3, #0]
2401bcb2:	6a1a      	ldr	r2, [r3, #32]
2401bcb4:	f241 1311 	movw	r3, #4369	; 0x1111
2401bcb8:	4013      	ands	r3, r2
2401bcba:	2b00      	cmp	r3, #0
2401bcbc:	d10f      	bne.n	2401bcde <HAL_TIM_Encoder_Stop_DMA+0xea>
2401bcbe:	687b      	ldr	r3, [r7, #4]
2401bcc0:	681b      	ldr	r3, [r3, #0]
2401bcc2:	6a1a      	ldr	r2, [r3, #32]
2401bcc4:	f240 4344 	movw	r3, #1092	; 0x444
2401bcc8:	4013      	ands	r3, r2
2401bcca:	2b00      	cmp	r3, #0
2401bccc:	d107      	bne.n	2401bcde <HAL_TIM_Encoder_Stop_DMA+0xea>
2401bcce:	687b      	ldr	r3, [r7, #4]
2401bcd0:	681b      	ldr	r3, [r3, #0]
2401bcd2:	681a      	ldr	r2, [r3, #0]
2401bcd4:	687b      	ldr	r3, [r7, #4]
2401bcd6:	681b      	ldr	r3, [r3, #0]
2401bcd8:	f022 0201 	bic.w	r2, r2, #1
2401bcdc:	601a      	str	r2, [r3, #0]

  /* Set the TIM channel(s) state */
  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
2401bcde:	683b      	ldr	r3, [r7, #0]
2401bce0:	2b00      	cmp	r3, #0
2401bce2:	d002      	beq.n	2401bcea <HAL_TIM_Encoder_Stop_DMA+0xf6>
2401bce4:	683b      	ldr	r3, [r7, #0]
2401bce6:	2b04      	cmp	r3, #4
2401bce8:	d148      	bne.n	2401bd7c <HAL_TIM_Encoder_Stop_DMA+0x188>
  {
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401bcea:	683b      	ldr	r3, [r7, #0]
2401bcec:	2b00      	cmp	r3, #0
2401bcee:	d104      	bne.n	2401bcfa <HAL_TIM_Encoder_Stop_DMA+0x106>
2401bcf0:	687b      	ldr	r3, [r7, #4]
2401bcf2:	2201      	movs	r2, #1
2401bcf4:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401bcf8:	e023      	b.n	2401bd42 <HAL_TIM_Encoder_Stop_DMA+0x14e>
2401bcfa:	683b      	ldr	r3, [r7, #0]
2401bcfc:	2b04      	cmp	r3, #4
2401bcfe:	d104      	bne.n	2401bd0a <HAL_TIM_Encoder_Stop_DMA+0x116>
2401bd00:	687b      	ldr	r3, [r7, #4]
2401bd02:	2201      	movs	r2, #1
2401bd04:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401bd08:	e01b      	b.n	2401bd42 <HAL_TIM_Encoder_Stop_DMA+0x14e>
2401bd0a:	683b      	ldr	r3, [r7, #0]
2401bd0c:	2b08      	cmp	r3, #8
2401bd0e:	d104      	bne.n	2401bd1a <HAL_TIM_Encoder_Stop_DMA+0x126>
2401bd10:	687b      	ldr	r3, [r7, #4]
2401bd12:	2201      	movs	r2, #1
2401bd14:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401bd18:	e013      	b.n	2401bd42 <HAL_TIM_Encoder_Stop_DMA+0x14e>
2401bd1a:	683b      	ldr	r3, [r7, #0]
2401bd1c:	2b0c      	cmp	r3, #12
2401bd1e:	d104      	bne.n	2401bd2a <HAL_TIM_Encoder_Stop_DMA+0x136>
2401bd20:	687b      	ldr	r3, [r7, #4]
2401bd22:	2201      	movs	r2, #1
2401bd24:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401bd28:	e00b      	b.n	2401bd42 <HAL_TIM_Encoder_Stop_DMA+0x14e>
2401bd2a:	683b      	ldr	r3, [r7, #0]
2401bd2c:	2b10      	cmp	r3, #16
2401bd2e:	d104      	bne.n	2401bd3a <HAL_TIM_Encoder_Stop_DMA+0x146>
2401bd30:	687b      	ldr	r3, [r7, #4]
2401bd32:	2201      	movs	r2, #1
2401bd34:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
2401bd38:	e003      	b.n	2401bd42 <HAL_TIM_Encoder_Stop_DMA+0x14e>
2401bd3a:	687b      	ldr	r3, [r7, #4]
2401bd3c:	2201      	movs	r2, #1
2401bd3e:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401bd42:	683b      	ldr	r3, [r7, #0]
2401bd44:	2b00      	cmp	r3, #0
2401bd46:	d104      	bne.n	2401bd52 <HAL_TIM_Encoder_Stop_DMA+0x15e>
2401bd48:	687b      	ldr	r3, [r7, #4]
2401bd4a:	2201      	movs	r2, #1
2401bd4c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401bd50:	e024      	b.n	2401bd9c <HAL_TIM_Encoder_Stop_DMA+0x1a8>
2401bd52:	683b      	ldr	r3, [r7, #0]
2401bd54:	2b04      	cmp	r3, #4
2401bd56:	d104      	bne.n	2401bd62 <HAL_TIM_Encoder_Stop_DMA+0x16e>
2401bd58:	687b      	ldr	r3, [r7, #4]
2401bd5a:	2201      	movs	r2, #1
2401bd5c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401bd60:	e01c      	b.n	2401bd9c <HAL_TIM_Encoder_Stop_DMA+0x1a8>
2401bd62:	683b      	ldr	r3, [r7, #0]
2401bd64:	2b08      	cmp	r3, #8
2401bd66:	d104      	bne.n	2401bd72 <HAL_TIM_Encoder_Stop_DMA+0x17e>
2401bd68:	687b      	ldr	r3, [r7, #4]
2401bd6a:	2201      	movs	r2, #1
2401bd6c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401bd70:	e014      	b.n	2401bd9c <HAL_TIM_Encoder_Stop_DMA+0x1a8>
2401bd72:	687b      	ldr	r3, [r7, #4]
2401bd74:	2201      	movs	r2, #1
2401bd76:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
2401bd7a:	e00f      	b.n	2401bd9c <HAL_TIM_Encoder_Stop_DMA+0x1a8>
  }
  else
  {
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401bd7c:	687b      	ldr	r3, [r7, #4]
2401bd7e:	2201      	movs	r2, #1
2401bd80:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401bd84:	687b      	ldr	r3, [r7, #4]
2401bd86:	2201      	movs	r2, #1
2401bd88:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401bd8c:	687b      	ldr	r3, [r7, #4]
2401bd8e:	2201      	movs	r2, #1
2401bd90:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401bd94:	687b      	ldr	r3, [r7, #4]
2401bd96:	2201      	movs	r2, #1
2401bd98:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  }

  /* Return function status */
  return HAL_OK;
2401bd9c:	2300      	movs	r3, #0
}
2401bd9e:	4618      	mov	r0, r3
2401bda0:	3708      	adds	r7, #8
2401bda2:	46bd      	mov	sp, r7
2401bda4:	bd80      	pop	{r7, pc}

2401bda6 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
2401bda6:	b580      	push	{r7, lr}
2401bda8:	b082      	sub	sp, #8
2401bdaa:	af00      	add	r7, sp, #0
2401bdac:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
2401bdae:	687b      	ldr	r3, [r7, #4]
2401bdb0:	681b      	ldr	r3, [r3, #0]
2401bdb2:	691b      	ldr	r3, [r3, #16]
2401bdb4:	f003 0302 	and.w	r3, r3, #2
2401bdb8:	2b02      	cmp	r3, #2
2401bdba:	d122      	bne.n	2401be02 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
2401bdbc:	687b      	ldr	r3, [r7, #4]
2401bdbe:	681b      	ldr	r3, [r3, #0]
2401bdc0:	68db      	ldr	r3, [r3, #12]
2401bdc2:	f003 0302 	and.w	r3, r3, #2
2401bdc6:	2b02      	cmp	r3, #2
2401bdc8:	d11b      	bne.n	2401be02 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
2401bdca:	687b      	ldr	r3, [r7, #4]
2401bdcc:	681b      	ldr	r3, [r3, #0]
2401bdce:	f06f 0202 	mvn.w	r2, #2
2401bdd2:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
2401bdd4:	687b      	ldr	r3, [r7, #4]
2401bdd6:	2201      	movs	r2, #1
2401bdd8:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
2401bdda:	687b      	ldr	r3, [r7, #4]
2401bddc:	681b      	ldr	r3, [r3, #0]
2401bdde:	699b      	ldr	r3, [r3, #24]
2401bde0:	f003 0303 	and.w	r3, r3, #3
2401bde4:	2b00      	cmp	r3, #0
2401bde6:	d003      	beq.n	2401bdf0 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
2401bde8:	6878      	ldr	r0, [r7, #4]
2401bdea:	f001 fafb 	bl	2401d3e4 <HAL_TIM_IC_CaptureCallback>
2401bdee:	e005      	b.n	2401bdfc <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
2401bdf0:	6878      	ldr	r0, [r7, #4]
2401bdf2:	f001 faed 	bl	2401d3d0 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
2401bdf6:	6878      	ldr	r0, [r7, #4]
2401bdf8:	f001 fb08 	bl	2401d40c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401bdfc:	687b      	ldr	r3, [r7, #4]
2401bdfe:	2200      	movs	r2, #0
2401be00:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
2401be02:	687b      	ldr	r3, [r7, #4]
2401be04:	681b      	ldr	r3, [r3, #0]
2401be06:	691b      	ldr	r3, [r3, #16]
2401be08:	f003 0304 	and.w	r3, r3, #4
2401be0c:	2b04      	cmp	r3, #4
2401be0e:	d122      	bne.n	2401be56 <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
2401be10:	687b      	ldr	r3, [r7, #4]
2401be12:	681b      	ldr	r3, [r3, #0]
2401be14:	68db      	ldr	r3, [r3, #12]
2401be16:	f003 0304 	and.w	r3, r3, #4
2401be1a:	2b04      	cmp	r3, #4
2401be1c:	d11b      	bne.n	2401be56 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
2401be1e:	687b      	ldr	r3, [r7, #4]
2401be20:	681b      	ldr	r3, [r3, #0]
2401be22:	f06f 0204 	mvn.w	r2, #4
2401be26:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2401be28:	687b      	ldr	r3, [r7, #4]
2401be2a:	2202      	movs	r2, #2
2401be2c:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
2401be2e:	687b      	ldr	r3, [r7, #4]
2401be30:	681b      	ldr	r3, [r3, #0]
2401be32:	699b      	ldr	r3, [r3, #24]
2401be34:	f403 7340 	and.w	r3, r3, #768	; 0x300
2401be38:	2b00      	cmp	r3, #0
2401be3a:	d003      	beq.n	2401be44 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
2401be3c:	6878      	ldr	r0, [r7, #4]
2401be3e:	f001 fad1 	bl	2401d3e4 <HAL_TIM_IC_CaptureCallback>
2401be42:	e005      	b.n	2401be50 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
2401be44:	6878      	ldr	r0, [r7, #4]
2401be46:	f001 fac3 	bl	2401d3d0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
2401be4a:	6878      	ldr	r0, [r7, #4]
2401be4c:	f001 fade 	bl	2401d40c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401be50:	687b      	ldr	r3, [r7, #4]
2401be52:	2200      	movs	r2, #0
2401be54:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
2401be56:	687b      	ldr	r3, [r7, #4]
2401be58:	681b      	ldr	r3, [r3, #0]
2401be5a:	691b      	ldr	r3, [r3, #16]
2401be5c:	f003 0308 	and.w	r3, r3, #8
2401be60:	2b08      	cmp	r3, #8
2401be62:	d122      	bne.n	2401beaa <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
2401be64:	687b      	ldr	r3, [r7, #4]
2401be66:	681b      	ldr	r3, [r3, #0]
2401be68:	68db      	ldr	r3, [r3, #12]
2401be6a:	f003 0308 	and.w	r3, r3, #8
2401be6e:	2b08      	cmp	r3, #8
2401be70:	d11b      	bne.n	2401beaa <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
2401be72:	687b      	ldr	r3, [r7, #4]
2401be74:	681b      	ldr	r3, [r3, #0]
2401be76:	f06f 0208 	mvn.w	r2, #8
2401be7a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2401be7c:	687b      	ldr	r3, [r7, #4]
2401be7e:	2204      	movs	r2, #4
2401be80:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
2401be82:	687b      	ldr	r3, [r7, #4]
2401be84:	681b      	ldr	r3, [r3, #0]
2401be86:	69db      	ldr	r3, [r3, #28]
2401be88:	f003 0303 	and.w	r3, r3, #3
2401be8c:	2b00      	cmp	r3, #0
2401be8e:	d003      	beq.n	2401be98 <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
2401be90:	6878      	ldr	r0, [r7, #4]
2401be92:	f001 faa7 	bl	2401d3e4 <HAL_TIM_IC_CaptureCallback>
2401be96:	e005      	b.n	2401bea4 <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
2401be98:	6878      	ldr	r0, [r7, #4]
2401be9a:	f001 fa99 	bl	2401d3d0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
2401be9e:	6878      	ldr	r0, [r7, #4]
2401bea0:	f001 fab4 	bl	2401d40c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401bea4:	687b      	ldr	r3, [r7, #4]
2401bea6:	2200      	movs	r2, #0
2401bea8:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
2401beaa:	687b      	ldr	r3, [r7, #4]
2401beac:	681b      	ldr	r3, [r3, #0]
2401beae:	691b      	ldr	r3, [r3, #16]
2401beb0:	f003 0310 	and.w	r3, r3, #16
2401beb4:	2b10      	cmp	r3, #16
2401beb6:	d122      	bne.n	2401befe <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
2401beb8:	687b      	ldr	r3, [r7, #4]
2401beba:	681b      	ldr	r3, [r3, #0]
2401bebc:	68db      	ldr	r3, [r3, #12]
2401bebe:	f003 0310 	and.w	r3, r3, #16
2401bec2:	2b10      	cmp	r3, #16
2401bec4:	d11b      	bne.n	2401befe <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
2401bec6:	687b      	ldr	r3, [r7, #4]
2401bec8:	681b      	ldr	r3, [r3, #0]
2401beca:	f06f 0210 	mvn.w	r2, #16
2401bece:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2401bed0:	687b      	ldr	r3, [r7, #4]
2401bed2:	2208      	movs	r2, #8
2401bed4:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
2401bed6:	687b      	ldr	r3, [r7, #4]
2401bed8:	681b      	ldr	r3, [r3, #0]
2401beda:	69db      	ldr	r3, [r3, #28]
2401bedc:	f403 7340 	and.w	r3, r3, #768	; 0x300
2401bee0:	2b00      	cmp	r3, #0
2401bee2:	d003      	beq.n	2401beec <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
2401bee4:	6878      	ldr	r0, [r7, #4]
2401bee6:	f001 fa7d 	bl	2401d3e4 <HAL_TIM_IC_CaptureCallback>
2401beea:	e005      	b.n	2401bef8 <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
2401beec:	6878      	ldr	r0, [r7, #4]
2401beee:	f001 fa6f 	bl	2401d3d0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
2401bef2:	6878      	ldr	r0, [r7, #4]
2401bef4:	f001 fa8a 	bl	2401d40c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401bef8:	687b      	ldr	r3, [r7, #4]
2401befa:	2200      	movs	r2, #0
2401befc:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
2401befe:	687b      	ldr	r3, [r7, #4]
2401bf00:	681b      	ldr	r3, [r3, #0]
2401bf02:	691b      	ldr	r3, [r3, #16]
2401bf04:	f003 0301 	and.w	r3, r3, #1
2401bf08:	2b01      	cmp	r3, #1
2401bf0a:	d10e      	bne.n	2401bf2a <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
2401bf0c:	687b      	ldr	r3, [r7, #4]
2401bf0e:	681b      	ldr	r3, [r3, #0]
2401bf10:	68db      	ldr	r3, [r3, #12]
2401bf12:	f003 0301 	and.w	r3, r3, #1
2401bf16:	2b01      	cmp	r3, #1
2401bf18:	d107      	bne.n	2401bf2a <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
2401bf1a:	687b      	ldr	r3, [r7, #4]
2401bf1c:	681b      	ldr	r3, [r3, #0]
2401bf1e:	f06f 0201 	mvn.w	r2, #1
2401bf22:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
2401bf24:	6878      	ldr	r0, [r7, #4]
2401bf26:	f7e4 fee3 	bl	24000cf0 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
2401bf2a:	687b      	ldr	r3, [r7, #4]
2401bf2c:	681b      	ldr	r3, [r3, #0]
2401bf2e:	691b      	ldr	r3, [r3, #16]
2401bf30:	f003 0380 	and.w	r3, r3, #128	; 0x80
2401bf34:	2b80      	cmp	r3, #128	; 0x80
2401bf36:	d10e      	bne.n	2401bf56 <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
2401bf38:	687b      	ldr	r3, [r7, #4]
2401bf3a:	681b      	ldr	r3, [r3, #0]
2401bf3c:	68db      	ldr	r3, [r3, #12]
2401bf3e:	f003 0380 	and.w	r3, r3, #128	; 0x80
2401bf42:	2b80      	cmp	r3, #128	; 0x80
2401bf44:	d107      	bne.n	2401bf56 <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
2401bf46:	687b      	ldr	r3, [r7, #4]
2401bf48:	681b      	ldr	r3, [r3, #0]
2401bf4a:	f06f 0280 	mvn.w	r2, #128	; 0x80
2401bf4e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
2401bf50:	6878      	ldr	r0, [r7, #4]
2401bf52:	f004 fe24 	bl	24020b9e <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
2401bf56:	687b      	ldr	r3, [r7, #4]
2401bf58:	681b      	ldr	r3, [r3, #0]
2401bf5a:	691b      	ldr	r3, [r3, #16]
2401bf5c:	f403 7380 	and.w	r3, r3, #256	; 0x100
2401bf60:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401bf64:	d10e      	bne.n	2401bf84 <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
2401bf66:	687b      	ldr	r3, [r7, #4]
2401bf68:	681b      	ldr	r3, [r3, #0]
2401bf6a:	68db      	ldr	r3, [r3, #12]
2401bf6c:	f003 0380 	and.w	r3, r3, #128	; 0x80
2401bf70:	2b80      	cmp	r3, #128	; 0x80
2401bf72:	d107      	bne.n	2401bf84 <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
2401bf74:	687b      	ldr	r3, [r7, #4]
2401bf76:	681b      	ldr	r3, [r3, #0]
2401bf78:	f46f 7280 	mvn.w	r2, #256	; 0x100
2401bf7c:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
2401bf7e:	6878      	ldr	r0, [r7, #4]
2401bf80:	f004 fe17 	bl	24020bb2 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
2401bf84:	687b      	ldr	r3, [r7, #4]
2401bf86:	681b      	ldr	r3, [r3, #0]
2401bf88:	691b      	ldr	r3, [r3, #16]
2401bf8a:	f003 0340 	and.w	r3, r3, #64	; 0x40
2401bf8e:	2b40      	cmp	r3, #64	; 0x40
2401bf90:	d10e      	bne.n	2401bfb0 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
2401bf92:	687b      	ldr	r3, [r7, #4]
2401bf94:	681b      	ldr	r3, [r3, #0]
2401bf96:	68db      	ldr	r3, [r3, #12]
2401bf98:	f003 0340 	and.w	r3, r3, #64	; 0x40
2401bf9c:	2b40      	cmp	r3, #64	; 0x40
2401bf9e:	d107      	bne.n	2401bfb0 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
2401bfa0:	687b      	ldr	r3, [r7, #4]
2401bfa2:	681b      	ldr	r3, [r3, #0]
2401bfa4:	f06f 0240 	mvn.w	r2, #64	; 0x40
2401bfa8:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
2401bfaa:	6878      	ldr	r0, [r7, #4]
2401bfac:	f001 fa42 	bl	2401d434 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
2401bfb0:	687b      	ldr	r3, [r7, #4]
2401bfb2:	681b      	ldr	r3, [r3, #0]
2401bfb4:	691b      	ldr	r3, [r3, #16]
2401bfb6:	f003 0320 	and.w	r3, r3, #32
2401bfba:	2b20      	cmp	r3, #32
2401bfbc:	d10e      	bne.n	2401bfdc <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
2401bfbe:	687b      	ldr	r3, [r7, #4]
2401bfc0:	681b      	ldr	r3, [r3, #0]
2401bfc2:	68db      	ldr	r3, [r3, #12]
2401bfc4:	f003 0320 	and.w	r3, r3, #32
2401bfc8:	2b20      	cmp	r3, #32
2401bfca:	d107      	bne.n	2401bfdc <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
2401bfcc:	687b      	ldr	r3, [r7, #4]
2401bfce:	681b      	ldr	r3, [r3, #0]
2401bfd0:	f06f 0220 	mvn.w	r2, #32
2401bfd4:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
2401bfd6:	6878      	ldr	r0, [r7, #4]
2401bfd8:	f004 fdcd 	bl	24020b76 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
2401bfdc:	bf00      	nop
2401bfde:	3708      	adds	r7, #8
2401bfe0:	46bd      	mov	sp, r7
2401bfe2:	bd80      	pop	{r7, pc}

2401bfe4 <HAL_TIM_OC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
                                           const TIM_OC_InitTypeDef *sConfig,
                                           uint32_t Channel)
{
2401bfe4:	b580      	push	{r7, lr}
2401bfe6:	b086      	sub	sp, #24
2401bfe8:	af00      	add	r7, sp, #0
2401bfea:	60f8      	str	r0, [r7, #12]
2401bfec:	60b9      	str	r1, [r7, #8]
2401bfee:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2401bff0:	2300      	movs	r3, #0
2401bff2:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));

  /* Process Locked */
  __HAL_LOCK(htim);
2401bff4:	68fb      	ldr	r3, [r7, #12]
2401bff6:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401bffa:	2b01      	cmp	r3, #1
2401bffc:	d101      	bne.n	2401c002 <HAL_TIM_OC_ConfigChannel+0x1e>
2401bffe:	2302      	movs	r3, #2
2401c000:	e066      	b.n	2401c0d0 <HAL_TIM_OC_ConfigChannel+0xec>
2401c002:	68fb      	ldr	r3, [r7, #12]
2401c004:	2201      	movs	r2, #1
2401c006:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  switch (Channel)
2401c00a:	687b      	ldr	r3, [r7, #4]
2401c00c:	2b14      	cmp	r3, #20
2401c00e:	d857      	bhi.n	2401c0c0 <HAL_TIM_OC_ConfigChannel+0xdc>
2401c010:	a201      	add	r2, pc, #4	; (adr r2, 2401c018 <HAL_TIM_OC_ConfigChannel+0x34>)
2401c012:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401c016:	bf00      	nop
2401c018:	2401c06d 	.word	0x2401c06d
2401c01c:	2401c0c1 	.word	0x2401c0c1
2401c020:	2401c0c1 	.word	0x2401c0c1
2401c024:	2401c0c1 	.word	0x2401c0c1
2401c028:	2401c07b 	.word	0x2401c07b
2401c02c:	2401c0c1 	.word	0x2401c0c1
2401c030:	2401c0c1 	.word	0x2401c0c1
2401c034:	2401c0c1 	.word	0x2401c0c1
2401c038:	2401c089 	.word	0x2401c089
2401c03c:	2401c0c1 	.word	0x2401c0c1
2401c040:	2401c0c1 	.word	0x2401c0c1
2401c044:	2401c0c1 	.word	0x2401c0c1
2401c048:	2401c097 	.word	0x2401c097
2401c04c:	2401c0c1 	.word	0x2401c0c1
2401c050:	2401c0c1 	.word	0x2401c0c1
2401c054:	2401c0c1 	.word	0x2401c0c1
2401c058:	2401c0a5 	.word	0x2401c0a5
2401c05c:	2401c0c1 	.word	0x2401c0c1
2401c060:	2401c0c1 	.word	0x2401c0c1
2401c064:	2401c0c1 	.word	0x2401c0c1
2401c068:	2401c0b3 	.word	0x2401c0b3
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 1 in Output Compare */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
2401c06c:	68fb      	ldr	r3, [r7, #12]
2401c06e:	681b      	ldr	r3, [r3, #0]
2401c070:	68b9      	ldr	r1, [r7, #8]
2401c072:	4618      	mov	r0, r3
2401c074:	f001 fcf0 	bl	2401da58 <TIM_OC1_SetConfig>
      break;
2401c078:	e025      	b.n	2401c0c6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 2 in Output Compare */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
2401c07a:	68fb      	ldr	r3, [r7, #12]
2401c07c:	681b      	ldr	r3, [r3, #0]
2401c07e:	68b9      	ldr	r1, [r7, #8]
2401c080:	4618      	mov	r0, r3
2401c082:	f001 fd79 	bl	2401db78 <TIM_OC2_SetConfig>
      break;
2401c086:	e01e      	b.n	2401c0c6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 3 in Output Compare */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
2401c088:	68fb      	ldr	r3, [r7, #12]
2401c08a:	681b      	ldr	r3, [r3, #0]
2401c08c:	68b9      	ldr	r1, [r7, #8]
2401c08e:	4618      	mov	r0, r3
2401c090:	f001 fdfc 	bl	2401dc8c <TIM_OC3_SetConfig>
      break;
2401c094:	e017      	b.n	2401c0c6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 4 in Output Compare */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
2401c096:	68fb      	ldr	r3, [r7, #12]
2401c098:	681b      	ldr	r3, [r3, #0]
2401c09a:	68b9      	ldr	r1, [r7, #8]
2401c09c:	4618      	mov	r0, r3
2401c09e:	f001 fe7d 	bl	2401dd9c <TIM_OC4_SetConfig>
      break;
2401c0a2:	e010      	b.n	2401c0c6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 5 in Output Compare */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
2401c0a4:	68fb      	ldr	r3, [r7, #12]
2401c0a6:	681b      	ldr	r3, [r3, #0]
2401c0a8:	68b9      	ldr	r1, [r7, #8]
2401c0aa:	4618      	mov	r0, r3
2401c0ac:	f001 fee0 	bl	2401de70 <TIM_OC5_SetConfig>
      break;
2401c0b0:	e009      	b.n	2401c0c6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 6 in Output Compare */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
2401c0b2:	68fb      	ldr	r3, [r7, #12]
2401c0b4:	681b      	ldr	r3, [r3, #0]
2401c0b6:	68b9      	ldr	r1, [r7, #8]
2401c0b8:	4618      	mov	r0, r3
2401c0ba:	f001 ff3d 	bl	2401df38 <TIM_OC6_SetConfig>
      break;
2401c0be:	e002      	b.n	2401c0c6 <HAL_TIM_OC_ConfigChannel+0xe2>
    }

    default:
      status = HAL_ERROR;
2401c0c0:	2301      	movs	r3, #1
2401c0c2:	75fb      	strb	r3, [r7, #23]
      break;
2401c0c4:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
2401c0c6:	68fb      	ldr	r3, [r7, #12]
2401c0c8:	2200      	movs	r2, #0
2401c0ca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2401c0ce:	7dfb      	ldrb	r3, [r7, #23]
}
2401c0d0:	4618      	mov	r0, r3
2401c0d2:	3718      	adds	r7, #24
2401c0d4:	46bd      	mov	sp, r7
2401c0d6:	bd80      	pop	{r7, pc}

2401c0d8 <HAL_TIM_IC_ConfigChannel>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, const TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
{
2401c0d8:	b580      	push	{r7, lr}
2401c0da:	b086      	sub	sp, #24
2401c0dc:	af00      	add	r7, sp, #0
2401c0de:	60f8      	str	r0, [r7, #12]
2401c0e0:	60b9      	str	r1, [r7, #8]
2401c0e2:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2401c0e4:	2300      	movs	r3, #0
2401c0e6:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));

  /* Process Locked */
  __HAL_LOCK(htim);
2401c0e8:	68fb      	ldr	r3, [r7, #12]
2401c0ea:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401c0ee:	2b01      	cmp	r3, #1
2401c0f0:	d101      	bne.n	2401c0f6 <HAL_TIM_IC_ConfigChannel+0x1e>
2401c0f2:	2302      	movs	r3, #2
2401c0f4:	e088      	b.n	2401c208 <HAL_TIM_IC_ConfigChannel+0x130>
2401c0f6:	68fb      	ldr	r3, [r7, #12]
2401c0f8:	2201      	movs	r2, #1
2401c0fa:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if (Channel == TIM_CHANNEL_1)
2401c0fe:	687b      	ldr	r3, [r7, #4]
2401c100:	2b00      	cmp	r3, #0
2401c102:	d11b      	bne.n	2401c13c <HAL_TIM_IC_ConfigChannel+0x64>
  {
    /* TI1 Configuration */
    TIM_TI1_SetConfig(htim->Instance,
2401c104:	68fb      	ldr	r3, [r7, #12]
2401c106:	6818      	ldr	r0, [r3, #0]
2401c108:	68bb      	ldr	r3, [r7, #8]
2401c10a:	6819      	ldr	r1, [r3, #0]
2401c10c:	68bb      	ldr	r3, [r7, #8]
2401c10e:	685a      	ldr	r2, [r3, #4]
2401c110:	68bb      	ldr	r3, [r7, #8]
2401c112:	68db      	ldr	r3, [r3, #12]
2401c114:	f002 f860 	bl	2401e1d8 <TIM_TI1_SetConfig>
                      sConfig->ICPolarity,
                      sConfig->ICSelection,
                      sConfig->ICFilter);

    /* Reset the IC1PSC Bits */
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
2401c118:	68fb      	ldr	r3, [r7, #12]
2401c11a:	681b      	ldr	r3, [r3, #0]
2401c11c:	699a      	ldr	r2, [r3, #24]
2401c11e:	68fb      	ldr	r3, [r7, #12]
2401c120:	681b      	ldr	r3, [r3, #0]
2401c122:	f022 020c 	bic.w	r2, r2, #12
2401c126:	619a      	str	r2, [r3, #24]

    /* Set the IC1PSC value */
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
2401c128:	68fb      	ldr	r3, [r7, #12]
2401c12a:	681b      	ldr	r3, [r3, #0]
2401c12c:	6999      	ldr	r1, [r3, #24]
2401c12e:	68bb      	ldr	r3, [r7, #8]
2401c130:	689a      	ldr	r2, [r3, #8]
2401c132:	68fb      	ldr	r3, [r7, #12]
2401c134:	681b      	ldr	r3, [r3, #0]
2401c136:	430a      	orrs	r2, r1
2401c138:	619a      	str	r2, [r3, #24]
2401c13a:	e060      	b.n	2401c1fe <HAL_TIM_IC_ConfigChannel+0x126>
  }
  else if (Channel == TIM_CHANNEL_2)
2401c13c:	687b      	ldr	r3, [r7, #4]
2401c13e:	2b04      	cmp	r3, #4
2401c140:	d11c      	bne.n	2401c17c <HAL_TIM_IC_ConfigChannel+0xa4>
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

    TIM_TI2_SetConfig(htim->Instance,
2401c142:	68fb      	ldr	r3, [r7, #12]
2401c144:	6818      	ldr	r0, [r3, #0]
2401c146:	68bb      	ldr	r3, [r7, #8]
2401c148:	6819      	ldr	r1, [r3, #0]
2401c14a:	68bb      	ldr	r3, [r7, #8]
2401c14c:	685a      	ldr	r2, [r3, #4]
2401c14e:	68bb      	ldr	r3, [r7, #8]
2401c150:	68db      	ldr	r3, [r3, #12]
2401c152:	f002 f8e4 	bl	2401e31e <TIM_TI2_SetConfig>
                      sConfig->ICPolarity,
                      sConfig->ICSelection,
                      sConfig->ICFilter);

    /* Reset the IC2PSC Bits */
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
2401c156:	68fb      	ldr	r3, [r7, #12]
2401c158:	681b      	ldr	r3, [r3, #0]
2401c15a:	699a      	ldr	r2, [r3, #24]
2401c15c:	68fb      	ldr	r3, [r7, #12]
2401c15e:	681b      	ldr	r3, [r3, #0]
2401c160:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
2401c164:	619a      	str	r2, [r3, #24]

    /* Set the IC2PSC value */
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
2401c166:	68fb      	ldr	r3, [r7, #12]
2401c168:	681b      	ldr	r3, [r3, #0]
2401c16a:	6999      	ldr	r1, [r3, #24]
2401c16c:	68bb      	ldr	r3, [r7, #8]
2401c16e:	689b      	ldr	r3, [r3, #8]
2401c170:	021a      	lsls	r2, r3, #8
2401c172:	68fb      	ldr	r3, [r7, #12]
2401c174:	681b      	ldr	r3, [r3, #0]
2401c176:	430a      	orrs	r2, r1
2401c178:	619a      	str	r2, [r3, #24]
2401c17a:	e040      	b.n	2401c1fe <HAL_TIM_IC_ConfigChannel+0x126>
  }
  else if (Channel == TIM_CHANNEL_3)
2401c17c:	687b      	ldr	r3, [r7, #4]
2401c17e:	2b08      	cmp	r3, #8
2401c180:	d11b      	bne.n	2401c1ba <HAL_TIM_IC_ConfigChannel+0xe2>
  {
    /* TI3 Configuration */
    assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

    TIM_TI3_SetConfig(htim->Instance,
2401c182:	68fb      	ldr	r3, [r7, #12]
2401c184:	6818      	ldr	r0, [r3, #0]
2401c186:	68bb      	ldr	r3, [r7, #8]
2401c188:	6819      	ldr	r1, [r3, #0]
2401c18a:	68bb      	ldr	r3, [r7, #8]
2401c18c:	685a      	ldr	r2, [r3, #4]
2401c18e:	68bb      	ldr	r3, [r7, #8]
2401c190:	68db      	ldr	r3, [r3, #12]
2401c192:	f002 f931 	bl	2401e3f8 <TIM_TI3_SetConfig>
                      sConfig->ICPolarity,
                      sConfig->ICSelection,
                      sConfig->ICFilter);

    /* Reset the IC3PSC Bits */
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
2401c196:	68fb      	ldr	r3, [r7, #12]
2401c198:	681b      	ldr	r3, [r3, #0]
2401c19a:	69da      	ldr	r2, [r3, #28]
2401c19c:	68fb      	ldr	r3, [r7, #12]
2401c19e:	681b      	ldr	r3, [r3, #0]
2401c1a0:	f022 020c 	bic.w	r2, r2, #12
2401c1a4:	61da      	str	r2, [r3, #28]

    /* Set the IC3PSC value */
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
2401c1a6:	68fb      	ldr	r3, [r7, #12]
2401c1a8:	681b      	ldr	r3, [r3, #0]
2401c1aa:	69d9      	ldr	r1, [r3, #28]
2401c1ac:	68bb      	ldr	r3, [r7, #8]
2401c1ae:	689a      	ldr	r2, [r3, #8]
2401c1b0:	68fb      	ldr	r3, [r7, #12]
2401c1b2:	681b      	ldr	r3, [r3, #0]
2401c1b4:	430a      	orrs	r2, r1
2401c1b6:	61da      	str	r2, [r3, #28]
2401c1b8:	e021      	b.n	2401c1fe <HAL_TIM_IC_ConfigChannel+0x126>
  }
  else if (Channel == TIM_CHANNEL_4)
2401c1ba:	687b      	ldr	r3, [r7, #4]
2401c1bc:	2b0c      	cmp	r3, #12
2401c1be:	d11c      	bne.n	2401c1fa <HAL_TIM_IC_ConfigChannel+0x122>
  {
    /* TI4 Configuration */
    assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

    TIM_TI4_SetConfig(htim->Instance,
2401c1c0:	68fb      	ldr	r3, [r7, #12]
2401c1c2:	6818      	ldr	r0, [r3, #0]
2401c1c4:	68bb      	ldr	r3, [r7, #8]
2401c1c6:	6819      	ldr	r1, [r3, #0]
2401c1c8:	68bb      	ldr	r3, [r7, #8]
2401c1ca:	685a      	ldr	r2, [r3, #4]
2401c1cc:	68bb      	ldr	r3, [r7, #8]
2401c1ce:	68db      	ldr	r3, [r3, #12]
2401c1d0:	f002 f94e 	bl	2401e470 <TIM_TI4_SetConfig>
                      sConfig->ICPolarity,
                      sConfig->ICSelection,
                      sConfig->ICFilter);

    /* Reset the IC4PSC Bits */
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
2401c1d4:	68fb      	ldr	r3, [r7, #12]
2401c1d6:	681b      	ldr	r3, [r3, #0]
2401c1d8:	69da      	ldr	r2, [r3, #28]
2401c1da:	68fb      	ldr	r3, [r7, #12]
2401c1dc:	681b      	ldr	r3, [r3, #0]
2401c1de:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
2401c1e2:	61da      	str	r2, [r3, #28]

    /* Set the IC4PSC value */
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
2401c1e4:	68fb      	ldr	r3, [r7, #12]
2401c1e6:	681b      	ldr	r3, [r3, #0]
2401c1e8:	69d9      	ldr	r1, [r3, #28]
2401c1ea:	68bb      	ldr	r3, [r7, #8]
2401c1ec:	689b      	ldr	r3, [r3, #8]
2401c1ee:	021a      	lsls	r2, r3, #8
2401c1f0:	68fb      	ldr	r3, [r7, #12]
2401c1f2:	681b      	ldr	r3, [r3, #0]
2401c1f4:	430a      	orrs	r2, r1
2401c1f6:	61da      	str	r2, [r3, #28]
2401c1f8:	e001      	b.n	2401c1fe <HAL_TIM_IC_ConfigChannel+0x126>
  }
  else
  {
    status = HAL_ERROR;
2401c1fa:	2301      	movs	r3, #1
2401c1fc:	75fb      	strb	r3, [r7, #23]
  }

  __HAL_UNLOCK(htim);
2401c1fe:	68fb      	ldr	r3, [r7, #12]
2401c200:	2200      	movs	r2, #0
2401c202:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2401c206:	7dfb      	ldrb	r3, [r7, #23]
}
2401c208:	4618      	mov	r0, r3
2401c20a:	3718      	adds	r7, #24
2401c20c:	46bd      	mov	sp, r7
2401c20e:	bd80      	pop	{r7, pc}

2401c210 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            const TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
2401c210:	b580      	push	{r7, lr}
2401c212:	b086      	sub	sp, #24
2401c214:	af00      	add	r7, sp, #0
2401c216:	60f8      	str	r0, [r7, #12]
2401c218:	60b9      	str	r1, [r7, #8]
2401c21a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2401c21c:	2300      	movs	r3, #0
2401c21e:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
2401c220:	68fb      	ldr	r3, [r7, #12]
2401c222:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401c226:	2b01      	cmp	r3, #1
2401c228:	d101      	bne.n	2401c22e <HAL_TIM_PWM_ConfigChannel+0x1e>
2401c22a:	2302      	movs	r3, #2
2401c22c:	e0ff      	b.n	2401c42e <HAL_TIM_PWM_ConfigChannel+0x21e>
2401c22e:	68fb      	ldr	r3, [r7, #12]
2401c230:	2201      	movs	r2, #1
2401c232:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  switch (Channel)
2401c236:	687b      	ldr	r3, [r7, #4]
2401c238:	2b14      	cmp	r3, #20
2401c23a:	f200 80f0 	bhi.w	2401c41e <HAL_TIM_PWM_ConfigChannel+0x20e>
2401c23e:	a201      	add	r2, pc, #4	; (adr r2, 2401c244 <HAL_TIM_PWM_ConfigChannel+0x34>)
2401c240:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401c244:	2401c299 	.word	0x2401c299
2401c248:	2401c41f 	.word	0x2401c41f
2401c24c:	2401c41f 	.word	0x2401c41f
2401c250:	2401c41f 	.word	0x2401c41f
2401c254:	2401c2d9 	.word	0x2401c2d9
2401c258:	2401c41f 	.word	0x2401c41f
2401c25c:	2401c41f 	.word	0x2401c41f
2401c260:	2401c41f 	.word	0x2401c41f
2401c264:	2401c31b 	.word	0x2401c31b
2401c268:	2401c41f 	.word	0x2401c41f
2401c26c:	2401c41f 	.word	0x2401c41f
2401c270:	2401c41f 	.word	0x2401c41f
2401c274:	2401c35b 	.word	0x2401c35b
2401c278:	2401c41f 	.word	0x2401c41f
2401c27c:	2401c41f 	.word	0x2401c41f
2401c280:	2401c41f 	.word	0x2401c41f
2401c284:	2401c39d 	.word	0x2401c39d
2401c288:	2401c41f 	.word	0x2401c41f
2401c28c:	2401c41f 	.word	0x2401c41f
2401c290:	2401c41f 	.word	0x2401c41f
2401c294:	2401c3dd 	.word	0x2401c3dd
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
2401c298:	68fb      	ldr	r3, [r7, #12]
2401c29a:	681b      	ldr	r3, [r3, #0]
2401c29c:	68b9      	ldr	r1, [r7, #8]
2401c29e:	4618      	mov	r0, r3
2401c2a0:	f001 fbda 	bl	2401da58 <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
2401c2a4:	68fb      	ldr	r3, [r7, #12]
2401c2a6:	681b      	ldr	r3, [r3, #0]
2401c2a8:	699a      	ldr	r2, [r3, #24]
2401c2aa:	68fb      	ldr	r3, [r7, #12]
2401c2ac:	681b      	ldr	r3, [r3, #0]
2401c2ae:	f042 0208 	orr.w	r2, r2, #8
2401c2b2:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
2401c2b4:	68fb      	ldr	r3, [r7, #12]
2401c2b6:	681b      	ldr	r3, [r3, #0]
2401c2b8:	699a      	ldr	r2, [r3, #24]
2401c2ba:	68fb      	ldr	r3, [r7, #12]
2401c2bc:	681b      	ldr	r3, [r3, #0]
2401c2be:	f022 0204 	bic.w	r2, r2, #4
2401c2c2:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
2401c2c4:	68fb      	ldr	r3, [r7, #12]
2401c2c6:	681b      	ldr	r3, [r3, #0]
2401c2c8:	6999      	ldr	r1, [r3, #24]
2401c2ca:	68bb      	ldr	r3, [r7, #8]
2401c2cc:	691a      	ldr	r2, [r3, #16]
2401c2ce:	68fb      	ldr	r3, [r7, #12]
2401c2d0:	681b      	ldr	r3, [r3, #0]
2401c2d2:	430a      	orrs	r2, r1
2401c2d4:	619a      	str	r2, [r3, #24]
      break;
2401c2d6:	e0a5      	b.n	2401c424 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
2401c2d8:	68fb      	ldr	r3, [r7, #12]
2401c2da:	681b      	ldr	r3, [r3, #0]
2401c2dc:	68b9      	ldr	r1, [r7, #8]
2401c2de:	4618      	mov	r0, r3
2401c2e0:	f001 fc4a 	bl	2401db78 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
2401c2e4:	68fb      	ldr	r3, [r7, #12]
2401c2e6:	681b      	ldr	r3, [r3, #0]
2401c2e8:	699a      	ldr	r2, [r3, #24]
2401c2ea:	68fb      	ldr	r3, [r7, #12]
2401c2ec:	681b      	ldr	r3, [r3, #0]
2401c2ee:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
2401c2f2:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
2401c2f4:	68fb      	ldr	r3, [r7, #12]
2401c2f6:	681b      	ldr	r3, [r3, #0]
2401c2f8:	699a      	ldr	r2, [r3, #24]
2401c2fa:	68fb      	ldr	r3, [r7, #12]
2401c2fc:	681b      	ldr	r3, [r3, #0]
2401c2fe:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2401c302:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
2401c304:	68fb      	ldr	r3, [r7, #12]
2401c306:	681b      	ldr	r3, [r3, #0]
2401c308:	6999      	ldr	r1, [r3, #24]
2401c30a:	68bb      	ldr	r3, [r7, #8]
2401c30c:	691b      	ldr	r3, [r3, #16]
2401c30e:	021a      	lsls	r2, r3, #8
2401c310:	68fb      	ldr	r3, [r7, #12]
2401c312:	681b      	ldr	r3, [r3, #0]
2401c314:	430a      	orrs	r2, r1
2401c316:	619a      	str	r2, [r3, #24]
      break;
2401c318:	e084      	b.n	2401c424 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
2401c31a:	68fb      	ldr	r3, [r7, #12]
2401c31c:	681b      	ldr	r3, [r3, #0]
2401c31e:	68b9      	ldr	r1, [r7, #8]
2401c320:	4618      	mov	r0, r3
2401c322:	f001 fcb3 	bl	2401dc8c <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
2401c326:	68fb      	ldr	r3, [r7, #12]
2401c328:	681b      	ldr	r3, [r3, #0]
2401c32a:	69da      	ldr	r2, [r3, #28]
2401c32c:	68fb      	ldr	r3, [r7, #12]
2401c32e:	681b      	ldr	r3, [r3, #0]
2401c330:	f042 0208 	orr.w	r2, r2, #8
2401c334:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
2401c336:	68fb      	ldr	r3, [r7, #12]
2401c338:	681b      	ldr	r3, [r3, #0]
2401c33a:	69da      	ldr	r2, [r3, #28]
2401c33c:	68fb      	ldr	r3, [r7, #12]
2401c33e:	681b      	ldr	r3, [r3, #0]
2401c340:	f022 0204 	bic.w	r2, r2, #4
2401c344:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
2401c346:	68fb      	ldr	r3, [r7, #12]
2401c348:	681b      	ldr	r3, [r3, #0]
2401c34a:	69d9      	ldr	r1, [r3, #28]
2401c34c:	68bb      	ldr	r3, [r7, #8]
2401c34e:	691a      	ldr	r2, [r3, #16]
2401c350:	68fb      	ldr	r3, [r7, #12]
2401c352:	681b      	ldr	r3, [r3, #0]
2401c354:	430a      	orrs	r2, r1
2401c356:	61da      	str	r2, [r3, #28]
      break;
2401c358:	e064      	b.n	2401c424 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
2401c35a:	68fb      	ldr	r3, [r7, #12]
2401c35c:	681b      	ldr	r3, [r3, #0]
2401c35e:	68b9      	ldr	r1, [r7, #8]
2401c360:	4618      	mov	r0, r3
2401c362:	f001 fd1b 	bl	2401dd9c <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
2401c366:	68fb      	ldr	r3, [r7, #12]
2401c368:	681b      	ldr	r3, [r3, #0]
2401c36a:	69da      	ldr	r2, [r3, #28]
2401c36c:	68fb      	ldr	r3, [r7, #12]
2401c36e:	681b      	ldr	r3, [r3, #0]
2401c370:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
2401c374:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
2401c376:	68fb      	ldr	r3, [r7, #12]
2401c378:	681b      	ldr	r3, [r3, #0]
2401c37a:	69da      	ldr	r2, [r3, #28]
2401c37c:	68fb      	ldr	r3, [r7, #12]
2401c37e:	681b      	ldr	r3, [r3, #0]
2401c380:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2401c384:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
2401c386:	68fb      	ldr	r3, [r7, #12]
2401c388:	681b      	ldr	r3, [r3, #0]
2401c38a:	69d9      	ldr	r1, [r3, #28]
2401c38c:	68bb      	ldr	r3, [r7, #8]
2401c38e:	691b      	ldr	r3, [r3, #16]
2401c390:	021a      	lsls	r2, r3, #8
2401c392:	68fb      	ldr	r3, [r7, #12]
2401c394:	681b      	ldr	r3, [r3, #0]
2401c396:	430a      	orrs	r2, r1
2401c398:	61da      	str	r2, [r3, #28]
      break;
2401c39a:	e043      	b.n	2401c424 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
2401c39c:	68fb      	ldr	r3, [r7, #12]
2401c39e:	681b      	ldr	r3, [r3, #0]
2401c3a0:	68b9      	ldr	r1, [r7, #8]
2401c3a2:	4618      	mov	r0, r3
2401c3a4:	f001 fd64 	bl	2401de70 <TIM_OC5_SetConfig>

      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
2401c3a8:	68fb      	ldr	r3, [r7, #12]
2401c3aa:	681b      	ldr	r3, [r3, #0]
2401c3ac:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2401c3ae:	68fb      	ldr	r3, [r7, #12]
2401c3b0:	681b      	ldr	r3, [r3, #0]
2401c3b2:	f042 0208 	orr.w	r2, r2, #8
2401c3b6:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
2401c3b8:	68fb      	ldr	r3, [r7, #12]
2401c3ba:	681b      	ldr	r3, [r3, #0]
2401c3bc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2401c3be:	68fb      	ldr	r3, [r7, #12]
2401c3c0:	681b      	ldr	r3, [r3, #0]
2401c3c2:	f022 0204 	bic.w	r2, r2, #4
2401c3c6:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
2401c3c8:	68fb      	ldr	r3, [r7, #12]
2401c3ca:	681b      	ldr	r3, [r3, #0]
2401c3cc:	6d59      	ldr	r1, [r3, #84]	; 0x54
2401c3ce:	68bb      	ldr	r3, [r7, #8]
2401c3d0:	691a      	ldr	r2, [r3, #16]
2401c3d2:	68fb      	ldr	r3, [r7, #12]
2401c3d4:	681b      	ldr	r3, [r3, #0]
2401c3d6:	430a      	orrs	r2, r1
2401c3d8:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2401c3da:	e023      	b.n	2401c424 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the Channel 6 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
2401c3dc:	68fb      	ldr	r3, [r7, #12]
2401c3de:	681b      	ldr	r3, [r3, #0]
2401c3e0:	68b9      	ldr	r1, [r7, #8]
2401c3e2:	4618      	mov	r0, r3
2401c3e4:	f001 fda8 	bl	2401df38 <TIM_OC6_SetConfig>

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
2401c3e8:	68fb      	ldr	r3, [r7, #12]
2401c3ea:	681b      	ldr	r3, [r3, #0]
2401c3ec:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2401c3ee:	68fb      	ldr	r3, [r7, #12]
2401c3f0:	681b      	ldr	r3, [r3, #0]
2401c3f2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
2401c3f6:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
2401c3f8:	68fb      	ldr	r3, [r7, #12]
2401c3fa:	681b      	ldr	r3, [r3, #0]
2401c3fc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2401c3fe:	68fb      	ldr	r3, [r7, #12]
2401c400:	681b      	ldr	r3, [r3, #0]
2401c402:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2401c406:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
2401c408:	68fb      	ldr	r3, [r7, #12]
2401c40a:	681b      	ldr	r3, [r3, #0]
2401c40c:	6d59      	ldr	r1, [r3, #84]	; 0x54
2401c40e:	68bb      	ldr	r3, [r7, #8]
2401c410:	691b      	ldr	r3, [r3, #16]
2401c412:	021a      	lsls	r2, r3, #8
2401c414:	68fb      	ldr	r3, [r7, #12]
2401c416:	681b      	ldr	r3, [r3, #0]
2401c418:	430a      	orrs	r2, r1
2401c41a:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2401c41c:	e002      	b.n	2401c424 <HAL_TIM_PWM_ConfigChannel+0x214>
    }

    default:
      status = HAL_ERROR;
2401c41e:	2301      	movs	r3, #1
2401c420:	75fb      	strb	r3, [r7, #23]
      break;
2401c422:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
2401c424:	68fb      	ldr	r3, [r7, #12]
2401c426:	2200      	movs	r2, #0
2401c428:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2401c42c:	7dfb      	ldrb	r3, [r7, #23]
}
2401c42e:	4618      	mov	r0, r3
2401c430:	3718      	adds	r7, #24
2401c432:	46bd      	mov	sp, r7
2401c434:	bd80      	pop	{r7, pc}
2401c436:	bf00      	nop

2401c438 <HAL_TIM_OnePulse_ConfigChannel>:
  *        without taking in account the comparison.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,
                                                 uint32_t OutputChannel,  uint32_t InputChannel)
{
2401c438:	b580      	push	{r7, lr}
2401c43a:	b08c      	sub	sp, #48	; 0x30
2401c43c:	af00      	add	r7, sp, #0
2401c43e:	60f8      	str	r0, [r7, #12]
2401c440:	60b9      	str	r1, [r7, #8]
2401c442:	607a      	str	r2, [r7, #4]
2401c444:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401c446:	2300      	movs	r3, #0
2401c448:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

  /* Check the parameters */
  assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
  assert_param(IS_TIM_OPM_CHANNELS(InputChannel));

  if (OutputChannel != InputChannel)
2401c44c:	687a      	ldr	r2, [r7, #4]
2401c44e:	683b      	ldr	r3, [r7, #0]
2401c450:	429a      	cmp	r2, r3
2401c452:	f000 80bf 	beq.w	2401c5d4 <HAL_TIM_OnePulse_ConfigChannel+0x19c>
  {
    /* Process Locked */
    __HAL_LOCK(htim);
2401c456:	68fb      	ldr	r3, [r7, #12]
2401c458:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401c45c:	2b01      	cmp	r3, #1
2401c45e:	d101      	bne.n	2401c464 <HAL_TIM_OnePulse_ConfigChannel+0x2c>
2401c460:	2302      	movs	r3, #2
2401c462:	e0b8      	b.n	2401c5d6 <HAL_TIM_OnePulse_ConfigChannel+0x19e>
2401c464:	68fb      	ldr	r3, [r7, #12]
2401c466:	2201      	movs	r2, #1
2401c468:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    htim->State = HAL_TIM_STATE_BUSY;
2401c46c:	68fb      	ldr	r3, [r7, #12]
2401c46e:	2202      	movs	r2, #2
2401c470:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Extract the Output compare configuration from sConfig structure */
    temp1.OCMode = sConfig->OCMode;
2401c474:	68bb      	ldr	r3, [r7, #8]
2401c476:	681b      	ldr	r3, [r3, #0]
2401c478:	613b      	str	r3, [r7, #16]
    temp1.Pulse = sConfig->Pulse;
2401c47a:	68bb      	ldr	r3, [r7, #8]
2401c47c:	685b      	ldr	r3, [r3, #4]
2401c47e:	617b      	str	r3, [r7, #20]
    temp1.OCPolarity = sConfig->OCPolarity;
2401c480:	68bb      	ldr	r3, [r7, #8]
2401c482:	689b      	ldr	r3, [r3, #8]
2401c484:	61bb      	str	r3, [r7, #24]
    temp1.OCNPolarity = sConfig->OCNPolarity;
2401c486:	68bb      	ldr	r3, [r7, #8]
2401c488:	68db      	ldr	r3, [r3, #12]
2401c48a:	61fb      	str	r3, [r7, #28]
    temp1.OCIdleState = sConfig->OCIdleState;
2401c48c:	68bb      	ldr	r3, [r7, #8]
2401c48e:	691b      	ldr	r3, [r3, #16]
2401c490:	627b      	str	r3, [r7, #36]	; 0x24
    temp1.OCNIdleState = sConfig->OCNIdleState;
2401c492:	68bb      	ldr	r3, [r7, #8]
2401c494:	695b      	ldr	r3, [r3, #20]
2401c496:	62bb      	str	r3, [r7, #40]	; 0x28

    switch (OutputChannel)
2401c498:	687b      	ldr	r3, [r7, #4]
2401c49a:	2b00      	cmp	r3, #0
2401c49c:	d003      	beq.n	2401c4a6 <HAL_TIM_OnePulse_ConfigChannel+0x6e>
2401c49e:	687b      	ldr	r3, [r7, #4]
2401c4a0:	2b04      	cmp	r3, #4
2401c4a2:	d009      	beq.n	2401c4b8 <HAL_TIM_OnePulse_ConfigChannel+0x80>
2401c4a4:	e011      	b.n	2401c4ca <HAL_TIM_OnePulse_ConfigChannel+0x92>
    {
      case TIM_CHANNEL_1:
      {
        assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

        TIM_OC1_SetConfig(htim->Instance, &temp1);
2401c4a6:	68fb      	ldr	r3, [r7, #12]
2401c4a8:	681b      	ldr	r3, [r3, #0]
2401c4aa:	f107 0210 	add.w	r2, r7, #16
2401c4ae:	4611      	mov	r1, r2
2401c4b0:	4618      	mov	r0, r3
2401c4b2:	f001 fad1 	bl	2401da58 <TIM_OC1_SetConfig>
        break;
2401c4b6:	e00c      	b.n	2401c4d2 <HAL_TIM_OnePulse_ConfigChannel+0x9a>

      case TIM_CHANNEL_2:
      {
        assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

        TIM_OC2_SetConfig(htim->Instance, &temp1);
2401c4b8:	68fb      	ldr	r3, [r7, #12]
2401c4ba:	681b      	ldr	r3, [r3, #0]
2401c4bc:	f107 0210 	add.w	r2, r7, #16
2401c4c0:	4611      	mov	r1, r2
2401c4c2:	4618      	mov	r0, r3
2401c4c4:	f001 fb58 	bl	2401db78 <TIM_OC2_SetConfig>
        break;
2401c4c8:	e003      	b.n	2401c4d2 <HAL_TIM_OnePulse_ConfigChannel+0x9a>
      }

      default:
        status = HAL_ERROR;
2401c4ca:	2301      	movs	r3, #1
2401c4cc:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        break;
2401c4d0:	bf00      	nop
    }

    if (status == HAL_OK)
2401c4d2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
2401c4d6:	2b00      	cmp	r3, #0
2401c4d8:	d170      	bne.n	2401c5bc <HAL_TIM_OnePulse_ConfigChannel+0x184>
    {
      switch (InputChannel)
2401c4da:	683b      	ldr	r3, [r7, #0]
2401c4dc:	2b00      	cmp	r3, #0
2401c4de:	d003      	beq.n	2401c4e8 <HAL_TIM_OnePulse_ConfigChannel+0xb0>
2401c4e0:	683b      	ldr	r3, [r7, #0]
2401c4e2:	2b04      	cmp	r3, #4
2401c4e4:	d033      	beq.n	2401c54e <HAL_TIM_OnePulse_ConfigChannel+0x116>
2401c4e6:	e065      	b.n	2401c5b4 <HAL_TIM_OnePulse_ConfigChannel+0x17c>
      {
        case TIM_CHANNEL_1:
        {
          assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

          TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
2401c4e8:	68fb      	ldr	r3, [r7, #12]
2401c4ea:	6818      	ldr	r0, [r3, #0]
2401c4ec:	68bb      	ldr	r3, [r7, #8]
2401c4ee:	6999      	ldr	r1, [r3, #24]
2401c4f0:	68bb      	ldr	r3, [r7, #8]
2401c4f2:	69da      	ldr	r2, [r3, #28]
2401c4f4:	68bb      	ldr	r3, [r7, #8]
2401c4f6:	6a1b      	ldr	r3, [r3, #32]
2401c4f8:	f001 fe6e 	bl	2401e1d8 <TIM_TI1_SetConfig>
                            sConfig->ICSelection, sConfig->ICFilter);

          /* Reset the IC1PSC Bits */
          htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
2401c4fc:	68fb      	ldr	r3, [r7, #12]
2401c4fe:	681b      	ldr	r3, [r3, #0]
2401c500:	699a      	ldr	r2, [r3, #24]
2401c502:	68fb      	ldr	r3, [r7, #12]
2401c504:	681b      	ldr	r3, [r3, #0]
2401c506:	f022 020c 	bic.w	r2, r2, #12
2401c50a:	619a      	str	r2, [r3, #24]

          /* Select the Trigger source */
          htim->Instance->SMCR &= ~TIM_SMCR_TS;
2401c50c:	68fb      	ldr	r3, [r7, #12]
2401c50e:	681b      	ldr	r3, [r3, #0]
2401c510:	6899      	ldr	r1, [r3, #8]
2401c512:	68fb      	ldr	r3, [r7, #12]
2401c514:	681a      	ldr	r2, [r3, #0]
2401c516:	4b32      	ldr	r3, [pc, #200]	; (2401c5e0 <HAL_TIM_OnePulse_ConfigChannel+0x1a8>)
2401c518:	400b      	ands	r3, r1
2401c51a:	6093      	str	r3, [r2, #8]
          htim->Instance->SMCR |= TIM_TS_TI1FP1;
2401c51c:	68fb      	ldr	r3, [r7, #12]
2401c51e:	681b      	ldr	r3, [r3, #0]
2401c520:	689a      	ldr	r2, [r3, #8]
2401c522:	68fb      	ldr	r3, [r7, #12]
2401c524:	681b      	ldr	r3, [r3, #0]
2401c526:	f042 0250 	orr.w	r2, r2, #80	; 0x50
2401c52a:	609a      	str	r2, [r3, #8]

          /* Select the Slave Mode */
          htim->Instance->SMCR &= ~TIM_SMCR_SMS;
2401c52c:	68fb      	ldr	r3, [r7, #12]
2401c52e:	681b      	ldr	r3, [r3, #0]
2401c530:	6899      	ldr	r1, [r3, #8]
2401c532:	68fb      	ldr	r3, [r7, #12]
2401c534:	681a      	ldr	r2, [r3, #0]
2401c536:	4b2b      	ldr	r3, [pc, #172]	; (2401c5e4 <HAL_TIM_OnePulse_ConfigChannel+0x1ac>)
2401c538:	400b      	ands	r3, r1
2401c53a:	6093      	str	r3, [r2, #8]
          htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
2401c53c:	68fb      	ldr	r3, [r7, #12]
2401c53e:	681b      	ldr	r3, [r3, #0]
2401c540:	689a      	ldr	r2, [r3, #8]
2401c542:	68fb      	ldr	r3, [r7, #12]
2401c544:	681b      	ldr	r3, [r3, #0]
2401c546:	f042 0206 	orr.w	r2, r2, #6
2401c54a:	609a      	str	r2, [r3, #8]
          break;
2401c54c:	e037      	b.n	2401c5be <HAL_TIM_OnePulse_ConfigChannel+0x186>

        case TIM_CHANNEL_2:
        {
          assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

          TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
2401c54e:	68fb      	ldr	r3, [r7, #12]
2401c550:	6818      	ldr	r0, [r3, #0]
2401c552:	68bb      	ldr	r3, [r7, #8]
2401c554:	6999      	ldr	r1, [r3, #24]
2401c556:	68bb      	ldr	r3, [r7, #8]
2401c558:	69da      	ldr	r2, [r3, #28]
2401c55a:	68bb      	ldr	r3, [r7, #8]
2401c55c:	6a1b      	ldr	r3, [r3, #32]
2401c55e:	f001 fede 	bl	2401e31e <TIM_TI2_SetConfig>
                            sConfig->ICSelection, sConfig->ICFilter);

          /* Reset the IC2PSC Bits */
          htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
2401c562:	68fb      	ldr	r3, [r7, #12]
2401c564:	681b      	ldr	r3, [r3, #0]
2401c566:	699a      	ldr	r2, [r3, #24]
2401c568:	68fb      	ldr	r3, [r7, #12]
2401c56a:	681b      	ldr	r3, [r3, #0]
2401c56c:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
2401c570:	619a      	str	r2, [r3, #24]

          /* Select the Trigger source */
          htim->Instance->SMCR &= ~TIM_SMCR_TS;
2401c572:	68fb      	ldr	r3, [r7, #12]
2401c574:	681b      	ldr	r3, [r3, #0]
2401c576:	6899      	ldr	r1, [r3, #8]
2401c578:	68fb      	ldr	r3, [r7, #12]
2401c57a:	681a      	ldr	r2, [r3, #0]
2401c57c:	4b18      	ldr	r3, [pc, #96]	; (2401c5e0 <HAL_TIM_OnePulse_ConfigChannel+0x1a8>)
2401c57e:	400b      	ands	r3, r1
2401c580:	6093      	str	r3, [r2, #8]
          htim->Instance->SMCR |= TIM_TS_TI2FP2;
2401c582:	68fb      	ldr	r3, [r7, #12]
2401c584:	681b      	ldr	r3, [r3, #0]
2401c586:	689a      	ldr	r2, [r3, #8]
2401c588:	68fb      	ldr	r3, [r7, #12]
2401c58a:	681b      	ldr	r3, [r3, #0]
2401c58c:	f042 0260 	orr.w	r2, r2, #96	; 0x60
2401c590:	609a      	str	r2, [r3, #8]

          /* Select the Slave Mode */
          htim->Instance->SMCR &= ~TIM_SMCR_SMS;
2401c592:	68fb      	ldr	r3, [r7, #12]
2401c594:	681b      	ldr	r3, [r3, #0]
2401c596:	6899      	ldr	r1, [r3, #8]
2401c598:	68fb      	ldr	r3, [r7, #12]
2401c59a:	681a      	ldr	r2, [r3, #0]
2401c59c:	4b11      	ldr	r3, [pc, #68]	; (2401c5e4 <HAL_TIM_OnePulse_ConfigChannel+0x1ac>)
2401c59e:	400b      	ands	r3, r1
2401c5a0:	6093      	str	r3, [r2, #8]
          htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
2401c5a2:	68fb      	ldr	r3, [r7, #12]
2401c5a4:	681b      	ldr	r3, [r3, #0]
2401c5a6:	689a      	ldr	r2, [r3, #8]
2401c5a8:	68fb      	ldr	r3, [r7, #12]
2401c5aa:	681b      	ldr	r3, [r3, #0]
2401c5ac:	f042 0206 	orr.w	r2, r2, #6
2401c5b0:	609a      	str	r2, [r3, #8]
          break;
2401c5b2:	e004      	b.n	2401c5be <HAL_TIM_OnePulse_ConfigChannel+0x186>
        }

        default:
          status = HAL_ERROR;
2401c5b4:	2301      	movs	r3, #1
2401c5b6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
          break;
2401c5ba:	e000      	b.n	2401c5be <HAL_TIM_OnePulse_ConfigChannel+0x186>
      }
    }
2401c5bc:	bf00      	nop

    htim->State = HAL_TIM_STATE_READY;
2401c5be:	68fb      	ldr	r3, [r7, #12]
2401c5c0:	2201      	movs	r2, #1
2401c5c2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    __HAL_UNLOCK(htim);
2401c5c6:	68fb      	ldr	r3, [r7, #12]
2401c5c8:	2200      	movs	r2, #0
2401c5ca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return status;
2401c5ce:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
2401c5d2:	e000      	b.n	2401c5d6 <HAL_TIM_OnePulse_ConfigChannel+0x19e>
  }
  else
  {
    return HAL_ERROR;
2401c5d4:	2301      	movs	r3, #1
  }
}
2401c5d6:	4618      	mov	r0, r3
2401c5d8:	3730      	adds	r7, #48	; 0x30
2401c5da:	46bd      	mov	sp, r7
2401c5dc:	bd80      	pop	{r7, pc}
2401c5de:	bf00      	nop
2401c5e0:	ffcfff8f 	.word	0xffcfff8f
2401c5e4:	fffefff8 	.word	0xfffefff8

2401c5e8 <HAL_TIM_DMABurst_WriteStart>:
  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
                                              uint32_t BurstRequestSrc, const uint32_t *BurstBuffer, uint32_t  BurstLength)
{
2401c5e8:	b580      	push	{r7, lr}
2401c5ea:	b088      	sub	sp, #32
2401c5ec:	af02      	add	r7, sp, #8
2401c5ee:	60f8      	str	r0, [r7, #12]
2401c5f0:	60b9      	str	r1, [r7, #8]
2401c5f2:	607a      	str	r2, [r7, #4]
2401c5f4:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;

  status = HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
                                            ((BurstLength) >> 8U) + 1U);
2401c5f6:	6a3b      	ldr	r3, [r7, #32]
2401c5f8:	0a1b      	lsrs	r3, r3, #8
  status = HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
2401c5fa:	3301      	adds	r3, #1
2401c5fc:	9301      	str	r3, [sp, #4]
2401c5fe:	6a3b      	ldr	r3, [r7, #32]
2401c600:	9300      	str	r3, [sp, #0]
2401c602:	683b      	ldr	r3, [r7, #0]
2401c604:	687a      	ldr	r2, [r7, #4]
2401c606:	68b9      	ldr	r1, [r7, #8]
2401c608:	68f8      	ldr	r0, [r7, #12]
2401c60a:	f000 f807 	bl	2401c61c <HAL_TIM_DMABurst_MultiWriteStart>
2401c60e:	4603      	mov	r3, r0
2401c610:	75fb      	strb	r3, [r7, #23]



  return status;
2401c612:	7dfb      	ldrb	r3, [r7, #23]
}
2401c614:	4618      	mov	r0, r3
2401c616:	3718      	adds	r7, #24
2401c618:	46bd      	mov	sp, r7
2401c61a:	bd80      	pop	{r7, pc}

2401c61c <HAL_TIM_DMABurst_MultiWriteStart>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
                                                   uint32_t BurstRequestSrc, const uint32_t *BurstBuffer,
                                                   uint32_t  BurstLength,  uint32_t  DataLength)
{
2401c61c:	b580      	push	{r7, lr}
2401c61e:	b086      	sub	sp, #24
2401c620:	af00      	add	r7, sp, #0
2401c622:	60f8      	str	r0, [r7, #12]
2401c624:	60b9      	str	r1, [r7, #8]
2401c626:	607a      	str	r2, [r7, #4]
2401c628:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401c62a:	2300      	movs	r3, #0
2401c62c:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
  assert_param(IS_TIM_DMA_LENGTH(BurstLength));
  assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));

  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)
2401c62e:	68fb      	ldr	r3, [r7, #12]
2401c630:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
2401c634:	b2db      	uxtb	r3, r3
2401c636:	2b02      	cmp	r3, #2
2401c638:	d101      	bne.n	2401c63e <HAL_TIM_DMABurst_MultiWriteStart+0x22>
  {
    return HAL_BUSY;
2401c63a:	2302      	movs	r3, #2
2401c63c:	e12b      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
  }
  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)
2401c63e:	68fb      	ldr	r3, [r7, #12]
2401c640:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
2401c644:	b2db      	uxtb	r3, r3
2401c646:	2b01      	cmp	r3, #1
2401c648:	d10b      	bne.n	2401c662 <HAL_TIM_DMABurst_MultiWriteStart+0x46>
  {
    if ((BurstBuffer == NULL) && (BurstLength > 0U))
2401c64a:	683b      	ldr	r3, [r7, #0]
2401c64c:	2b00      	cmp	r3, #0
2401c64e:	d104      	bne.n	2401c65a <HAL_TIM_DMABurst_MultiWriteStart+0x3e>
2401c650:	6a3b      	ldr	r3, [r7, #32]
2401c652:	2b00      	cmp	r3, #0
2401c654:	d001      	beq.n	2401c65a <HAL_TIM_DMABurst_MultiWriteStart+0x3e>
    {
      return HAL_ERROR;
2401c656:	2301      	movs	r3, #1
2401c658:	e11d      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
    }
    else
    {
      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;
2401c65a:	68fb      	ldr	r3, [r7, #12]
2401c65c:	2202      	movs	r2, #2
2401c65e:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
  else
  {
    /* nothing to do */
  }

  switch (BurstRequestSrc)
2401c662:	687b      	ldr	r3, [r7, #4]
2401c664:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401c668:	f000 80d8 	beq.w	2401c81c <HAL_TIM_DMABurst_MultiWriteStart+0x200>
2401c66c:	687b      	ldr	r3, [r7, #4]
2401c66e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401c672:	f200 80ee 	bhi.w	2401c852 <HAL_TIM_DMABurst_MultiWriteStart+0x236>
2401c676:	687b      	ldr	r3, [r7, #4]
2401c678:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401c67c:	f000 80b3 	beq.w	2401c7e6 <HAL_TIM_DMABurst_MultiWriteStart+0x1ca>
2401c680:	687b      	ldr	r3, [r7, #4]
2401c682:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401c686:	f200 80e4 	bhi.w	2401c852 <HAL_TIM_DMABurst_MultiWriteStart+0x236>
2401c68a:	687b      	ldr	r3, [r7, #4]
2401c68c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401c690:	f000 808e 	beq.w	2401c7b0 <HAL_TIM_DMABurst_MultiWriteStart+0x194>
2401c694:	687b      	ldr	r3, [r7, #4]
2401c696:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401c69a:	f200 80da 	bhi.w	2401c852 <HAL_TIM_DMABurst_MultiWriteStart+0x236>
2401c69e:	687b      	ldr	r3, [r7, #4]
2401c6a0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401c6a4:	d069      	beq.n	2401c77a <HAL_TIM_DMABurst_MultiWriteStart+0x15e>
2401c6a6:	687b      	ldr	r3, [r7, #4]
2401c6a8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401c6ac:	f200 80d1 	bhi.w	2401c852 <HAL_TIM_DMABurst_MultiWriteStart+0x236>
2401c6b0:	687b      	ldr	r3, [r7, #4]
2401c6b2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401c6b6:	d045      	beq.n	2401c744 <HAL_TIM_DMABurst_MultiWriteStart+0x128>
2401c6b8:	687b      	ldr	r3, [r7, #4]
2401c6ba:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401c6be:	f200 80c8 	bhi.w	2401c852 <HAL_TIM_DMABurst_MultiWriteStart+0x236>
2401c6c2:	687b      	ldr	r3, [r7, #4]
2401c6c4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401c6c8:	d004      	beq.n	2401c6d4 <HAL_TIM_DMABurst_MultiWriteStart+0xb8>
2401c6ca:	687b      	ldr	r3, [r7, #4]
2401c6cc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2401c6d0:	d01c      	beq.n	2401c70c <HAL_TIM_DMABurst_MultiWriteStart+0xf0>
2401c6d2:	e0be      	b.n	2401c852 <HAL_TIM_DMABurst_MultiWriteStart+0x236>
  {
    case TIM_DMA_UPDATE:
    {
      /* Set the DMA Period elapsed callbacks */
      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
2401c6d4:	68fb      	ldr	r3, [r7, #12]
2401c6d6:	6a1b      	ldr	r3, [r3, #32]
2401c6d8:	4a71      	ldr	r2, [pc, #452]	; (2401c8a0 <HAL_TIM_DMABurst_MultiWriteStart+0x284>)
2401c6da:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
2401c6dc:	68fb      	ldr	r3, [r7, #12]
2401c6de:	6a1b      	ldr	r3, [r3, #32]
2401c6e0:	4a70      	ldr	r2, [pc, #448]	; (2401c8a4 <HAL_TIM_DMABurst_MultiWriteStart+0x288>)
2401c6e2:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
2401c6e4:	68fb      	ldr	r3, [r7, #12]
2401c6e6:	6a1b      	ldr	r3, [r3, #32]
2401c6e8:	4a6f      	ldr	r2, [pc, #444]	; (2401c8a8 <HAL_TIM_DMABurst_MultiWriteStart+0x28c>)
2401c6ea:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,
2401c6ec:	68fb      	ldr	r3, [r7, #12]
2401c6ee:	6a18      	ldr	r0, [r3, #32]
2401c6f0:	6839      	ldr	r1, [r7, #0]
                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
2401c6f2:	68fb      	ldr	r3, [r7, #12]
2401c6f4:	681b      	ldr	r3, [r3, #0]
2401c6f6:	334c      	adds	r3, #76	; 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,
2401c6f8:	461a      	mov	r2, r3
2401c6fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401c6fc:	f7e7 fa28 	bl	24003b50 <HAL_DMA_Start_IT>
2401c700:	4603      	mov	r3, r0
2401c702:	2b00      	cmp	r3, #0
2401c704:	f000 80a8 	beq.w	2401c858 <HAL_TIM_DMABurst_MultiWriteStart+0x23c>
      {
        /* Return error status */
        return HAL_ERROR;
2401c708:	2301      	movs	r3, #1
2401c70a:	e0c4      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
      break;
    }
    case TIM_DMA_CC1:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
2401c70c:	68fb      	ldr	r3, [r7, #12]
2401c70e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401c710:	4a66      	ldr	r2, [pc, #408]	; (2401c8ac <HAL_TIM_DMABurst_MultiWriteStart+0x290>)
2401c712:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401c714:	68fb      	ldr	r3, [r7, #12]
2401c716:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401c718:	4a65      	ldr	r2, [pc, #404]	; (2401c8b0 <HAL_TIM_DMABurst_MultiWriteStart+0x294>)
2401c71a:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2401c71c:	68fb      	ldr	r3, [r7, #12]
2401c71e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401c720:	4a61      	ldr	r2, [pc, #388]	; (2401c8a8 <HAL_TIM_DMABurst_MultiWriteStart+0x28c>)
2401c722:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
2401c724:	68fb      	ldr	r3, [r7, #12]
2401c726:	6a58      	ldr	r0, [r3, #36]	; 0x24
2401c728:	6839      	ldr	r1, [r7, #0]
                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
2401c72a:	68fb      	ldr	r3, [r7, #12]
2401c72c:	681b      	ldr	r3, [r3, #0]
2401c72e:	334c      	adds	r3, #76	; 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
2401c730:	461a      	mov	r2, r3
2401c732:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401c734:	f7e7 fa0c 	bl	24003b50 <HAL_DMA_Start_IT>
2401c738:	4603      	mov	r3, r0
2401c73a:	2b00      	cmp	r3, #0
2401c73c:	f000 808e 	beq.w	2401c85c <HAL_TIM_DMABurst_MultiWriteStart+0x240>
      {
        /* Return error status */
        return HAL_ERROR;
2401c740:	2301      	movs	r3, #1
2401c742:	e0a8      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
      break;
    }
    case TIM_DMA_CC2:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
2401c744:	68fb      	ldr	r3, [r7, #12]
2401c746:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401c748:	4a58      	ldr	r2, [pc, #352]	; (2401c8ac <HAL_TIM_DMABurst_MultiWriteStart+0x290>)
2401c74a:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401c74c:	68fb      	ldr	r3, [r7, #12]
2401c74e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401c750:	4a57      	ldr	r2, [pc, #348]	; (2401c8b0 <HAL_TIM_DMABurst_MultiWriteStart+0x294>)
2401c752:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
2401c754:	68fb      	ldr	r3, [r7, #12]
2401c756:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401c758:	4a53      	ldr	r2, [pc, #332]	; (2401c8a8 <HAL_TIM_DMABurst_MultiWriteStart+0x28c>)
2401c75a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
2401c75c:	68fb      	ldr	r3, [r7, #12]
2401c75e:	6a98      	ldr	r0, [r3, #40]	; 0x28
2401c760:	6839      	ldr	r1, [r7, #0]
                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
2401c762:	68fb      	ldr	r3, [r7, #12]
2401c764:	681b      	ldr	r3, [r3, #0]
2401c766:	334c      	adds	r3, #76	; 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
2401c768:	461a      	mov	r2, r3
2401c76a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401c76c:	f7e7 f9f0 	bl	24003b50 <HAL_DMA_Start_IT>
2401c770:	4603      	mov	r3, r0
2401c772:	2b00      	cmp	r3, #0
2401c774:	d074      	beq.n	2401c860 <HAL_TIM_DMABurst_MultiWriteStart+0x244>
      {
        /* Return error status */
        return HAL_ERROR;
2401c776:	2301      	movs	r3, #1
2401c778:	e08d      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
      break;
    }
    case TIM_DMA_CC3:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
2401c77a:	68fb      	ldr	r3, [r7, #12]
2401c77c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401c77e:	4a4b      	ldr	r2, [pc, #300]	; (2401c8ac <HAL_TIM_DMABurst_MultiWriteStart+0x290>)
2401c780:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401c782:	68fb      	ldr	r3, [r7, #12]
2401c784:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401c786:	4a4a      	ldr	r2, [pc, #296]	; (2401c8b0 <HAL_TIM_DMABurst_MultiWriteStart+0x294>)
2401c788:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
2401c78a:	68fb      	ldr	r3, [r7, #12]
2401c78c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401c78e:	4a46      	ldr	r2, [pc, #280]	; (2401c8a8 <HAL_TIM_DMABurst_MultiWriteStart+0x28c>)
2401c790:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
2401c792:	68fb      	ldr	r3, [r7, #12]
2401c794:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2401c796:	6839      	ldr	r1, [r7, #0]
                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
2401c798:	68fb      	ldr	r3, [r7, #12]
2401c79a:	681b      	ldr	r3, [r3, #0]
2401c79c:	334c      	adds	r3, #76	; 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
2401c79e:	461a      	mov	r2, r3
2401c7a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401c7a2:	f7e7 f9d5 	bl	24003b50 <HAL_DMA_Start_IT>
2401c7a6:	4603      	mov	r3, r0
2401c7a8:	2b00      	cmp	r3, #0
2401c7aa:	d05b      	beq.n	2401c864 <HAL_TIM_DMABurst_MultiWriteStart+0x248>
      {
        /* Return error status */
        return HAL_ERROR;
2401c7ac:	2301      	movs	r3, #1
2401c7ae:	e072      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
      break;
    }
    case TIM_DMA_CC4:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
2401c7b0:	68fb      	ldr	r3, [r7, #12]
2401c7b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401c7b4:	4a3d      	ldr	r2, [pc, #244]	; (2401c8ac <HAL_TIM_DMABurst_MultiWriteStart+0x290>)
2401c7b6:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401c7b8:	68fb      	ldr	r3, [r7, #12]
2401c7ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401c7bc:	4a3c      	ldr	r2, [pc, #240]	; (2401c8b0 <HAL_TIM_DMABurst_MultiWriteStart+0x294>)
2401c7be:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
2401c7c0:	68fb      	ldr	r3, [r7, #12]
2401c7c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401c7c4:	4a38      	ldr	r2, [pc, #224]	; (2401c8a8 <HAL_TIM_DMABurst_MultiWriteStart+0x28c>)
2401c7c6:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
2401c7c8:	68fb      	ldr	r3, [r7, #12]
2401c7ca:	6b18      	ldr	r0, [r3, #48]	; 0x30
2401c7cc:	6839      	ldr	r1, [r7, #0]
                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
2401c7ce:	68fb      	ldr	r3, [r7, #12]
2401c7d0:	681b      	ldr	r3, [r3, #0]
2401c7d2:	334c      	adds	r3, #76	; 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
2401c7d4:	461a      	mov	r2, r3
2401c7d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401c7d8:	f7e7 f9ba 	bl	24003b50 <HAL_DMA_Start_IT>
2401c7dc:	4603      	mov	r3, r0
2401c7de:	2b00      	cmp	r3, #0
2401c7e0:	d042      	beq.n	2401c868 <HAL_TIM_DMABurst_MultiWriteStart+0x24c>
      {
        /* Return error status */
        return HAL_ERROR;
2401c7e2:	2301      	movs	r3, #1
2401c7e4:	e057      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
      break;
    }
    case TIM_DMA_COM:
    {
      /* Set the DMA commutation callbacks */
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
2401c7e6:	68fb      	ldr	r3, [r7, #12]
2401c7e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401c7ea:	4a32      	ldr	r2, [pc, #200]	; (2401c8b4 <HAL_TIM_DMABurst_MultiWriteStart+0x298>)
2401c7ec:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
2401c7ee:	68fb      	ldr	r3, [r7, #12]
2401c7f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401c7f2:	4a31      	ldr	r2, [pc, #196]	; (2401c8b8 <HAL_TIM_DMABurst_MultiWriteStart+0x29c>)
2401c7f4:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
2401c7f6:	68fb      	ldr	r3, [r7, #12]
2401c7f8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401c7fa:	4a2b      	ldr	r2, [pc, #172]	; (2401c8a8 <HAL_TIM_DMABurst_MultiWriteStart+0x28c>)
2401c7fc:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
2401c7fe:	68fb      	ldr	r3, [r7, #12]
2401c800:	6b58      	ldr	r0, [r3, #52]	; 0x34
2401c802:	6839      	ldr	r1, [r7, #0]
                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
2401c804:	68fb      	ldr	r3, [r7, #12]
2401c806:	681b      	ldr	r3, [r3, #0]
2401c808:	334c      	adds	r3, #76	; 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
2401c80a:	461a      	mov	r2, r3
2401c80c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401c80e:	f7e7 f99f 	bl	24003b50 <HAL_DMA_Start_IT>
2401c812:	4603      	mov	r3, r0
2401c814:	2b00      	cmp	r3, #0
2401c816:	d029      	beq.n	2401c86c <HAL_TIM_DMABurst_MultiWriteStart+0x250>
      {
        /* Return error status */
        return HAL_ERROR;
2401c818:	2301      	movs	r3, #1
2401c81a:	e03c      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
      break;
    }
    case TIM_DMA_TRIGGER:
    {
      /* Set the DMA trigger callbacks */
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
2401c81c:	68fb      	ldr	r3, [r7, #12]
2401c81e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401c820:	4a26      	ldr	r2, [pc, #152]	; (2401c8bc <HAL_TIM_DMABurst_MultiWriteStart+0x2a0>)
2401c822:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
2401c824:	68fb      	ldr	r3, [r7, #12]
2401c826:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401c828:	4a25      	ldr	r2, [pc, #148]	; (2401c8c0 <HAL_TIM_DMABurst_MultiWriteStart+0x2a4>)
2401c82a:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
2401c82c:	68fb      	ldr	r3, [r7, #12]
2401c82e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401c830:	4a1d      	ldr	r2, [pc, #116]	; (2401c8a8 <HAL_TIM_DMABurst_MultiWriteStart+0x28c>)
2401c832:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
2401c834:	68fb      	ldr	r3, [r7, #12]
2401c836:	6b98      	ldr	r0, [r3, #56]	; 0x38
2401c838:	6839      	ldr	r1, [r7, #0]
                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
2401c83a:	68fb      	ldr	r3, [r7, #12]
2401c83c:	681b      	ldr	r3, [r3, #0]
2401c83e:	334c      	adds	r3, #76	; 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
2401c840:	461a      	mov	r2, r3
2401c842:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401c844:	f7e7 f984 	bl	24003b50 <HAL_DMA_Start_IT>
2401c848:	4603      	mov	r3, r0
2401c84a:	2b00      	cmp	r3, #0
2401c84c:	d010      	beq.n	2401c870 <HAL_TIM_DMABurst_MultiWriteStart+0x254>
      {
        /* Return error status */
        return HAL_ERROR;
2401c84e:	2301      	movs	r3, #1
2401c850:	e021      	b.n	2401c896 <HAL_TIM_DMABurst_MultiWriteStart+0x27a>
      }
      break;
    }
    default:
      status = HAL_ERROR;
2401c852:	2301      	movs	r3, #1
2401c854:	75fb      	strb	r3, [r7, #23]
      break;
2401c856:	e00c      	b.n	2401c872 <HAL_TIM_DMABurst_MultiWriteStart+0x256>
      break;
2401c858:	bf00      	nop
2401c85a:	e00a      	b.n	2401c872 <HAL_TIM_DMABurst_MultiWriteStart+0x256>
      break;
2401c85c:	bf00      	nop
2401c85e:	e008      	b.n	2401c872 <HAL_TIM_DMABurst_MultiWriteStart+0x256>
      break;
2401c860:	bf00      	nop
2401c862:	e006      	b.n	2401c872 <HAL_TIM_DMABurst_MultiWriteStart+0x256>
      break;
2401c864:	bf00      	nop
2401c866:	e004      	b.n	2401c872 <HAL_TIM_DMABurst_MultiWriteStart+0x256>
      break;
2401c868:	bf00      	nop
2401c86a:	e002      	b.n	2401c872 <HAL_TIM_DMABurst_MultiWriteStart+0x256>
      break;
2401c86c:	bf00      	nop
2401c86e:	e000      	b.n	2401c872 <HAL_TIM_DMABurst_MultiWriteStart+0x256>
      break;
2401c870:	bf00      	nop
  }

  if (status == HAL_OK)
2401c872:	7dfb      	ldrb	r3, [r7, #23]
2401c874:	2b00      	cmp	r3, #0
2401c876:	d10d      	bne.n	2401c894 <HAL_TIM_DMABurst_MultiWriteStart+0x278>
  {
    /* Configure the DMA Burst Mode */
    htim->Instance->DCR = (BurstBaseAddress | BurstLength);
2401c878:	68fb      	ldr	r3, [r7, #12]
2401c87a:	681b      	ldr	r3, [r3, #0]
2401c87c:	68b9      	ldr	r1, [r7, #8]
2401c87e:	6a3a      	ldr	r2, [r7, #32]
2401c880:	430a      	orrs	r2, r1
2401c882:	649a      	str	r2, [r3, #72]	; 0x48
    /* Enable the TIM DMA Request */
    __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
2401c884:	68fb      	ldr	r3, [r7, #12]
2401c886:	681b      	ldr	r3, [r3, #0]
2401c888:	68d9      	ldr	r1, [r3, #12]
2401c88a:	68fb      	ldr	r3, [r7, #12]
2401c88c:	681b      	ldr	r3, [r3, #0]
2401c88e:	687a      	ldr	r2, [r7, #4]
2401c890:	430a      	orrs	r2, r1
2401c892:	60da      	str	r2, [r3, #12]
  }

  /* Return function status */
  return status;
2401c894:	7dfb      	ldrb	r3, [r7, #23]
}
2401c896:	4618      	mov	r0, r3
2401c898:	3718      	adds	r7, #24
2401c89a:	46bd      	mov	sp, r7
2401c89c:	bd80      	pop	{r7, pc}
2401c89e:	bf00      	nop
2401c8a0:	2401d891 	.word	0x2401d891
2401c8a4:	2401d8bf 	.word	0x2401d8bf
2401c8a8:	2401d5bf 	.word	0x2401d5bf
2401c8ac:	2401d651 	.word	0x2401d651
2401c8b0:	2401d6f9 	.word	0x2401d6f9
2401c8b4:	24020c35 	.word	0x24020c35
2401c8b8:	24020c59 	.word	0x24020c59
2401c8bc:	2401d8db 	.word	0x2401d8db
2401c8c0:	2401d909 	.word	0x2401d909

2401c8c4 <HAL_TIM_DMABurst_WriteStop>:
  * @param  htim TIM handle
  * @param  BurstRequestSrc TIM DMA Request sources to disable
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
{
2401c8c4:	b580      	push	{r7, lr}
2401c8c6:	b084      	sub	sp, #16
2401c8c8:	af00      	add	r7, sp, #0
2401c8ca:	6078      	str	r0, [r7, #4]
2401c8cc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401c8ce:	2300      	movs	r3, #0
2401c8d0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));

  /* Abort the DMA transfer (at least disable the DMA stream) */
  switch (BurstRequestSrc)
2401c8d2:	683b      	ldr	r3, [r7, #0]
2401c8d4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401c8d8:	d050      	beq.n	2401c97c <HAL_TIM_DMABurst_WriteStop+0xb8>
2401c8da:	683b      	ldr	r3, [r7, #0]
2401c8dc:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401c8e0:	d852      	bhi.n	2401c988 <HAL_TIM_DMABurst_WriteStop+0xc4>
2401c8e2:	683b      	ldr	r3, [r7, #0]
2401c8e4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401c8e8:	d042      	beq.n	2401c970 <HAL_TIM_DMABurst_WriteStop+0xac>
2401c8ea:	683b      	ldr	r3, [r7, #0]
2401c8ec:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401c8f0:	d84a      	bhi.n	2401c988 <HAL_TIM_DMABurst_WriteStop+0xc4>
2401c8f2:	683b      	ldr	r3, [r7, #0]
2401c8f4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401c8f8:	d034      	beq.n	2401c964 <HAL_TIM_DMABurst_WriteStop+0xa0>
2401c8fa:	683b      	ldr	r3, [r7, #0]
2401c8fc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401c900:	d842      	bhi.n	2401c988 <HAL_TIM_DMABurst_WriteStop+0xc4>
2401c902:	683b      	ldr	r3, [r7, #0]
2401c904:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401c908:	d026      	beq.n	2401c958 <HAL_TIM_DMABurst_WriteStop+0x94>
2401c90a:	683b      	ldr	r3, [r7, #0]
2401c90c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401c910:	d83a      	bhi.n	2401c988 <HAL_TIM_DMABurst_WriteStop+0xc4>
2401c912:	683b      	ldr	r3, [r7, #0]
2401c914:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401c918:	d018      	beq.n	2401c94c <HAL_TIM_DMABurst_WriteStop+0x88>
2401c91a:	683b      	ldr	r3, [r7, #0]
2401c91c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401c920:	d832      	bhi.n	2401c988 <HAL_TIM_DMABurst_WriteStop+0xc4>
2401c922:	683b      	ldr	r3, [r7, #0]
2401c924:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401c928:	d004      	beq.n	2401c934 <HAL_TIM_DMABurst_WriteStop+0x70>
2401c92a:	683b      	ldr	r3, [r7, #0]
2401c92c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2401c930:	d006      	beq.n	2401c940 <HAL_TIM_DMABurst_WriteStop+0x7c>
2401c932:	e029      	b.n	2401c988 <HAL_TIM_DMABurst_WriteStop+0xc4>
  {
    case TIM_DMA_UPDATE:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
2401c934:	687b      	ldr	r3, [r7, #4]
2401c936:	6a1b      	ldr	r3, [r3, #32]
2401c938:	4618      	mov	r0, r3
2401c93a:	f7e7 fe91 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401c93e:	e026      	b.n	2401c98e <HAL_TIM_DMABurst_WriteStop+0xca>
    }
    case TIM_DMA_CC1:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2401c940:	687b      	ldr	r3, [r7, #4]
2401c942:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401c944:	4618      	mov	r0, r3
2401c946:	f7e7 fe8b 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401c94a:	e020      	b.n	2401c98e <HAL_TIM_DMABurst_WriteStop+0xca>
    }
    case TIM_DMA_CC2:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2401c94c:	687b      	ldr	r3, [r7, #4]
2401c94e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401c950:	4618      	mov	r0, r3
2401c952:	f7e7 fe85 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401c956:	e01a      	b.n	2401c98e <HAL_TIM_DMABurst_WriteStop+0xca>
    }
    case TIM_DMA_CC3:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2401c958:	687b      	ldr	r3, [r7, #4]
2401c95a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401c95c:	4618      	mov	r0, r3
2401c95e:	f7e7 fe7f 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401c962:	e014      	b.n	2401c98e <HAL_TIM_DMABurst_WriteStop+0xca>
    }
    case TIM_DMA_CC4:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2401c964:	687b      	ldr	r3, [r7, #4]
2401c966:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401c968:	4618      	mov	r0, r3
2401c96a:	f7e7 fe79 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401c96e:	e00e      	b.n	2401c98e <HAL_TIM_DMABurst_WriteStop+0xca>
    }
    case TIM_DMA_COM:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
2401c970:	687b      	ldr	r3, [r7, #4]
2401c972:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401c974:	4618      	mov	r0, r3
2401c976:	f7e7 fe73 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401c97a:	e008      	b.n	2401c98e <HAL_TIM_DMABurst_WriteStop+0xca>
    }
    case TIM_DMA_TRIGGER:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
2401c97c:	687b      	ldr	r3, [r7, #4]
2401c97e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401c980:	4618      	mov	r0, r3
2401c982:	f7e7 fe6d 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401c986:	e002      	b.n	2401c98e <HAL_TIM_DMABurst_WriteStop+0xca>
    }
    default:
      status = HAL_ERROR;
2401c988:	2301      	movs	r3, #1
2401c98a:	73fb      	strb	r3, [r7, #15]
      break;
2401c98c:	bf00      	nop
  }

  if (status == HAL_OK)
2401c98e:	7bfb      	ldrb	r3, [r7, #15]
2401c990:	2b00      	cmp	r3, #0
2401c992:	d10c      	bne.n	2401c9ae <HAL_TIM_DMABurst_WriteStop+0xea>
  {
    /* Disable the TIM Update DMA request */
    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
2401c994:	687b      	ldr	r3, [r7, #4]
2401c996:	681b      	ldr	r3, [r3, #0]
2401c998:	68d9      	ldr	r1, [r3, #12]
2401c99a:	683b      	ldr	r3, [r7, #0]
2401c99c:	43da      	mvns	r2, r3
2401c99e:	687b      	ldr	r3, [r7, #4]
2401c9a0:	681b      	ldr	r3, [r3, #0]
2401c9a2:	400a      	ands	r2, r1
2401c9a4:	60da      	str	r2, [r3, #12]

    /* Change the DMA burst operation state */
    htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
2401c9a6:	687b      	ldr	r3, [r7, #4]
2401c9a8:	2201      	movs	r2, #1
2401c9aa:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
  }

  /* Return function status */
  return status;
2401c9ae:	7bfb      	ldrb	r3, [r7, #15]
}
2401c9b0:	4618      	mov	r0, r3
2401c9b2:	3710      	adds	r7, #16
2401c9b4:	46bd      	mov	sp, r7
2401c9b6:	bd80      	pop	{r7, pc}

2401c9b8 <HAL_TIM_DMABurst_ReadStart>:
  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
                                             uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)
{
2401c9b8:	b580      	push	{r7, lr}
2401c9ba:	b088      	sub	sp, #32
2401c9bc:	af02      	add	r7, sp, #8
2401c9be:	60f8      	str	r0, [r7, #12]
2401c9c0:	60b9      	str	r1, [r7, #8]
2401c9c2:	607a      	str	r2, [r7, #4]
2401c9c4:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;

  status = HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
                                           ((BurstLength) >> 8U) + 1U);
2401c9c6:	6a3b      	ldr	r3, [r7, #32]
2401c9c8:	0a1b      	lsrs	r3, r3, #8
  status = HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
2401c9ca:	3301      	adds	r3, #1
2401c9cc:	9301      	str	r3, [sp, #4]
2401c9ce:	6a3b      	ldr	r3, [r7, #32]
2401c9d0:	9300      	str	r3, [sp, #0]
2401c9d2:	683b      	ldr	r3, [r7, #0]
2401c9d4:	687a      	ldr	r2, [r7, #4]
2401c9d6:	68b9      	ldr	r1, [r7, #8]
2401c9d8:	68f8      	ldr	r0, [r7, #12]
2401c9da:	f000 f807 	bl	2401c9ec <HAL_TIM_DMABurst_MultiReadStart>
2401c9de:	4603      	mov	r3, r0
2401c9e0:	75fb      	strb	r3, [r7, #23]


  return status;
2401c9e2:	7dfb      	ldrb	r3, [r7, #23]
}
2401c9e4:	4618      	mov	r0, r3
2401c9e6:	3718      	adds	r7, #24
2401c9e8:	46bd      	mov	sp, r7
2401c9ea:	bd80      	pop	{r7, pc}

2401c9ec <HAL_TIM_DMABurst_MultiReadStart>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
                                                  uint32_t BurstRequestSrc, uint32_t  *BurstBuffer,
                                                  uint32_t  BurstLength, uint32_t  DataLength)
{
2401c9ec:	b580      	push	{r7, lr}
2401c9ee:	b086      	sub	sp, #24
2401c9f0:	af00      	add	r7, sp, #0
2401c9f2:	60f8      	str	r0, [r7, #12]
2401c9f4:	60b9      	str	r1, [r7, #8]
2401c9f6:	607a      	str	r2, [r7, #4]
2401c9f8:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401c9fa:	2300      	movs	r3, #0
2401c9fc:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
  assert_param(IS_TIM_DMA_LENGTH(BurstLength));
  assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));

  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)
2401c9fe:	68fb      	ldr	r3, [r7, #12]
2401ca00:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
2401ca04:	b2db      	uxtb	r3, r3
2401ca06:	2b02      	cmp	r3, #2
2401ca08:	d101      	bne.n	2401ca0e <HAL_TIM_DMABurst_MultiReadStart+0x22>
  {
    return HAL_BUSY;
2401ca0a:	2302      	movs	r3, #2
2401ca0c:	e12b      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
  }
  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)
2401ca0e:	68fb      	ldr	r3, [r7, #12]
2401ca10:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
2401ca14:	b2db      	uxtb	r3, r3
2401ca16:	2b01      	cmp	r3, #1
2401ca18:	d10b      	bne.n	2401ca32 <HAL_TIM_DMABurst_MultiReadStart+0x46>
  {
    if ((BurstBuffer == NULL) && (BurstLength > 0U))
2401ca1a:	683b      	ldr	r3, [r7, #0]
2401ca1c:	2b00      	cmp	r3, #0
2401ca1e:	d104      	bne.n	2401ca2a <HAL_TIM_DMABurst_MultiReadStart+0x3e>
2401ca20:	6a3b      	ldr	r3, [r7, #32]
2401ca22:	2b00      	cmp	r3, #0
2401ca24:	d001      	beq.n	2401ca2a <HAL_TIM_DMABurst_MultiReadStart+0x3e>
    {
      return HAL_ERROR;
2401ca26:	2301      	movs	r3, #1
2401ca28:	e11d      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
    }
    else
    {
      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;
2401ca2a:	68fb      	ldr	r3, [r7, #12]
2401ca2c:	2202      	movs	r2, #2
2401ca2e:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
  }
  else
  {
    /* nothing to do */
  }
  switch (BurstRequestSrc)
2401ca32:	687b      	ldr	r3, [r7, #4]
2401ca34:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401ca38:	f000 80d8 	beq.w	2401cbec <HAL_TIM_DMABurst_MultiReadStart+0x200>
2401ca3c:	687b      	ldr	r3, [r7, #4]
2401ca3e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401ca42:	f200 80ee 	bhi.w	2401cc22 <HAL_TIM_DMABurst_MultiReadStart+0x236>
2401ca46:	687b      	ldr	r3, [r7, #4]
2401ca48:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401ca4c:	f000 80b3 	beq.w	2401cbb6 <HAL_TIM_DMABurst_MultiReadStart+0x1ca>
2401ca50:	687b      	ldr	r3, [r7, #4]
2401ca52:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401ca56:	f200 80e4 	bhi.w	2401cc22 <HAL_TIM_DMABurst_MultiReadStart+0x236>
2401ca5a:	687b      	ldr	r3, [r7, #4]
2401ca5c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401ca60:	f000 808e 	beq.w	2401cb80 <HAL_TIM_DMABurst_MultiReadStart+0x194>
2401ca64:	687b      	ldr	r3, [r7, #4]
2401ca66:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401ca6a:	f200 80da 	bhi.w	2401cc22 <HAL_TIM_DMABurst_MultiReadStart+0x236>
2401ca6e:	687b      	ldr	r3, [r7, #4]
2401ca70:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401ca74:	d069      	beq.n	2401cb4a <HAL_TIM_DMABurst_MultiReadStart+0x15e>
2401ca76:	687b      	ldr	r3, [r7, #4]
2401ca78:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401ca7c:	f200 80d1 	bhi.w	2401cc22 <HAL_TIM_DMABurst_MultiReadStart+0x236>
2401ca80:	687b      	ldr	r3, [r7, #4]
2401ca82:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401ca86:	d045      	beq.n	2401cb14 <HAL_TIM_DMABurst_MultiReadStart+0x128>
2401ca88:	687b      	ldr	r3, [r7, #4]
2401ca8a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401ca8e:	f200 80c8 	bhi.w	2401cc22 <HAL_TIM_DMABurst_MultiReadStart+0x236>
2401ca92:	687b      	ldr	r3, [r7, #4]
2401ca94:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401ca98:	d004      	beq.n	2401caa4 <HAL_TIM_DMABurst_MultiReadStart+0xb8>
2401ca9a:	687b      	ldr	r3, [r7, #4]
2401ca9c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2401caa0:	d01c      	beq.n	2401cadc <HAL_TIM_DMABurst_MultiReadStart+0xf0>
2401caa2:	e0be      	b.n	2401cc22 <HAL_TIM_DMABurst_MultiReadStart+0x236>
  {
    case TIM_DMA_UPDATE:
    {
      /* Set the DMA Period elapsed callbacks */
      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
2401caa4:	68fb      	ldr	r3, [r7, #12]
2401caa6:	6a1b      	ldr	r3, [r3, #32]
2401caa8:	4a71      	ldr	r2, [pc, #452]	; (2401cc70 <HAL_TIM_DMABurst_MultiReadStart+0x284>)
2401caaa:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
2401caac:	68fb      	ldr	r3, [r7, #12]
2401caae:	6a1b      	ldr	r3, [r3, #32]
2401cab0:	4a70      	ldr	r2, [pc, #448]	; (2401cc74 <HAL_TIM_DMABurst_MultiReadStart+0x288>)
2401cab2:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
2401cab4:	68fb      	ldr	r3, [r7, #12]
2401cab6:	6a1b      	ldr	r3, [r3, #32]
2401cab8:	4a6f      	ldr	r2, [pc, #444]	; (2401cc78 <HAL_TIM_DMABurst_MultiReadStart+0x28c>)
2401caba:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2401cabc:	68fb      	ldr	r3, [r7, #12]
2401cabe:	6a18      	ldr	r0, [r3, #32]
2401cac0:	68fb      	ldr	r3, [r7, #12]
2401cac2:	681b      	ldr	r3, [r3, #0]
2401cac4:	334c      	adds	r3, #76	; 0x4c
2401cac6:	4619      	mov	r1, r3
2401cac8:	683a      	ldr	r2, [r7, #0]
2401caca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401cacc:	f7e7 f840 	bl	24003b50 <HAL_DMA_Start_IT>
2401cad0:	4603      	mov	r3, r0
2401cad2:	2b00      	cmp	r3, #0
2401cad4:	f000 80a8 	beq.w	2401cc28 <HAL_TIM_DMABurst_MultiReadStart+0x23c>
                           DataLength) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401cad8:	2301      	movs	r3, #1
2401cada:	e0c4      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
      break;
    }
    case TIM_DMA_CC1:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2401cadc:	68fb      	ldr	r3, [r7, #12]
2401cade:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401cae0:	4a66      	ldr	r2, [pc, #408]	; (2401cc7c <HAL_TIM_DMABurst_MultiReadStart+0x290>)
2401cae2:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401cae4:	68fb      	ldr	r3, [r7, #12]
2401cae6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401cae8:	4a65      	ldr	r2, [pc, #404]	; (2401cc80 <HAL_TIM_DMABurst_MultiReadStart+0x294>)
2401caea:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2401caec:	68fb      	ldr	r3, [r7, #12]
2401caee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401caf0:	4a61      	ldr	r2, [pc, #388]	; (2401cc78 <HAL_TIM_DMABurst_MultiReadStart+0x28c>)
2401caf2:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2401caf4:	68fb      	ldr	r3, [r7, #12]
2401caf6:	6a58      	ldr	r0, [r3, #36]	; 0x24
2401caf8:	68fb      	ldr	r3, [r7, #12]
2401cafa:	681b      	ldr	r3, [r3, #0]
2401cafc:	334c      	adds	r3, #76	; 0x4c
2401cafe:	4619      	mov	r1, r3
2401cb00:	683a      	ldr	r2, [r7, #0]
2401cb02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401cb04:	f7e7 f824 	bl	24003b50 <HAL_DMA_Start_IT>
2401cb08:	4603      	mov	r3, r0
2401cb0a:	2b00      	cmp	r3, #0
2401cb0c:	f000 808e 	beq.w	2401cc2c <HAL_TIM_DMABurst_MultiReadStart+0x240>
                           DataLength) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401cb10:	2301      	movs	r3, #1
2401cb12:	e0a8      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
      break;
    }
    case TIM_DMA_CC2:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2401cb14:	68fb      	ldr	r3, [r7, #12]
2401cb16:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401cb18:	4a58      	ldr	r2, [pc, #352]	; (2401cc7c <HAL_TIM_DMABurst_MultiReadStart+0x290>)
2401cb1a:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401cb1c:	68fb      	ldr	r3, [r7, #12]
2401cb1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401cb20:	4a57      	ldr	r2, [pc, #348]	; (2401cc80 <HAL_TIM_DMABurst_MultiReadStart+0x294>)
2401cb22:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
2401cb24:	68fb      	ldr	r3, [r7, #12]
2401cb26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401cb28:	4a53      	ldr	r2, [pc, #332]	; (2401cc78 <HAL_TIM_DMABurst_MultiReadStart+0x28c>)
2401cb2a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2401cb2c:	68fb      	ldr	r3, [r7, #12]
2401cb2e:	6a98      	ldr	r0, [r3, #40]	; 0x28
2401cb30:	68fb      	ldr	r3, [r7, #12]
2401cb32:	681b      	ldr	r3, [r3, #0]
2401cb34:	334c      	adds	r3, #76	; 0x4c
2401cb36:	4619      	mov	r1, r3
2401cb38:	683a      	ldr	r2, [r7, #0]
2401cb3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401cb3c:	f7e7 f808 	bl	24003b50 <HAL_DMA_Start_IT>
2401cb40:	4603      	mov	r3, r0
2401cb42:	2b00      	cmp	r3, #0
2401cb44:	d074      	beq.n	2401cc30 <HAL_TIM_DMABurst_MultiReadStart+0x244>
                           DataLength) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401cb46:	2301      	movs	r3, #1
2401cb48:	e08d      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
      break;
    }
    case TIM_DMA_CC3:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
2401cb4a:	68fb      	ldr	r3, [r7, #12]
2401cb4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401cb4e:	4a4b      	ldr	r2, [pc, #300]	; (2401cc7c <HAL_TIM_DMABurst_MultiReadStart+0x290>)
2401cb50:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401cb52:	68fb      	ldr	r3, [r7, #12]
2401cb54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401cb56:	4a4a      	ldr	r2, [pc, #296]	; (2401cc80 <HAL_TIM_DMABurst_MultiReadStart+0x294>)
2401cb58:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
2401cb5a:	68fb      	ldr	r3, [r7, #12]
2401cb5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401cb5e:	4a46      	ldr	r2, [pc, #280]	; (2401cc78 <HAL_TIM_DMABurst_MultiReadStart+0x28c>)
2401cb60:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2401cb62:	68fb      	ldr	r3, [r7, #12]
2401cb64:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2401cb66:	68fb      	ldr	r3, [r7, #12]
2401cb68:	681b      	ldr	r3, [r3, #0]
2401cb6a:	334c      	adds	r3, #76	; 0x4c
2401cb6c:	4619      	mov	r1, r3
2401cb6e:	683a      	ldr	r2, [r7, #0]
2401cb70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401cb72:	f7e6 ffed 	bl	24003b50 <HAL_DMA_Start_IT>
2401cb76:	4603      	mov	r3, r0
2401cb78:	2b00      	cmp	r3, #0
2401cb7a:	d05b      	beq.n	2401cc34 <HAL_TIM_DMABurst_MultiReadStart+0x248>
                           DataLength) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401cb7c:	2301      	movs	r3, #1
2401cb7e:	e072      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
      break;
    }
    case TIM_DMA_CC4:
    {
      /* Set the DMA capture callbacks */
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
2401cb80:	68fb      	ldr	r3, [r7, #12]
2401cb82:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401cb84:	4a3d      	ldr	r2, [pc, #244]	; (2401cc7c <HAL_TIM_DMABurst_MultiReadStart+0x290>)
2401cb86:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401cb88:	68fb      	ldr	r3, [r7, #12]
2401cb8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401cb8c:	4a3c      	ldr	r2, [pc, #240]	; (2401cc80 <HAL_TIM_DMABurst_MultiReadStart+0x294>)
2401cb8e:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
2401cb90:	68fb      	ldr	r3, [r7, #12]
2401cb92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401cb94:	4a38      	ldr	r2, [pc, #224]	; (2401cc78 <HAL_TIM_DMABurst_MultiReadStart+0x28c>)
2401cb96:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2401cb98:	68fb      	ldr	r3, [r7, #12]
2401cb9a:	6b18      	ldr	r0, [r3, #48]	; 0x30
2401cb9c:	68fb      	ldr	r3, [r7, #12]
2401cb9e:	681b      	ldr	r3, [r3, #0]
2401cba0:	334c      	adds	r3, #76	; 0x4c
2401cba2:	4619      	mov	r1, r3
2401cba4:	683a      	ldr	r2, [r7, #0]
2401cba6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401cba8:	f7e6 ffd2 	bl	24003b50 <HAL_DMA_Start_IT>
2401cbac:	4603      	mov	r3, r0
2401cbae:	2b00      	cmp	r3, #0
2401cbb0:	d042      	beq.n	2401cc38 <HAL_TIM_DMABurst_MultiReadStart+0x24c>
                           DataLength) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401cbb2:	2301      	movs	r3, #1
2401cbb4:	e057      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
      break;
    }
    case TIM_DMA_COM:
    {
      /* Set the DMA commutation callbacks */
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
2401cbb6:	68fb      	ldr	r3, [r7, #12]
2401cbb8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401cbba:	4a32      	ldr	r2, [pc, #200]	; (2401cc84 <HAL_TIM_DMABurst_MultiReadStart+0x298>)
2401cbbc:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
2401cbbe:	68fb      	ldr	r3, [r7, #12]
2401cbc0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401cbc2:	4a31      	ldr	r2, [pc, #196]	; (2401cc88 <HAL_TIM_DMABurst_MultiReadStart+0x29c>)
2401cbc4:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
2401cbc6:	68fb      	ldr	r3, [r7, #12]
2401cbc8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401cbca:	4a2b      	ldr	r2, [pc, #172]	; (2401cc78 <HAL_TIM_DMABurst_MultiReadStart+0x28c>)
2401cbcc:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2401cbce:	68fb      	ldr	r3, [r7, #12]
2401cbd0:	6b58      	ldr	r0, [r3, #52]	; 0x34
2401cbd2:	68fb      	ldr	r3, [r7, #12]
2401cbd4:	681b      	ldr	r3, [r3, #0]
2401cbd6:	334c      	adds	r3, #76	; 0x4c
2401cbd8:	4619      	mov	r1, r3
2401cbda:	683a      	ldr	r2, [r7, #0]
2401cbdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401cbde:	f7e6 ffb7 	bl	24003b50 <HAL_DMA_Start_IT>
2401cbe2:	4603      	mov	r3, r0
2401cbe4:	2b00      	cmp	r3, #0
2401cbe6:	d029      	beq.n	2401cc3c <HAL_TIM_DMABurst_MultiReadStart+0x250>
                           DataLength) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401cbe8:	2301      	movs	r3, #1
2401cbea:	e03c      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
      break;
    }
    case TIM_DMA_TRIGGER:
    {
      /* Set the DMA trigger callbacks */
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
2401cbec:	68fb      	ldr	r3, [r7, #12]
2401cbee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401cbf0:	4a26      	ldr	r2, [pc, #152]	; (2401cc8c <HAL_TIM_DMABurst_MultiReadStart+0x2a0>)
2401cbf2:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
2401cbf4:	68fb      	ldr	r3, [r7, #12]
2401cbf6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401cbf8:	4a25      	ldr	r2, [pc, #148]	; (2401cc90 <HAL_TIM_DMABurst_MultiReadStart+0x2a4>)
2401cbfa:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
2401cbfc:	68fb      	ldr	r3, [r7, #12]
2401cbfe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401cc00:	4a1d      	ldr	r2, [pc, #116]	; (2401cc78 <HAL_TIM_DMABurst_MultiReadStart+0x28c>)
2401cc02:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2401cc04:	68fb      	ldr	r3, [r7, #12]
2401cc06:	6b98      	ldr	r0, [r3, #56]	; 0x38
2401cc08:	68fb      	ldr	r3, [r7, #12]
2401cc0a:	681b      	ldr	r3, [r3, #0]
2401cc0c:	334c      	adds	r3, #76	; 0x4c
2401cc0e:	4619      	mov	r1, r3
2401cc10:	683a      	ldr	r2, [r7, #0]
2401cc12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401cc14:	f7e6 ff9c 	bl	24003b50 <HAL_DMA_Start_IT>
2401cc18:	4603      	mov	r3, r0
2401cc1a:	2b00      	cmp	r3, #0
2401cc1c:	d010      	beq.n	2401cc40 <HAL_TIM_DMABurst_MultiReadStart+0x254>
                           DataLength) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401cc1e:	2301      	movs	r3, #1
2401cc20:	e021      	b.n	2401cc66 <HAL_TIM_DMABurst_MultiReadStart+0x27a>
      }
      break;
    }
    default:
      status = HAL_ERROR;
2401cc22:	2301      	movs	r3, #1
2401cc24:	75fb      	strb	r3, [r7, #23]
      break;
2401cc26:	e00c      	b.n	2401cc42 <HAL_TIM_DMABurst_MultiReadStart+0x256>
      break;
2401cc28:	bf00      	nop
2401cc2a:	e00a      	b.n	2401cc42 <HAL_TIM_DMABurst_MultiReadStart+0x256>
      break;
2401cc2c:	bf00      	nop
2401cc2e:	e008      	b.n	2401cc42 <HAL_TIM_DMABurst_MultiReadStart+0x256>
      break;
2401cc30:	bf00      	nop
2401cc32:	e006      	b.n	2401cc42 <HAL_TIM_DMABurst_MultiReadStart+0x256>
      break;
2401cc34:	bf00      	nop
2401cc36:	e004      	b.n	2401cc42 <HAL_TIM_DMABurst_MultiReadStart+0x256>
      break;
2401cc38:	bf00      	nop
2401cc3a:	e002      	b.n	2401cc42 <HAL_TIM_DMABurst_MultiReadStart+0x256>
      break;
2401cc3c:	bf00      	nop
2401cc3e:	e000      	b.n	2401cc42 <HAL_TIM_DMABurst_MultiReadStart+0x256>
      break;
2401cc40:	bf00      	nop
  }

  if (status == HAL_OK)
2401cc42:	7dfb      	ldrb	r3, [r7, #23]
2401cc44:	2b00      	cmp	r3, #0
2401cc46:	d10d      	bne.n	2401cc64 <HAL_TIM_DMABurst_MultiReadStart+0x278>
  {
    /* Configure the DMA Burst Mode */
    htim->Instance->DCR = (BurstBaseAddress | BurstLength);
2401cc48:	68fb      	ldr	r3, [r7, #12]
2401cc4a:	681b      	ldr	r3, [r3, #0]
2401cc4c:	68b9      	ldr	r1, [r7, #8]
2401cc4e:	6a3a      	ldr	r2, [r7, #32]
2401cc50:	430a      	orrs	r2, r1
2401cc52:	649a      	str	r2, [r3, #72]	; 0x48

    /* Enable the TIM DMA Request */
    __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
2401cc54:	68fb      	ldr	r3, [r7, #12]
2401cc56:	681b      	ldr	r3, [r3, #0]
2401cc58:	68d9      	ldr	r1, [r3, #12]
2401cc5a:	68fb      	ldr	r3, [r7, #12]
2401cc5c:	681b      	ldr	r3, [r3, #0]
2401cc5e:	687a      	ldr	r2, [r7, #4]
2401cc60:	430a      	orrs	r2, r1
2401cc62:	60da      	str	r2, [r3, #12]
  }

  /* Return function status */
  return status;
2401cc64:	7dfb      	ldrb	r3, [r7, #23]
}
2401cc66:	4618      	mov	r0, r3
2401cc68:	3718      	adds	r7, #24
2401cc6a:	46bd      	mov	sp, r7
2401cc6c:	bd80      	pop	{r7, pc}
2401cc6e:	bf00      	nop
2401cc70:	2401d891 	.word	0x2401d891
2401cc74:	2401d8bf 	.word	0x2401d8bf
2401cc78:	2401d5bf 	.word	0x2401d5bf
2401cc7c:	2401d761 	.word	0x2401d761
2401cc80:	2401d829 	.word	0x2401d829
2401cc84:	24020c35 	.word	0x24020c35
2401cc88:	24020c59 	.word	0x24020c59
2401cc8c:	2401d8db 	.word	0x2401d8db
2401cc90:	2401d909 	.word	0x2401d909

2401cc94 <HAL_TIM_DMABurst_ReadStop>:
  * @param  htim TIM handle
  * @param  BurstRequestSrc TIM DMA Request sources to disable.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
{
2401cc94:	b580      	push	{r7, lr}
2401cc96:	b084      	sub	sp, #16
2401cc98:	af00      	add	r7, sp, #0
2401cc9a:	6078      	str	r0, [r7, #4]
2401cc9c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401cc9e:	2300      	movs	r3, #0
2401cca0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));

  /* Abort the DMA transfer (at least disable the DMA stream) */
  switch (BurstRequestSrc)
2401cca2:	683b      	ldr	r3, [r7, #0]
2401cca4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401cca8:	d050      	beq.n	2401cd4c <HAL_TIM_DMABurst_ReadStop+0xb8>
2401ccaa:	683b      	ldr	r3, [r7, #0]
2401ccac:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401ccb0:	d852      	bhi.n	2401cd58 <HAL_TIM_DMABurst_ReadStop+0xc4>
2401ccb2:	683b      	ldr	r3, [r7, #0]
2401ccb4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401ccb8:	d042      	beq.n	2401cd40 <HAL_TIM_DMABurst_ReadStop+0xac>
2401ccba:	683b      	ldr	r3, [r7, #0]
2401ccbc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401ccc0:	d84a      	bhi.n	2401cd58 <HAL_TIM_DMABurst_ReadStop+0xc4>
2401ccc2:	683b      	ldr	r3, [r7, #0]
2401ccc4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401ccc8:	d034      	beq.n	2401cd34 <HAL_TIM_DMABurst_ReadStop+0xa0>
2401ccca:	683b      	ldr	r3, [r7, #0]
2401cccc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401ccd0:	d842      	bhi.n	2401cd58 <HAL_TIM_DMABurst_ReadStop+0xc4>
2401ccd2:	683b      	ldr	r3, [r7, #0]
2401ccd4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401ccd8:	d026      	beq.n	2401cd28 <HAL_TIM_DMABurst_ReadStop+0x94>
2401ccda:	683b      	ldr	r3, [r7, #0]
2401ccdc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2401cce0:	d83a      	bhi.n	2401cd58 <HAL_TIM_DMABurst_ReadStop+0xc4>
2401cce2:	683b      	ldr	r3, [r7, #0]
2401cce4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401cce8:	d018      	beq.n	2401cd1c <HAL_TIM_DMABurst_ReadStop+0x88>
2401ccea:	683b      	ldr	r3, [r7, #0]
2401ccec:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2401ccf0:	d832      	bhi.n	2401cd58 <HAL_TIM_DMABurst_ReadStop+0xc4>
2401ccf2:	683b      	ldr	r3, [r7, #0]
2401ccf4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401ccf8:	d004      	beq.n	2401cd04 <HAL_TIM_DMABurst_ReadStop+0x70>
2401ccfa:	683b      	ldr	r3, [r7, #0]
2401ccfc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2401cd00:	d006      	beq.n	2401cd10 <HAL_TIM_DMABurst_ReadStop+0x7c>
2401cd02:	e029      	b.n	2401cd58 <HAL_TIM_DMABurst_ReadStop+0xc4>
  {
    case TIM_DMA_UPDATE:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
2401cd04:	687b      	ldr	r3, [r7, #4]
2401cd06:	6a1b      	ldr	r3, [r3, #32]
2401cd08:	4618      	mov	r0, r3
2401cd0a:	f7e7 fca9 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401cd0e:	e026      	b.n	2401cd5e <HAL_TIM_DMABurst_ReadStop+0xca>
    }
    case TIM_DMA_CC1:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2401cd10:	687b      	ldr	r3, [r7, #4]
2401cd12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401cd14:	4618      	mov	r0, r3
2401cd16:	f7e7 fca3 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401cd1a:	e020      	b.n	2401cd5e <HAL_TIM_DMABurst_ReadStop+0xca>
    }
    case TIM_DMA_CC2:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2401cd1c:	687b      	ldr	r3, [r7, #4]
2401cd1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401cd20:	4618      	mov	r0, r3
2401cd22:	f7e7 fc9d 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401cd26:	e01a      	b.n	2401cd5e <HAL_TIM_DMABurst_ReadStop+0xca>
    }
    case TIM_DMA_CC3:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2401cd28:	687b      	ldr	r3, [r7, #4]
2401cd2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401cd2c:	4618      	mov	r0, r3
2401cd2e:	f7e7 fc97 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401cd32:	e014      	b.n	2401cd5e <HAL_TIM_DMABurst_ReadStop+0xca>
    }
    case TIM_DMA_CC4:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2401cd34:	687b      	ldr	r3, [r7, #4]
2401cd36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401cd38:	4618      	mov	r0, r3
2401cd3a:	f7e7 fc91 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401cd3e:	e00e      	b.n	2401cd5e <HAL_TIM_DMABurst_ReadStop+0xca>
    }
    case TIM_DMA_COM:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
2401cd40:	687b      	ldr	r3, [r7, #4]
2401cd42:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401cd44:	4618      	mov	r0, r3
2401cd46:	f7e7 fc8b 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401cd4a:	e008      	b.n	2401cd5e <HAL_TIM_DMABurst_ReadStop+0xca>
    }
    case TIM_DMA_TRIGGER:
    {
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
2401cd4c:	687b      	ldr	r3, [r7, #4]
2401cd4e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401cd50:	4618      	mov	r0, r3
2401cd52:	f7e7 fc85 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401cd56:	e002      	b.n	2401cd5e <HAL_TIM_DMABurst_ReadStop+0xca>
    }
    default:
      status = HAL_ERROR;
2401cd58:	2301      	movs	r3, #1
2401cd5a:	73fb      	strb	r3, [r7, #15]
      break;
2401cd5c:	bf00      	nop
  }

  if (status == HAL_OK)
2401cd5e:	7bfb      	ldrb	r3, [r7, #15]
2401cd60:	2b00      	cmp	r3, #0
2401cd62:	d10c      	bne.n	2401cd7e <HAL_TIM_DMABurst_ReadStop+0xea>
  {
    /* Disable the TIM Update DMA request */
    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
2401cd64:	687b      	ldr	r3, [r7, #4]
2401cd66:	681b      	ldr	r3, [r3, #0]
2401cd68:	68d9      	ldr	r1, [r3, #12]
2401cd6a:	683b      	ldr	r3, [r7, #0]
2401cd6c:	43da      	mvns	r2, r3
2401cd6e:	687b      	ldr	r3, [r7, #4]
2401cd70:	681b      	ldr	r3, [r3, #0]
2401cd72:	400a      	ands	r2, r1
2401cd74:	60da      	str	r2, [r3, #12]

    /* Change the DMA burst operation state */
    htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
2401cd76:	687b      	ldr	r3, [r7, #4]
2401cd78:	2201      	movs	r2, #1
2401cd7a:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
  }

  /* Return function status */
  return status;
2401cd7e:	7bfb      	ldrb	r3, [r7, #15]
}
2401cd80:	4618      	mov	r0, r3
2401cd82:	3710      	adds	r7, #16
2401cd84:	46bd      	mov	sp, r7
2401cd86:	bd80      	pop	{r7, pc}

2401cd88 <HAL_TIM_GenerateEvent>:
  *         only for timer instances supporting break input(s).
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
{
2401cd88:	b480      	push	{r7}
2401cd8a:	b083      	sub	sp, #12
2401cd8c:	af00      	add	r7, sp, #0
2401cd8e:	6078      	str	r0, [r7, #4]
2401cd90:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_EVENT_SOURCE(EventSource));

  /* Process Locked */
  __HAL_LOCK(htim);
2401cd92:	687b      	ldr	r3, [r7, #4]
2401cd94:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401cd98:	2b01      	cmp	r3, #1
2401cd9a:	d101      	bne.n	2401cda0 <HAL_TIM_GenerateEvent+0x18>
2401cd9c:	2302      	movs	r3, #2
2401cd9e:	e014      	b.n	2401cdca <HAL_TIM_GenerateEvent+0x42>
2401cda0:	687b      	ldr	r3, [r7, #4]
2401cda2:	2201      	movs	r2, #1
2401cda4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
2401cda8:	687b      	ldr	r3, [r7, #4]
2401cdaa:	2202      	movs	r2, #2
2401cdac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the event sources */
  htim->Instance->EGR = EventSource;
2401cdb0:	687b      	ldr	r3, [r7, #4]
2401cdb2:	681b      	ldr	r3, [r3, #0]
2401cdb4:	683a      	ldr	r2, [r7, #0]
2401cdb6:	615a      	str	r2, [r3, #20]

  /* Change the TIM state */
  htim->State = HAL_TIM_STATE_READY;
2401cdb8:	687b      	ldr	r3, [r7, #4]
2401cdba:	2201      	movs	r2, #1
2401cdbc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
2401cdc0:	687b      	ldr	r3, [r7, #4]
2401cdc2:	2200      	movs	r2, #0
2401cdc4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Return function status */
  return HAL_OK;
2401cdc8:	2300      	movs	r3, #0
}
2401cdca:	4618      	mov	r0, r3
2401cdcc:	370c      	adds	r7, #12
2401cdce:	46bd      	mov	sp, r7
2401cdd0:	f85d 7b04 	ldr.w	r7, [sp], #4
2401cdd4:	4770      	bx	lr
	...

2401cdd8 <HAL_TIM_ConfigOCrefClear>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
                                           const TIM_ClearInputConfigTypeDef *sClearInputConfig,
                                           uint32_t Channel)
{
2401cdd8:	b580      	push	{r7, lr}
2401cdda:	b086      	sub	sp, #24
2401cddc:	af00      	add	r7, sp, #0
2401cdde:	60f8      	str	r0, [r7, #12]
2401cde0:	60b9      	str	r1, [r7, #8]
2401cde2:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2401cde4:	2300      	movs	r3, #0
2401cde6:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
  assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));

  /* Process Locked */
  __HAL_LOCK(htim);
2401cde8:	68fb      	ldr	r3, [r7, #12]
2401cdea:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401cdee:	2b01      	cmp	r3, #1
2401cdf0:	d101      	bne.n	2401cdf6 <HAL_TIM_ConfigOCrefClear+0x1e>
2401cdf2:	2302      	movs	r3, #2
2401cdf4:	e0f8      	b.n	2401cfe8 <HAL_TIM_ConfigOCrefClear+0x210>
2401cdf6:	68fb      	ldr	r3, [r7, #12]
2401cdf8:	2201      	movs	r2, #1
2401cdfa:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
2401cdfe:	68fb      	ldr	r3, [r7, #12]
2401ce00:	2202      	movs	r2, #2
2401ce02:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  switch (sClearInputConfig->ClearInputSource)
2401ce06:	68bb      	ldr	r3, [r7, #8]
2401ce08:	685b      	ldr	r3, [r3, #4]
2401ce0a:	2b00      	cmp	r3, #0
2401ce0c:	d002      	beq.n	2401ce14 <HAL_TIM_ConfigOCrefClear+0x3c>
2401ce0e:	2b01      	cmp	r3, #1
2401ce10:	d009      	beq.n	2401ce26 <HAL_TIM_ConfigOCrefClear+0x4e>
2401ce12:	e021      	b.n	2401ce58 <HAL_TIM_ConfigOCrefClear+0x80>
  {
    case TIM_CLEARINPUTSOURCE_NONE:
    {
      /* Clear the OCREF clear selection bit and the the ETR Bits */
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
2401ce14:	68fb      	ldr	r3, [r7, #12]
2401ce16:	681b      	ldr	r3, [r3, #0]
2401ce18:	689a      	ldr	r2, [r3, #8]
2401ce1a:	68fb      	ldr	r3, [r7, #12]
2401ce1c:	681b      	ldr	r3, [r3, #0]
2401ce1e:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
2401ce22:	609a      	str	r2, [r3, #8]
      break;
2401ce24:	e01b      	b.n	2401ce5e <HAL_TIM_ConfigOCrefClear+0x86>
      assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
      assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
      assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));

      /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
      if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
2401ce26:	68bb      	ldr	r3, [r7, #8]
2401ce28:	68db      	ldr	r3, [r3, #12]
2401ce2a:	2b00      	cmp	r3, #0
2401ce2c:	d009      	beq.n	2401ce42 <HAL_TIM_ConfigOCrefClear+0x6a>
      {
        htim->State = HAL_TIM_STATE_READY;
2401ce2e:	68fb      	ldr	r3, [r7, #12]
2401ce30:	2201      	movs	r2, #1
2401ce32:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        __HAL_UNLOCK(htim);
2401ce36:	68fb      	ldr	r3, [r7, #12]
2401ce38:	2200      	movs	r2, #0
2401ce3a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        return HAL_ERROR;
2401ce3e:	2301      	movs	r3, #1
2401ce40:	e0d2      	b.n	2401cfe8 <HAL_TIM_ConfigOCrefClear+0x210>
      }

      TIM_ETR_SetConfig(htim->Instance,
2401ce42:	68fb      	ldr	r3, [r7, #12]
2401ce44:	6818      	ldr	r0, [r3, #0]
2401ce46:	68bb      	ldr	r3, [r7, #8]
2401ce48:	68d9      	ldr	r1, [r3, #12]
2401ce4a:	68bb      	ldr	r3, [r7, #8]
2401ce4c:	689a      	ldr	r2, [r3, #8]
2401ce4e:	68bb      	ldr	r3, [r7, #8]
2401ce50:	691b      	ldr	r3, [r3, #16]
2401ce52:	f001 fb69 	bl	2401e528 <TIM_ETR_SetConfig>
                        sClearInputConfig->ClearInputPrescaler,
                        sClearInputConfig->ClearInputPolarity,
                        sClearInputConfig->ClearInputFilter);
      break;
2401ce56:	e002      	b.n	2401ce5e <HAL_TIM_ConfigOCrefClear+0x86>
    }

    default:
      status = HAL_ERROR;
2401ce58:	2301      	movs	r3, #1
2401ce5a:	75fb      	strb	r3, [r7, #23]
      break;
2401ce5c:	bf00      	nop
  }

  if (status == HAL_OK)
2401ce5e:	7dfb      	ldrb	r3, [r7, #23]
2401ce60:	2b00      	cmp	r3, #0
2401ce62:	f040 80b5 	bne.w	2401cfd0 <HAL_TIM_ConfigOCrefClear+0x1f8>
  {
    switch (Channel)
2401ce66:	687b      	ldr	r3, [r7, #4]
2401ce68:	2b14      	cmp	r3, #20
2401ce6a:	f200 80b3 	bhi.w	2401cfd4 <HAL_TIM_ConfigOCrefClear+0x1fc>
2401ce6e:	a201      	add	r2, pc, #4	; (adr r2, 2401ce74 <HAL_TIM_ConfigOCrefClear+0x9c>)
2401ce70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401ce74:	2401cec9 	.word	0x2401cec9
2401ce78:	2401cfd5 	.word	0x2401cfd5
2401ce7c:	2401cfd5 	.word	0x2401cfd5
2401ce80:	2401cfd5 	.word	0x2401cfd5
2401ce84:	2401cef5 	.word	0x2401cef5
2401ce88:	2401cfd5 	.word	0x2401cfd5
2401ce8c:	2401cfd5 	.word	0x2401cfd5
2401ce90:	2401cfd5 	.word	0x2401cfd5
2401ce94:	2401cf21 	.word	0x2401cf21
2401ce98:	2401cfd5 	.word	0x2401cfd5
2401ce9c:	2401cfd5 	.word	0x2401cfd5
2401cea0:	2401cfd5 	.word	0x2401cfd5
2401cea4:	2401cf4d 	.word	0x2401cf4d
2401cea8:	2401cfd5 	.word	0x2401cfd5
2401ceac:	2401cfd5 	.word	0x2401cfd5
2401ceb0:	2401cfd5 	.word	0x2401cfd5
2401ceb4:	2401cf79 	.word	0x2401cf79
2401ceb8:	2401cfd5 	.word	0x2401cfd5
2401cebc:	2401cfd5 	.word	0x2401cfd5
2401cec0:	2401cfd5 	.word	0x2401cfd5
2401cec4:	2401cfa5 	.word	0x2401cfa5
    {
      case TIM_CHANNEL_1:
      {
        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2401cec8:	68bb      	ldr	r3, [r7, #8]
2401ceca:	681b      	ldr	r3, [r3, #0]
2401cecc:	2b00      	cmp	r3, #0
2401cece:	d008      	beq.n	2401cee2 <HAL_TIM_ConfigOCrefClear+0x10a>
        {
          /* Enable the OCREF clear feature for Channel 1 */
          SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
2401ced0:	68fb      	ldr	r3, [r7, #12]
2401ced2:	681b      	ldr	r3, [r3, #0]
2401ced4:	699a      	ldr	r2, [r3, #24]
2401ced6:	68fb      	ldr	r3, [r7, #12]
2401ced8:	681b      	ldr	r3, [r3, #0]
2401ceda:	f042 0280 	orr.w	r2, r2, #128	; 0x80
2401cede:	619a      	str	r2, [r3, #24]
        else
        {
          /* Disable the OCREF clear feature for Channel 1 */
          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
        }
        break;
2401cee0:	e079      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
2401cee2:	68fb      	ldr	r3, [r7, #12]
2401cee4:	681b      	ldr	r3, [r3, #0]
2401cee6:	699a      	ldr	r2, [r3, #24]
2401cee8:	68fb      	ldr	r3, [r7, #12]
2401ceea:	681b      	ldr	r3, [r3, #0]
2401ceec:	f022 0280 	bic.w	r2, r2, #128	; 0x80
2401cef0:	619a      	str	r2, [r3, #24]
        break;
2401cef2:	e070      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
      }
      case TIM_CHANNEL_2:
      {
        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2401cef4:	68bb      	ldr	r3, [r7, #8]
2401cef6:	681b      	ldr	r3, [r3, #0]
2401cef8:	2b00      	cmp	r3, #0
2401cefa:	d008      	beq.n	2401cf0e <HAL_TIM_ConfigOCrefClear+0x136>
        {
          /* Enable the OCREF clear feature for Channel 2 */
          SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
2401cefc:	68fb      	ldr	r3, [r7, #12]
2401cefe:	681b      	ldr	r3, [r3, #0]
2401cf00:	699a      	ldr	r2, [r3, #24]
2401cf02:	68fb      	ldr	r3, [r7, #12]
2401cf04:	681b      	ldr	r3, [r3, #0]
2401cf06:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401cf0a:	619a      	str	r2, [r3, #24]
        else
        {
          /* Disable the OCREF clear feature for Channel 2 */
          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
        }
        break;
2401cf0c:	e063      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
2401cf0e:	68fb      	ldr	r3, [r7, #12]
2401cf10:	681b      	ldr	r3, [r3, #0]
2401cf12:	699a      	ldr	r2, [r3, #24]
2401cf14:	68fb      	ldr	r3, [r7, #12]
2401cf16:	681b      	ldr	r3, [r3, #0]
2401cf18:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401cf1c:	619a      	str	r2, [r3, #24]
        break;
2401cf1e:	e05a      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
      }
      case TIM_CHANNEL_3:
      {
        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2401cf20:	68bb      	ldr	r3, [r7, #8]
2401cf22:	681b      	ldr	r3, [r3, #0]
2401cf24:	2b00      	cmp	r3, #0
2401cf26:	d008      	beq.n	2401cf3a <HAL_TIM_ConfigOCrefClear+0x162>
        {
          /* Enable the OCREF clear feature for Channel 3 */
          SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
2401cf28:	68fb      	ldr	r3, [r7, #12]
2401cf2a:	681b      	ldr	r3, [r3, #0]
2401cf2c:	69da      	ldr	r2, [r3, #28]
2401cf2e:	68fb      	ldr	r3, [r7, #12]
2401cf30:	681b      	ldr	r3, [r3, #0]
2401cf32:	f042 0280 	orr.w	r2, r2, #128	; 0x80
2401cf36:	61da      	str	r2, [r3, #28]
        else
        {
          /* Disable the OCREF clear feature for Channel 3 */
          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
        }
        break;
2401cf38:	e04d      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
2401cf3a:	68fb      	ldr	r3, [r7, #12]
2401cf3c:	681b      	ldr	r3, [r3, #0]
2401cf3e:	69da      	ldr	r2, [r3, #28]
2401cf40:	68fb      	ldr	r3, [r7, #12]
2401cf42:	681b      	ldr	r3, [r3, #0]
2401cf44:	f022 0280 	bic.w	r2, r2, #128	; 0x80
2401cf48:	61da      	str	r2, [r3, #28]
        break;
2401cf4a:	e044      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
      }
      case TIM_CHANNEL_4:
      {
        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2401cf4c:	68bb      	ldr	r3, [r7, #8]
2401cf4e:	681b      	ldr	r3, [r3, #0]
2401cf50:	2b00      	cmp	r3, #0
2401cf52:	d008      	beq.n	2401cf66 <HAL_TIM_ConfigOCrefClear+0x18e>
        {
          /* Enable the OCREF clear feature for Channel 4 */
          SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
2401cf54:	68fb      	ldr	r3, [r7, #12]
2401cf56:	681b      	ldr	r3, [r3, #0]
2401cf58:	69da      	ldr	r2, [r3, #28]
2401cf5a:	68fb      	ldr	r3, [r7, #12]
2401cf5c:	681b      	ldr	r3, [r3, #0]
2401cf5e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401cf62:	61da      	str	r2, [r3, #28]
        else
        {
          /* Disable the OCREF clear feature for Channel 4 */
          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
        }
        break;
2401cf64:	e037      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
2401cf66:	68fb      	ldr	r3, [r7, #12]
2401cf68:	681b      	ldr	r3, [r3, #0]
2401cf6a:	69da      	ldr	r2, [r3, #28]
2401cf6c:	68fb      	ldr	r3, [r7, #12]
2401cf6e:	681b      	ldr	r3, [r3, #0]
2401cf70:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401cf74:	61da      	str	r2, [r3, #28]
        break;
2401cf76:	e02e      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
      }
      case TIM_CHANNEL_5:
      {
        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2401cf78:	68bb      	ldr	r3, [r7, #8]
2401cf7a:	681b      	ldr	r3, [r3, #0]
2401cf7c:	2b00      	cmp	r3, #0
2401cf7e:	d008      	beq.n	2401cf92 <HAL_TIM_ConfigOCrefClear+0x1ba>
        {
          /* Enable the OCREF clear feature for Channel 5 */
          SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
2401cf80:	68fb      	ldr	r3, [r7, #12]
2401cf82:	681b      	ldr	r3, [r3, #0]
2401cf84:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2401cf86:	68fb      	ldr	r3, [r7, #12]
2401cf88:	681b      	ldr	r3, [r3, #0]
2401cf8a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
2401cf8e:	655a      	str	r2, [r3, #84]	; 0x54
        else
        {
          /* Disable the OCREF clear feature for Channel 5 */
          CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
        }
        break;
2401cf90:	e021      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
          CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
2401cf92:	68fb      	ldr	r3, [r7, #12]
2401cf94:	681b      	ldr	r3, [r3, #0]
2401cf96:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2401cf98:	68fb      	ldr	r3, [r7, #12]
2401cf9a:	681b      	ldr	r3, [r3, #0]
2401cf9c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
2401cfa0:	655a      	str	r2, [r3, #84]	; 0x54
        break;
2401cfa2:	e018      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
      }
      case TIM_CHANNEL_6:
      {
        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2401cfa4:	68bb      	ldr	r3, [r7, #8]
2401cfa6:	681b      	ldr	r3, [r3, #0]
2401cfa8:	2b00      	cmp	r3, #0
2401cfaa:	d008      	beq.n	2401cfbe <HAL_TIM_ConfigOCrefClear+0x1e6>
        {
          /* Enable the OCREF clear feature for Channel 6 */
          SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
2401cfac:	68fb      	ldr	r3, [r7, #12]
2401cfae:	681b      	ldr	r3, [r3, #0]
2401cfb0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2401cfb2:	68fb      	ldr	r3, [r7, #12]
2401cfb4:	681b      	ldr	r3, [r3, #0]
2401cfb6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401cfba:	655a      	str	r2, [r3, #84]	; 0x54
        else
        {
          /* Disable the OCREF clear feature for Channel 6 */
          CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
        }
        break;
2401cfbc:	e00b      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
          CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
2401cfbe:	68fb      	ldr	r3, [r7, #12]
2401cfc0:	681b      	ldr	r3, [r3, #0]
2401cfc2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2401cfc4:	68fb      	ldr	r3, [r7, #12]
2401cfc6:	681b      	ldr	r3, [r3, #0]
2401cfc8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401cfcc:	655a      	str	r2, [r3, #84]	; 0x54
        break;
2401cfce:	e002      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
      }
      default:
        break;
    }
  }
2401cfd0:	bf00      	nop
2401cfd2:	e000      	b.n	2401cfd6 <HAL_TIM_ConfigOCrefClear+0x1fe>
        break;
2401cfd4:	bf00      	nop

  htim->State = HAL_TIM_STATE_READY;
2401cfd6:	68fb      	ldr	r3, [r7, #12]
2401cfd8:	2201      	movs	r2, #1
2401cfda:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
2401cfde:	68fb      	ldr	r3, [r7, #12]
2401cfe0:	2200      	movs	r2, #0
2401cfe2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2401cfe6:	7dfb      	ldrb	r3, [r7, #23]
}
2401cfe8:	4618      	mov	r0, r3
2401cfea:	3718      	adds	r7, #24
2401cfec:	46bd      	mov	sp, r7
2401cfee:	bd80      	pop	{r7, pc}

2401cff0 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, const TIM_ClockConfigTypeDef *sClockSourceConfig)
{
2401cff0:	b580      	push	{r7, lr}
2401cff2:	b084      	sub	sp, #16
2401cff4:	af00      	add	r7, sp, #0
2401cff6:	6078      	str	r0, [r7, #4]
2401cff8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401cffa:	2300      	movs	r3, #0
2401cffc:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
2401cffe:	687b      	ldr	r3, [r7, #4]
2401d000:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401d004:	2b01      	cmp	r3, #1
2401d006:	d101      	bne.n	2401d00c <HAL_TIM_ConfigClockSource+0x1c>
2401d008:	2302      	movs	r3, #2
2401d00a:	e0dc      	b.n	2401d1c6 <HAL_TIM_ConfigClockSource+0x1d6>
2401d00c:	687b      	ldr	r3, [r7, #4]
2401d00e:	2201      	movs	r2, #1
2401d010:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
2401d014:	687b      	ldr	r3, [r7, #4]
2401d016:	2202      	movs	r2, #2
2401d018:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
2401d01c:	687b      	ldr	r3, [r7, #4]
2401d01e:	681b      	ldr	r3, [r3, #0]
2401d020:	689b      	ldr	r3, [r3, #8]
2401d022:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
2401d024:	68ba      	ldr	r2, [r7, #8]
2401d026:	4b6a      	ldr	r3, [pc, #424]	; (2401d1d0 <HAL_TIM_ConfigClockSource+0x1e0>)
2401d028:	4013      	ands	r3, r2
2401d02a:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
2401d02c:	68bb      	ldr	r3, [r7, #8]
2401d02e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
2401d032:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
2401d034:	687b      	ldr	r3, [r7, #4]
2401d036:	681b      	ldr	r3, [r3, #0]
2401d038:	68ba      	ldr	r2, [r7, #8]
2401d03a:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
2401d03c:	683b      	ldr	r3, [r7, #0]
2401d03e:	681b      	ldr	r3, [r3, #0]
2401d040:	4a64      	ldr	r2, [pc, #400]	; (2401d1d4 <HAL_TIM_ConfigClockSource+0x1e4>)
2401d042:	4293      	cmp	r3, r2
2401d044:	f000 80a9 	beq.w	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d048:	4a62      	ldr	r2, [pc, #392]	; (2401d1d4 <HAL_TIM_ConfigClockSource+0x1e4>)
2401d04a:	4293      	cmp	r3, r2
2401d04c:	f200 80ae 	bhi.w	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d050:	4a61      	ldr	r2, [pc, #388]	; (2401d1d8 <HAL_TIM_ConfigClockSource+0x1e8>)
2401d052:	4293      	cmp	r3, r2
2401d054:	f000 80a1 	beq.w	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d058:	4a5f      	ldr	r2, [pc, #380]	; (2401d1d8 <HAL_TIM_ConfigClockSource+0x1e8>)
2401d05a:	4293      	cmp	r3, r2
2401d05c:	f200 80a6 	bhi.w	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d060:	4a5e      	ldr	r2, [pc, #376]	; (2401d1dc <HAL_TIM_ConfigClockSource+0x1ec>)
2401d062:	4293      	cmp	r3, r2
2401d064:	f000 8099 	beq.w	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d068:	4a5c      	ldr	r2, [pc, #368]	; (2401d1dc <HAL_TIM_ConfigClockSource+0x1ec>)
2401d06a:	4293      	cmp	r3, r2
2401d06c:	f200 809e 	bhi.w	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d070:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
2401d074:	f000 8091 	beq.w	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d078:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
2401d07c:	f200 8096 	bhi.w	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d080:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2401d084:	f000 8089 	beq.w	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d088:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2401d08c:	f200 808e 	bhi.w	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d090:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401d094:	d03e      	beq.n	2401d114 <HAL_TIM_ConfigClockSource+0x124>
2401d096:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401d09a:	f200 8087 	bhi.w	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d09e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401d0a2:	f000 8086 	beq.w	2401d1b2 <HAL_TIM_ConfigClockSource+0x1c2>
2401d0a6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401d0aa:	d87f      	bhi.n	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d0ac:	2b70      	cmp	r3, #112	; 0x70
2401d0ae:	d01a      	beq.n	2401d0e6 <HAL_TIM_ConfigClockSource+0xf6>
2401d0b0:	2b70      	cmp	r3, #112	; 0x70
2401d0b2:	d87b      	bhi.n	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d0b4:	2b60      	cmp	r3, #96	; 0x60
2401d0b6:	d050      	beq.n	2401d15a <HAL_TIM_ConfigClockSource+0x16a>
2401d0b8:	2b60      	cmp	r3, #96	; 0x60
2401d0ba:	d877      	bhi.n	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d0bc:	2b50      	cmp	r3, #80	; 0x50
2401d0be:	d03c      	beq.n	2401d13a <HAL_TIM_ConfigClockSource+0x14a>
2401d0c0:	2b50      	cmp	r3, #80	; 0x50
2401d0c2:	d873      	bhi.n	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d0c4:	2b40      	cmp	r3, #64	; 0x40
2401d0c6:	d058      	beq.n	2401d17a <HAL_TIM_ConfigClockSource+0x18a>
2401d0c8:	2b40      	cmp	r3, #64	; 0x40
2401d0ca:	d86f      	bhi.n	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d0cc:	2b30      	cmp	r3, #48	; 0x30
2401d0ce:	d064      	beq.n	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d0d0:	2b30      	cmp	r3, #48	; 0x30
2401d0d2:	d86b      	bhi.n	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d0d4:	2b20      	cmp	r3, #32
2401d0d6:	d060      	beq.n	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d0d8:	2b20      	cmp	r3, #32
2401d0da:	d867      	bhi.n	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
2401d0dc:	2b00      	cmp	r3, #0
2401d0de:	d05c      	beq.n	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d0e0:	2b10      	cmp	r3, #16
2401d0e2:	d05a      	beq.n	2401d19a <HAL_TIM_ConfigClockSource+0x1aa>
2401d0e4:	e062      	b.n	2401d1ac <HAL_TIM_ConfigClockSource+0x1bc>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
2401d0e6:	687b      	ldr	r3, [r7, #4]
2401d0e8:	6818      	ldr	r0, [r3, #0]
2401d0ea:	683b      	ldr	r3, [r7, #0]
2401d0ec:	6899      	ldr	r1, [r3, #8]
2401d0ee:	683b      	ldr	r3, [r7, #0]
2401d0f0:	685a      	ldr	r2, [r3, #4]
2401d0f2:	683b      	ldr	r3, [r7, #0]
2401d0f4:	68db      	ldr	r3, [r3, #12]
2401d0f6:	f001 fa17 	bl	2401e528 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
2401d0fa:	687b      	ldr	r3, [r7, #4]
2401d0fc:	681b      	ldr	r3, [r3, #0]
2401d0fe:	689b      	ldr	r3, [r3, #8]
2401d100:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
2401d102:	68bb      	ldr	r3, [r7, #8]
2401d104:	f043 0377 	orr.w	r3, r3, #119	; 0x77
2401d108:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
2401d10a:	687b      	ldr	r3, [r7, #4]
2401d10c:	681b      	ldr	r3, [r3, #0]
2401d10e:	68ba      	ldr	r2, [r7, #8]
2401d110:	609a      	str	r2, [r3, #8]
      break;
2401d112:	e04f      	b.n	2401d1b4 <HAL_TIM_ConfigClockSource+0x1c4>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
2401d114:	687b      	ldr	r3, [r7, #4]
2401d116:	6818      	ldr	r0, [r3, #0]
2401d118:	683b      	ldr	r3, [r7, #0]
2401d11a:	6899      	ldr	r1, [r3, #8]
2401d11c:	683b      	ldr	r3, [r7, #0]
2401d11e:	685a      	ldr	r2, [r3, #4]
2401d120:	683b      	ldr	r3, [r7, #0]
2401d122:	68db      	ldr	r3, [r3, #12]
2401d124:	f001 fa00 	bl	2401e528 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
2401d128:	687b      	ldr	r3, [r7, #4]
2401d12a:	681b      	ldr	r3, [r3, #0]
2401d12c:	689a      	ldr	r2, [r3, #8]
2401d12e:	687b      	ldr	r3, [r7, #4]
2401d130:	681b      	ldr	r3, [r3, #0]
2401d132:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2401d136:	609a      	str	r2, [r3, #8]
      break;
2401d138:	e03c      	b.n	2401d1b4 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
2401d13a:	687b      	ldr	r3, [r7, #4]
2401d13c:	6818      	ldr	r0, [r3, #0]
2401d13e:	683b      	ldr	r3, [r7, #0]
2401d140:	6859      	ldr	r1, [r3, #4]
2401d142:	683b      	ldr	r3, [r7, #0]
2401d144:	68db      	ldr	r3, [r3, #12]
2401d146:	461a      	mov	r2, r3
2401d148:	f001 f8ba 	bl	2401e2c0 <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
2401d14c:	687b      	ldr	r3, [r7, #4]
2401d14e:	681b      	ldr	r3, [r3, #0]
2401d150:	2150      	movs	r1, #80	; 0x50
2401d152:	4618      	mov	r0, r3
2401d154:	f001 f9ca 	bl	2401e4ec <TIM_ITRx_SetConfig>
      break;
2401d158:	e02c      	b.n	2401d1b4 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
2401d15a:	687b      	ldr	r3, [r7, #4]
2401d15c:	6818      	ldr	r0, [r3, #0]
2401d15e:	683b      	ldr	r3, [r7, #0]
2401d160:	6859      	ldr	r1, [r3, #4]
2401d162:	683b      	ldr	r3, [r7, #0]
2401d164:	68db      	ldr	r3, [r3, #12]
2401d166:	461a      	mov	r2, r3
2401d168:	f001 f916 	bl	2401e398 <TIM_TI2_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
2401d16c:	687b      	ldr	r3, [r7, #4]
2401d16e:	681b      	ldr	r3, [r3, #0]
2401d170:	2160      	movs	r1, #96	; 0x60
2401d172:	4618      	mov	r0, r3
2401d174:	f001 f9ba 	bl	2401e4ec <TIM_ITRx_SetConfig>
      break;
2401d178:	e01c      	b.n	2401d1b4 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
2401d17a:	687b      	ldr	r3, [r7, #4]
2401d17c:	6818      	ldr	r0, [r3, #0]
2401d17e:	683b      	ldr	r3, [r7, #0]
2401d180:	6859      	ldr	r1, [r3, #4]
2401d182:	683b      	ldr	r3, [r7, #0]
2401d184:	68db      	ldr	r3, [r3, #12]
2401d186:	461a      	mov	r2, r3
2401d188:	f001 f89a 	bl	2401e2c0 <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
2401d18c:	687b      	ldr	r3, [r7, #4]
2401d18e:	681b      	ldr	r3, [r3, #0]
2401d190:	2140      	movs	r1, #64	; 0x40
2401d192:	4618      	mov	r0, r3
2401d194:	f001 f9aa 	bl	2401e4ec <TIM_ITRx_SetConfig>
      break;
2401d198:	e00c      	b.n	2401d1b4 <HAL_TIM_ConfigClockSource+0x1c4>
    case TIM_CLOCKSOURCE_ITR8:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
2401d19a:	687b      	ldr	r3, [r7, #4]
2401d19c:	681a      	ldr	r2, [r3, #0]
2401d19e:	683b      	ldr	r3, [r7, #0]
2401d1a0:	681b      	ldr	r3, [r3, #0]
2401d1a2:	4619      	mov	r1, r3
2401d1a4:	4610      	mov	r0, r2
2401d1a6:	f001 f9a1 	bl	2401e4ec <TIM_ITRx_SetConfig>
      break;
2401d1aa:	e003      	b.n	2401d1b4 <HAL_TIM_ConfigClockSource+0x1c4>
    }

    default:
      status = HAL_ERROR;
2401d1ac:	2301      	movs	r3, #1
2401d1ae:	73fb      	strb	r3, [r7, #15]
      break;
2401d1b0:	e000      	b.n	2401d1b4 <HAL_TIM_ConfigClockSource+0x1c4>
      break;
2401d1b2:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
2401d1b4:	687b      	ldr	r3, [r7, #4]
2401d1b6:	2201      	movs	r2, #1
2401d1b8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
2401d1bc:	687b      	ldr	r3, [r7, #4]
2401d1be:	2200      	movs	r2, #0
2401d1c0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2401d1c4:	7bfb      	ldrb	r3, [r7, #15]
}
2401d1c6:	4618      	mov	r0, r3
2401d1c8:	3710      	adds	r7, #16
2401d1ca:	46bd      	mov	sp, r7
2401d1cc:	bd80      	pop	{r7, pc}
2401d1ce:	bf00      	nop
2401d1d0:	ffceff88 	.word	0xffceff88
2401d1d4:	00100040 	.word	0x00100040
2401d1d8:	00100030 	.word	0x00100030
2401d1dc:	00100020 	.word	0x00100020

2401d1e0 <HAL_TIM_ConfigTI1Input>:
  *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
  *            pins are connected to the TI1 input (XOR combination)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
{
2401d1e0:	b480      	push	{r7}
2401d1e2:	b085      	sub	sp, #20
2401d1e4:	af00      	add	r7, sp, #0
2401d1e6:	6078      	str	r0, [r7, #4]
2401d1e8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TI1SELECTION(TI1_Selection));

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
2401d1ea:	687b      	ldr	r3, [r7, #4]
2401d1ec:	681b      	ldr	r3, [r3, #0]
2401d1ee:	685b      	ldr	r3, [r3, #4]
2401d1f0:	60fb      	str	r3, [r7, #12]

  /* Reset the TI1 selection */
  tmpcr2 &= ~TIM_CR2_TI1S;
2401d1f2:	68fb      	ldr	r3, [r7, #12]
2401d1f4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
2401d1f8:	60fb      	str	r3, [r7, #12]

  /* Set the TI1 selection */
  tmpcr2 |= TI1_Selection;
2401d1fa:	68fa      	ldr	r2, [r7, #12]
2401d1fc:	683b      	ldr	r3, [r7, #0]
2401d1fe:	4313      	orrs	r3, r2
2401d200:	60fb      	str	r3, [r7, #12]

  /* Write to TIMxCR2 */
  htim->Instance->CR2 = tmpcr2;
2401d202:	687b      	ldr	r3, [r7, #4]
2401d204:	681b      	ldr	r3, [r3, #0]
2401d206:	68fa      	ldr	r2, [r7, #12]
2401d208:	605a      	str	r2, [r3, #4]

  return HAL_OK;
2401d20a:	2300      	movs	r3, #0
}
2401d20c:	4618      	mov	r0, r3
2401d20e:	3714      	adds	r7, #20
2401d210:	46bd      	mov	sp, r7
2401d212:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d216:	4770      	bx	lr

2401d218 <HAL_TIM_SlaveConfigSynchro>:
  *         timer input or external trigger input) and the Slave mode
  *         (Disable, Reset, Gated, Trigger, External clock mode 1).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, const TIM_SlaveConfigTypeDef *sSlaveConfig)
{
2401d218:	b580      	push	{r7, lr}
2401d21a:	b082      	sub	sp, #8
2401d21c:	af00      	add	r7, sp, #0
2401d21e:	6078      	str	r0, [r7, #4]
2401d220:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));

  __HAL_LOCK(htim);
2401d222:	687b      	ldr	r3, [r7, #4]
2401d224:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401d228:	2b01      	cmp	r3, #1
2401d22a:	d101      	bne.n	2401d230 <HAL_TIM_SlaveConfigSynchro+0x18>
2401d22c:	2302      	movs	r3, #2
2401d22e:	e031      	b.n	2401d294 <HAL_TIM_SlaveConfigSynchro+0x7c>
2401d230:	687b      	ldr	r3, [r7, #4]
2401d232:	2201      	movs	r2, #1
2401d234:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
2401d238:	687b      	ldr	r3, [r7, #4]
2401d23a:	2202      	movs	r2, #2
2401d23c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
2401d240:	6839      	ldr	r1, [r7, #0]
2401d242:	6878      	ldr	r0, [r7, #4]
2401d244:	f000 fede 	bl	2401e004 <TIM_SlaveTimer_SetConfig>
2401d248:	4603      	mov	r3, r0
2401d24a:	2b00      	cmp	r3, #0
2401d24c:	d009      	beq.n	2401d262 <HAL_TIM_SlaveConfigSynchro+0x4a>
  {
    htim->State = HAL_TIM_STATE_READY;
2401d24e:	687b      	ldr	r3, [r7, #4]
2401d250:	2201      	movs	r2, #1
2401d252:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    __HAL_UNLOCK(htim);
2401d256:	687b      	ldr	r3, [r7, #4]
2401d258:	2200      	movs	r2, #0
2401d25a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    return HAL_ERROR;
2401d25e:	2301      	movs	r3, #1
2401d260:	e018      	b.n	2401d294 <HAL_TIM_SlaveConfigSynchro+0x7c>
  }

  /* Disable Trigger Interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
2401d262:	687b      	ldr	r3, [r7, #4]
2401d264:	681b      	ldr	r3, [r3, #0]
2401d266:	68da      	ldr	r2, [r3, #12]
2401d268:	687b      	ldr	r3, [r7, #4]
2401d26a:	681b      	ldr	r3, [r3, #0]
2401d26c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
2401d270:	60da      	str	r2, [r3, #12]

  /* Disable Trigger DMA request */
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
2401d272:	687b      	ldr	r3, [r7, #4]
2401d274:	681b      	ldr	r3, [r3, #0]
2401d276:	68da      	ldr	r2, [r3, #12]
2401d278:	687b      	ldr	r3, [r7, #4]
2401d27a:	681b      	ldr	r3, [r3, #0]
2401d27c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2401d280:	60da      	str	r2, [r3, #12]

  htim->State = HAL_TIM_STATE_READY;
2401d282:	687b      	ldr	r3, [r7, #4]
2401d284:	2201      	movs	r2, #1
2401d286:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
2401d28a:	687b      	ldr	r3, [r7, #4]
2401d28c:	2200      	movs	r2, #0
2401d28e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2401d292:	2300      	movs	r3, #0
}
2401d294:	4618      	mov	r0, r3
2401d296:	3708      	adds	r7, #8
2401d298:	46bd      	mov	sp, r7
2401d29a:	bd80      	pop	{r7, pc}

2401d29c <HAL_TIM_SlaveConfigSynchro_IT>:
  *         (Disable, Reset, Gated, Trigger, External clock mode 1).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
                                                const TIM_SlaveConfigTypeDef *sSlaveConfig)
{
2401d29c:	b580      	push	{r7, lr}
2401d29e:	b082      	sub	sp, #8
2401d2a0:	af00      	add	r7, sp, #0
2401d2a2:	6078      	str	r0, [r7, #4]
2401d2a4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));

  __HAL_LOCK(htim);
2401d2a6:	687b      	ldr	r3, [r7, #4]
2401d2a8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2401d2ac:	2b01      	cmp	r3, #1
2401d2ae:	d101      	bne.n	2401d2b4 <HAL_TIM_SlaveConfigSynchro_IT+0x18>
2401d2b0:	2302      	movs	r3, #2
2401d2b2:	e031      	b.n	2401d318 <HAL_TIM_SlaveConfigSynchro_IT+0x7c>
2401d2b4:	687b      	ldr	r3, [r7, #4]
2401d2b6:	2201      	movs	r2, #1
2401d2b8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
2401d2bc:	687b      	ldr	r3, [r7, #4]
2401d2be:	2202      	movs	r2, #2
2401d2c0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
2401d2c4:	6839      	ldr	r1, [r7, #0]
2401d2c6:	6878      	ldr	r0, [r7, #4]
2401d2c8:	f000 fe9c 	bl	2401e004 <TIM_SlaveTimer_SetConfig>
2401d2cc:	4603      	mov	r3, r0
2401d2ce:	2b00      	cmp	r3, #0
2401d2d0:	d009      	beq.n	2401d2e6 <HAL_TIM_SlaveConfigSynchro_IT+0x4a>
  {
    htim->State = HAL_TIM_STATE_READY;
2401d2d2:	687b      	ldr	r3, [r7, #4]
2401d2d4:	2201      	movs	r2, #1
2401d2d6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    __HAL_UNLOCK(htim);
2401d2da:	687b      	ldr	r3, [r7, #4]
2401d2dc:	2200      	movs	r2, #0
2401d2de:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    return HAL_ERROR;
2401d2e2:	2301      	movs	r3, #1
2401d2e4:	e018      	b.n	2401d318 <HAL_TIM_SlaveConfigSynchro_IT+0x7c>
  }

  /* Enable Trigger Interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
2401d2e6:	687b      	ldr	r3, [r7, #4]
2401d2e8:	681b      	ldr	r3, [r3, #0]
2401d2ea:	68da      	ldr	r2, [r3, #12]
2401d2ec:	687b      	ldr	r3, [r7, #4]
2401d2ee:	681b      	ldr	r3, [r3, #0]
2401d2f0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
2401d2f4:	60da      	str	r2, [r3, #12]

  /* Disable Trigger DMA request */
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
2401d2f6:	687b      	ldr	r3, [r7, #4]
2401d2f8:	681b      	ldr	r3, [r3, #0]
2401d2fa:	68da      	ldr	r2, [r3, #12]
2401d2fc:	687b      	ldr	r3, [r7, #4]
2401d2fe:	681b      	ldr	r3, [r3, #0]
2401d300:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2401d304:	60da      	str	r2, [r3, #12]

  htim->State = HAL_TIM_STATE_READY;
2401d306:	687b      	ldr	r3, [r7, #4]
2401d308:	2201      	movs	r2, #1
2401d30a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
2401d30e:	687b      	ldr	r3, [r7, #4]
2401d310:	2200      	movs	r2, #0
2401d312:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2401d316:	2300      	movs	r3, #0
}
2401d318:	4618      	mov	r0, r3
2401d31a:	3708      	adds	r7, #8
2401d31c:	46bd      	mov	sp, r7
2401d31e:	bd80      	pop	{r7, pc}

2401d320 <HAL_TIM_ReadCapturedValue>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval Captured value
  */
uint32_t HAL_TIM_ReadCapturedValue(const TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401d320:	b480      	push	{r7}
2401d322:	b085      	sub	sp, #20
2401d324:	af00      	add	r7, sp, #0
2401d326:	6078      	str	r0, [r7, #4]
2401d328:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0U;
2401d32a:	2300      	movs	r3, #0
2401d32c:	60fb      	str	r3, [r7, #12]

  switch (Channel)
2401d32e:	683b      	ldr	r3, [r7, #0]
2401d330:	2b0c      	cmp	r3, #12
2401d332:	d831      	bhi.n	2401d398 <HAL_TIM_ReadCapturedValue+0x78>
2401d334:	a201      	add	r2, pc, #4	; (adr r2, 2401d33c <HAL_TIM_ReadCapturedValue+0x1c>)
2401d336:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401d33a:	bf00      	nop
2401d33c:	2401d371 	.word	0x2401d371
2401d340:	2401d399 	.word	0x2401d399
2401d344:	2401d399 	.word	0x2401d399
2401d348:	2401d399 	.word	0x2401d399
2401d34c:	2401d37b 	.word	0x2401d37b
2401d350:	2401d399 	.word	0x2401d399
2401d354:	2401d399 	.word	0x2401d399
2401d358:	2401d399 	.word	0x2401d399
2401d35c:	2401d385 	.word	0x2401d385
2401d360:	2401d399 	.word	0x2401d399
2401d364:	2401d399 	.word	0x2401d399
2401d368:	2401d399 	.word	0x2401d399
2401d36c:	2401d38f 	.word	0x2401d38f
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Return the capture 1 value */
      tmpreg =  htim->Instance->CCR1;
2401d370:	687b      	ldr	r3, [r7, #4]
2401d372:	681b      	ldr	r3, [r3, #0]
2401d374:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401d376:	60fb      	str	r3, [r7, #12]

      break;
2401d378:	e00f      	b.n	2401d39a <HAL_TIM_ReadCapturedValue+0x7a>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Return the capture 2 value */
      tmpreg =   htim->Instance->CCR2;
2401d37a:	687b      	ldr	r3, [r7, #4]
2401d37c:	681b      	ldr	r3, [r3, #0]
2401d37e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d380:	60fb      	str	r3, [r7, #12]

      break;
2401d382:	e00a      	b.n	2401d39a <HAL_TIM_ReadCapturedValue+0x7a>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Return the capture 3 value */
      tmpreg =   htim->Instance->CCR3;
2401d384:	687b      	ldr	r3, [r7, #4]
2401d386:	681b      	ldr	r3, [r3, #0]
2401d388:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401d38a:	60fb      	str	r3, [r7, #12]

      break;
2401d38c:	e005      	b.n	2401d39a <HAL_TIM_ReadCapturedValue+0x7a>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Return the capture 4 value */
      tmpreg =   htim->Instance->CCR4;
2401d38e:	687b      	ldr	r3, [r7, #4]
2401d390:	681b      	ldr	r3, [r3, #0]
2401d392:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2401d394:	60fb      	str	r3, [r7, #12]

      break;
2401d396:	e000      	b.n	2401d39a <HAL_TIM_ReadCapturedValue+0x7a>
    }

    default:
      break;
2401d398:	bf00      	nop
  }

  return tmpreg;
2401d39a:	68fb      	ldr	r3, [r7, #12]
}
2401d39c:	4618      	mov	r0, r3
2401d39e:	3714      	adds	r7, #20
2401d3a0:	46bd      	mov	sp, r7
2401d3a2:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d3a6:	4770      	bx	lr
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
2401d3a8:	b480      	push	{r7}
2401d3aa:	b083      	sub	sp, #12
2401d3ac:	af00      	add	r7, sp, #0
2401d3ae:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */
}
2401d3b0:	bf00      	nop
2401d3b2:	370c      	adds	r7, #12
2401d3b4:	46bd      	mov	sp, r7
2401d3b6:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d3ba:	4770      	bx	lr

2401d3bc <HAL_TIM_PeriodElapsedHalfCpltCallback>:
  * @brief  Period elapsed half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
{
2401d3bc:	b480      	push	{r7}
2401d3be:	b083      	sub	sp, #12
2401d3c0:	af00      	add	r7, sp, #0
2401d3c2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   */
}
2401d3c4:	bf00      	nop
2401d3c6:	370c      	adds	r7, #12
2401d3c8:	46bd      	mov	sp, r7
2401d3ca:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d3ce:	4770      	bx	lr

2401d3d0 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
2401d3d0:	b480      	push	{r7}
2401d3d2:	b083      	sub	sp, #12
2401d3d4:	af00      	add	r7, sp, #0
2401d3d6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
2401d3d8:	bf00      	nop
2401d3da:	370c      	adds	r7, #12
2401d3dc:	46bd      	mov	sp, r7
2401d3de:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d3e2:	4770      	bx	lr

2401d3e4 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
2401d3e4:	b480      	push	{r7}
2401d3e6:	b083      	sub	sp, #12
2401d3e8:	af00      	add	r7, sp, #0
2401d3ea:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
2401d3ec:	bf00      	nop
2401d3ee:	370c      	adds	r7, #12
2401d3f0:	46bd      	mov	sp, r7
2401d3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d3f6:	4770      	bx	lr

2401d3f8 <HAL_TIM_IC_CaptureHalfCpltCallback>:
  * @brief  Input Capture half complete callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
{
2401d3f8:	b480      	push	{r7}
2401d3fa:	b083      	sub	sp, #12
2401d3fc:	af00      	add	r7, sp, #0
2401d3fe:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   */
}
2401d400:	bf00      	nop
2401d402:	370c      	adds	r7, #12
2401d404:	46bd      	mov	sp, r7
2401d406:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d40a:	4770      	bx	lr

2401d40c <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
2401d40c:	b480      	push	{r7}
2401d40e:	b083      	sub	sp, #12
2401d410:	af00      	add	r7, sp, #0
2401d412:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
2401d414:	bf00      	nop
2401d416:	370c      	adds	r7, #12
2401d418:	46bd      	mov	sp, r7
2401d41a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d41e:	4770      	bx	lr

2401d420 <HAL_TIM_PWM_PulseFinishedHalfCpltCallback>:
  * @brief  PWM Pulse finished half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
{
2401d420:	b480      	push	{r7}
2401d422:	b083      	sub	sp, #12
2401d424:	af00      	add	r7, sp, #0
2401d426:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   */
}
2401d428:	bf00      	nop
2401d42a:	370c      	adds	r7, #12
2401d42c:	46bd      	mov	sp, r7
2401d42e:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d432:	4770      	bx	lr

2401d434 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
2401d434:	b480      	push	{r7}
2401d436:	b083      	sub	sp, #12
2401d438:	af00      	add	r7, sp, #0
2401d43a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
2401d43c:	bf00      	nop
2401d43e:	370c      	adds	r7, #12
2401d440:	46bd      	mov	sp, r7
2401d442:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d446:	4770      	bx	lr

2401d448 <HAL_TIM_TriggerHalfCpltCallback>:
  * @brief  Hall Trigger detection half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
{
2401d448:	b480      	push	{r7}
2401d44a:	b083      	sub	sp, #12
2401d44c:	af00      	add	r7, sp, #0
2401d44e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   */
}
2401d450:	bf00      	nop
2401d452:	370c      	adds	r7, #12
2401d454:	46bd      	mov	sp, r7
2401d456:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d45a:	4770      	bx	lr

2401d45c <HAL_TIM_ErrorCallback>:
  * @brief  Timer error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
{
2401d45c:	b480      	push	{r7}
2401d45e:	b083      	sub	sp, #12
2401d460:	af00      	add	r7, sp, #0
2401d462:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_ErrorCallback could be implemented in the user file
   */
}
2401d464:	bf00      	nop
2401d466:	370c      	adds	r7, #12
2401d468:	46bd      	mov	sp, r7
2401d46a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d46e:	4770      	bx	lr

2401d470 <HAL_TIM_Base_GetState>:
  * @brief  Return the TIM Base handle state.
  * @param  htim TIM Base handle
  * @retval HAL state
  */
HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(const TIM_HandleTypeDef *htim)
{
2401d470:	b480      	push	{r7}
2401d472:	b083      	sub	sp, #12
2401d474:	af00      	add	r7, sp, #0
2401d476:	6078      	str	r0, [r7, #4]
  return htim->State;
2401d478:	687b      	ldr	r3, [r7, #4]
2401d47a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401d47e:	b2db      	uxtb	r3, r3
}
2401d480:	4618      	mov	r0, r3
2401d482:	370c      	adds	r7, #12
2401d484:	46bd      	mov	sp, r7
2401d486:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d48a:	4770      	bx	lr

2401d48c <HAL_TIM_OC_GetState>:
  * @brief  Return the TIM OC handle state.
  * @param  htim TIM Output Compare handle
  * @retval HAL state
  */
HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(const TIM_HandleTypeDef *htim)
{
2401d48c:	b480      	push	{r7}
2401d48e:	b083      	sub	sp, #12
2401d490:	af00      	add	r7, sp, #0
2401d492:	6078      	str	r0, [r7, #4]
  return htim->State;
2401d494:	687b      	ldr	r3, [r7, #4]
2401d496:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401d49a:	b2db      	uxtb	r3, r3
}
2401d49c:	4618      	mov	r0, r3
2401d49e:	370c      	adds	r7, #12
2401d4a0:	46bd      	mov	sp, r7
2401d4a2:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d4a6:	4770      	bx	lr

2401d4a8 <HAL_TIM_PWM_GetState>:
  * @brief  Return the TIM PWM handle state.
  * @param  htim TIM handle
  * @retval HAL state
  */
HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(const TIM_HandleTypeDef *htim)
{
2401d4a8:	b480      	push	{r7}
2401d4aa:	b083      	sub	sp, #12
2401d4ac:	af00      	add	r7, sp, #0
2401d4ae:	6078      	str	r0, [r7, #4]
  return htim->State;
2401d4b0:	687b      	ldr	r3, [r7, #4]
2401d4b2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401d4b6:	b2db      	uxtb	r3, r3
}
2401d4b8:	4618      	mov	r0, r3
2401d4ba:	370c      	adds	r7, #12
2401d4bc:	46bd      	mov	sp, r7
2401d4be:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d4c2:	4770      	bx	lr

2401d4c4 <HAL_TIM_IC_GetState>:
  * @brief  Return the TIM Input Capture handle state.
  * @param  htim TIM IC handle
  * @retval HAL state
  */
HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(const TIM_HandleTypeDef *htim)
{
2401d4c4:	b480      	push	{r7}
2401d4c6:	b083      	sub	sp, #12
2401d4c8:	af00      	add	r7, sp, #0
2401d4ca:	6078      	str	r0, [r7, #4]
  return htim->State;
2401d4cc:	687b      	ldr	r3, [r7, #4]
2401d4ce:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401d4d2:	b2db      	uxtb	r3, r3
}
2401d4d4:	4618      	mov	r0, r3
2401d4d6:	370c      	adds	r7, #12
2401d4d8:	46bd      	mov	sp, r7
2401d4da:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d4de:	4770      	bx	lr

2401d4e0 <HAL_TIM_OnePulse_GetState>:
  * @brief  Return the TIM One Pulse Mode handle state.
  * @param  htim TIM OPM handle
  * @retval HAL state
  */
HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(const TIM_HandleTypeDef *htim)
{
2401d4e0:	b480      	push	{r7}
2401d4e2:	b083      	sub	sp, #12
2401d4e4:	af00      	add	r7, sp, #0
2401d4e6:	6078      	str	r0, [r7, #4]
  return htim->State;
2401d4e8:	687b      	ldr	r3, [r7, #4]
2401d4ea:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401d4ee:	b2db      	uxtb	r3, r3
}
2401d4f0:	4618      	mov	r0, r3
2401d4f2:	370c      	adds	r7, #12
2401d4f4:	46bd      	mov	sp, r7
2401d4f6:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d4fa:	4770      	bx	lr

2401d4fc <HAL_TIM_Encoder_GetState>:
  * @brief  Return the TIM Encoder Mode handle state.
  * @param  htim TIM Encoder Interface handle
  * @retval HAL state
  */
HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(const TIM_HandleTypeDef *htim)
{
2401d4fc:	b480      	push	{r7}
2401d4fe:	b083      	sub	sp, #12
2401d500:	af00      	add	r7, sp, #0
2401d502:	6078      	str	r0, [r7, #4]
  return htim->State;
2401d504:	687b      	ldr	r3, [r7, #4]
2401d506:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401d50a:	b2db      	uxtb	r3, r3
}
2401d50c:	4618      	mov	r0, r3
2401d50e:	370c      	adds	r7, #12
2401d510:	46bd      	mov	sp, r7
2401d512:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d516:	4770      	bx	lr

2401d518 <HAL_TIM_GetActiveChannel>:
  * @brief  Return the TIM Encoder Mode handle state.
  * @param  htim TIM handle
  * @retval Active channel
  */
HAL_TIM_ActiveChannel HAL_TIM_GetActiveChannel(const TIM_HandleTypeDef *htim)
{
2401d518:	b480      	push	{r7}
2401d51a:	b083      	sub	sp, #12
2401d51c:	af00      	add	r7, sp, #0
2401d51e:	6078      	str	r0, [r7, #4]
  return htim->Channel;
2401d520:	687b      	ldr	r3, [r7, #4]
2401d522:	7f1b      	ldrb	r3, [r3, #28]
}
2401d524:	4618      	mov	r0, r3
2401d526:	370c      	adds	r7, #12
2401d528:	46bd      	mov	sp, r7
2401d52a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d52e:	4770      	bx	lr

2401d530 <HAL_TIM_GetChannelState>:
  *            @arg TIM_CHANNEL_5: TIM Channel 5
  *            @arg TIM_CHANNEL_6: TIM Channel 6
  * @retval TIM Channel state
  */
HAL_TIM_ChannelStateTypeDef HAL_TIM_GetChannelState(const TIM_HandleTypeDef *htim,  uint32_t Channel)
{
2401d530:	b480      	push	{r7}
2401d532:	b085      	sub	sp, #20
2401d534:	af00      	add	r7, sp, #0
2401d536:	6078      	str	r0, [r7, #4]
2401d538:	6039      	str	r1, [r7, #0]
  HAL_TIM_ChannelStateTypeDef channel_state;

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
2401d53a:	683b      	ldr	r3, [r7, #0]
2401d53c:	2b00      	cmp	r3, #0
2401d53e:	d104      	bne.n	2401d54a <HAL_TIM_GetChannelState+0x1a>
2401d540:	687b      	ldr	r3, [r7, #4]
2401d542:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401d546:	b2db      	uxtb	r3, r3
2401d548:	e023      	b.n	2401d592 <HAL_TIM_GetChannelState+0x62>
2401d54a:	683b      	ldr	r3, [r7, #0]
2401d54c:	2b04      	cmp	r3, #4
2401d54e:	d104      	bne.n	2401d55a <HAL_TIM_GetChannelState+0x2a>
2401d550:	687b      	ldr	r3, [r7, #4]
2401d552:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401d556:	b2db      	uxtb	r3, r3
2401d558:	e01b      	b.n	2401d592 <HAL_TIM_GetChannelState+0x62>
2401d55a:	683b      	ldr	r3, [r7, #0]
2401d55c:	2b08      	cmp	r3, #8
2401d55e:	d104      	bne.n	2401d56a <HAL_TIM_GetChannelState+0x3a>
2401d560:	687b      	ldr	r3, [r7, #4]
2401d562:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401d566:	b2db      	uxtb	r3, r3
2401d568:	e013      	b.n	2401d592 <HAL_TIM_GetChannelState+0x62>
2401d56a:	683b      	ldr	r3, [r7, #0]
2401d56c:	2b0c      	cmp	r3, #12
2401d56e:	d104      	bne.n	2401d57a <HAL_TIM_GetChannelState+0x4a>
2401d570:	687b      	ldr	r3, [r7, #4]
2401d572:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401d576:	b2db      	uxtb	r3, r3
2401d578:	e00b      	b.n	2401d592 <HAL_TIM_GetChannelState+0x62>
2401d57a:	683b      	ldr	r3, [r7, #0]
2401d57c:	2b10      	cmp	r3, #16
2401d57e:	d104      	bne.n	2401d58a <HAL_TIM_GetChannelState+0x5a>
2401d580:	687b      	ldr	r3, [r7, #4]
2401d582:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2401d586:	b2db      	uxtb	r3, r3
2401d588:	e003      	b.n	2401d592 <HAL_TIM_GetChannelState+0x62>
2401d58a:	687b      	ldr	r3, [r7, #4]
2401d58c:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
2401d590:	b2db      	uxtb	r3, r3
2401d592:	73fb      	strb	r3, [r7, #15]

  return channel_state;
2401d594:	7bfb      	ldrb	r3, [r7, #15]
}
2401d596:	4618      	mov	r0, r3
2401d598:	3714      	adds	r7, #20
2401d59a:	46bd      	mov	sp, r7
2401d59c:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d5a0:	4770      	bx	lr

2401d5a2 <HAL_TIM_DMABurstState>:
  * @brief  Return actual state of a DMA burst operation.
  * @param  htim TIM handle
  * @retval DMA burst state
  */
HAL_TIM_DMABurstStateTypeDef HAL_TIM_DMABurstState(const TIM_HandleTypeDef *htim)
{
2401d5a2:	b480      	push	{r7}
2401d5a4:	b083      	sub	sp, #12
2401d5a6:	af00      	add	r7, sp, #0
2401d5a8:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));

  return htim->DMABurstState;
2401d5aa:	687b      	ldr	r3, [r7, #4]
2401d5ac:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
2401d5b0:	b2db      	uxtb	r3, r3
}
2401d5b2:	4618      	mov	r0, r3
2401d5b4:	370c      	adds	r7, #12
2401d5b6:	46bd      	mov	sp, r7
2401d5b8:	f85d 7b04 	ldr.w	r7, [sp], #4
2401d5bc:	4770      	bx	lr

2401d5be <TIM_DMAError>:
  * @brief  TIM DMA error callback
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
void TIM_DMAError(DMA_HandleTypeDef *hdma)
{
2401d5be:	b580      	push	{r7, lr}
2401d5c0:	b084      	sub	sp, #16
2401d5c2:	af00      	add	r7, sp, #0
2401d5c4:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d5c6:	687b      	ldr	r3, [r7, #4]
2401d5c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d5ca:	60fb      	str	r3, [r7, #12]

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2401d5cc:	68fb      	ldr	r3, [r7, #12]
2401d5ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401d5d0:	687a      	ldr	r2, [r7, #4]
2401d5d2:	429a      	cmp	r2, r3
2401d5d4:	d107      	bne.n	2401d5e6 <TIM_DMAError+0x28>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
2401d5d6:	68fb      	ldr	r3, [r7, #12]
2401d5d8:	2201      	movs	r2, #1
2401d5da:	771a      	strb	r2, [r3, #28]
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401d5dc:	68fb      	ldr	r3, [r7, #12]
2401d5de:	2201      	movs	r2, #1
2401d5e0:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401d5e4:	e02a      	b.n	2401d63c <TIM_DMAError+0x7e>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2401d5e6:	68fb      	ldr	r3, [r7, #12]
2401d5e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401d5ea:	687a      	ldr	r2, [r7, #4]
2401d5ec:	429a      	cmp	r2, r3
2401d5ee:	d107      	bne.n	2401d600 <TIM_DMAError+0x42>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2401d5f0:	68fb      	ldr	r3, [r7, #12]
2401d5f2:	2202      	movs	r2, #2
2401d5f4:	771a      	strb	r2, [r3, #28]
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401d5f6:	68fb      	ldr	r3, [r7, #12]
2401d5f8:	2201      	movs	r2, #1
2401d5fa:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401d5fe:	e01d      	b.n	2401d63c <TIM_DMAError+0x7e>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2401d600:	68fb      	ldr	r3, [r7, #12]
2401d602:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401d604:	687a      	ldr	r2, [r7, #4]
2401d606:	429a      	cmp	r2, r3
2401d608:	d107      	bne.n	2401d61a <TIM_DMAError+0x5c>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2401d60a:	68fb      	ldr	r3, [r7, #12]
2401d60c:	2204      	movs	r2, #4
2401d60e:	771a      	strb	r2, [r3, #28]
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
2401d610:	68fb      	ldr	r3, [r7, #12]
2401d612:	2201      	movs	r2, #1
2401d614:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401d618:	e010      	b.n	2401d63c <TIM_DMAError+0x7e>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2401d61a:	68fb      	ldr	r3, [r7, #12]
2401d61c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401d61e:	687a      	ldr	r2, [r7, #4]
2401d620:	429a      	cmp	r2, r3
2401d622:	d107      	bne.n	2401d634 <TIM_DMAError+0x76>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2401d624:	68fb      	ldr	r3, [r7, #12]
2401d626:	2208      	movs	r2, #8
2401d628:	771a      	strb	r2, [r3, #28]
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
2401d62a:	68fb      	ldr	r3, [r7, #12]
2401d62c:	2201      	movs	r2, #1
2401d62e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401d632:	e003      	b.n	2401d63c <TIM_DMAError+0x7e>
  }
  else
  {
    htim->State = HAL_TIM_STATE_READY;
2401d634:	68fb      	ldr	r3, [r7, #12]
2401d636:	2201      	movs	r2, #1
2401d638:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->ErrorCallback(htim);
#else
  HAL_TIM_ErrorCallback(htim);
2401d63c:	68f8      	ldr	r0, [r7, #12]
2401d63e:	f7ff ff0d 	bl	2401d45c <HAL_TIM_ErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401d642:	68fb      	ldr	r3, [r7, #12]
2401d644:	2200      	movs	r2, #0
2401d646:	771a      	strb	r2, [r3, #28]
}
2401d648:	bf00      	nop
2401d64a:	3710      	adds	r7, #16
2401d64c:	46bd      	mov	sp, r7
2401d64e:	bd80      	pop	{r7, pc}

2401d650 <TIM_DMADelayPulseCplt>:
  * @brief  TIM DMA Delay Pulse complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
static void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
{
2401d650:	b580      	push	{r7, lr}
2401d652:	b084      	sub	sp, #16
2401d654:	af00      	add	r7, sp, #0
2401d656:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d658:	687b      	ldr	r3, [r7, #4]
2401d65a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d65c:	60fb      	str	r3, [r7, #12]

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2401d65e:	68fb      	ldr	r3, [r7, #12]
2401d660:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401d662:	687a      	ldr	r2, [r7, #4]
2401d664:	429a      	cmp	r2, r3
2401d666:	d10b      	bne.n	2401d680 <TIM_DMADelayPulseCplt+0x30>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
2401d668:	68fb      	ldr	r3, [r7, #12]
2401d66a:	2201      	movs	r2, #1
2401d66c:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
2401d66e:	687b      	ldr	r3, [r7, #4]
2401d670:	69db      	ldr	r3, [r3, #28]
2401d672:	2b00      	cmp	r3, #0
2401d674:	d136      	bne.n	2401d6e4 <TIM_DMADelayPulseCplt+0x94>
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401d676:	68fb      	ldr	r3, [r7, #12]
2401d678:	2201      	movs	r2, #1
2401d67a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
2401d67e:	e031      	b.n	2401d6e4 <TIM_DMADelayPulseCplt+0x94>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2401d680:	68fb      	ldr	r3, [r7, #12]
2401d682:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401d684:	687a      	ldr	r2, [r7, #4]
2401d686:	429a      	cmp	r2, r3
2401d688:	d10b      	bne.n	2401d6a2 <TIM_DMADelayPulseCplt+0x52>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2401d68a:	68fb      	ldr	r3, [r7, #12]
2401d68c:	2202      	movs	r2, #2
2401d68e:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
2401d690:	687b      	ldr	r3, [r7, #4]
2401d692:	69db      	ldr	r3, [r3, #28]
2401d694:	2b00      	cmp	r3, #0
2401d696:	d125      	bne.n	2401d6e4 <TIM_DMADelayPulseCplt+0x94>
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401d698:	68fb      	ldr	r3, [r7, #12]
2401d69a:	2201      	movs	r2, #1
2401d69c:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
2401d6a0:	e020      	b.n	2401d6e4 <TIM_DMADelayPulseCplt+0x94>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2401d6a2:	68fb      	ldr	r3, [r7, #12]
2401d6a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401d6a6:	687a      	ldr	r2, [r7, #4]
2401d6a8:	429a      	cmp	r2, r3
2401d6aa:	d10b      	bne.n	2401d6c4 <TIM_DMADelayPulseCplt+0x74>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2401d6ac:	68fb      	ldr	r3, [r7, #12]
2401d6ae:	2204      	movs	r2, #4
2401d6b0:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
2401d6b2:	687b      	ldr	r3, [r7, #4]
2401d6b4:	69db      	ldr	r3, [r3, #28]
2401d6b6:	2b00      	cmp	r3, #0
2401d6b8:	d114      	bne.n	2401d6e4 <TIM_DMADelayPulseCplt+0x94>
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
2401d6ba:	68fb      	ldr	r3, [r7, #12]
2401d6bc:	2201      	movs	r2, #1
2401d6be:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401d6c2:	e00f      	b.n	2401d6e4 <TIM_DMADelayPulseCplt+0x94>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2401d6c4:	68fb      	ldr	r3, [r7, #12]
2401d6c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401d6c8:	687a      	ldr	r2, [r7, #4]
2401d6ca:	429a      	cmp	r2, r3
2401d6cc:	d10a      	bne.n	2401d6e4 <TIM_DMADelayPulseCplt+0x94>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2401d6ce:	68fb      	ldr	r3, [r7, #12]
2401d6d0:	2208      	movs	r2, #8
2401d6d2:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
2401d6d4:	687b      	ldr	r3, [r7, #4]
2401d6d6:	69db      	ldr	r3, [r3, #28]
2401d6d8:	2b00      	cmp	r3, #0
2401d6da:	d103      	bne.n	2401d6e4 <TIM_DMADelayPulseCplt+0x94>
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
2401d6dc:	68fb      	ldr	r3, [r7, #12]
2401d6de:	2201      	movs	r2, #1
2401d6e0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->PWM_PulseFinishedCallback(htim);
#else
  HAL_TIM_PWM_PulseFinishedCallback(htim);
2401d6e4:	68f8      	ldr	r0, [r7, #12]
2401d6e6:	f7ff fe91 	bl	2401d40c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401d6ea:	68fb      	ldr	r3, [r7, #12]
2401d6ec:	2200      	movs	r2, #0
2401d6ee:	771a      	strb	r2, [r3, #28]
}
2401d6f0:	bf00      	nop
2401d6f2:	3710      	adds	r7, #16
2401d6f4:	46bd      	mov	sp, r7
2401d6f6:	bd80      	pop	{r7, pc}

2401d6f8 <TIM_DMADelayPulseHalfCplt>:
  * @brief  TIM DMA Delay Pulse half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
{
2401d6f8:	b580      	push	{r7, lr}
2401d6fa:	b084      	sub	sp, #16
2401d6fc:	af00      	add	r7, sp, #0
2401d6fe:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d700:	687b      	ldr	r3, [r7, #4]
2401d702:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d704:	60fb      	str	r3, [r7, #12]

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2401d706:	68fb      	ldr	r3, [r7, #12]
2401d708:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401d70a:	687a      	ldr	r2, [r7, #4]
2401d70c:	429a      	cmp	r2, r3
2401d70e:	d103      	bne.n	2401d718 <TIM_DMADelayPulseHalfCplt+0x20>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
2401d710:	68fb      	ldr	r3, [r7, #12]
2401d712:	2201      	movs	r2, #1
2401d714:	771a      	strb	r2, [r3, #28]
2401d716:	e019      	b.n	2401d74c <TIM_DMADelayPulseHalfCplt+0x54>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2401d718:	68fb      	ldr	r3, [r7, #12]
2401d71a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401d71c:	687a      	ldr	r2, [r7, #4]
2401d71e:	429a      	cmp	r2, r3
2401d720:	d103      	bne.n	2401d72a <TIM_DMADelayPulseHalfCplt+0x32>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2401d722:	68fb      	ldr	r3, [r7, #12]
2401d724:	2202      	movs	r2, #2
2401d726:	771a      	strb	r2, [r3, #28]
2401d728:	e010      	b.n	2401d74c <TIM_DMADelayPulseHalfCplt+0x54>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2401d72a:	68fb      	ldr	r3, [r7, #12]
2401d72c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401d72e:	687a      	ldr	r2, [r7, #4]
2401d730:	429a      	cmp	r2, r3
2401d732:	d103      	bne.n	2401d73c <TIM_DMADelayPulseHalfCplt+0x44>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2401d734:	68fb      	ldr	r3, [r7, #12]
2401d736:	2204      	movs	r2, #4
2401d738:	771a      	strb	r2, [r3, #28]
2401d73a:	e007      	b.n	2401d74c <TIM_DMADelayPulseHalfCplt+0x54>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2401d73c:	68fb      	ldr	r3, [r7, #12]
2401d73e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401d740:	687a      	ldr	r2, [r7, #4]
2401d742:	429a      	cmp	r2, r3
2401d744:	d102      	bne.n	2401d74c <TIM_DMADelayPulseHalfCplt+0x54>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2401d746:	68fb      	ldr	r3, [r7, #12]
2401d748:	2208      	movs	r2, #8
2401d74a:	771a      	strb	r2, [r3, #28]
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->PWM_PulseFinishedHalfCpltCallback(htim);
#else
  HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
2401d74c:	68f8      	ldr	r0, [r7, #12]
2401d74e:	f7ff fe67 	bl	2401d420 <HAL_TIM_PWM_PulseFinishedHalfCpltCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401d752:	68fb      	ldr	r3, [r7, #12]
2401d754:	2200      	movs	r2, #0
2401d756:	771a      	strb	r2, [r3, #28]
}
2401d758:	bf00      	nop
2401d75a:	3710      	adds	r7, #16
2401d75c:	46bd      	mov	sp, r7
2401d75e:	bd80      	pop	{r7, pc}

2401d760 <TIM_DMACaptureCplt>:
  * @brief  TIM DMA Capture complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
{
2401d760:	b580      	push	{r7, lr}
2401d762:	b084      	sub	sp, #16
2401d764:	af00      	add	r7, sp, #0
2401d766:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d768:	687b      	ldr	r3, [r7, #4]
2401d76a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d76c:	60fb      	str	r3, [r7, #12]

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2401d76e:	68fb      	ldr	r3, [r7, #12]
2401d770:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401d772:	687a      	ldr	r2, [r7, #4]
2401d774:	429a      	cmp	r2, r3
2401d776:	d10f      	bne.n	2401d798 <TIM_DMACaptureCplt+0x38>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
2401d778:	68fb      	ldr	r3, [r7, #12]
2401d77a:	2201      	movs	r2, #1
2401d77c:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
2401d77e:	687b      	ldr	r3, [r7, #4]
2401d780:	69db      	ldr	r3, [r3, #28]
2401d782:	2b00      	cmp	r3, #0
2401d784:	d146      	bne.n	2401d814 <TIM_DMACaptureCplt+0xb4>
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401d786:	68fb      	ldr	r3, [r7, #12]
2401d788:	2201      	movs	r2, #1
2401d78a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401d78e:	68fb      	ldr	r3, [r7, #12]
2401d790:	2201      	movs	r2, #1
2401d792:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401d796:	e03d      	b.n	2401d814 <TIM_DMACaptureCplt+0xb4>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2401d798:	68fb      	ldr	r3, [r7, #12]
2401d79a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401d79c:	687a      	ldr	r2, [r7, #4]
2401d79e:	429a      	cmp	r2, r3
2401d7a0:	d10f      	bne.n	2401d7c2 <TIM_DMACaptureCplt+0x62>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2401d7a2:	68fb      	ldr	r3, [r7, #12]
2401d7a4:	2202      	movs	r2, #2
2401d7a6:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
2401d7a8:	687b      	ldr	r3, [r7, #4]
2401d7aa:	69db      	ldr	r3, [r3, #28]
2401d7ac:	2b00      	cmp	r3, #0
2401d7ae:	d131      	bne.n	2401d814 <TIM_DMACaptureCplt+0xb4>
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401d7b0:	68fb      	ldr	r3, [r7, #12]
2401d7b2:	2201      	movs	r2, #1
2401d7b4:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401d7b8:	68fb      	ldr	r3, [r7, #12]
2401d7ba:	2201      	movs	r2, #1
2401d7bc:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401d7c0:	e028      	b.n	2401d814 <TIM_DMACaptureCplt+0xb4>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2401d7c2:	68fb      	ldr	r3, [r7, #12]
2401d7c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401d7c6:	687a      	ldr	r2, [r7, #4]
2401d7c8:	429a      	cmp	r2, r3
2401d7ca:	d10f      	bne.n	2401d7ec <TIM_DMACaptureCplt+0x8c>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2401d7cc:	68fb      	ldr	r3, [r7, #12]
2401d7ce:	2204      	movs	r2, #4
2401d7d0:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
2401d7d2:	687b      	ldr	r3, [r7, #4]
2401d7d4:	69db      	ldr	r3, [r3, #28]
2401d7d6:	2b00      	cmp	r3, #0
2401d7d8:	d11c      	bne.n	2401d814 <TIM_DMACaptureCplt+0xb4>
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
2401d7da:	68fb      	ldr	r3, [r7, #12]
2401d7dc:	2201      	movs	r2, #1
2401d7de:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
2401d7e2:	68fb      	ldr	r3, [r7, #12]
2401d7e4:	2201      	movs	r2, #1
2401d7e6:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401d7ea:	e013      	b.n	2401d814 <TIM_DMACaptureCplt+0xb4>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2401d7ec:	68fb      	ldr	r3, [r7, #12]
2401d7ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401d7f0:	687a      	ldr	r2, [r7, #4]
2401d7f2:	429a      	cmp	r2, r3
2401d7f4:	d10e      	bne.n	2401d814 <TIM_DMACaptureCplt+0xb4>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2401d7f6:	68fb      	ldr	r3, [r7, #12]
2401d7f8:	2208      	movs	r2, #8
2401d7fa:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
2401d7fc:	687b      	ldr	r3, [r7, #4]
2401d7fe:	69db      	ldr	r3, [r3, #28]
2401d800:	2b00      	cmp	r3, #0
2401d802:	d107      	bne.n	2401d814 <TIM_DMACaptureCplt+0xb4>
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
2401d804:	68fb      	ldr	r3, [r7, #12]
2401d806:	2201      	movs	r2, #1
2401d808:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
2401d80c:	68fb      	ldr	r3, [r7, #12]
2401d80e:	2201      	movs	r2, #1
2401d810:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->IC_CaptureCallback(htim);
#else
  HAL_TIM_IC_CaptureCallback(htim);
2401d814:	68f8      	ldr	r0, [r7, #12]
2401d816:	f7ff fde5 	bl	2401d3e4 <HAL_TIM_IC_CaptureCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401d81a:	68fb      	ldr	r3, [r7, #12]
2401d81c:	2200      	movs	r2, #0
2401d81e:	771a      	strb	r2, [r3, #28]
}
2401d820:	bf00      	nop
2401d822:	3710      	adds	r7, #16
2401d824:	46bd      	mov	sp, r7
2401d826:	bd80      	pop	{r7, pc}

2401d828 <TIM_DMACaptureHalfCplt>:
  * @brief  TIM DMA Capture half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
{
2401d828:	b580      	push	{r7, lr}
2401d82a:	b084      	sub	sp, #16
2401d82c:	af00      	add	r7, sp, #0
2401d82e:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d830:	687b      	ldr	r3, [r7, #4]
2401d832:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d834:	60fb      	str	r3, [r7, #12]

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2401d836:	68fb      	ldr	r3, [r7, #12]
2401d838:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401d83a:	687a      	ldr	r2, [r7, #4]
2401d83c:	429a      	cmp	r2, r3
2401d83e:	d103      	bne.n	2401d848 <TIM_DMACaptureHalfCplt+0x20>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
2401d840:	68fb      	ldr	r3, [r7, #12]
2401d842:	2201      	movs	r2, #1
2401d844:	771a      	strb	r2, [r3, #28]
2401d846:	e019      	b.n	2401d87c <TIM_DMACaptureHalfCplt+0x54>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2401d848:	68fb      	ldr	r3, [r7, #12]
2401d84a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401d84c:	687a      	ldr	r2, [r7, #4]
2401d84e:	429a      	cmp	r2, r3
2401d850:	d103      	bne.n	2401d85a <TIM_DMACaptureHalfCplt+0x32>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2401d852:	68fb      	ldr	r3, [r7, #12]
2401d854:	2202      	movs	r2, #2
2401d856:	771a      	strb	r2, [r3, #28]
2401d858:	e010      	b.n	2401d87c <TIM_DMACaptureHalfCplt+0x54>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2401d85a:	68fb      	ldr	r3, [r7, #12]
2401d85c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401d85e:	687a      	ldr	r2, [r7, #4]
2401d860:	429a      	cmp	r2, r3
2401d862:	d103      	bne.n	2401d86c <TIM_DMACaptureHalfCplt+0x44>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2401d864:	68fb      	ldr	r3, [r7, #12]
2401d866:	2204      	movs	r2, #4
2401d868:	771a      	strb	r2, [r3, #28]
2401d86a:	e007      	b.n	2401d87c <TIM_DMACaptureHalfCplt+0x54>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2401d86c:	68fb      	ldr	r3, [r7, #12]
2401d86e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401d870:	687a      	ldr	r2, [r7, #4]
2401d872:	429a      	cmp	r2, r3
2401d874:	d102      	bne.n	2401d87c <TIM_DMACaptureHalfCplt+0x54>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2401d876:	68fb      	ldr	r3, [r7, #12]
2401d878:	2208      	movs	r2, #8
2401d87a:	771a      	strb	r2, [r3, #28]
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->IC_CaptureHalfCpltCallback(htim);
#else
  HAL_TIM_IC_CaptureHalfCpltCallback(htim);
2401d87c:	68f8      	ldr	r0, [r7, #12]
2401d87e:	f7ff fdbb 	bl	2401d3f8 <HAL_TIM_IC_CaptureHalfCpltCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2401d882:	68fb      	ldr	r3, [r7, #12]
2401d884:	2200      	movs	r2, #0
2401d886:	771a      	strb	r2, [r3, #28]
}
2401d888:	bf00      	nop
2401d88a:	3710      	adds	r7, #16
2401d88c:	46bd      	mov	sp, r7
2401d88e:	bd80      	pop	{r7, pc}

2401d890 <TIM_DMAPeriodElapsedCplt>:
  * @brief  TIM DMA Period Elapse complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
{
2401d890:	b580      	push	{r7, lr}
2401d892:	b084      	sub	sp, #16
2401d894:	af00      	add	r7, sp, #0
2401d896:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d898:	687b      	ldr	r3, [r7, #4]
2401d89a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d89c:	60fb      	str	r3, [r7, #12]

  if (htim->hdma[TIM_DMA_ID_UPDATE]->Init.Mode == DMA_NORMAL)
2401d89e:	68fb      	ldr	r3, [r7, #12]
2401d8a0:	6a1b      	ldr	r3, [r3, #32]
2401d8a2:	69db      	ldr	r3, [r3, #28]
2401d8a4:	2b00      	cmp	r3, #0
2401d8a6:	d103      	bne.n	2401d8b0 <TIM_DMAPeriodElapsedCplt+0x20>
  {
    htim->State = HAL_TIM_STATE_READY;
2401d8a8:	68fb      	ldr	r3, [r7, #12]
2401d8aa:	2201      	movs	r2, #1
2401d8ac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->PeriodElapsedCallback(htim);
#else
  HAL_TIM_PeriodElapsedCallback(htim);
2401d8b0:	68f8      	ldr	r0, [r7, #12]
2401d8b2:	f7e3 fa1d 	bl	24000cf0 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
}
2401d8b6:	bf00      	nop
2401d8b8:	3710      	adds	r7, #16
2401d8ba:	46bd      	mov	sp, r7
2401d8bc:	bd80      	pop	{r7, pc}

2401d8be <TIM_DMAPeriodElapsedHalfCplt>:
  * @brief  TIM DMA Period Elapse half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
{
2401d8be:	b580      	push	{r7, lr}
2401d8c0:	b084      	sub	sp, #16
2401d8c2:	af00      	add	r7, sp, #0
2401d8c4:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d8c6:	687b      	ldr	r3, [r7, #4]
2401d8c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d8ca:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->PeriodElapsedHalfCpltCallback(htim);
#else
  HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
2401d8cc:	68f8      	ldr	r0, [r7, #12]
2401d8ce:	f7ff fd75 	bl	2401d3bc <HAL_TIM_PeriodElapsedHalfCpltCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
}
2401d8d2:	bf00      	nop
2401d8d4:	3710      	adds	r7, #16
2401d8d6:	46bd      	mov	sp, r7
2401d8d8:	bd80      	pop	{r7, pc}

2401d8da <TIM_DMATriggerCplt>:
  * @brief  TIM DMA Trigger callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
{
2401d8da:	b580      	push	{r7, lr}
2401d8dc:	b084      	sub	sp, #16
2401d8de:	af00      	add	r7, sp, #0
2401d8e0:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d8e2:	687b      	ldr	r3, [r7, #4]
2401d8e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d8e6:	60fb      	str	r3, [r7, #12]

  if (htim->hdma[TIM_DMA_ID_TRIGGER]->Init.Mode == DMA_NORMAL)
2401d8e8:	68fb      	ldr	r3, [r7, #12]
2401d8ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d8ec:	69db      	ldr	r3, [r3, #28]
2401d8ee:	2b00      	cmp	r3, #0
2401d8f0:	d103      	bne.n	2401d8fa <TIM_DMATriggerCplt+0x20>
  {
    htim->State = HAL_TIM_STATE_READY;
2401d8f2:	68fb      	ldr	r3, [r7, #12]
2401d8f4:	2201      	movs	r2, #1
2401d8f6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->TriggerCallback(htim);
#else
  HAL_TIM_TriggerCallback(htim);
2401d8fa:	68f8      	ldr	r0, [r7, #12]
2401d8fc:	f7ff fd9a 	bl	2401d434 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
}
2401d900:	bf00      	nop
2401d902:	3710      	adds	r7, #16
2401d904:	46bd      	mov	sp, r7
2401d906:	bd80      	pop	{r7, pc}

2401d908 <TIM_DMATriggerHalfCplt>:
  * @brief  TIM DMA Trigger half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
{
2401d908:	b580      	push	{r7, lr}
2401d90a:	b084      	sub	sp, #16
2401d90c:	af00      	add	r7, sp, #0
2401d90e:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2401d910:	687b      	ldr	r3, [r7, #4]
2401d912:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401d914:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->TriggerHalfCpltCallback(htim);
#else
  HAL_TIM_TriggerHalfCpltCallback(htim);
2401d916:	68f8      	ldr	r0, [r7, #12]
2401d918:	f7ff fd96 	bl	2401d448 <HAL_TIM_TriggerHalfCpltCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
}
2401d91c:	bf00      	nop
2401d91e:	3710      	adds	r7, #16
2401d920:	46bd      	mov	sp, r7
2401d922:	bd80      	pop	{r7, pc}

2401d924 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
2401d924:	b480      	push	{r7}
2401d926:	b085      	sub	sp, #20
2401d928:	af00      	add	r7, sp, #0
2401d92a:	6078      	str	r0, [r7, #4]
2401d92c:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
2401d92e:	687b      	ldr	r3, [r7, #4]
2401d930:	681b      	ldr	r3, [r3, #0]
2401d932:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
2401d934:	687b      	ldr	r3, [r7, #4]
2401d936:	4a40      	ldr	r2, [pc, #256]	; (2401da38 <TIM_Base_SetConfig+0x114>)
2401d938:	4293      	cmp	r3, r2
2401d93a:	d013      	beq.n	2401d964 <TIM_Base_SetConfig+0x40>
2401d93c:	687b      	ldr	r3, [r7, #4]
2401d93e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401d942:	d00f      	beq.n	2401d964 <TIM_Base_SetConfig+0x40>
2401d944:	687b      	ldr	r3, [r7, #4]
2401d946:	4a3d      	ldr	r2, [pc, #244]	; (2401da3c <TIM_Base_SetConfig+0x118>)
2401d948:	4293      	cmp	r3, r2
2401d94a:	d00b      	beq.n	2401d964 <TIM_Base_SetConfig+0x40>
2401d94c:	687b      	ldr	r3, [r7, #4]
2401d94e:	4a3c      	ldr	r2, [pc, #240]	; (2401da40 <TIM_Base_SetConfig+0x11c>)
2401d950:	4293      	cmp	r3, r2
2401d952:	d007      	beq.n	2401d964 <TIM_Base_SetConfig+0x40>
2401d954:	687b      	ldr	r3, [r7, #4]
2401d956:	4a3b      	ldr	r2, [pc, #236]	; (2401da44 <TIM_Base_SetConfig+0x120>)
2401d958:	4293      	cmp	r3, r2
2401d95a:	d003      	beq.n	2401d964 <TIM_Base_SetConfig+0x40>
2401d95c:	687b      	ldr	r3, [r7, #4]
2401d95e:	4a3a      	ldr	r2, [pc, #232]	; (2401da48 <TIM_Base_SetConfig+0x124>)
2401d960:	4293      	cmp	r3, r2
2401d962:	d108      	bne.n	2401d976 <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
2401d964:	68fb      	ldr	r3, [r7, #12]
2401d966:	f023 0370 	bic.w	r3, r3, #112	; 0x70
2401d96a:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
2401d96c:	683b      	ldr	r3, [r7, #0]
2401d96e:	685b      	ldr	r3, [r3, #4]
2401d970:	68fa      	ldr	r2, [r7, #12]
2401d972:	4313      	orrs	r3, r2
2401d974:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
2401d976:	687b      	ldr	r3, [r7, #4]
2401d978:	4a2f      	ldr	r2, [pc, #188]	; (2401da38 <TIM_Base_SetConfig+0x114>)
2401d97a:	4293      	cmp	r3, r2
2401d97c:	d01f      	beq.n	2401d9be <TIM_Base_SetConfig+0x9a>
2401d97e:	687b      	ldr	r3, [r7, #4]
2401d980:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401d984:	d01b      	beq.n	2401d9be <TIM_Base_SetConfig+0x9a>
2401d986:	687b      	ldr	r3, [r7, #4]
2401d988:	4a2c      	ldr	r2, [pc, #176]	; (2401da3c <TIM_Base_SetConfig+0x118>)
2401d98a:	4293      	cmp	r3, r2
2401d98c:	d017      	beq.n	2401d9be <TIM_Base_SetConfig+0x9a>
2401d98e:	687b      	ldr	r3, [r7, #4]
2401d990:	4a2b      	ldr	r2, [pc, #172]	; (2401da40 <TIM_Base_SetConfig+0x11c>)
2401d992:	4293      	cmp	r3, r2
2401d994:	d013      	beq.n	2401d9be <TIM_Base_SetConfig+0x9a>
2401d996:	687b      	ldr	r3, [r7, #4]
2401d998:	4a2a      	ldr	r2, [pc, #168]	; (2401da44 <TIM_Base_SetConfig+0x120>)
2401d99a:	4293      	cmp	r3, r2
2401d99c:	d00f      	beq.n	2401d9be <TIM_Base_SetConfig+0x9a>
2401d99e:	687b      	ldr	r3, [r7, #4]
2401d9a0:	4a29      	ldr	r2, [pc, #164]	; (2401da48 <TIM_Base_SetConfig+0x124>)
2401d9a2:	4293      	cmp	r3, r2
2401d9a4:	d00b      	beq.n	2401d9be <TIM_Base_SetConfig+0x9a>
2401d9a6:	687b      	ldr	r3, [r7, #4]
2401d9a8:	4a28      	ldr	r2, [pc, #160]	; (2401da4c <TIM_Base_SetConfig+0x128>)
2401d9aa:	4293      	cmp	r3, r2
2401d9ac:	d007      	beq.n	2401d9be <TIM_Base_SetConfig+0x9a>
2401d9ae:	687b      	ldr	r3, [r7, #4]
2401d9b0:	4a27      	ldr	r2, [pc, #156]	; (2401da50 <TIM_Base_SetConfig+0x12c>)
2401d9b2:	4293      	cmp	r3, r2
2401d9b4:	d003      	beq.n	2401d9be <TIM_Base_SetConfig+0x9a>
2401d9b6:	687b      	ldr	r3, [r7, #4]
2401d9b8:	4a26      	ldr	r2, [pc, #152]	; (2401da54 <TIM_Base_SetConfig+0x130>)
2401d9ba:	4293      	cmp	r3, r2
2401d9bc:	d108      	bne.n	2401d9d0 <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
2401d9be:	68fb      	ldr	r3, [r7, #12]
2401d9c0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
2401d9c4:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
2401d9c6:	683b      	ldr	r3, [r7, #0]
2401d9c8:	68db      	ldr	r3, [r3, #12]
2401d9ca:	68fa      	ldr	r2, [r7, #12]
2401d9cc:	4313      	orrs	r3, r2
2401d9ce:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
2401d9d0:	68fb      	ldr	r3, [r7, #12]
2401d9d2:	f023 0280 	bic.w	r2, r3, #128	; 0x80
2401d9d6:	683b      	ldr	r3, [r7, #0]
2401d9d8:	695b      	ldr	r3, [r3, #20]
2401d9da:	4313      	orrs	r3, r2
2401d9dc:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
2401d9de:	687b      	ldr	r3, [r7, #4]
2401d9e0:	68fa      	ldr	r2, [r7, #12]
2401d9e2:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
2401d9e4:	683b      	ldr	r3, [r7, #0]
2401d9e6:	689a      	ldr	r2, [r3, #8]
2401d9e8:	687b      	ldr	r3, [r7, #4]
2401d9ea:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
2401d9ec:	683b      	ldr	r3, [r7, #0]
2401d9ee:	681a      	ldr	r2, [r3, #0]
2401d9f0:	687b      	ldr	r3, [r7, #4]
2401d9f2:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
2401d9f4:	687b      	ldr	r3, [r7, #4]
2401d9f6:	4a10      	ldr	r2, [pc, #64]	; (2401da38 <TIM_Base_SetConfig+0x114>)
2401d9f8:	4293      	cmp	r3, r2
2401d9fa:	d00f      	beq.n	2401da1c <TIM_Base_SetConfig+0xf8>
2401d9fc:	687b      	ldr	r3, [r7, #4]
2401d9fe:	4a12      	ldr	r2, [pc, #72]	; (2401da48 <TIM_Base_SetConfig+0x124>)
2401da00:	4293      	cmp	r3, r2
2401da02:	d00b      	beq.n	2401da1c <TIM_Base_SetConfig+0xf8>
2401da04:	687b      	ldr	r3, [r7, #4]
2401da06:	4a11      	ldr	r2, [pc, #68]	; (2401da4c <TIM_Base_SetConfig+0x128>)
2401da08:	4293      	cmp	r3, r2
2401da0a:	d007      	beq.n	2401da1c <TIM_Base_SetConfig+0xf8>
2401da0c:	687b      	ldr	r3, [r7, #4]
2401da0e:	4a10      	ldr	r2, [pc, #64]	; (2401da50 <TIM_Base_SetConfig+0x12c>)
2401da10:	4293      	cmp	r3, r2
2401da12:	d003      	beq.n	2401da1c <TIM_Base_SetConfig+0xf8>
2401da14:	687b      	ldr	r3, [r7, #4]
2401da16:	4a0f      	ldr	r2, [pc, #60]	; (2401da54 <TIM_Base_SetConfig+0x130>)
2401da18:	4293      	cmp	r3, r2
2401da1a:	d103      	bne.n	2401da24 <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
2401da1c:	683b      	ldr	r3, [r7, #0]
2401da1e:	691a      	ldr	r2, [r3, #16]
2401da20:	687b      	ldr	r3, [r7, #4]
2401da22:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
2401da24:	687b      	ldr	r3, [r7, #4]
2401da26:	2201      	movs	r2, #1
2401da28:	615a      	str	r2, [r3, #20]
}
2401da2a:	bf00      	nop
2401da2c:	3714      	adds	r7, #20
2401da2e:	46bd      	mov	sp, r7
2401da30:	f85d 7b04 	ldr.w	r7, [sp], #4
2401da34:	4770      	bx	lr
2401da36:	bf00      	nop
2401da38:	40010000 	.word	0x40010000
2401da3c:	40000400 	.word	0x40000400
2401da40:	40000800 	.word	0x40000800
2401da44:	40000c00 	.word	0x40000c00
2401da48:	40010400 	.word	0x40010400
2401da4c:	40014000 	.word	0x40014000
2401da50:	40014400 	.word	0x40014400
2401da54:	40014800 	.word	0x40014800

2401da58 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
2401da58:	b480      	push	{r7}
2401da5a:	b087      	sub	sp, #28
2401da5c:	af00      	add	r7, sp, #0
2401da5e:	6078      	str	r0, [r7, #4]
2401da60:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
2401da62:	687b      	ldr	r3, [r7, #4]
2401da64:	6a1b      	ldr	r3, [r3, #32]
2401da66:	f023 0201 	bic.w	r2, r3, #1
2401da6a:	687b      	ldr	r3, [r7, #4]
2401da6c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2401da6e:	687b      	ldr	r3, [r7, #4]
2401da70:	6a1b      	ldr	r3, [r3, #32]
2401da72:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2401da74:	687b      	ldr	r3, [r7, #4]
2401da76:	685b      	ldr	r3, [r3, #4]
2401da78:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
2401da7a:	687b      	ldr	r3, [r7, #4]
2401da7c:	699b      	ldr	r3, [r3, #24]
2401da7e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
2401da80:	68fa      	ldr	r2, [r7, #12]
2401da82:	4b37      	ldr	r3, [pc, #220]	; (2401db60 <TIM_OC1_SetConfig+0x108>)
2401da84:	4013      	ands	r3, r2
2401da86:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
2401da88:	68fb      	ldr	r3, [r7, #12]
2401da8a:	f023 0303 	bic.w	r3, r3, #3
2401da8e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
2401da90:	683b      	ldr	r3, [r7, #0]
2401da92:	681b      	ldr	r3, [r3, #0]
2401da94:	68fa      	ldr	r2, [r7, #12]
2401da96:	4313      	orrs	r3, r2
2401da98:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
2401da9a:	697b      	ldr	r3, [r7, #20]
2401da9c:	f023 0302 	bic.w	r3, r3, #2
2401daa0:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
2401daa2:	683b      	ldr	r3, [r7, #0]
2401daa4:	689b      	ldr	r3, [r3, #8]
2401daa6:	697a      	ldr	r2, [r7, #20]
2401daa8:	4313      	orrs	r3, r2
2401daaa:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
2401daac:	687b      	ldr	r3, [r7, #4]
2401daae:	4a2d      	ldr	r2, [pc, #180]	; (2401db64 <TIM_OC1_SetConfig+0x10c>)
2401dab0:	4293      	cmp	r3, r2
2401dab2:	d00f      	beq.n	2401dad4 <TIM_OC1_SetConfig+0x7c>
2401dab4:	687b      	ldr	r3, [r7, #4]
2401dab6:	4a2c      	ldr	r2, [pc, #176]	; (2401db68 <TIM_OC1_SetConfig+0x110>)
2401dab8:	4293      	cmp	r3, r2
2401daba:	d00b      	beq.n	2401dad4 <TIM_OC1_SetConfig+0x7c>
2401dabc:	687b      	ldr	r3, [r7, #4]
2401dabe:	4a2b      	ldr	r2, [pc, #172]	; (2401db6c <TIM_OC1_SetConfig+0x114>)
2401dac0:	4293      	cmp	r3, r2
2401dac2:	d007      	beq.n	2401dad4 <TIM_OC1_SetConfig+0x7c>
2401dac4:	687b      	ldr	r3, [r7, #4]
2401dac6:	4a2a      	ldr	r2, [pc, #168]	; (2401db70 <TIM_OC1_SetConfig+0x118>)
2401dac8:	4293      	cmp	r3, r2
2401daca:	d003      	beq.n	2401dad4 <TIM_OC1_SetConfig+0x7c>
2401dacc:	687b      	ldr	r3, [r7, #4]
2401dace:	4a29      	ldr	r2, [pc, #164]	; (2401db74 <TIM_OC1_SetConfig+0x11c>)
2401dad0:	4293      	cmp	r3, r2
2401dad2:	d10c      	bne.n	2401daee <TIM_OC1_SetConfig+0x96>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
2401dad4:	697b      	ldr	r3, [r7, #20]
2401dad6:	f023 0308 	bic.w	r3, r3, #8
2401dada:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
2401dadc:	683b      	ldr	r3, [r7, #0]
2401dade:	68db      	ldr	r3, [r3, #12]
2401dae0:	697a      	ldr	r2, [r7, #20]
2401dae2:	4313      	orrs	r3, r2
2401dae4:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
2401dae6:	697b      	ldr	r3, [r7, #20]
2401dae8:	f023 0304 	bic.w	r3, r3, #4
2401daec:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2401daee:	687b      	ldr	r3, [r7, #4]
2401daf0:	4a1c      	ldr	r2, [pc, #112]	; (2401db64 <TIM_OC1_SetConfig+0x10c>)
2401daf2:	4293      	cmp	r3, r2
2401daf4:	d00f      	beq.n	2401db16 <TIM_OC1_SetConfig+0xbe>
2401daf6:	687b      	ldr	r3, [r7, #4]
2401daf8:	4a1b      	ldr	r2, [pc, #108]	; (2401db68 <TIM_OC1_SetConfig+0x110>)
2401dafa:	4293      	cmp	r3, r2
2401dafc:	d00b      	beq.n	2401db16 <TIM_OC1_SetConfig+0xbe>
2401dafe:	687b      	ldr	r3, [r7, #4]
2401db00:	4a1a      	ldr	r2, [pc, #104]	; (2401db6c <TIM_OC1_SetConfig+0x114>)
2401db02:	4293      	cmp	r3, r2
2401db04:	d007      	beq.n	2401db16 <TIM_OC1_SetConfig+0xbe>
2401db06:	687b      	ldr	r3, [r7, #4]
2401db08:	4a19      	ldr	r2, [pc, #100]	; (2401db70 <TIM_OC1_SetConfig+0x118>)
2401db0a:	4293      	cmp	r3, r2
2401db0c:	d003      	beq.n	2401db16 <TIM_OC1_SetConfig+0xbe>
2401db0e:	687b      	ldr	r3, [r7, #4]
2401db10:	4a18      	ldr	r2, [pc, #96]	; (2401db74 <TIM_OC1_SetConfig+0x11c>)
2401db12:	4293      	cmp	r3, r2
2401db14:	d111      	bne.n	2401db3a <TIM_OC1_SetConfig+0xe2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
2401db16:	693b      	ldr	r3, [r7, #16]
2401db18:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2401db1c:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
2401db1e:	693b      	ldr	r3, [r7, #16]
2401db20:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2401db24:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
2401db26:	683b      	ldr	r3, [r7, #0]
2401db28:	695b      	ldr	r3, [r3, #20]
2401db2a:	693a      	ldr	r2, [r7, #16]
2401db2c:	4313      	orrs	r3, r2
2401db2e:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
2401db30:	683b      	ldr	r3, [r7, #0]
2401db32:	699b      	ldr	r3, [r3, #24]
2401db34:	693a      	ldr	r2, [r7, #16]
2401db36:	4313      	orrs	r3, r2
2401db38:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2401db3a:	687b      	ldr	r3, [r7, #4]
2401db3c:	693a      	ldr	r2, [r7, #16]
2401db3e:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
2401db40:	687b      	ldr	r3, [r7, #4]
2401db42:	68fa      	ldr	r2, [r7, #12]
2401db44:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
2401db46:	683b      	ldr	r3, [r7, #0]
2401db48:	685a      	ldr	r2, [r3, #4]
2401db4a:	687b      	ldr	r3, [r7, #4]
2401db4c:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2401db4e:	687b      	ldr	r3, [r7, #4]
2401db50:	697a      	ldr	r2, [r7, #20]
2401db52:	621a      	str	r2, [r3, #32]
}
2401db54:	bf00      	nop
2401db56:	371c      	adds	r7, #28
2401db58:	46bd      	mov	sp, r7
2401db5a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401db5e:	4770      	bx	lr
2401db60:	fffeff8f 	.word	0xfffeff8f
2401db64:	40010000 	.word	0x40010000
2401db68:	40010400 	.word	0x40010400
2401db6c:	40014000 	.word	0x40014000
2401db70:	40014400 	.word	0x40014400
2401db74:	40014800 	.word	0x40014800

2401db78 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
2401db78:	b480      	push	{r7}
2401db7a:	b087      	sub	sp, #28
2401db7c:	af00      	add	r7, sp, #0
2401db7e:	6078      	str	r0, [r7, #4]
2401db80:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
2401db82:	687b      	ldr	r3, [r7, #4]
2401db84:	6a1b      	ldr	r3, [r3, #32]
2401db86:	f023 0210 	bic.w	r2, r3, #16
2401db8a:	687b      	ldr	r3, [r7, #4]
2401db8c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2401db8e:	687b      	ldr	r3, [r7, #4]
2401db90:	6a1b      	ldr	r3, [r3, #32]
2401db92:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2401db94:	687b      	ldr	r3, [r7, #4]
2401db96:	685b      	ldr	r3, [r3, #4]
2401db98:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
2401db9a:	687b      	ldr	r3, [r7, #4]
2401db9c:	699b      	ldr	r3, [r3, #24]
2401db9e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
2401dba0:	68fa      	ldr	r2, [r7, #12]
2401dba2:	4b34      	ldr	r3, [pc, #208]	; (2401dc74 <TIM_OC2_SetConfig+0xfc>)
2401dba4:	4013      	ands	r3, r2
2401dba6:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
2401dba8:	68fb      	ldr	r3, [r7, #12]
2401dbaa:	f423 7340 	bic.w	r3, r3, #768	; 0x300
2401dbae:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
2401dbb0:	683b      	ldr	r3, [r7, #0]
2401dbb2:	681b      	ldr	r3, [r3, #0]
2401dbb4:	021b      	lsls	r3, r3, #8
2401dbb6:	68fa      	ldr	r2, [r7, #12]
2401dbb8:	4313      	orrs	r3, r2
2401dbba:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
2401dbbc:	697b      	ldr	r3, [r7, #20]
2401dbbe:	f023 0320 	bic.w	r3, r3, #32
2401dbc2:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
2401dbc4:	683b      	ldr	r3, [r7, #0]
2401dbc6:	689b      	ldr	r3, [r3, #8]
2401dbc8:	011b      	lsls	r3, r3, #4
2401dbca:	697a      	ldr	r2, [r7, #20]
2401dbcc:	4313      	orrs	r3, r2
2401dbce:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
2401dbd0:	687b      	ldr	r3, [r7, #4]
2401dbd2:	4a29      	ldr	r2, [pc, #164]	; (2401dc78 <TIM_OC2_SetConfig+0x100>)
2401dbd4:	4293      	cmp	r3, r2
2401dbd6:	d003      	beq.n	2401dbe0 <TIM_OC2_SetConfig+0x68>
2401dbd8:	687b      	ldr	r3, [r7, #4]
2401dbda:	4a28      	ldr	r2, [pc, #160]	; (2401dc7c <TIM_OC2_SetConfig+0x104>)
2401dbdc:	4293      	cmp	r3, r2
2401dbde:	d10d      	bne.n	2401dbfc <TIM_OC2_SetConfig+0x84>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
2401dbe0:	697b      	ldr	r3, [r7, #20]
2401dbe2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
2401dbe6:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
2401dbe8:	683b      	ldr	r3, [r7, #0]
2401dbea:	68db      	ldr	r3, [r3, #12]
2401dbec:	011b      	lsls	r3, r3, #4
2401dbee:	697a      	ldr	r2, [r7, #20]
2401dbf0:	4313      	orrs	r3, r2
2401dbf2:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
2401dbf4:	697b      	ldr	r3, [r7, #20]
2401dbf6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
2401dbfa:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2401dbfc:	687b      	ldr	r3, [r7, #4]
2401dbfe:	4a1e      	ldr	r2, [pc, #120]	; (2401dc78 <TIM_OC2_SetConfig+0x100>)
2401dc00:	4293      	cmp	r3, r2
2401dc02:	d00f      	beq.n	2401dc24 <TIM_OC2_SetConfig+0xac>
2401dc04:	687b      	ldr	r3, [r7, #4]
2401dc06:	4a1d      	ldr	r2, [pc, #116]	; (2401dc7c <TIM_OC2_SetConfig+0x104>)
2401dc08:	4293      	cmp	r3, r2
2401dc0a:	d00b      	beq.n	2401dc24 <TIM_OC2_SetConfig+0xac>
2401dc0c:	687b      	ldr	r3, [r7, #4]
2401dc0e:	4a1c      	ldr	r2, [pc, #112]	; (2401dc80 <TIM_OC2_SetConfig+0x108>)
2401dc10:	4293      	cmp	r3, r2
2401dc12:	d007      	beq.n	2401dc24 <TIM_OC2_SetConfig+0xac>
2401dc14:	687b      	ldr	r3, [r7, #4]
2401dc16:	4a1b      	ldr	r2, [pc, #108]	; (2401dc84 <TIM_OC2_SetConfig+0x10c>)
2401dc18:	4293      	cmp	r3, r2
2401dc1a:	d003      	beq.n	2401dc24 <TIM_OC2_SetConfig+0xac>
2401dc1c:	687b      	ldr	r3, [r7, #4]
2401dc1e:	4a1a      	ldr	r2, [pc, #104]	; (2401dc88 <TIM_OC2_SetConfig+0x110>)
2401dc20:	4293      	cmp	r3, r2
2401dc22:	d113      	bne.n	2401dc4c <TIM_OC2_SetConfig+0xd4>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
2401dc24:	693b      	ldr	r3, [r7, #16]
2401dc26:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
2401dc2a:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
2401dc2c:	693b      	ldr	r3, [r7, #16]
2401dc2e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
2401dc32:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
2401dc34:	683b      	ldr	r3, [r7, #0]
2401dc36:	695b      	ldr	r3, [r3, #20]
2401dc38:	009b      	lsls	r3, r3, #2
2401dc3a:	693a      	ldr	r2, [r7, #16]
2401dc3c:	4313      	orrs	r3, r2
2401dc3e:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
2401dc40:	683b      	ldr	r3, [r7, #0]
2401dc42:	699b      	ldr	r3, [r3, #24]
2401dc44:	009b      	lsls	r3, r3, #2
2401dc46:	693a      	ldr	r2, [r7, #16]
2401dc48:	4313      	orrs	r3, r2
2401dc4a:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2401dc4c:	687b      	ldr	r3, [r7, #4]
2401dc4e:	693a      	ldr	r2, [r7, #16]
2401dc50:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
2401dc52:	687b      	ldr	r3, [r7, #4]
2401dc54:	68fa      	ldr	r2, [r7, #12]
2401dc56:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
2401dc58:	683b      	ldr	r3, [r7, #0]
2401dc5a:	685a      	ldr	r2, [r3, #4]
2401dc5c:	687b      	ldr	r3, [r7, #4]
2401dc5e:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2401dc60:	687b      	ldr	r3, [r7, #4]
2401dc62:	697a      	ldr	r2, [r7, #20]
2401dc64:	621a      	str	r2, [r3, #32]
}
2401dc66:	bf00      	nop
2401dc68:	371c      	adds	r7, #28
2401dc6a:	46bd      	mov	sp, r7
2401dc6c:	f85d 7b04 	ldr.w	r7, [sp], #4
2401dc70:	4770      	bx	lr
2401dc72:	bf00      	nop
2401dc74:	feff8fff 	.word	0xfeff8fff
2401dc78:	40010000 	.word	0x40010000
2401dc7c:	40010400 	.word	0x40010400
2401dc80:	40014000 	.word	0x40014000
2401dc84:	40014400 	.word	0x40014400
2401dc88:	40014800 	.word	0x40014800

2401dc8c <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
2401dc8c:	b480      	push	{r7}
2401dc8e:	b087      	sub	sp, #28
2401dc90:	af00      	add	r7, sp, #0
2401dc92:	6078      	str	r0, [r7, #4]
2401dc94:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
2401dc96:	687b      	ldr	r3, [r7, #4]
2401dc98:	6a1b      	ldr	r3, [r3, #32]
2401dc9a:	f423 7280 	bic.w	r2, r3, #256	; 0x100
2401dc9e:	687b      	ldr	r3, [r7, #4]
2401dca0:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2401dca2:	687b      	ldr	r3, [r7, #4]
2401dca4:	6a1b      	ldr	r3, [r3, #32]
2401dca6:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2401dca8:	687b      	ldr	r3, [r7, #4]
2401dcaa:	685b      	ldr	r3, [r3, #4]
2401dcac:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
2401dcae:	687b      	ldr	r3, [r7, #4]
2401dcb0:	69db      	ldr	r3, [r3, #28]
2401dcb2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
2401dcb4:	68fa      	ldr	r2, [r7, #12]
2401dcb6:	4b33      	ldr	r3, [pc, #204]	; (2401dd84 <TIM_OC3_SetConfig+0xf8>)
2401dcb8:	4013      	ands	r3, r2
2401dcba:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
2401dcbc:	68fb      	ldr	r3, [r7, #12]
2401dcbe:	f023 0303 	bic.w	r3, r3, #3
2401dcc2:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
2401dcc4:	683b      	ldr	r3, [r7, #0]
2401dcc6:	681b      	ldr	r3, [r3, #0]
2401dcc8:	68fa      	ldr	r2, [r7, #12]
2401dcca:	4313      	orrs	r3, r2
2401dccc:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
2401dcce:	697b      	ldr	r3, [r7, #20]
2401dcd0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2401dcd4:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
2401dcd6:	683b      	ldr	r3, [r7, #0]
2401dcd8:	689b      	ldr	r3, [r3, #8]
2401dcda:	021b      	lsls	r3, r3, #8
2401dcdc:	697a      	ldr	r2, [r7, #20]
2401dcde:	4313      	orrs	r3, r2
2401dce0:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
2401dce2:	687b      	ldr	r3, [r7, #4]
2401dce4:	4a28      	ldr	r2, [pc, #160]	; (2401dd88 <TIM_OC3_SetConfig+0xfc>)
2401dce6:	4293      	cmp	r3, r2
2401dce8:	d003      	beq.n	2401dcf2 <TIM_OC3_SetConfig+0x66>
2401dcea:	687b      	ldr	r3, [r7, #4]
2401dcec:	4a27      	ldr	r2, [pc, #156]	; (2401dd8c <TIM_OC3_SetConfig+0x100>)
2401dcee:	4293      	cmp	r3, r2
2401dcf0:	d10d      	bne.n	2401dd0e <TIM_OC3_SetConfig+0x82>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
2401dcf2:	697b      	ldr	r3, [r7, #20]
2401dcf4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
2401dcf8:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
2401dcfa:	683b      	ldr	r3, [r7, #0]
2401dcfc:	68db      	ldr	r3, [r3, #12]
2401dcfe:	021b      	lsls	r3, r3, #8
2401dd00:	697a      	ldr	r2, [r7, #20]
2401dd02:	4313      	orrs	r3, r2
2401dd04:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
2401dd06:	697b      	ldr	r3, [r7, #20]
2401dd08:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
2401dd0c:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2401dd0e:	687b      	ldr	r3, [r7, #4]
2401dd10:	4a1d      	ldr	r2, [pc, #116]	; (2401dd88 <TIM_OC3_SetConfig+0xfc>)
2401dd12:	4293      	cmp	r3, r2
2401dd14:	d00f      	beq.n	2401dd36 <TIM_OC3_SetConfig+0xaa>
2401dd16:	687b      	ldr	r3, [r7, #4]
2401dd18:	4a1c      	ldr	r2, [pc, #112]	; (2401dd8c <TIM_OC3_SetConfig+0x100>)
2401dd1a:	4293      	cmp	r3, r2
2401dd1c:	d00b      	beq.n	2401dd36 <TIM_OC3_SetConfig+0xaa>
2401dd1e:	687b      	ldr	r3, [r7, #4]
2401dd20:	4a1b      	ldr	r2, [pc, #108]	; (2401dd90 <TIM_OC3_SetConfig+0x104>)
2401dd22:	4293      	cmp	r3, r2
2401dd24:	d007      	beq.n	2401dd36 <TIM_OC3_SetConfig+0xaa>
2401dd26:	687b      	ldr	r3, [r7, #4]
2401dd28:	4a1a      	ldr	r2, [pc, #104]	; (2401dd94 <TIM_OC3_SetConfig+0x108>)
2401dd2a:	4293      	cmp	r3, r2
2401dd2c:	d003      	beq.n	2401dd36 <TIM_OC3_SetConfig+0xaa>
2401dd2e:	687b      	ldr	r3, [r7, #4]
2401dd30:	4a19      	ldr	r2, [pc, #100]	; (2401dd98 <TIM_OC3_SetConfig+0x10c>)
2401dd32:	4293      	cmp	r3, r2
2401dd34:	d113      	bne.n	2401dd5e <TIM_OC3_SetConfig+0xd2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
2401dd36:	693b      	ldr	r3, [r7, #16]
2401dd38:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
2401dd3c:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
2401dd3e:	693b      	ldr	r3, [r7, #16]
2401dd40:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
2401dd44:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
2401dd46:	683b      	ldr	r3, [r7, #0]
2401dd48:	695b      	ldr	r3, [r3, #20]
2401dd4a:	011b      	lsls	r3, r3, #4
2401dd4c:	693a      	ldr	r2, [r7, #16]
2401dd4e:	4313      	orrs	r3, r2
2401dd50:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
2401dd52:	683b      	ldr	r3, [r7, #0]
2401dd54:	699b      	ldr	r3, [r3, #24]
2401dd56:	011b      	lsls	r3, r3, #4
2401dd58:	693a      	ldr	r2, [r7, #16]
2401dd5a:	4313      	orrs	r3, r2
2401dd5c:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2401dd5e:	687b      	ldr	r3, [r7, #4]
2401dd60:	693a      	ldr	r2, [r7, #16]
2401dd62:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
2401dd64:	687b      	ldr	r3, [r7, #4]
2401dd66:	68fa      	ldr	r2, [r7, #12]
2401dd68:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
2401dd6a:	683b      	ldr	r3, [r7, #0]
2401dd6c:	685a      	ldr	r2, [r3, #4]
2401dd6e:	687b      	ldr	r3, [r7, #4]
2401dd70:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2401dd72:	687b      	ldr	r3, [r7, #4]
2401dd74:	697a      	ldr	r2, [r7, #20]
2401dd76:	621a      	str	r2, [r3, #32]
}
2401dd78:	bf00      	nop
2401dd7a:	371c      	adds	r7, #28
2401dd7c:	46bd      	mov	sp, r7
2401dd7e:	f85d 7b04 	ldr.w	r7, [sp], #4
2401dd82:	4770      	bx	lr
2401dd84:	fffeff8f 	.word	0xfffeff8f
2401dd88:	40010000 	.word	0x40010000
2401dd8c:	40010400 	.word	0x40010400
2401dd90:	40014000 	.word	0x40014000
2401dd94:	40014400 	.word	0x40014400
2401dd98:	40014800 	.word	0x40014800

2401dd9c <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
2401dd9c:	b480      	push	{r7}
2401dd9e:	b087      	sub	sp, #28
2401dda0:	af00      	add	r7, sp, #0
2401dda2:	6078      	str	r0, [r7, #4]
2401dda4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
2401dda6:	687b      	ldr	r3, [r7, #4]
2401dda8:	6a1b      	ldr	r3, [r3, #32]
2401ddaa:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
2401ddae:	687b      	ldr	r3, [r7, #4]
2401ddb0:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2401ddb2:	687b      	ldr	r3, [r7, #4]
2401ddb4:	6a1b      	ldr	r3, [r3, #32]
2401ddb6:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2401ddb8:	687b      	ldr	r3, [r7, #4]
2401ddba:	685b      	ldr	r3, [r3, #4]
2401ddbc:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
2401ddbe:	687b      	ldr	r3, [r7, #4]
2401ddc0:	69db      	ldr	r3, [r3, #28]
2401ddc2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
2401ddc4:	68fa      	ldr	r2, [r7, #12]
2401ddc6:	4b24      	ldr	r3, [pc, #144]	; (2401de58 <TIM_OC4_SetConfig+0xbc>)
2401ddc8:	4013      	ands	r3, r2
2401ddca:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
2401ddcc:	68fb      	ldr	r3, [r7, #12]
2401ddce:	f423 7340 	bic.w	r3, r3, #768	; 0x300
2401ddd2:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
2401ddd4:	683b      	ldr	r3, [r7, #0]
2401ddd6:	681b      	ldr	r3, [r3, #0]
2401ddd8:	021b      	lsls	r3, r3, #8
2401ddda:	68fa      	ldr	r2, [r7, #12]
2401dddc:	4313      	orrs	r3, r2
2401ddde:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
2401dde0:	693b      	ldr	r3, [r7, #16]
2401dde2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
2401dde6:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
2401dde8:	683b      	ldr	r3, [r7, #0]
2401ddea:	689b      	ldr	r3, [r3, #8]
2401ddec:	031b      	lsls	r3, r3, #12
2401ddee:	693a      	ldr	r2, [r7, #16]
2401ddf0:	4313      	orrs	r3, r2
2401ddf2:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2401ddf4:	687b      	ldr	r3, [r7, #4]
2401ddf6:	4a19      	ldr	r2, [pc, #100]	; (2401de5c <TIM_OC4_SetConfig+0xc0>)
2401ddf8:	4293      	cmp	r3, r2
2401ddfa:	d00f      	beq.n	2401de1c <TIM_OC4_SetConfig+0x80>
2401ddfc:	687b      	ldr	r3, [r7, #4]
2401ddfe:	4a18      	ldr	r2, [pc, #96]	; (2401de60 <TIM_OC4_SetConfig+0xc4>)
2401de00:	4293      	cmp	r3, r2
2401de02:	d00b      	beq.n	2401de1c <TIM_OC4_SetConfig+0x80>
2401de04:	687b      	ldr	r3, [r7, #4]
2401de06:	4a17      	ldr	r2, [pc, #92]	; (2401de64 <TIM_OC4_SetConfig+0xc8>)
2401de08:	4293      	cmp	r3, r2
2401de0a:	d007      	beq.n	2401de1c <TIM_OC4_SetConfig+0x80>
2401de0c:	687b      	ldr	r3, [r7, #4]
2401de0e:	4a16      	ldr	r2, [pc, #88]	; (2401de68 <TIM_OC4_SetConfig+0xcc>)
2401de10:	4293      	cmp	r3, r2
2401de12:	d003      	beq.n	2401de1c <TIM_OC4_SetConfig+0x80>
2401de14:	687b      	ldr	r3, [r7, #4]
2401de16:	4a15      	ldr	r2, [pc, #84]	; (2401de6c <TIM_OC4_SetConfig+0xd0>)
2401de18:	4293      	cmp	r3, r2
2401de1a:	d109      	bne.n	2401de30 <TIM_OC4_SetConfig+0x94>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
2401de1c:	697b      	ldr	r3, [r7, #20]
2401de1e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
2401de22:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
2401de24:	683b      	ldr	r3, [r7, #0]
2401de26:	695b      	ldr	r3, [r3, #20]
2401de28:	019b      	lsls	r3, r3, #6
2401de2a:	697a      	ldr	r2, [r7, #20]
2401de2c:	4313      	orrs	r3, r2
2401de2e:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2401de30:	687b      	ldr	r3, [r7, #4]
2401de32:	697a      	ldr	r2, [r7, #20]
2401de34:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
2401de36:	687b      	ldr	r3, [r7, #4]
2401de38:	68fa      	ldr	r2, [r7, #12]
2401de3a:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
2401de3c:	683b      	ldr	r3, [r7, #0]
2401de3e:	685a      	ldr	r2, [r3, #4]
2401de40:	687b      	ldr	r3, [r7, #4]
2401de42:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2401de44:	687b      	ldr	r3, [r7, #4]
2401de46:	693a      	ldr	r2, [r7, #16]
2401de48:	621a      	str	r2, [r3, #32]
}
2401de4a:	bf00      	nop
2401de4c:	371c      	adds	r7, #28
2401de4e:	46bd      	mov	sp, r7
2401de50:	f85d 7b04 	ldr.w	r7, [sp], #4
2401de54:	4770      	bx	lr
2401de56:	bf00      	nop
2401de58:	feff8fff 	.word	0xfeff8fff
2401de5c:	40010000 	.word	0x40010000
2401de60:	40010400 	.word	0x40010400
2401de64:	40014000 	.word	0x40014000
2401de68:	40014400 	.word	0x40014400
2401de6c:	40014800 	.word	0x40014800

2401de70 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              const TIM_OC_InitTypeDef *OC_Config)
{
2401de70:	b480      	push	{r7}
2401de72:	b087      	sub	sp, #28
2401de74:	af00      	add	r7, sp, #0
2401de76:	6078      	str	r0, [r7, #4]
2401de78:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
2401de7a:	687b      	ldr	r3, [r7, #4]
2401de7c:	6a1b      	ldr	r3, [r3, #32]
2401de7e:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
2401de82:	687b      	ldr	r3, [r7, #4]
2401de84:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2401de86:	687b      	ldr	r3, [r7, #4]
2401de88:	6a1b      	ldr	r3, [r3, #32]
2401de8a:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2401de8c:	687b      	ldr	r3, [r7, #4]
2401de8e:	685b      	ldr	r3, [r3, #4]
2401de90:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
2401de92:	687b      	ldr	r3, [r7, #4]
2401de94:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401de96:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
2401de98:	68fa      	ldr	r2, [r7, #12]
2401de9a:	4b21      	ldr	r3, [pc, #132]	; (2401df20 <TIM_OC5_SetConfig+0xb0>)
2401de9c:	4013      	ands	r3, r2
2401de9e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
2401dea0:	683b      	ldr	r3, [r7, #0]
2401dea2:	681b      	ldr	r3, [r3, #0]
2401dea4:	68fa      	ldr	r2, [r7, #12]
2401dea6:	4313      	orrs	r3, r2
2401dea8:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
2401deaa:	693b      	ldr	r3, [r7, #16]
2401deac:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
2401deb0:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
2401deb2:	683b      	ldr	r3, [r7, #0]
2401deb4:	689b      	ldr	r3, [r3, #8]
2401deb6:	041b      	lsls	r3, r3, #16
2401deb8:	693a      	ldr	r2, [r7, #16]
2401deba:	4313      	orrs	r3, r2
2401debc:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2401debe:	687b      	ldr	r3, [r7, #4]
2401dec0:	4a18      	ldr	r2, [pc, #96]	; (2401df24 <TIM_OC5_SetConfig+0xb4>)
2401dec2:	4293      	cmp	r3, r2
2401dec4:	d00f      	beq.n	2401dee6 <TIM_OC5_SetConfig+0x76>
2401dec6:	687b      	ldr	r3, [r7, #4]
2401dec8:	4a17      	ldr	r2, [pc, #92]	; (2401df28 <TIM_OC5_SetConfig+0xb8>)
2401deca:	4293      	cmp	r3, r2
2401decc:	d00b      	beq.n	2401dee6 <TIM_OC5_SetConfig+0x76>
2401dece:	687b      	ldr	r3, [r7, #4]
2401ded0:	4a16      	ldr	r2, [pc, #88]	; (2401df2c <TIM_OC5_SetConfig+0xbc>)
2401ded2:	4293      	cmp	r3, r2
2401ded4:	d007      	beq.n	2401dee6 <TIM_OC5_SetConfig+0x76>
2401ded6:	687b      	ldr	r3, [r7, #4]
2401ded8:	4a15      	ldr	r2, [pc, #84]	; (2401df30 <TIM_OC5_SetConfig+0xc0>)
2401deda:	4293      	cmp	r3, r2
2401dedc:	d003      	beq.n	2401dee6 <TIM_OC5_SetConfig+0x76>
2401dede:	687b      	ldr	r3, [r7, #4]
2401dee0:	4a14      	ldr	r2, [pc, #80]	; (2401df34 <TIM_OC5_SetConfig+0xc4>)
2401dee2:	4293      	cmp	r3, r2
2401dee4:	d109      	bne.n	2401defa <TIM_OC5_SetConfig+0x8a>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
2401dee6:	697b      	ldr	r3, [r7, #20]
2401dee8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401deec:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
2401deee:	683b      	ldr	r3, [r7, #0]
2401def0:	695b      	ldr	r3, [r3, #20]
2401def2:	021b      	lsls	r3, r3, #8
2401def4:	697a      	ldr	r2, [r7, #20]
2401def6:	4313      	orrs	r3, r2
2401def8:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2401defa:	687b      	ldr	r3, [r7, #4]
2401defc:	697a      	ldr	r2, [r7, #20]
2401defe:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
2401df00:	687b      	ldr	r3, [r7, #4]
2401df02:	68fa      	ldr	r2, [r7, #12]
2401df04:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
2401df06:	683b      	ldr	r3, [r7, #0]
2401df08:	685a      	ldr	r2, [r3, #4]
2401df0a:	687b      	ldr	r3, [r7, #4]
2401df0c:	659a      	str	r2, [r3, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2401df0e:	687b      	ldr	r3, [r7, #4]
2401df10:	693a      	ldr	r2, [r7, #16]
2401df12:	621a      	str	r2, [r3, #32]
}
2401df14:	bf00      	nop
2401df16:	371c      	adds	r7, #28
2401df18:	46bd      	mov	sp, r7
2401df1a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401df1e:	4770      	bx	lr
2401df20:	fffeff8f 	.word	0xfffeff8f
2401df24:	40010000 	.word	0x40010000
2401df28:	40010400 	.word	0x40010400
2401df2c:	40014000 	.word	0x40014000
2401df30:	40014400 	.word	0x40014400
2401df34:	40014800 	.word	0x40014800

2401df38 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              const TIM_OC_InitTypeDef *OC_Config)
{
2401df38:	b480      	push	{r7}
2401df3a:	b087      	sub	sp, #28
2401df3c:	af00      	add	r7, sp, #0
2401df3e:	6078      	str	r0, [r7, #4]
2401df40:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
2401df42:	687b      	ldr	r3, [r7, #4]
2401df44:	6a1b      	ldr	r3, [r3, #32]
2401df46:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
2401df4a:	687b      	ldr	r3, [r7, #4]
2401df4c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2401df4e:	687b      	ldr	r3, [r7, #4]
2401df50:	6a1b      	ldr	r3, [r3, #32]
2401df52:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2401df54:	687b      	ldr	r3, [r7, #4]
2401df56:	685b      	ldr	r3, [r3, #4]
2401df58:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
2401df5a:	687b      	ldr	r3, [r7, #4]
2401df5c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401df5e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
2401df60:	68fa      	ldr	r2, [r7, #12]
2401df62:	4b22      	ldr	r3, [pc, #136]	; (2401dfec <TIM_OC6_SetConfig+0xb4>)
2401df64:	4013      	ands	r3, r2
2401df66:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
2401df68:	683b      	ldr	r3, [r7, #0]
2401df6a:	681b      	ldr	r3, [r3, #0]
2401df6c:	021b      	lsls	r3, r3, #8
2401df6e:	68fa      	ldr	r2, [r7, #12]
2401df70:	4313      	orrs	r3, r2
2401df72:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
2401df74:	693b      	ldr	r3, [r7, #16]
2401df76:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
2401df7a:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
2401df7c:	683b      	ldr	r3, [r7, #0]
2401df7e:	689b      	ldr	r3, [r3, #8]
2401df80:	051b      	lsls	r3, r3, #20
2401df82:	693a      	ldr	r2, [r7, #16]
2401df84:	4313      	orrs	r3, r2
2401df86:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2401df88:	687b      	ldr	r3, [r7, #4]
2401df8a:	4a19      	ldr	r2, [pc, #100]	; (2401dff0 <TIM_OC6_SetConfig+0xb8>)
2401df8c:	4293      	cmp	r3, r2
2401df8e:	d00f      	beq.n	2401dfb0 <TIM_OC6_SetConfig+0x78>
2401df90:	687b      	ldr	r3, [r7, #4]
2401df92:	4a18      	ldr	r2, [pc, #96]	; (2401dff4 <TIM_OC6_SetConfig+0xbc>)
2401df94:	4293      	cmp	r3, r2
2401df96:	d00b      	beq.n	2401dfb0 <TIM_OC6_SetConfig+0x78>
2401df98:	687b      	ldr	r3, [r7, #4]
2401df9a:	4a17      	ldr	r2, [pc, #92]	; (2401dff8 <TIM_OC6_SetConfig+0xc0>)
2401df9c:	4293      	cmp	r3, r2
2401df9e:	d007      	beq.n	2401dfb0 <TIM_OC6_SetConfig+0x78>
2401dfa0:	687b      	ldr	r3, [r7, #4]
2401dfa2:	4a16      	ldr	r2, [pc, #88]	; (2401dffc <TIM_OC6_SetConfig+0xc4>)
2401dfa4:	4293      	cmp	r3, r2
2401dfa6:	d003      	beq.n	2401dfb0 <TIM_OC6_SetConfig+0x78>
2401dfa8:	687b      	ldr	r3, [r7, #4]
2401dfaa:	4a15      	ldr	r2, [pc, #84]	; (2401e000 <TIM_OC6_SetConfig+0xc8>)
2401dfac:	4293      	cmp	r3, r2
2401dfae:	d109      	bne.n	2401dfc4 <TIM_OC6_SetConfig+0x8c>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
2401dfb0:	697b      	ldr	r3, [r7, #20]
2401dfb2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
2401dfb6:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
2401dfb8:	683b      	ldr	r3, [r7, #0]
2401dfba:	695b      	ldr	r3, [r3, #20]
2401dfbc:	029b      	lsls	r3, r3, #10
2401dfbe:	697a      	ldr	r2, [r7, #20]
2401dfc0:	4313      	orrs	r3, r2
2401dfc2:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2401dfc4:	687b      	ldr	r3, [r7, #4]
2401dfc6:	697a      	ldr	r2, [r7, #20]
2401dfc8:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
2401dfca:	687b      	ldr	r3, [r7, #4]
2401dfcc:	68fa      	ldr	r2, [r7, #12]
2401dfce:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
2401dfd0:	683b      	ldr	r3, [r7, #0]
2401dfd2:	685a      	ldr	r2, [r3, #4]
2401dfd4:	687b      	ldr	r3, [r7, #4]
2401dfd6:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2401dfd8:	687b      	ldr	r3, [r7, #4]
2401dfda:	693a      	ldr	r2, [r7, #16]
2401dfdc:	621a      	str	r2, [r3, #32]
}
2401dfde:	bf00      	nop
2401dfe0:	371c      	adds	r7, #28
2401dfe2:	46bd      	mov	sp, r7
2401dfe4:	f85d 7b04 	ldr.w	r7, [sp], #4
2401dfe8:	4770      	bx	lr
2401dfea:	bf00      	nop
2401dfec:	feff8fff 	.word	0xfeff8fff
2401dff0:	40010000 	.word	0x40010000
2401dff4:	40010400 	.word	0x40010400
2401dff8:	40014000 	.word	0x40014000
2401dffc:	40014400 	.word	0x40014400
2401e000:	40014800 	.word	0x40014800

2401e004 <TIM_SlaveTimer_SetConfig>:
  * @param  sSlaveConfig Slave timer configuration
  * @retval None
  */
static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
                                                  const TIM_SlaveConfigTypeDef *sSlaveConfig)
{
2401e004:	b580      	push	{r7, lr}
2401e006:	b086      	sub	sp, #24
2401e008:	af00      	add	r7, sp, #0
2401e00a:	6078      	str	r0, [r7, #4]
2401e00c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401e00e:	2300      	movs	r3, #0
2401e010:	75fb      	strb	r3, [r7, #23]
  uint32_t tmpsmcr;
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
2401e012:	687b      	ldr	r3, [r7, #4]
2401e014:	681b      	ldr	r3, [r3, #0]
2401e016:	689b      	ldr	r3, [r3, #8]
2401e018:	613b      	str	r3, [r7, #16]

  /* Reset the Trigger Selection Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
2401e01a:	693a      	ldr	r2, [r7, #16]
2401e01c:	4b65      	ldr	r3, [pc, #404]	; (2401e1b4 <TIM_SlaveTimer_SetConfig+0x1b0>)
2401e01e:	4013      	ands	r3, r2
2401e020:	613b      	str	r3, [r7, #16]
  /* Set the Input Trigger source */
  tmpsmcr |= sSlaveConfig->InputTrigger;
2401e022:	683b      	ldr	r3, [r7, #0]
2401e024:	685b      	ldr	r3, [r3, #4]
2401e026:	693a      	ldr	r2, [r7, #16]
2401e028:	4313      	orrs	r3, r2
2401e02a:	613b      	str	r3, [r7, #16]

  /* Reset the slave mode Bits */
  tmpsmcr &= ~TIM_SMCR_SMS;
2401e02c:	693a      	ldr	r2, [r7, #16]
2401e02e:	4b62      	ldr	r3, [pc, #392]	; (2401e1b8 <TIM_SlaveTimer_SetConfig+0x1b4>)
2401e030:	4013      	ands	r3, r2
2401e032:	613b      	str	r3, [r7, #16]
  /* Set the slave mode */
  tmpsmcr |= sSlaveConfig->SlaveMode;
2401e034:	683b      	ldr	r3, [r7, #0]
2401e036:	681b      	ldr	r3, [r3, #0]
2401e038:	693a      	ldr	r2, [r7, #16]
2401e03a:	4313      	orrs	r3, r2
2401e03c:	613b      	str	r3, [r7, #16]

  /* Write to TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
2401e03e:	687b      	ldr	r3, [r7, #4]
2401e040:	681b      	ldr	r3, [r3, #0]
2401e042:	693a      	ldr	r2, [r7, #16]
2401e044:	609a      	str	r2, [r3, #8]

  /* Configure the trigger prescaler, filter, and polarity */
  switch (sSlaveConfig->InputTrigger)
2401e046:	683b      	ldr	r3, [r7, #0]
2401e048:	685b      	ldr	r3, [r3, #4]
2401e04a:	4a5c      	ldr	r2, [pc, #368]	; (2401e1bc <TIM_SlaveTimer_SetConfig+0x1b8>)
2401e04c:	4293      	cmp	r3, r2
2401e04e:	f000 80ab 	beq.w	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e052:	4a5a      	ldr	r2, [pc, #360]	; (2401e1bc <TIM_SlaveTimer_SetConfig+0x1b8>)
2401e054:	4293      	cmp	r3, r2
2401e056:	f200 80a4 	bhi.w	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e05a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2401e05e:	f000 80a3 	beq.w	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e062:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2401e066:	f200 809c 	bhi.w	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e06a:	4a55      	ldr	r2, [pc, #340]	; (2401e1c0 <TIM_SlaveTimer_SetConfig+0x1bc>)
2401e06c:	4293      	cmp	r3, r2
2401e06e:	f000 809b 	beq.w	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e072:	4a53      	ldr	r2, [pc, #332]	; (2401e1c0 <TIM_SlaveTimer_SetConfig+0x1bc>)
2401e074:	4293      	cmp	r3, r2
2401e076:	f200 8094 	bhi.w	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e07a:	4a52      	ldr	r2, [pc, #328]	; (2401e1c4 <TIM_SlaveTimer_SetConfig+0x1c0>)
2401e07c:	4293      	cmp	r3, r2
2401e07e:	f000 8093 	beq.w	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e082:	4a50      	ldr	r2, [pc, #320]	; (2401e1c4 <TIM_SlaveTimer_SetConfig+0x1c0>)
2401e084:	4293      	cmp	r3, r2
2401e086:	f200 808c 	bhi.w	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e08a:	4a4f      	ldr	r2, [pc, #316]	; (2401e1c8 <TIM_SlaveTimer_SetConfig+0x1c4>)
2401e08c:	4293      	cmp	r3, r2
2401e08e:	f000 808b 	beq.w	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e092:	4a4d      	ldr	r2, [pc, #308]	; (2401e1c8 <TIM_SlaveTimer_SetConfig+0x1c4>)
2401e094:	4293      	cmp	r3, r2
2401e096:	f200 8084 	bhi.w	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e09a:	4a4c      	ldr	r2, [pc, #304]	; (2401e1cc <TIM_SlaveTimer_SetConfig+0x1c8>)
2401e09c:	4293      	cmp	r3, r2
2401e09e:	f000 8083 	beq.w	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e0a2:	4a4a      	ldr	r2, [pc, #296]	; (2401e1cc <TIM_SlaveTimer_SetConfig+0x1c8>)
2401e0a4:	4293      	cmp	r3, r2
2401e0a6:	d87c      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0a8:	4a49      	ldr	r2, [pc, #292]	; (2401e1d0 <TIM_SlaveTimer_SetConfig+0x1cc>)
2401e0aa:	4293      	cmp	r3, r2
2401e0ac:	d07c      	beq.n	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e0ae:	4a48      	ldr	r2, [pc, #288]	; (2401e1d0 <TIM_SlaveTimer_SetConfig+0x1cc>)
2401e0b0:	4293      	cmp	r3, r2
2401e0b2:	d876      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0b4:	4a47      	ldr	r2, [pc, #284]	; (2401e1d4 <TIM_SlaveTimer_SetConfig+0x1d0>)
2401e0b6:	4293      	cmp	r3, r2
2401e0b8:	d076      	beq.n	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e0ba:	4a46      	ldr	r2, [pc, #280]	; (2401e1d4 <TIM_SlaveTimer_SetConfig+0x1d0>)
2401e0bc:	4293      	cmp	r3, r2
2401e0be:	d870      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0c0:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
2401e0c4:	d070      	beq.n	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e0c6:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
2401e0ca:	d86a      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0cc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2401e0d0:	d06a      	beq.n	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e0d2:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2401e0d6:	d864      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0d8:	2b70      	cmp	r3, #112	; 0x70
2401e0da:	d01a      	beq.n	2401e112 <TIM_SlaveTimer_SetConfig+0x10e>
2401e0dc:	2b70      	cmp	r3, #112	; 0x70
2401e0de:	d860      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0e0:	2b60      	cmp	r3, #96	; 0x60
2401e0e2:	d054      	beq.n	2401e18e <TIM_SlaveTimer_SetConfig+0x18a>
2401e0e4:	2b60      	cmp	r3, #96	; 0x60
2401e0e6:	d85c      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0e8:	2b50      	cmp	r3, #80	; 0x50
2401e0ea:	d046      	beq.n	2401e17a <TIM_SlaveTimer_SetConfig+0x176>
2401e0ec:	2b50      	cmp	r3, #80	; 0x50
2401e0ee:	d858      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0f0:	2b40      	cmp	r3, #64	; 0x40
2401e0f2:	d019      	beq.n	2401e128 <TIM_SlaveTimer_SetConfig+0x124>
2401e0f4:	2b40      	cmp	r3, #64	; 0x40
2401e0f6:	d854      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e0f8:	2b30      	cmp	r3, #48	; 0x30
2401e0fa:	d055      	beq.n	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e0fc:	2b30      	cmp	r3, #48	; 0x30
2401e0fe:	d850      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e100:	2b20      	cmp	r3, #32
2401e102:	d051      	beq.n	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e104:	2b20      	cmp	r3, #32
2401e106:	d84c      	bhi.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
2401e108:	2b00      	cmp	r3, #0
2401e10a:	d04d      	beq.n	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e10c:	2b10      	cmp	r3, #16
2401e10e:	d04b      	beq.n	2401e1a8 <TIM_SlaveTimer_SetConfig+0x1a4>
2401e110:	e047      	b.n	2401e1a2 <TIM_SlaveTimer_SetConfig+0x19e>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
      assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
      /* Configure the ETR Trigger source */
      TIM_ETR_SetConfig(htim->Instance,
2401e112:	687b      	ldr	r3, [r7, #4]
2401e114:	6818      	ldr	r0, [r3, #0]
2401e116:	683b      	ldr	r3, [r7, #0]
2401e118:	68d9      	ldr	r1, [r3, #12]
2401e11a:	683b      	ldr	r3, [r7, #0]
2401e11c:	689a      	ldr	r2, [r3, #8]
2401e11e:	683b      	ldr	r3, [r7, #0]
2401e120:	691b      	ldr	r3, [r3, #16]
2401e122:	f000 fa01 	bl	2401e528 <TIM_ETR_SetConfig>
                        sSlaveConfig->TriggerPrescaler,
                        sSlaveConfig->TriggerPolarity,
                        sSlaveConfig->TriggerFilter);
      break;
2401e126:	e040      	b.n	2401e1aa <TIM_SlaveTimer_SetConfig+0x1a6>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));

      if (sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
2401e128:	683b      	ldr	r3, [r7, #0]
2401e12a:	681b      	ldr	r3, [r3, #0]
2401e12c:	2b05      	cmp	r3, #5
2401e12e:	d101      	bne.n	2401e134 <TIM_SlaveTimer_SetConfig+0x130>
      {
        return HAL_ERROR;
2401e130:	2301      	movs	r3, #1
2401e132:	e03b      	b.n	2401e1ac <TIM_SlaveTimer_SetConfig+0x1a8>
      }

      /* Disable the Channel 1: Reset the CC1E Bit */
      tmpccer = htim->Instance->CCER;
2401e134:	687b      	ldr	r3, [r7, #4]
2401e136:	681b      	ldr	r3, [r3, #0]
2401e138:	6a1b      	ldr	r3, [r3, #32]
2401e13a:	60fb      	str	r3, [r7, #12]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
2401e13c:	687b      	ldr	r3, [r7, #4]
2401e13e:	681b      	ldr	r3, [r3, #0]
2401e140:	6a1a      	ldr	r2, [r3, #32]
2401e142:	687b      	ldr	r3, [r7, #4]
2401e144:	681b      	ldr	r3, [r3, #0]
2401e146:	f022 0201 	bic.w	r2, r2, #1
2401e14a:	621a      	str	r2, [r3, #32]
      tmpccmr1 = htim->Instance->CCMR1;
2401e14c:	687b      	ldr	r3, [r7, #4]
2401e14e:	681b      	ldr	r3, [r3, #0]
2401e150:	699b      	ldr	r3, [r3, #24]
2401e152:	60bb      	str	r3, [r7, #8]

      /* Set the filter */
      tmpccmr1 &= ~TIM_CCMR1_IC1F;
2401e154:	68bb      	ldr	r3, [r7, #8]
2401e156:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
2401e15a:	60bb      	str	r3, [r7, #8]
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
2401e15c:	683b      	ldr	r3, [r7, #0]
2401e15e:	691b      	ldr	r3, [r3, #16]
2401e160:	011b      	lsls	r3, r3, #4
2401e162:	68ba      	ldr	r2, [r7, #8]
2401e164:	4313      	orrs	r3, r2
2401e166:	60bb      	str	r3, [r7, #8]

      /* Write to TIMx CCMR1 and CCER registers */
      htim->Instance->CCMR1 = tmpccmr1;
2401e168:	687b      	ldr	r3, [r7, #4]
2401e16a:	681b      	ldr	r3, [r3, #0]
2401e16c:	68ba      	ldr	r2, [r7, #8]
2401e16e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCER = tmpccer;
2401e170:	687b      	ldr	r3, [r7, #4]
2401e172:	681b      	ldr	r3, [r3, #0]
2401e174:	68fa      	ldr	r2, [r7, #12]
2401e176:	621a      	str	r2, [r3, #32]
      break;
2401e178:	e017      	b.n	2401e1aa <TIM_SlaveTimer_SetConfig+0x1a6>
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));

      /* Configure TI1 Filter and Polarity */
      TIM_TI1_ConfigInputStage(htim->Instance,
2401e17a:	687b      	ldr	r3, [r7, #4]
2401e17c:	6818      	ldr	r0, [r3, #0]
2401e17e:	683b      	ldr	r3, [r7, #0]
2401e180:	6899      	ldr	r1, [r3, #8]
2401e182:	683b      	ldr	r3, [r7, #0]
2401e184:	691b      	ldr	r3, [r3, #16]
2401e186:	461a      	mov	r2, r3
2401e188:	f000 f89a 	bl	2401e2c0 <TIM_TI1_ConfigInputStage>
                               sSlaveConfig->TriggerPolarity,
                               sSlaveConfig->TriggerFilter);
      break;
2401e18c:	e00d      	b.n	2401e1aa <TIM_SlaveTimer_SetConfig+0x1a6>
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));

      /* Configure TI2 Filter and Polarity */
      TIM_TI2_ConfigInputStage(htim->Instance,
2401e18e:	687b      	ldr	r3, [r7, #4]
2401e190:	6818      	ldr	r0, [r3, #0]
2401e192:	683b      	ldr	r3, [r7, #0]
2401e194:	6899      	ldr	r1, [r3, #8]
2401e196:	683b      	ldr	r3, [r7, #0]
2401e198:	691b      	ldr	r3, [r3, #16]
2401e19a:	461a      	mov	r2, r3
2401e19c:	f000 f8fc 	bl	2401e398 <TIM_TI2_ConfigInputStage>
                               sSlaveConfig->TriggerPolarity,
                               sSlaveConfig->TriggerFilter);
      break;
2401e1a0:	e003      	b.n	2401e1aa <TIM_SlaveTimer_SetConfig+0x1a6>
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
      break;
    }

    default:
      status = HAL_ERROR;
2401e1a2:	2301      	movs	r3, #1
2401e1a4:	75fb      	strb	r3, [r7, #23]
      break;
2401e1a6:	e000      	b.n	2401e1aa <TIM_SlaveTimer_SetConfig+0x1a6>
      break;
2401e1a8:	bf00      	nop
  }

  return status;
2401e1aa:	7dfb      	ldrb	r3, [r7, #23]
}
2401e1ac:	4618      	mov	r0, r3
2401e1ae:	3718      	adds	r7, #24
2401e1b0:	46bd      	mov	sp, r7
2401e1b2:	bd80      	pop	{r7, pc}
2401e1b4:	ffcfff8f 	.word	0xffcfff8f
2401e1b8:	fffefff8 	.word	0xfffefff8
2401e1bc:	00200010 	.word	0x00200010
2401e1c0:	00100070 	.word	0x00100070
2401e1c4:	00100060 	.word	0x00100060
2401e1c8:	00100050 	.word	0x00100050
2401e1cc:	00100040 	.word	0x00100040
2401e1d0:	00100030 	.word	0x00100030
2401e1d4:	00100020 	.word	0x00100020

2401e1d8 <TIM_TI1_SetConfig>:
  *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  */
void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                       uint32_t TIM_ICFilter)
{
2401e1d8:	b480      	push	{r7}
2401e1da:	b087      	sub	sp, #28
2401e1dc:	af00      	add	r7, sp, #0
2401e1de:	60f8      	str	r0, [r7, #12]
2401e1e0:	60b9      	str	r1, [r7, #8]
2401e1e2:	607a      	str	r2, [r7, #4]
2401e1e4:	603b      	str	r3, [r7, #0]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
2401e1e6:	68fb      	ldr	r3, [r7, #12]
2401e1e8:	6a1b      	ldr	r3, [r3, #32]
2401e1ea:	f023 0201 	bic.w	r2, r3, #1
2401e1ee:	68fb      	ldr	r3, [r7, #12]
2401e1f0:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
2401e1f2:	68fb      	ldr	r3, [r7, #12]
2401e1f4:	699b      	ldr	r3, [r3, #24]
2401e1f6:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
2401e1f8:	68fb      	ldr	r3, [r7, #12]
2401e1fa:	6a1b      	ldr	r3, [r3, #32]
2401e1fc:	613b      	str	r3, [r7, #16]

  /* Select the Input */
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
2401e1fe:	68fb      	ldr	r3, [r7, #12]
2401e200:	4a28      	ldr	r2, [pc, #160]	; (2401e2a4 <TIM_TI1_SetConfig+0xcc>)
2401e202:	4293      	cmp	r3, r2
2401e204:	d01b      	beq.n	2401e23e <TIM_TI1_SetConfig+0x66>
2401e206:	68fb      	ldr	r3, [r7, #12]
2401e208:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401e20c:	d017      	beq.n	2401e23e <TIM_TI1_SetConfig+0x66>
2401e20e:	68fb      	ldr	r3, [r7, #12]
2401e210:	4a25      	ldr	r2, [pc, #148]	; (2401e2a8 <TIM_TI1_SetConfig+0xd0>)
2401e212:	4293      	cmp	r3, r2
2401e214:	d013      	beq.n	2401e23e <TIM_TI1_SetConfig+0x66>
2401e216:	68fb      	ldr	r3, [r7, #12]
2401e218:	4a24      	ldr	r2, [pc, #144]	; (2401e2ac <TIM_TI1_SetConfig+0xd4>)
2401e21a:	4293      	cmp	r3, r2
2401e21c:	d00f      	beq.n	2401e23e <TIM_TI1_SetConfig+0x66>
2401e21e:	68fb      	ldr	r3, [r7, #12]
2401e220:	4a23      	ldr	r2, [pc, #140]	; (2401e2b0 <TIM_TI1_SetConfig+0xd8>)
2401e222:	4293      	cmp	r3, r2
2401e224:	d00b      	beq.n	2401e23e <TIM_TI1_SetConfig+0x66>
2401e226:	68fb      	ldr	r3, [r7, #12]
2401e228:	4a22      	ldr	r2, [pc, #136]	; (2401e2b4 <TIM_TI1_SetConfig+0xdc>)
2401e22a:	4293      	cmp	r3, r2
2401e22c:	d007      	beq.n	2401e23e <TIM_TI1_SetConfig+0x66>
2401e22e:	68fb      	ldr	r3, [r7, #12]
2401e230:	4a21      	ldr	r2, [pc, #132]	; (2401e2b8 <TIM_TI1_SetConfig+0xe0>)
2401e232:	4293      	cmp	r3, r2
2401e234:	d003      	beq.n	2401e23e <TIM_TI1_SetConfig+0x66>
2401e236:	68fb      	ldr	r3, [r7, #12]
2401e238:	4a20      	ldr	r2, [pc, #128]	; (2401e2bc <TIM_TI1_SetConfig+0xe4>)
2401e23a:	4293      	cmp	r3, r2
2401e23c:	d101      	bne.n	2401e242 <TIM_TI1_SetConfig+0x6a>
2401e23e:	2301      	movs	r3, #1
2401e240:	e000      	b.n	2401e244 <TIM_TI1_SetConfig+0x6c>
2401e242:	2300      	movs	r3, #0
2401e244:	2b00      	cmp	r3, #0
2401e246:	d008      	beq.n	2401e25a <TIM_TI1_SetConfig+0x82>
  {
    tmpccmr1 &= ~TIM_CCMR1_CC1S;
2401e248:	697b      	ldr	r3, [r7, #20]
2401e24a:	f023 0303 	bic.w	r3, r3, #3
2401e24e:	617b      	str	r3, [r7, #20]
    tmpccmr1 |= TIM_ICSelection;
2401e250:	697a      	ldr	r2, [r7, #20]
2401e252:	687b      	ldr	r3, [r7, #4]
2401e254:	4313      	orrs	r3, r2
2401e256:	617b      	str	r3, [r7, #20]
2401e258:	e003      	b.n	2401e262 <TIM_TI1_SetConfig+0x8a>
  }
  else
  {
    tmpccmr1 |= TIM_CCMR1_CC1S_0;
2401e25a:	697b      	ldr	r3, [r7, #20]
2401e25c:	f043 0301 	orr.w	r3, r3, #1
2401e260:	617b      	str	r3, [r7, #20]
  }

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
2401e262:	697b      	ldr	r3, [r7, #20]
2401e264:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
2401e268:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
2401e26a:	683b      	ldr	r3, [r7, #0]
2401e26c:	011b      	lsls	r3, r3, #4
2401e26e:	b2db      	uxtb	r3, r3
2401e270:	697a      	ldr	r2, [r7, #20]
2401e272:	4313      	orrs	r3, r2
2401e274:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
2401e276:	693b      	ldr	r3, [r7, #16]
2401e278:	f023 030a 	bic.w	r3, r3, #10
2401e27c:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
2401e27e:	68bb      	ldr	r3, [r7, #8]
2401e280:	f003 030a 	and.w	r3, r3, #10
2401e284:	693a      	ldr	r2, [r7, #16]
2401e286:	4313      	orrs	r3, r2
2401e288:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
2401e28a:	68fb      	ldr	r3, [r7, #12]
2401e28c:	697a      	ldr	r2, [r7, #20]
2401e28e:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
2401e290:	68fb      	ldr	r3, [r7, #12]
2401e292:	693a      	ldr	r2, [r7, #16]
2401e294:	621a      	str	r2, [r3, #32]
}
2401e296:	bf00      	nop
2401e298:	371c      	adds	r7, #28
2401e29a:	46bd      	mov	sp, r7
2401e29c:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e2a0:	4770      	bx	lr
2401e2a2:	bf00      	nop
2401e2a4:	40010000 	.word	0x40010000
2401e2a8:	40000400 	.word	0x40000400
2401e2ac:	40000800 	.word	0x40000800
2401e2b0:	40000c00 	.word	0x40000c00
2401e2b4:	40010400 	.word	0x40010400
2401e2b8:	40001800 	.word	0x40001800
2401e2bc:	40014000 	.word	0x40014000

2401e2c0 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
2401e2c0:	b480      	push	{r7}
2401e2c2:	b087      	sub	sp, #28
2401e2c4:	af00      	add	r7, sp, #0
2401e2c6:	60f8      	str	r0, [r7, #12]
2401e2c8:	60b9      	str	r1, [r7, #8]
2401e2ca:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
2401e2cc:	68fb      	ldr	r3, [r7, #12]
2401e2ce:	6a1b      	ldr	r3, [r3, #32]
2401e2d0:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
2401e2d2:	68fb      	ldr	r3, [r7, #12]
2401e2d4:	6a1b      	ldr	r3, [r3, #32]
2401e2d6:	f023 0201 	bic.w	r2, r3, #1
2401e2da:	68fb      	ldr	r3, [r7, #12]
2401e2dc:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
2401e2de:	68fb      	ldr	r3, [r7, #12]
2401e2e0:	699b      	ldr	r3, [r3, #24]
2401e2e2:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
2401e2e4:	693b      	ldr	r3, [r7, #16]
2401e2e6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
2401e2ea:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
2401e2ec:	687b      	ldr	r3, [r7, #4]
2401e2ee:	011b      	lsls	r3, r3, #4
2401e2f0:	693a      	ldr	r2, [r7, #16]
2401e2f2:	4313      	orrs	r3, r2
2401e2f4:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
2401e2f6:	697b      	ldr	r3, [r7, #20]
2401e2f8:	f023 030a 	bic.w	r3, r3, #10
2401e2fc:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
2401e2fe:	697a      	ldr	r2, [r7, #20]
2401e300:	68bb      	ldr	r3, [r7, #8]
2401e302:	4313      	orrs	r3, r2
2401e304:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
2401e306:	68fb      	ldr	r3, [r7, #12]
2401e308:	693a      	ldr	r2, [r7, #16]
2401e30a:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
2401e30c:	68fb      	ldr	r3, [r7, #12]
2401e30e:	697a      	ldr	r2, [r7, #20]
2401e310:	621a      	str	r2, [r3, #32]
}
2401e312:	bf00      	nop
2401e314:	371c      	adds	r7, #28
2401e316:	46bd      	mov	sp, r7
2401e318:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e31c:	4770      	bx	lr

2401e31e <TIM_TI2_SetConfig>:
  *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  */
static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
2401e31e:	b480      	push	{r7}
2401e320:	b087      	sub	sp, #28
2401e322:	af00      	add	r7, sp, #0
2401e324:	60f8      	str	r0, [r7, #12]
2401e326:	60b9      	str	r1, [r7, #8]
2401e328:	607a      	str	r2, [r7, #4]
2401e32a:	603b      	str	r3, [r7, #0]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
2401e32c:	68fb      	ldr	r3, [r7, #12]
2401e32e:	6a1b      	ldr	r3, [r3, #32]
2401e330:	f023 0210 	bic.w	r2, r3, #16
2401e334:	68fb      	ldr	r3, [r7, #12]
2401e336:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
2401e338:	68fb      	ldr	r3, [r7, #12]
2401e33a:	699b      	ldr	r3, [r3, #24]
2401e33c:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
2401e33e:	68fb      	ldr	r3, [r7, #12]
2401e340:	6a1b      	ldr	r3, [r3, #32]
2401e342:	613b      	str	r3, [r7, #16]

  /* Select the Input */
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
2401e344:	697b      	ldr	r3, [r7, #20]
2401e346:	f423 7340 	bic.w	r3, r3, #768	; 0x300
2401e34a:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICSelection << 8U);
2401e34c:	687b      	ldr	r3, [r7, #4]
2401e34e:	021b      	lsls	r3, r3, #8
2401e350:	697a      	ldr	r2, [r7, #20]
2401e352:	4313      	orrs	r3, r2
2401e354:	617b      	str	r3, [r7, #20]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
2401e356:	697b      	ldr	r3, [r7, #20]
2401e358:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
2401e35c:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
2401e35e:	683b      	ldr	r3, [r7, #0]
2401e360:	031b      	lsls	r3, r3, #12
2401e362:	b29b      	uxth	r3, r3
2401e364:	697a      	ldr	r2, [r7, #20]
2401e366:	4313      	orrs	r3, r2
2401e368:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
2401e36a:	693b      	ldr	r3, [r7, #16]
2401e36c:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
2401e370:	613b      	str	r3, [r7, #16]
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
2401e372:	68bb      	ldr	r3, [r7, #8]
2401e374:	011b      	lsls	r3, r3, #4
2401e376:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
2401e37a:	693a      	ldr	r2, [r7, #16]
2401e37c:	4313      	orrs	r3, r2
2401e37e:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
2401e380:	68fb      	ldr	r3, [r7, #12]
2401e382:	697a      	ldr	r2, [r7, #20]
2401e384:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
2401e386:	68fb      	ldr	r3, [r7, #12]
2401e388:	693a      	ldr	r2, [r7, #16]
2401e38a:	621a      	str	r2, [r3, #32]
}
2401e38c:	bf00      	nop
2401e38e:	371c      	adds	r7, #28
2401e390:	46bd      	mov	sp, r7
2401e392:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e396:	4770      	bx	lr

2401e398 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
2401e398:	b480      	push	{r7}
2401e39a:	b087      	sub	sp, #28
2401e39c:	af00      	add	r7, sp, #0
2401e39e:	60f8      	str	r0, [r7, #12]
2401e3a0:	60b9      	str	r1, [r7, #8]
2401e3a2:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
2401e3a4:	68fb      	ldr	r3, [r7, #12]
2401e3a6:	6a1b      	ldr	r3, [r3, #32]
2401e3a8:	f023 0210 	bic.w	r2, r3, #16
2401e3ac:	68fb      	ldr	r3, [r7, #12]
2401e3ae:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
2401e3b0:	68fb      	ldr	r3, [r7, #12]
2401e3b2:	699b      	ldr	r3, [r3, #24]
2401e3b4:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
2401e3b6:	68fb      	ldr	r3, [r7, #12]
2401e3b8:	6a1b      	ldr	r3, [r3, #32]
2401e3ba:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
2401e3bc:	697b      	ldr	r3, [r7, #20]
2401e3be:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
2401e3c2:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
2401e3c4:	687b      	ldr	r3, [r7, #4]
2401e3c6:	031b      	lsls	r3, r3, #12
2401e3c8:	697a      	ldr	r2, [r7, #20]
2401e3ca:	4313      	orrs	r3, r2
2401e3cc:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
2401e3ce:	693b      	ldr	r3, [r7, #16]
2401e3d0:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
2401e3d4:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
2401e3d6:	68bb      	ldr	r3, [r7, #8]
2401e3d8:	011b      	lsls	r3, r3, #4
2401e3da:	693a      	ldr	r2, [r7, #16]
2401e3dc:	4313      	orrs	r3, r2
2401e3de:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
2401e3e0:	68fb      	ldr	r3, [r7, #12]
2401e3e2:	697a      	ldr	r2, [r7, #20]
2401e3e4:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
2401e3e6:	68fb      	ldr	r3, [r7, #12]
2401e3e8:	693a      	ldr	r2, [r7, #16]
2401e3ea:	621a      	str	r2, [r3, #32]
}
2401e3ec:	bf00      	nop
2401e3ee:	371c      	adds	r7, #28
2401e3f0:	46bd      	mov	sp, r7
2401e3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e3f6:	4770      	bx	lr

2401e3f8 <TIM_TI3_SetConfig>:
  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
  *        protected against un-initialized filter and polarity values.
  */
static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
2401e3f8:	b480      	push	{r7}
2401e3fa:	b087      	sub	sp, #28
2401e3fc:	af00      	add	r7, sp, #0
2401e3fe:	60f8      	str	r0, [r7, #12]
2401e400:	60b9      	str	r1, [r7, #8]
2401e402:	607a      	str	r2, [r7, #4]
2401e404:	603b      	str	r3, [r7, #0]
  uint32_t tmpccmr2;
  uint32_t tmpccer;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
2401e406:	68fb      	ldr	r3, [r7, #12]
2401e408:	6a1b      	ldr	r3, [r3, #32]
2401e40a:	f423 7280 	bic.w	r2, r3, #256	; 0x100
2401e40e:	68fb      	ldr	r3, [r7, #12]
2401e410:	621a      	str	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
2401e412:	68fb      	ldr	r3, [r7, #12]
2401e414:	69db      	ldr	r3, [r3, #28]
2401e416:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
2401e418:	68fb      	ldr	r3, [r7, #12]
2401e41a:	6a1b      	ldr	r3, [r3, #32]
2401e41c:	613b      	str	r3, [r7, #16]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC3S;
2401e41e:	697b      	ldr	r3, [r7, #20]
2401e420:	f023 0303 	bic.w	r3, r3, #3
2401e424:	617b      	str	r3, [r7, #20]
  tmpccmr2 |= TIM_ICSelection;
2401e426:	697a      	ldr	r2, [r7, #20]
2401e428:	687b      	ldr	r3, [r7, #4]
2401e42a:	4313      	orrs	r3, r2
2401e42c:	617b      	str	r3, [r7, #20]

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
2401e42e:	697b      	ldr	r3, [r7, #20]
2401e430:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
2401e434:	617b      	str	r3, [r7, #20]
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
2401e436:	683b      	ldr	r3, [r7, #0]
2401e438:	011b      	lsls	r3, r3, #4
2401e43a:	b2db      	uxtb	r3, r3
2401e43c:	697a      	ldr	r2, [r7, #20]
2401e43e:	4313      	orrs	r3, r2
2401e440:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
2401e442:	693b      	ldr	r3, [r7, #16]
2401e444:	f423 6320 	bic.w	r3, r3, #2560	; 0xa00
2401e448:	613b      	str	r3, [r7, #16]
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
2401e44a:	68bb      	ldr	r3, [r7, #8]
2401e44c:	021b      	lsls	r3, r3, #8
2401e44e:	f403 6320 	and.w	r3, r3, #2560	; 0xa00
2401e452:	693a      	ldr	r2, [r7, #16]
2401e454:	4313      	orrs	r3, r2
2401e456:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
2401e458:	68fb      	ldr	r3, [r7, #12]
2401e45a:	697a      	ldr	r2, [r7, #20]
2401e45c:	61da      	str	r2, [r3, #28]
  TIMx->CCER = tmpccer;
2401e45e:	68fb      	ldr	r3, [r7, #12]
2401e460:	693a      	ldr	r2, [r7, #16]
2401e462:	621a      	str	r2, [r3, #32]
}
2401e464:	bf00      	nop
2401e466:	371c      	adds	r7, #28
2401e468:	46bd      	mov	sp, r7
2401e46a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e46e:	4770      	bx	lr

2401e470 <TIM_TI4_SetConfig>:
  *        protected against un-initialized filter and polarity values.
  * @retval None
  */
static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
2401e470:	b480      	push	{r7}
2401e472:	b087      	sub	sp, #28
2401e474:	af00      	add	r7, sp, #0
2401e476:	60f8      	str	r0, [r7, #12]
2401e478:	60b9      	str	r1, [r7, #8]
2401e47a:	607a      	str	r2, [r7, #4]
2401e47c:	603b      	str	r3, [r7, #0]
  uint32_t tmpccmr2;
  uint32_t tmpccer;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
2401e47e:	68fb      	ldr	r3, [r7, #12]
2401e480:	6a1b      	ldr	r3, [r3, #32]
2401e482:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
2401e486:	68fb      	ldr	r3, [r7, #12]
2401e488:	621a      	str	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
2401e48a:	68fb      	ldr	r3, [r7, #12]
2401e48c:	69db      	ldr	r3, [r3, #28]
2401e48e:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
2401e490:	68fb      	ldr	r3, [r7, #12]
2401e492:	6a1b      	ldr	r3, [r3, #32]
2401e494:	613b      	str	r3, [r7, #16]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
2401e496:	697b      	ldr	r3, [r7, #20]
2401e498:	f423 7340 	bic.w	r3, r3, #768	; 0x300
2401e49c:	617b      	str	r3, [r7, #20]
  tmpccmr2 |= (TIM_ICSelection << 8U);
2401e49e:	687b      	ldr	r3, [r7, #4]
2401e4a0:	021b      	lsls	r3, r3, #8
2401e4a2:	697a      	ldr	r2, [r7, #20]
2401e4a4:	4313      	orrs	r3, r2
2401e4a6:	617b      	str	r3, [r7, #20]

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
2401e4a8:	697b      	ldr	r3, [r7, #20]
2401e4aa:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
2401e4ae:	617b      	str	r3, [r7, #20]
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
2401e4b0:	683b      	ldr	r3, [r7, #0]
2401e4b2:	031b      	lsls	r3, r3, #12
2401e4b4:	b29b      	uxth	r3, r3
2401e4b6:	697a      	ldr	r2, [r7, #20]
2401e4b8:	4313      	orrs	r3, r2
2401e4ba:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
2401e4bc:	693b      	ldr	r3, [r7, #16]
2401e4be:	f423 4320 	bic.w	r3, r3, #40960	; 0xa000
2401e4c2:	613b      	str	r3, [r7, #16]
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
2401e4c4:	68bb      	ldr	r3, [r7, #8]
2401e4c6:	031b      	lsls	r3, r3, #12
2401e4c8:	f403 4320 	and.w	r3, r3, #40960	; 0xa000
2401e4cc:	693a      	ldr	r2, [r7, #16]
2401e4ce:	4313      	orrs	r3, r2
2401e4d0:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
2401e4d2:	68fb      	ldr	r3, [r7, #12]
2401e4d4:	697a      	ldr	r2, [r7, #20]
2401e4d6:	61da      	str	r2, [r3, #28]
  TIMx->CCER = tmpccer ;
2401e4d8:	68fb      	ldr	r3, [r7, #12]
2401e4da:	693a      	ldr	r2, [r7, #16]
2401e4dc:	621a      	str	r2, [r3, #32]
}
2401e4de:	bf00      	nop
2401e4e0:	371c      	adds	r7, #28
2401e4e2:	46bd      	mov	sp, r7
2401e4e4:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e4e8:	4770      	bx	lr
	...

2401e4ec <TIM_ITRx_SetConfig>:
  *       (*)  Value not defined in all devices.
  *
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
2401e4ec:	b480      	push	{r7}
2401e4ee:	b085      	sub	sp, #20
2401e4f0:	af00      	add	r7, sp, #0
2401e4f2:	6078      	str	r0, [r7, #4]
2401e4f4:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
2401e4f6:	687b      	ldr	r3, [r7, #4]
2401e4f8:	689b      	ldr	r3, [r3, #8]
2401e4fa:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
2401e4fc:	68fa      	ldr	r2, [r7, #12]
2401e4fe:	4b09      	ldr	r3, [pc, #36]	; (2401e524 <TIM_ITRx_SetConfig+0x38>)
2401e500:	4013      	ands	r3, r2
2401e502:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
2401e504:	683a      	ldr	r2, [r7, #0]
2401e506:	68fb      	ldr	r3, [r7, #12]
2401e508:	4313      	orrs	r3, r2
2401e50a:	f043 0307 	orr.w	r3, r3, #7
2401e50e:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
2401e510:	687b      	ldr	r3, [r7, #4]
2401e512:	68fa      	ldr	r2, [r7, #12]
2401e514:	609a      	str	r2, [r3, #8]
}
2401e516:	bf00      	nop
2401e518:	3714      	adds	r7, #20
2401e51a:	46bd      	mov	sp, r7
2401e51c:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e520:	4770      	bx	lr
2401e522:	bf00      	nop
2401e524:	ffcfff8f 	.word	0xffcfff8f

2401e528 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
2401e528:	b480      	push	{r7}
2401e52a:	b087      	sub	sp, #28
2401e52c:	af00      	add	r7, sp, #0
2401e52e:	60f8      	str	r0, [r7, #12]
2401e530:	60b9      	str	r1, [r7, #8]
2401e532:	607a      	str	r2, [r7, #4]
2401e534:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
2401e536:	68fb      	ldr	r3, [r7, #12]
2401e538:	689b      	ldr	r3, [r3, #8]
2401e53a:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
2401e53c:	697b      	ldr	r3, [r7, #20]
2401e53e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
2401e542:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
2401e544:	683b      	ldr	r3, [r7, #0]
2401e546:	021a      	lsls	r2, r3, #8
2401e548:	687b      	ldr	r3, [r7, #4]
2401e54a:	431a      	orrs	r2, r3
2401e54c:	68bb      	ldr	r3, [r7, #8]
2401e54e:	4313      	orrs	r3, r2
2401e550:	697a      	ldr	r2, [r7, #20]
2401e552:	4313      	orrs	r3, r2
2401e554:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
2401e556:	68fb      	ldr	r3, [r7, #12]
2401e558:	697a      	ldr	r2, [r7, #20]
2401e55a:	609a      	str	r2, [r3, #8]
}
2401e55c:	bf00      	nop
2401e55e:	371c      	adds	r7, #28
2401e560:	46bd      	mov	sp, r7
2401e562:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e566:	4770      	bx	lr

2401e568 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
2401e568:	b480      	push	{r7}
2401e56a:	b087      	sub	sp, #28
2401e56c:	af00      	add	r7, sp, #0
2401e56e:	60f8      	str	r0, [r7, #12]
2401e570:	60b9      	str	r1, [r7, #8]
2401e572:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
2401e574:	68bb      	ldr	r3, [r7, #8]
2401e576:	f003 031f 	and.w	r3, r3, #31
2401e57a:	2201      	movs	r2, #1
2401e57c:	fa02 f303 	lsl.w	r3, r2, r3
2401e580:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
2401e582:	68fb      	ldr	r3, [r7, #12]
2401e584:	6a1a      	ldr	r2, [r3, #32]
2401e586:	697b      	ldr	r3, [r7, #20]
2401e588:	43db      	mvns	r3, r3
2401e58a:	401a      	ands	r2, r3
2401e58c:	68fb      	ldr	r3, [r7, #12]
2401e58e:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2401e590:	68fb      	ldr	r3, [r7, #12]
2401e592:	6a1a      	ldr	r2, [r3, #32]
2401e594:	68bb      	ldr	r3, [r7, #8]
2401e596:	f003 031f 	and.w	r3, r3, #31
2401e59a:	6879      	ldr	r1, [r7, #4]
2401e59c:	fa01 f303 	lsl.w	r3, r1, r3
2401e5a0:	431a      	orrs	r2, r3
2401e5a2:	68fb      	ldr	r3, [r7, #12]
2401e5a4:	621a      	str	r2, [r3, #32]
}
2401e5a6:	bf00      	nop
2401e5a8:	371c      	adds	r7, #28
2401e5aa:	46bd      	mov	sp, r7
2401e5ac:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e5b0:	4770      	bx	lr
	...

2401e5b4 <HAL_TIMEx_HallSensor_Init>:
  * @param  htim TIM Hall Sensor Interface handle
  * @param  sConfig TIM Hall Sensor configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, const TIM_HallSensor_InitTypeDef *sConfig)
{
2401e5b4:	b580      	push	{r7, lr}
2401e5b6:	b08a      	sub	sp, #40	; 0x28
2401e5b8:	af00      	add	r7, sp, #0
2401e5ba:	6078      	str	r0, [r7, #4]
2401e5bc:	6039      	str	r1, [r7, #0]
  TIM_OC_InitTypeDef OC_Config;

  /* Check the TIM handle allocation */
  if (htim == NULL)
2401e5be:	687b      	ldr	r3, [r7, #4]
2401e5c0:	2b00      	cmp	r3, #0
2401e5c2:	d101      	bne.n	2401e5c8 <HAL_TIMEx_HallSensor_Init+0x14>
  {
    return HAL_ERROR;
2401e5c4:	2301      	movs	r3, #1
2401e5c6:	e09a      	b.n	2401e6fe <HAL_TIMEx_HallSensor_Init+0x14a>
  assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));

  if (htim->State == HAL_TIM_STATE_RESET)
2401e5c8:	687b      	ldr	r3, [r7, #4]
2401e5ca:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2401e5ce:	b2db      	uxtb	r3, r3
2401e5d0:	2b00      	cmp	r3, #0
2401e5d2:	d106      	bne.n	2401e5e2 <HAL_TIMEx_HallSensor_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
2401e5d4:	687b      	ldr	r3, [r7, #4]
2401e5d6:	2200      	movs	r2, #0
2401e5d8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->HallSensor_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIMEx_HallSensor_MspInit(htim);
2401e5dc:	6878      	ldr	r0, [r7, #4]
2401e5de:	f000 f8db 	bl	2401e798 <HAL_TIMEx_HallSensor_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
2401e5e2:	687b      	ldr	r3, [r7, #4]
2401e5e4:	2202      	movs	r2, #2
2401e5e6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Configure the Time base in the Encoder Mode */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2401e5ea:	687b      	ldr	r3, [r7, #4]
2401e5ec:	681a      	ldr	r2, [r3, #0]
2401e5ee:	687b      	ldr	r3, [r7, #4]
2401e5f0:	3304      	adds	r3, #4
2401e5f2:	4619      	mov	r1, r3
2401e5f4:	4610      	mov	r0, r2
2401e5f6:	f7ff f995 	bl	2401d924 <TIM_Base_SetConfig>

  /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
  TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
2401e5fa:	687b      	ldr	r3, [r7, #4]
2401e5fc:	6818      	ldr	r0, [r3, #0]
2401e5fe:	683b      	ldr	r3, [r7, #0]
2401e600:	6819      	ldr	r1, [r3, #0]
2401e602:	683b      	ldr	r3, [r7, #0]
2401e604:	689b      	ldr	r3, [r3, #8]
2401e606:	2203      	movs	r2, #3
2401e608:	f7ff fde6 	bl	2401e1d8 <TIM_TI1_SetConfig>

  /* Reset the IC1PSC Bits */
  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
2401e60c:	687b      	ldr	r3, [r7, #4]
2401e60e:	681b      	ldr	r3, [r3, #0]
2401e610:	699a      	ldr	r2, [r3, #24]
2401e612:	687b      	ldr	r3, [r7, #4]
2401e614:	681b      	ldr	r3, [r3, #0]
2401e616:	f022 020c 	bic.w	r2, r2, #12
2401e61a:	619a      	str	r2, [r3, #24]
  /* Set the IC1PSC value */
  htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
2401e61c:	687b      	ldr	r3, [r7, #4]
2401e61e:	681b      	ldr	r3, [r3, #0]
2401e620:	6999      	ldr	r1, [r3, #24]
2401e622:	683b      	ldr	r3, [r7, #0]
2401e624:	685a      	ldr	r2, [r3, #4]
2401e626:	687b      	ldr	r3, [r7, #4]
2401e628:	681b      	ldr	r3, [r3, #0]
2401e62a:	430a      	orrs	r2, r1
2401e62c:	619a      	str	r2, [r3, #24]

  /* Enable the Hall sensor interface (XOR function of the three inputs) */
  htim->Instance->CR2 |= TIM_CR2_TI1S;
2401e62e:	687b      	ldr	r3, [r7, #4]
2401e630:	681b      	ldr	r3, [r3, #0]
2401e632:	685a      	ldr	r2, [r3, #4]
2401e634:	687b      	ldr	r3, [r7, #4]
2401e636:	681b      	ldr	r3, [r3, #0]
2401e638:	f042 0280 	orr.w	r2, r2, #128	; 0x80
2401e63c:	605a      	str	r2, [r3, #4]

  /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
  htim->Instance->SMCR &= ~TIM_SMCR_TS;
2401e63e:	687b      	ldr	r3, [r7, #4]
2401e640:	681b      	ldr	r3, [r3, #0]
2401e642:	6899      	ldr	r1, [r3, #8]
2401e644:	687b      	ldr	r3, [r7, #4]
2401e646:	681a      	ldr	r2, [r3, #0]
2401e648:	4b2f      	ldr	r3, [pc, #188]	; (2401e708 <HAL_TIMEx_HallSensor_Init+0x154>)
2401e64a:	400b      	ands	r3, r1
2401e64c:	6093      	str	r3, [r2, #8]
  htim->Instance->SMCR |= TIM_TS_TI1F_ED;
2401e64e:	687b      	ldr	r3, [r7, #4]
2401e650:	681b      	ldr	r3, [r3, #0]
2401e652:	689a      	ldr	r2, [r3, #8]
2401e654:	687b      	ldr	r3, [r7, #4]
2401e656:	681b      	ldr	r3, [r3, #0]
2401e658:	f042 0240 	orr.w	r2, r2, #64	; 0x40
2401e65c:	609a      	str	r2, [r3, #8]

  /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
2401e65e:	687b      	ldr	r3, [r7, #4]
2401e660:	681b      	ldr	r3, [r3, #0]
2401e662:	6899      	ldr	r1, [r3, #8]
2401e664:	687b      	ldr	r3, [r7, #4]
2401e666:	681a      	ldr	r2, [r3, #0]
2401e668:	4b28      	ldr	r3, [pc, #160]	; (2401e70c <HAL_TIMEx_HallSensor_Init+0x158>)
2401e66a:	400b      	ands	r3, r1
2401e66c:	6093      	str	r3, [r2, #8]
  htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
2401e66e:	687b      	ldr	r3, [r7, #4]
2401e670:	681b      	ldr	r3, [r3, #0]
2401e672:	689a      	ldr	r2, [r3, #8]
2401e674:	687b      	ldr	r3, [r7, #4]
2401e676:	681b      	ldr	r3, [r3, #0]
2401e678:	f042 0204 	orr.w	r2, r2, #4
2401e67c:	609a      	str	r2, [r3, #8]

  /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
  OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
2401e67e:	2300      	movs	r3, #0
2401e680:	61fb      	str	r3, [r7, #28]
  OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
2401e682:	2300      	movs	r3, #0
2401e684:	623b      	str	r3, [r7, #32]
  OC_Config.OCMode = TIM_OCMODE_PWM2;
2401e686:	2370      	movs	r3, #112	; 0x70
2401e688:	60fb      	str	r3, [r7, #12]
  OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
2401e68a:	2300      	movs	r3, #0
2401e68c:	627b      	str	r3, [r7, #36]	; 0x24
  OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
2401e68e:	2300      	movs	r3, #0
2401e690:	61bb      	str	r3, [r7, #24]
  OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
2401e692:	2300      	movs	r3, #0
2401e694:	617b      	str	r3, [r7, #20]
  OC_Config.Pulse = sConfig->Commutation_Delay;
2401e696:	683b      	ldr	r3, [r7, #0]
2401e698:	68db      	ldr	r3, [r3, #12]
2401e69a:	613b      	str	r3, [r7, #16]

  TIM_OC2_SetConfig(htim->Instance, &OC_Config);
2401e69c:	687b      	ldr	r3, [r7, #4]
2401e69e:	681b      	ldr	r3, [r3, #0]
2401e6a0:	f107 020c 	add.w	r2, r7, #12
2401e6a4:	4611      	mov	r1, r2
2401e6a6:	4618      	mov	r0, r3
2401e6a8:	f7ff fa66 	bl	2401db78 <TIM_OC2_SetConfig>

  /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    register to 101 */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
2401e6ac:	687b      	ldr	r3, [r7, #4]
2401e6ae:	681b      	ldr	r3, [r3, #0]
2401e6b0:	685a      	ldr	r2, [r3, #4]
2401e6b2:	687b      	ldr	r3, [r7, #4]
2401e6b4:	681b      	ldr	r3, [r3, #0]
2401e6b6:	f022 0270 	bic.w	r2, r2, #112	; 0x70
2401e6ba:	605a      	str	r2, [r3, #4]
  htim->Instance->CR2 |= TIM_TRGO_OC2REF;
2401e6bc:	687b      	ldr	r3, [r7, #4]
2401e6be:	681b      	ldr	r3, [r3, #0]
2401e6c0:	685a      	ldr	r2, [r3, #4]
2401e6c2:	687b      	ldr	r3, [r7, #4]
2401e6c4:	681b      	ldr	r3, [r3, #0]
2401e6c6:	f042 0250 	orr.w	r2, r2, #80	; 0x50
2401e6ca:	605a      	str	r2, [r3, #4]

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
2401e6cc:	687b      	ldr	r3, [r7, #4]
2401e6ce:	2201      	movs	r2, #1
2401e6d0:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401e6d4:	687b      	ldr	r3, [r7, #4]
2401e6d6:	2201      	movs	r2, #1
2401e6d8:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401e6dc:	687b      	ldr	r3, [r7, #4]
2401e6de:	2201      	movs	r2, #1
2401e6e0:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401e6e4:	687b      	ldr	r3, [r7, #4]
2401e6e6:	2201      	movs	r2, #1
2401e6e8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401e6ec:	687b      	ldr	r3, [r7, #4]
2401e6ee:	2201      	movs	r2, #1
2401e6f0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
2401e6f4:	687b      	ldr	r3, [r7, #4]
2401e6f6:	2201      	movs	r2, #1
2401e6f8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
2401e6fc:	2300      	movs	r3, #0
}
2401e6fe:	4618      	mov	r0, r3
2401e700:	3728      	adds	r7, #40	; 0x28
2401e702:	46bd      	mov	sp, r7
2401e704:	bd80      	pop	{r7, pc}
2401e706:	bf00      	nop
2401e708:	ffcfff8f 	.word	0xffcfff8f
2401e70c:	fffefff8 	.word	0xfffefff8

2401e710 <HAL_TIMEx_HallSensor_DeInit>:
  * @brief  DeInitializes the TIM Hall Sensor interface
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
{
2401e710:	b580      	push	{r7, lr}
2401e712:	b082      	sub	sp, #8
2401e714:	af00      	add	r7, sp, #0
2401e716:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
2401e718:	687b      	ldr	r3, [r7, #4]
2401e71a:	2202      	movs	r2, #2
2401e71c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
2401e720:	687b      	ldr	r3, [r7, #4]
2401e722:	681b      	ldr	r3, [r3, #0]
2401e724:	6a1a      	ldr	r2, [r3, #32]
2401e726:	f241 1311 	movw	r3, #4369	; 0x1111
2401e72a:	4013      	ands	r3, r2
2401e72c:	2b00      	cmp	r3, #0
2401e72e:	d10f      	bne.n	2401e750 <HAL_TIMEx_HallSensor_DeInit+0x40>
2401e730:	687b      	ldr	r3, [r7, #4]
2401e732:	681b      	ldr	r3, [r3, #0]
2401e734:	6a1a      	ldr	r2, [r3, #32]
2401e736:	f240 4344 	movw	r3, #1092	; 0x444
2401e73a:	4013      	ands	r3, r2
2401e73c:	2b00      	cmp	r3, #0
2401e73e:	d107      	bne.n	2401e750 <HAL_TIMEx_HallSensor_DeInit+0x40>
2401e740:	687b      	ldr	r3, [r7, #4]
2401e742:	681b      	ldr	r3, [r3, #0]
2401e744:	681a      	ldr	r2, [r3, #0]
2401e746:	687b      	ldr	r3, [r7, #4]
2401e748:	681b      	ldr	r3, [r3, #0]
2401e74a:	f022 0201 	bic.w	r2, r2, #1
2401e74e:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->HallSensor_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_TIMEx_HallSensor_MspDeInit(htim);
2401e750:	6878      	ldr	r0, [r7, #4]
2401e752:	f000 f82b 	bl	2401e7ac <HAL_TIMEx_HallSensor_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
2401e756:	687b      	ldr	r3, [r7, #4]
2401e758:	2200      	movs	r2, #0
2401e75a:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Change the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
2401e75e:	687b      	ldr	r3, [r7, #4]
2401e760:	2200      	movs	r2, #0
2401e762:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
2401e766:	687b      	ldr	r3, [r7, #4]
2401e768:	2200      	movs	r2, #0
2401e76a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
2401e76e:	687b      	ldr	r3, [r7, #4]
2401e770:	2200      	movs	r2, #0
2401e772:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
2401e776:	687b      	ldr	r3, [r7, #4]
2401e778:	2200      	movs	r2, #0
2401e77a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
2401e77e:	687b      	ldr	r3, [r7, #4]
2401e780:	2200      	movs	r2, #0
2401e782:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
2401e786:	687b      	ldr	r3, [r7, #4]
2401e788:	2200      	movs	r2, #0
2401e78a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2401e78e:	2300      	movs	r3, #0
}
2401e790:	4618      	mov	r0, r3
2401e792:	3708      	adds	r7, #8
2401e794:	46bd      	mov	sp, r7
2401e796:	bd80      	pop	{r7, pc}

2401e798 <HAL_TIMEx_HallSensor_MspInit>:
  * @brief  Initializes the TIM Hall Sensor MSP.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval None
  */
__weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
{
2401e798:	b480      	push	{r7}
2401e79a:	b083      	sub	sp, #12
2401e79c:	af00      	add	r7, sp, #0
2401e79e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
   */
}
2401e7a0:	bf00      	nop
2401e7a2:	370c      	adds	r7, #12
2401e7a4:	46bd      	mov	sp, r7
2401e7a6:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e7aa:	4770      	bx	lr

2401e7ac <HAL_TIMEx_HallSensor_MspDeInit>:
  * @brief  DeInitializes TIM Hall Sensor MSP.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval None
  */
__weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
{
2401e7ac:	b480      	push	{r7}
2401e7ae:	b083      	sub	sp, #12
2401e7b0:	af00      	add	r7, sp, #0
2401e7b2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
   */
}
2401e7b4:	bf00      	nop
2401e7b6:	370c      	adds	r7, #12
2401e7b8:	46bd      	mov	sp, r7
2401e7ba:	f85d 7b04 	ldr.w	r7, [sp], #4
2401e7be:	4770      	bx	lr

2401e7c0 <HAL_TIMEx_HallSensor_Start>:
  * @brief  Starts the TIM Hall Sensor Interface.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
{
2401e7c0:	b580      	push	{r7, lr}
2401e7c2:	b084      	sub	sp, #16
2401e7c4:	af00      	add	r7, sp, #0
2401e7c6:	6078      	str	r0, [r7, #4]
  uint32_t tmpsmcr;
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
2401e7c8:	687b      	ldr	r3, [r7, #4]
2401e7ca:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401e7ce:	73fb      	strb	r3, [r7, #15]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
2401e7d0:	687b      	ldr	r3, [r7, #4]
2401e7d2:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401e7d6:	73bb      	strb	r3, [r7, #14]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
2401e7d8:	687b      	ldr	r3, [r7, #4]
2401e7da:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401e7de:	737b      	strb	r3, [r7, #13]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
2401e7e0:	687b      	ldr	r3, [r7, #4]
2401e7e2:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401e7e6:	733b      	strb	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));

  /* Check the TIM channels state */
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401e7e8:	7bfb      	ldrb	r3, [r7, #15]
2401e7ea:	2b01      	cmp	r3, #1
2401e7ec:	d108      	bne.n	2401e800 <HAL_TIMEx_HallSensor_Start+0x40>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2401e7ee:	7bbb      	ldrb	r3, [r7, #14]
2401e7f0:	2b01      	cmp	r3, #1
2401e7f2:	d105      	bne.n	2401e800 <HAL_TIMEx_HallSensor_Start+0x40>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401e7f4:	7b7b      	ldrb	r3, [r7, #13]
2401e7f6:	2b01      	cmp	r3, #1
2401e7f8:	d102      	bne.n	2401e800 <HAL_TIMEx_HallSensor_Start+0x40>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2401e7fa:	7b3b      	ldrb	r3, [r7, #12]
2401e7fc:	2b01      	cmp	r3, #1
2401e7fe:	d001      	beq.n	2401e804 <HAL_TIMEx_HallSensor_Start+0x44>
  {
    return HAL_ERROR;
2401e800:	2301      	movs	r3, #1
2401e802:	e05f      	b.n	2401e8c4 <HAL_TIMEx_HallSensor_Start+0x104>
  }

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401e804:	687b      	ldr	r3, [r7, #4]
2401e806:	2202      	movs	r2, #2
2401e808:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401e80c:	687b      	ldr	r3, [r7, #4]
2401e80e:	2202      	movs	r2, #2
2401e810:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401e814:	687b      	ldr	r3, [r7, #4]
2401e816:	2202      	movs	r2, #2
2401e818:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401e81c:	687b      	ldr	r3, [r7, #4]
2401e81e:	2202      	movs	r2, #2
2401e820:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Enable the Input Capture channel 1
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) */
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401e824:	687b      	ldr	r3, [r7, #4]
2401e826:	681b      	ldr	r3, [r3, #0]
2401e828:	2201      	movs	r2, #1
2401e82a:	2100      	movs	r1, #0
2401e82c:	4618      	mov	r0, r3
2401e82e:	f7ff fe9b 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401e832:	687b      	ldr	r3, [r7, #4]
2401e834:	681b      	ldr	r3, [r3, #0]
2401e836:	4a25      	ldr	r2, [pc, #148]	; (2401e8cc <HAL_TIMEx_HallSensor_Start+0x10c>)
2401e838:	4293      	cmp	r3, r2
2401e83a:	d022      	beq.n	2401e882 <HAL_TIMEx_HallSensor_Start+0xc2>
2401e83c:	687b      	ldr	r3, [r7, #4]
2401e83e:	681b      	ldr	r3, [r3, #0]
2401e840:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401e844:	d01d      	beq.n	2401e882 <HAL_TIMEx_HallSensor_Start+0xc2>
2401e846:	687b      	ldr	r3, [r7, #4]
2401e848:	681b      	ldr	r3, [r3, #0]
2401e84a:	4a21      	ldr	r2, [pc, #132]	; (2401e8d0 <HAL_TIMEx_HallSensor_Start+0x110>)
2401e84c:	4293      	cmp	r3, r2
2401e84e:	d018      	beq.n	2401e882 <HAL_TIMEx_HallSensor_Start+0xc2>
2401e850:	687b      	ldr	r3, [r7, #4]
2401e852:	681b      	ldr	r3, [r3, #0]
2401e854:	4a1f      	ldr	r2, [pc, #124]	; (2401e8d4 <HAL_TIMEx_HallSensor_Start+0x114>)
2401e856:	4293      	cmp	r3, r2
2401e858:	d013      	beq.n	2401e882 <HAL_TIMEx_HallSensor_Start+0xc2>
2401e85a:	687b      	ldr	r3, [r7, #4]
2401e85c:	681b      	ldr	r3, [r3, #0]
2401e85e:	4a1e      	ldr	r2, [pc, #120]	; (2401e8d8 <HAL_TIMEx_HallSensor_Start+0x118>)
2401e860:	4293      	cmp	r3, r2
2401e862:	d00e      	beq.n	2401e882 <HAL_TIMEx_HallSensor_Start+0xc2>
2401e864:	687b      	ldr	r3, [r7, #4]
2401e866:	681b      	ldr	r3, [r3, #0]
2401e868:	4a1c      	ldr	r2, [pc, #112]	; (2401e8dc <HAL_TIMEx_HallSensor_Start+0x11c>)
2401e86a:	4293      	cmp	r3, r2
2401e86c:	d009      	beq.n	2401e882 <HAL_TIMEx_HallSensor_Start+0xc2>
2401e86e:	687b      	ldr	r3, [r7, #4]
2401e870:	681b      	ldr	r3, [r3, #0]
2401e872:	4a1b      	ldr	r2, [pc, #108]	; (2401e8e0 <HAL_TIMEx_HallSensor_Start+0x120>)
2401e874:	4293      	cmp	r3, r2
2401e876:	d004      	beq.n	2401e882 <HAL_TIMEx_HallSensor_Start+0xc2>
2401e878:	687b      	ldr	r3, [r7, #4]
2401e87a:	681b      	ldr	r3, [r3, #0]
2401e87c:	4a19      	ldr	r2, [pc, #100]	; (2401e8e4 <HAL_TIMEx_HallSensor_Start+0x124>)
2401e87e:	4293      	cmp	r3, r2
2401e880:	d115      	bne.n	2401e8ae <HAL_TIMEx_HallSensor_Start+0xee>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401e882:	687b      	ldr	r3, [r7, #4]
2401e884:	681b      	ldr	r3, [r3, #0]
2401e886:	689a      	ldr	r2, [r3, #8]
2401e888:	4b17      	ldr	r3, [pc, #92]	; (2401e8e8 <HAL_TIMEx_HallSensor_Start+0x128>)
2401e88a:	4013      	ands	r3, r2
2401e88c:	60bb      	str	r3, [r7, #8]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401e88e:	68bb      	ldr	r3, [r7, #8]
2401e890:	2b06      	cmp	r3, #6
2401e892:	d015      	beq.n	2401e8c0 <HAL_TIMEx_HallSensor_Start+0x100>
2401e894:	68bb      	ldr	r3, [r7, #8]
2401e896:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401e89a:	d011      	beq.n	2401e8c0 <HAL_TIMEx_HallSensor_Start+0x100>
    {
      __HAL_TIM_ENABLE(htim);
2401e89c:	687b      	ldr	r3, [r7, #4]
2401e89e:	681b      	ldr	r3, [r3, #0]
2401e8a0:	681a      	ldr	r2, [r3, #0]
2401e8a2:	687b      	ldr	r3, [r7, #4]
2401e8a4:	681b      	ldr	r3, [r3, #0]
2401e8a6:	f042 0201 	orr.w	r2, r2, #1
2401e8aa:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401e8ac:	e008      	b.n	2401e8c0 <HAL_TIMEx_HallSensor_Start+0x100>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
2401e8ae:	687b      	ldr	r3, [r7, #4]
2401e8b0:	681b      	ldr	r3, [r3, #0]
2401e8b2:	681a      	ldr	r2, [r3, #0]
2401e8b4:	687b      	ldr	r3, [r7, #4]
2401e8b6:	681b      	ldr	r3, [r3, #0]
2401e8b8:	f042 0201 	orr.w	r2, r2, #1
2401e8bc:	601a      	str	r2, [r3, #0]
2401e8be:	e000      	b.n	2401e8c2 <HAL_TIMEx_HallSensor_Start+0x102>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401e8c0:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
2401e8c2:	2300      	movs	r3, #0
}
2401e8c4:	4618      	mov	r0, r3
2401e8c6:	3710      	adds	r7, #16
2401e8c8:	46bd      	mov	sp, r7
2401e8ca:	bd80      	pop	{r7, pc}
2401e8cc:	40010000 	.word	0x40010000
2401e8d0:	40000400 	.word	0x40000400
2401e8d4:	40000800 	.word	0x40000800
2401e8d8:	40000c00 	.word	0x40000c00
2401e8dc:	40010400 	.word	0x40010400
2401e8e0:	40001800 	.word	0x40001800
2401e8e4:	40014000 	.word	0x40014000
2401e8e8:	00010007 	.word	0x00010007

2401e8ec <HAL_TIMEx_HallSensor_Stop>:
  * @brief  Stops the TIM Hall sensor Interface.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
{
2401e8ec:	b580      	push	{r7, lr}
2401e8ee:	b082      	sub	sp, #8
2401e8f0:	af00      	add	r7, sp, #0
2401e8f2:	6078      	str	r0, [r7, #4]
  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));

  /* Disable the Input Capture channels 1, 2 and 3
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) */
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401e8f4:	687b      	ldr	r3, [r7, #4]
2401e8f6:	681b      	ldr	r3, [r3, #0]
2401e8f8:	2200      	movs	r2, #0
2401e8fa:	2100      	movs	r1, #0
2401e8fc:	4618      	mov	r0, r3
2401e8fe:	f7ff fe33 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401e902:	687b      	ldr	r3, [r7, #4]
2401e904:	681b      	ldr	r3, [r3, #0]
2401e906:	6a1a      	ldr	r2, [r3, #32]
2401e908:	f241 1311 	movw	r3, #4369	; 0x1111
2401e90c:	4013      	ands	r3, r2
2401e90e:	2b00      	cmp	r3, #0
2401e910:	d10f      	bne.n	2401e932 <HAL_TIMEx_HallSensor_Stop+0x46>
2401e912:	687b      	ldr	r3, [r7, #4]
2401e914:	681b      	ldr	r3, [r3, #0]
2401e916:	6a1a      	ldr	r2, [r3, #32]
2401e918:	f240 4344 	movw	r3, #1092	; 0x444
2401e91c:	4013      	ands	r3, r2
2401e91e:	2b00      	cmp	r3, #0
2401e920:	d107      	bne.n	2401e932 <HAL_TIMEx_HallSensor_Stop+0x46>
2401e922:	687b      	ldr	r3, [r7, #4]
2401e924:	681b      	ldr	r3, [r3, #0]
2401e926:	681a      	ldr	r2, [r3, #0]
2401e928:	687b      	ldr	r3, [r7, #4]
2401e92a:	681b      	ldr	r3, [r3, #0]
2401e92c:	f022 0201 	bic.w	r2, r2, #1
2401e930:	601a      	str	r2, [r3, #0]

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401e932:	687b      	ldr	r3, [r7, #4]
2401e934:	2201      	movs	r2, #1
2401e936:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401e93a:	687b      	ldr	r3, [r7, #4]
2401e93c:	2201      	movs	r2, #1
2401e93e:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401e942:	687b      	ldr	r3, [r7, #4]
2401e944:	2201      	movs	r2, #1
2401e946:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401e94a:	687b      	ldr	r3, [r7, #4]
2401e94c:	2201      	movs	r2, #1
2401e94e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Return function status */
  return HAL_OK;
2401e952:	2300      	movs	r3, #0
}
2401e954:	4618      	mov	r0, r3
2401e956:	3708      	adds	r7, #8
2401e958:	46bd      	mov	sp, r7
2401e95a:	bd80      	pop	{r7, pc}

2401e95c <HAL_TIMEx_HallSensor_Start_IT>:
  * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
{
2401e95c:	b580      	push	{r7, lr}
2401e95e:	b084      	sub	sp, #16
2401e960:	af00      	add	r7, sp, #0
2401e962:	6078      	str	r0, [r7, #4]
  uint32_t tmpsmcr;
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
2401e964:	687b      	ldr	r3, [r7, #4]
2401e966:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401e96a:	73fb      	strb	r3, [r7, #15]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
2401e96c:	687b      	ldr	r3, [r7, #4]
2401e96e:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
2401e972:	73bb      	strb	r3, [r7, #14]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
2401e974:	687b      	ldr	r3, [r7, #4]
2401e976:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401e97a:	737b      	strb	r3, [r7, #13]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
2401e97c:	687b      	ldr	r3, [r7, #4]
2401e97e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401e982:	733b      	strb	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));

  /* Check the TIM channels state */
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401e984:	7bfb      	ldrb	r3, [r7, #15]
2401e986:	2b01      	cmp	r3, #1
2401e988:	d108      	bne.n	2401e99c <HAL_TIMEx_HallSensor_Start_IT+0x40>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2401e98a:	7bbb      	ldrb	r3, [r7, #14]
2401e98c:	2b01      	cmp	r3, #1
2401e98e:	d105      	bne.n	2401e99c <HAL_TIMEx_HallSensor_Start_IT+0x40>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
2401e990:	7b7b      	ldrb	r3, [r7, #13]
2401e992:	2b01      	cmp	r3, #1
2401e994:	d102      	bne.n	2401e99c <HAL_TIMEx_HallSensor_Start_IT+0x40>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2401e996:	7b3b      	ldrb	r3, [r7, #12]
2401e998:	2b01      	cmp	r3, #1
2401e99a:	d001      	beq.n	2401e9a0 <HAL_TIMEx_HallSensor_Start_IT+0x44>
  {
    return HAL_ERROR;
2401e99c:	2301      	movs	r3, #1
2401e99e:	e067      	b.n	2401ea70 <HAL_TIMEx_HallSensor_Start_IT+0x114>
  }

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401e9a0:	687b      	ldr	r3, [r7, #4]
2401e9a2:	2202      	movs	r2, #2
2401e9a4:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401e9a8:	687b      	ldr	r3, [r7, #4]
2401e9aa:	2202      	movs	r2, #2
2401e9ac:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401e9b0:	687b      	ldr	r3, [r7, #4]
2401e9b2:	2202      	movs	r2, #2
2401e9b4:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2401e9b8:	687b      	ldr	r3, [r7, #4]
2401e9ba:	2202      	movs	r2, #2
2401e9bc:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Enable the capture compare Interrupts 1 event */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2401e9c0:	687b      	ldr	r3, [r7, #4]
2401e9c2:	681b      	ldr	r3, [r3, #0]
2401e9c4:	68da      	ldr	r2, [r3, #12]
2401e9c6:	687b      	ldr	r3, [r7, #4]
2401e9c8:	681b      	ldr	r3, [r3, #0]
2401e9ca:	f042 0202 	orr.w	r2, r2, #2
2401e9ce:	60da      	str	r2, [r3, #12]

  /* Enable the Input Capture channel 1
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) */
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401e9d0:	687b      	ldr	r3, [r7, #4]
2401e9d2:	681b      	ldr	r3, [r3, #0]
2401e9d4:	2201      	movs	r2, #1
2401e9d6:	2100      	movs	r1, #0
2401e9d8:	4618      	mov	r0, r3
2401e9da:	f7ff fdc5 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401e9de:	687b      	ldr	r3, [r7, #4]
2401e9e0:	681b      	ldr	r3, [r3, #0]
2401e9e2:	4a25      	ldr	r2, [pc, #148]	; (2401ea78 <HAL_TIMEx_HallSensor_Start_IT+0x11c>)
2401e9e4:	4293      	cmp	r3, r2
2401e9e6:	d022      	beq.n	2401ea2e <HAL_TIMEx_HallSensor_Start_IT+0xd2>
2401e9e8:	687b      	ldr	r3, [r7, #4]
2401e9ea:	681b      	ldr	r3, [r3, #0]
2401e9ec:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401e9f0:	d01d      	beq.n	2401ea2e <HAL_TIMEx_HallSensor_Start_IT+0xd2>
2401e9f2:	687b      	ldr	r3, [r7, #4]
2401e9f4:	681b      	ldr	r3, [r3, #0]
2401e9f6:	4a21      	ldr	r2, [pc, #132]	; (2401ea7c <HAL_TIMEx_HallSensor_Start_IT+0x120>)
2401e9f8:	4293      	cmp	r3, r2
2401e9fa:	d018      	beq.n	2401ea2e <HAL_TIMEx_HallSensor_Start_IT+0xd2>
2401e9fc:	687b      	ldr	r3, [r7, #4]
2401e9fe:	681b      	ldr	r3, [r3, #0]
2401ea00:	4a1f      	ldr	r2, [pc, #124]	; (2401ea80 <HAL_TIMEx_HallSensor_Start_IT+0x124>)
2401ea02:	4293      	cmp	r3, r2
2401ea04:	d013      	beq.n	2401ea2e <HAL_TIMEx_HallSensor_Start_IT+0xd2>
2401ea06:	687b      	ldr	r3, [r7, #4]
2401ea08:	681b      	ldr	r3, [r3, #0]
2401ea0a:	4a1e      	ldr	r2, [pc, #120]	; (2401ea84 <HAL_TIMEx_HallSensor_Start_IT+0x128>)
2401ea0c:	4293      	cmp	r3, r2
2401ea0e:	d00e      	beq.n	2401ea2e <HAL_TIMEx_HallSensor_Start_IT+0xd2>
2401ea10:	687b      	ldr	r3, [r7, #4]
2401ea12:	681b      	ldr	r3, [r3, #0]
2401ea14:	4a1c      	ldr	r2, [pc, #112]	; (2401ea88 <HAL_TIMEx_HallSensor_Start_IT+0x12c>)
2401ea16:	4293      	cmp	r3, r2
2401ea18:	d009      	beq.n	2401ea2e <HAL_TIMEx_HallSensor_Start_IT+0xd2>
2401ea1a:	687b      	ldr	r3, [r7, #4]
2401ea1c:	681b      	ldr	r3, [r3, #0]
2401ea1e:	4a1b      	ldr	r2, [pc, #108]	; (2401ea8c <HAL_TIMEx_HallSensor_Start_IT+0x130>)
2401ea20:	4293      	cmp	r3, r2
2401ea22:	d004      	beq.n	2401ea2e <HAL_TIMEx_HallSensor_Start_IT+0xd2>
2401ea24:	687b      	ldr	r3, [r7, #4]
2401ea26:	681b      	ldr	r3, [r3, #0]
2401ea28:	4a19      	ldr	r2, [pc, #100]	; (2401ea90 <HAL_TIMEx_HallSensor_Start_IT+0x134>)
2401ea2a:	4293      	cmp	r3, r2
2401ea2c:	d115      	bne.n	2401ea5a <HAL_TIMEx_HallSensor_Start_IT+0xfe>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401ea2e:	687b      	ldr	r3, [r7, #4]
2401ea30:	681b      	ldr	r3, [r3, #0]
2401ea32:	689a      	ldr	r2, [r3, #8]
2401ea34:	4b17      	ldr	r3, [pc, #92]	; (2401ea94 <HAL_TIMEx_HallSensor_Start_IT+0x138>)
2401ea36:	4013      	ands	r3, r2
2401ea38:	60bb      	str	r3, [r7, #8]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ea3a:	68bb      	ldr	r3, [r7, #8]
2401ea3c:	2b06      	cmp	r3, #6
2401ea3e:	d015      	beq.n	2401ea6c <HAL_TIMEx_HallSensor_Start_IT+0x110>
2401ea40:	68bb      	ldr	r3, [r7, #8]
2401ea42:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401ea46:	d011      	beq.n	2401ea6c <HAL_TIMEx_HallSensor_Start_IT+0x110>
    {
      __HAL_TIM_ENABLE(htim);
2401ea48:	687b      	ldr	r3, [r7, #4]
2401ea4a:	681b      	ldr	r3, [r3, #0]
2401ea4c:	681a      	ldr	r2, [r3, #0]
2401ea4e:	687b      	ldr	r3, [r7, #4]
2401ea50:	681b      	ldr	r3, [r3, #0]
2401ea52:	f042 0201 	orr.w	r2, r2, #1
2401ea56:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ea58:	e008      	b.n	2401ea6c <HAL_TIMEx_HallSensor_Start_IT+0x110>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
2401ea5a:	687b      	ldr	r3, [r7, #4]
2401ea5c:	681b      	ldr	r3, [r3, #0]
2401ea5e:	681a      	ldr	r2, [r3, #0]
2401ea60:	687b      	ldr	r3, [r7, #4]
2401ea62:	681b      	ldr	r3, [r3, #0]
2401ea64:	f042 0201 	orr.w	r2, r2, #1
2401ea68:	601a      	str	r2, [r3, #0]
2401ea6a:	e000      	b.n	2401ea6e <HAL_TIMEx_HallSensor_Start_IT+0x112>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ea6c:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
2401ea6e:	2300      	movs	r3, #0
}
2401ea70:	4618      	mov	r0, r3
2401ea72:	3710      	adds	r7, #16
2401ea74:	46bd      	mov	sp, r7
2401ea76:	bd80      	pop	{r7, pc}
2401ea78:	40010000 	.word	0x40010000
2401ea7c:	40000400 	.word	0x40000400
2401ea80:	40000800 	.word	0x40000800
2401ea84:	40000c00 	.word	0x40000c00
2401ea88:	40010400 	.word	0x40010400
2401ea8c:	40001800 	.word	0x40001800
2401ea90:	40014000 	.word	0x40014000
2401ea94:	00010007 	.word	0x00010007

2401ea98 <HAL_TIMEx_HallSensor_Stop_IT>:
  * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
{
2401ea98:	b580      	push	{r7, lr}
2401ea9a:	b082      	sub	sp, #8
2401ea9c:	af00      	add	r7, sp, #0
2401ea9e:	6078      	str	r0, [r7, #4]
  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));

  /* Disable the Input Capture channel 1
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) */
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401eaa0:	687b      	ldr	r3, [r7, #4]
2401eaa2:	681b      	ldr	r3, [r3, #0]
2401eaa4:	2200      	movs	r2, #0
2401eaa6:	2100      	movs	r1, #0
2401eaa8:	4618      	mov	r0, r3
2401eaaa:	f7ff fd5d 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Disable the capture compare Interrupts event */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2401eaae:	687b      	ldr	r3, [r7, #4]
2401eab0:	681b      	ldr	r3, [r3, #0]
2401eab2:	68da      	ldr	r2, [r3, #12]
2401eab4:	687b      	ldr	r3, [r7, #4]
2401eab6:	681b      	ldr	r3, [r3, #0]
2401eab8:	f022 0202 	bic.w	r2, r2, #2
2401eabc:	60da      	str	r2, [r3, #12]

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401eabe:	687b      	ldr	r3, [r7, #4]
2401eac0:	681b      	ldr	r3, [r3, #0]
2401eac2:	6a1a      	ldr	r2, [r3, #32]
2401eac4:	f241 1311 	movw	r3, #4369	; 0x1111
2401eac8:	4013      	ands	r3, r2
2401eaca:	2b00      	cmp	r3, #0
2401eacc:	d10f      	bne.n	2401eaee <HAL_TIMEx_HallSensor_Stop_IT+0x56>
2401eace:	687b      	ldr	r3, [r7, #4]
2401ead0:	681b      	ldr	r3, [r3, #0]
2401ead2:	6a1a      	ldr	r2, [r3, #32]
2401ead4:	f240 4344 	movw	r3, #1092	; 0x444
2401ead8:	4013      	ands	r3, r2
2401eada:	2b00      	cmp	r3, #0
2401eadc:	d107      	bne.n	2401eaee <HAL_TIMEx_HallSensor_Stop_IT+0x56>
2401eade:	687b      	ldr	r3, [r7, #4]
2401eae0:	681b      	ldr	r3, [r3, #0]
2401eae2:	681a      	ldr	r2, [r3, #0]
2401eae4:	687b      	ldr	r3, [r7, #4]
2401eae6:	681b      	ldr	r3, [r3, #0]
2401eae8:	f022 0201 	bic.w	r2, r2, #1
2401eaec:	601a      	str	r2, [r3, #0]

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401eaee:	687b      	ldr	r3, [r7, #4]
2401eaf0:	2201      	movs	r2, #1
2401eaf2:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401eaf6:	687b      	ldr	r3, [r7, #4]
2401eaf8:	2201      	movs	r2, #1
2401eafa:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401eafe:	687b      	ldr	r3, [r7, #4]
2401eb00:	2201      	movs	r2, #1
2401eb02:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
2401eb06:	687b      	ldr	r3, [r7, #4]
2401eb08:	2201      	movs	r2, #1
2401eb0a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Return function status */
  return HAL_OK;
2401eb0e:	2300      	movs	r3, #0
}
2401eb10:	4618      	mov	r0, r3
2401eb12:	3708      	adds	r7, #8
2401eb14:	46bd      	mov	sp, r7
2401eb16:	bd80      	pop	{r7, pc}

2401eb18 <HAL_TIMEx_HallSensor_Start_DMA>:
  * @param  pData The destination Buffer address.
  * @param  Length The length of data to be transferred from TIM peripheral to memory.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
{
2401eb18:	b580      	push	{r7, lr}
2401eb1a:	b086      	sub	sp, #24
2401eb1c:	af00      	add	r7, sp, #0
2401eb1e:	60f8      	str	r0, [r7, #12]
2401eb20:	60b9      	str	r1, [r7, #8]
2401eb22:	4613      	mov	r3, r2
2401eb24:	80fb      	strh	r3, [r7, #6]
  uint32_t tmpsmcr;
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
2401eb26:	68fb      	ldr	r3, [r7, #12]
2401eb28:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2401eb2c:	75fb      	strb	r3, [r7, #23]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
2401eb2e:	68fb      	ldr	r3, [r7, #12]
2401eb30:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401eb34:	75bb      	strb	r3, [r7, #22]

  /* Check the parameters */
  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));

  /* Set the TIM channel state */
  if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
2401eb36:	7dfb      	ldrb	r3, [r7, #23]
2401eb38:	2b02      	cmp	r3, #2
2401eb3a:	d002      	beq.n	2401eb42 <HAL_TIMEx_HallSensor_Start_DMA+0x2a>
      || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))
2401eb3c:	7dbb      	ldrb	r3, [r7, #22]
2401eb3e:	2b02      	cmp	r3, #2
2401eb40:	d101      	bne.n	2401eb46 <HAL_TIMEx_HallSensor_Start_DMA+0x2e>
  {
    return HAL_BUSY;
2401eb42:	2302      	movs	r3, #2
2401eb44:	e08c      	b.n	2401ec60 <HAL_TIMEx_HallSensor_Start_DMA+0x148>
  }
  else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
2401eb46:	7dfb      	ldrb	r3, [r7, #23]
2401eb48:	2b01      	cmp	r3, #1
2401eb4a:	d134      	bne.n	2401ebb6 <HAL_TIMEx_HallSensor_Start_DMA+0x9e>
           && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))
2401eb4c:	7dbb      	ldrb	r3, [r7, #22]
2401eb4e:	2b01      	cmp	r3, #1
2401eb50:	d131      	bne.n	2401ebb6 <HAL_TIMEx_HallSensor_Start_DMA+0x9e>
  {
    if ((pData == NULL) || (Length == 0U))
2401eb52:	68bb      	ldr	r3, [r7, #8]
2401eb54:	2b00      	cmp	r3, #0
2401eb56:	d002      	beq.n	2401eb5e <HAL_TIMEx_HallSensor_Start_DMA+0x46>
2401eb58:	88fb      	ldrh	r3, [r7, #6]
2401eb5a:	2b00      	cmp	r3, #0
2401eb5c:	d101      	bne.n	2401eb62 <HAL_TIMEx_HallSensor_Start_DMA+0x4a>
    {
      return HAL_ERROR;
2401eb5e:	2301      	movs	r3, #1
2401eb60:	e07e      	b.n	2401ec60 <HAL_TIMEx_HallSensor_Start_DMA+0x148>
    }
    else
    {
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401eb62:	68fb      	ldr	r3, [r7, #12]
2401eb64:	2202      	movs	r2, #2
2401eb66:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
2401eb6a:	68fb      	ldr	r3, [r7, #12]
2401eb6c:	2202      	movs	r2, #2
2401eb6e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    if ((pData == NULL) || (Length == 0U))
2401eb72:	bf00      	nop
  }

  /* Enable the Input Capture channel 1
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) */
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2401eb74:	68fb      	ldr	r3, [r7, #12]
2401eb76:	681b      	ldr	r3, [r3, #0]
2401eb78:	2201      	movs	r2, #1
2401eb7a:	2100      	movs	r1, #0
2401eb7c:	4618      	mov	r0, r3
2401eb7e:	f7ff fcf3 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Set the DMA Input Capture 1 Callbacks */
  htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2401eb82:	68fb      	ldr	r3, [r7, #12]
2401eb84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401eb86:	4a38      	ldr	r2, [pc, #224]	; (2401ec68 <HAL_TIMEx_HallSensor_Start_DMA+0x150>)
2401eb88:	63da      	str	r2, [r3, #60]	; 0x3c
  htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2401eb8a:	68fb      	ldr	r3, [r7, #12]
2401eb8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401eb8e:	4a37      	ldr	r2, [pc, #220]	; (2401ec6c <HAL_TIMEx_HallSensor_Start_DMA+0x154>)
2401eb90:	641a      	str	r2, [r3, #64]	; 0x40
  /* Set the DMA error callback */
  htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2401eb92:	68fb      	ldr	r3, [r7, #12]
2401eb94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401eb96:	4a36      	ldr	r2, [pc, #216]	; (2401ec70 <HAL_TIMEx_HallSensor_Start_DMA+0x158>)
2401eb98:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Enable the DMA stream for Capture 1*/
  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
2401eb9a:	68fb      	ldr	r3, [r7, #12]
2401eb9c:	6a58      	ldr	r0, [r3, #36]	; 0x24
2401eb9e:	68fb      	ldr	r3, [r7, #12]
2401eba0:	681b      	ldr	r3, [r3, #0]
2401eba2:	3334      	adds	r3, #52	; 0x34
2401eba4:	4619      	mov	r1, r3
2401eba6:	68ba      	ldr	r2, [r7, #8]
2401eba8:	88fb      	ldrh	r3, [r7, #6]
2401ebaa:	f7e4 ffd1 	bl	24003b50 <HAL_DMA_Start_IT>
2401ebae:	4603      	mov	r3, r0
2401ebb0:	2b00      	cmp	r3, #0
2401ebb2:	d004      	beq.n	2401ebbe <HAL_TIMEx_HallSensor_Start_DMA+0xa6>
2401ebb4:	e001      	b.n	2401ebba <HAL_TIMEx_HallSensor_Start_DMA+0xa2>
    return HAL_ERROR;
2401ebb6:	2301      	movs	r3, #1
2401ebb8:	e052      	b.n	2401ec60 <HAL_TIMEx_HallSensor_Start_DMA+0x148>
  {
    /* Return error status */
    return HAL_ERROR;
2401ebba:	2301      	movs	r3, #1
2401ebbc:	e050      	b.n	2401ec60 <HAL_TIMEx_HallSensor_Start_DMA+0x148>
  }
  /* Enable the capture compare 1 Interrupt */
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2401ebbe:	68fb      	ldr	r3, [r7, #12]
2401ebc0:	681b      	ldr	r3, [r3, #0]
2401ebc2:	68da      	ldr	r2, [r3, #12]
2401ebc4:	68fb      	ldr	r3, [r7, #12]
2401ebc6:	681b      	ldr	r3, [r3, #0]
2401ebc8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2401ebcc:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401ebce:	68fb      	ldr	r3, [r7, #12]
2401ebd0:	681b      	ldr	r3, [r3, #0]
2401ebd2:	4a28      	ldr	r2, [pc, #160]	; (2401ec74 <HAL_TIMEx_HallSensor_Start_DMA+0x15c>)
2401ebd4:	4293      	cmp	r3, r2
2401ebd6:	d022      	beq.n	2401ec1e <HAL_TIMEx_HallSensor_Start_DMA+0x106>
2401ebd8:	68fb      	ldr	r3, [r7, #12]
2401ebda:	681b      	ldr	r3, [r3, #0]
2401ebdc:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401ebe0:	d01d      	beq.n	2401ec1e <HAL_TIMEx_HallSensor_Start_DMA+0x106>
2401ebe2:	68fb      	ldr	r3, [r7, #12]
2401ebe4:	681b      	ldr	r3, [r3, #0]
2401ebe6:	4a24      	ldr	r2, [pc, #144]	; (2401ec78 <HAL_TIMEx_HallSensor_Start_DMA+0x160>)
2401ebe8:	4293      	cmp	r3, r2
2401ebea:	d018      	beq.n	2401ec1e <HAL_TIMEx_HallSensor_Start_DMA+0x106>
2401ebec:	68fb      	ldr	r3, [r7, #12]
2401ebee:	681b      	ldr	r3, [r3, #0]
2401ebf0:	4a22      	ldr	r2, [pc, #136]	; (2401ec7c <HAL_TIMEx_HallSensor_Start_DMA+0x164>)
2401ebf2:	4293      	cmp	r3, r2
2401ebf4:	d013      	beq.n	2401ec1e <HAL_TIMEx_HallSensor_Start_DMA+0x106>
2401ebf6:	68fb      	ldr	r3, [r7, #12]
2401ebf8:	681b      	ldr	r3, [r3, #0]
2401ebfa:	4a21      	ldr	r2, [pc, #132]	; (2401ec80 <HAL_TIMEx_HallSensor_Start_DMA+0x168>)
2401ebfc:	4293      	cmp	r3, r2
2401ebfe:	d00e      	beq.n	2401ec1e <HAL_TIMEx_HallSensor_Start_DMA+0x106>
2401ec00:	68fb      	ldr	r3, [r7, #12]
2401ec02:	681b      	ldr	r3, [r3, #0]
2401ec04:	4a1f      	ldr	r2, [pc, #124]	; (2401ec84 <HAL_TIMEx_HallSensor_Start_DMA+0x16c>)
2401ec06:	4293      	cmp	r3, r2
2401ec08:	d009      	beq.n	2401ec1e <HAL_TIMEx_HallSensor_Start_DMA+0x106>
2401ec0a:	68fb      	ldr	r3, [r7, #12]
2401ec0c:	681b      	ldr	r3, [r3, #0]
2401ec0e:	4a1e      	ldr	r2, [pc, #120]	; (2401ec88 <HAL_TIMEx_HallSensor_Start_DMA+0x170>)
2401ec10:	4293      	cmp	r3, r2
2401ec12:	d004      	beq.n	2401ec1e <HAL_TIMEx_HallSensor_Start_DMA+0x106>
2401ec14:	68fb      	ldr	r3, [r7, #12]
2401ec16:	681b      	ldr	r3, [r3, #0]
2401ec18:	4a1c      	ldr	r2, [pc, #112]	; (2401ec8c <HAL_TIMEx_HallSensor_Start_DMA+0x174>)
2401ec1a:	4293      	cmp	r3, r2
2401ec1c:	d115      	bne.n	2401ec4a <HAL_TIMEx_HallSensor_Start_DMA+0x132>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401ec1e:	68fb      	ldr	r3, [r7, #12]
2401ec20:	681b      	ldr	r3, [r3, #0]
2401ec22:	689a      	ldr	r2, [r3, #8]
2401ec24:	4b1a      	ldr	r3, [pc, #104]	; (2401ec90 <HAL_TIMEx_HallSensor_Start_DMA+0x178>)
2401ec26:	4013      	ands	r3, r2
2401ec28:	613b      	str	r3, [r7, #16]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ec2a:	693b      	ldr	r3, [r7, #16]
2401ec2c:	2b06      	cmp	r3, #6
2401ec2e:	d015      	beq.n	2401ec5c <HAL_TIMEx_HallSensor_Start_DMA+0x144>
2401ec30:	693b      	ldr	r3, [r7, #16]
2401ec32:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401ec36:	d011      	beq.n	2401ec5c <HAL_TIMEx_HallSensor_Start_DMA+0x144>
    {
      __HAL_TIM_ENABLE(htim);
2401ec38:	68fb      	ldr	r3, [r7, #12]
2401ec3a:	681b      	ldr	r3, [r3, #0]
2401ec3c:	681a      	ldr	r2, [r3, #0]
2401ec3e:	68fb      	ldr	r3, [r7, #12]
2401ec40:	681b      	ldr	r3, [r3, #0]
2401ec42:	f042 0201 	orr.w	r2, r2, #1
2401ec46:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ec48:	e008      	b.n	2401ec5c <HAL_TIMEx_HallSensor_Start_DMA+0x144>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
2401ec4a:	68fb      	ldr	r3, [r7, #12]
2401ec4c:	681b      	ldr	r3, [r3, #0]
2401ec4e:	681a      	ldr	r2, [r3, #0]
2401ec50:	68fb      	ldr	r3, [r7, #12]
2401ec52:	681b      	ldr	r3, [r3, #0]
2401ec54:	f042 0201 	orr.w	r2, r2, #1
2401ec58:	601a      	str	r2, [r3, #0]
2401ec5a:	e000      	b.n	2401ec5e <HAL_TIMEx_HallSensor_Start_DMA+0x146>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ec5c:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
2401ec5e:	2300      	movs	r3, #0
}
2401ec60:	4618      	mov	r0, r3
2401ec62:	3718      	adds	r7, #24
2401ec64:	46bd      	mov	sp, r7
2401ec66:	bd80      	pop	{r7, pc}
2401ec68:	2401d761 	.word	0x2401d761
2401ec6c:	2401d829 	.word	0x2401d829
2401ec70:	2401d5bf 	.word	0x2401d5bf
2401ec74:	40010000 	.word	0x40010000
2401ec78:	40000400 	.word	0x40000400
2401ec7c:	40000800 	.word	0x40000800
2401ec80:	40000c00 	.word	0x40000c00
2401ec84:	40010400 	.word	0x40010400
2401ec88:	40001800 	.word	0x40001800
2401ec8c:	40014000 	.word	0x40014000
2401ec90:	00010007 	.word	0x00010007

2401ec94 <HAL_TIMEx_HallSensor_Stop_DMA>:
  * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
{
2401ec94:	b580      	push	{r7, lr}
2401ec96:	b082      	sub	sp, #8
2401ec98:	af00      	add	r7, sp, #0
2401ec9a:	6078      	str	r0, [r7, #4]
  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));

  /* Disable the Input Capture channel 1
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) */
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2401ec9c:	687b      	ldr	r3, [r7, #4]
2401ec9e:	681b      	ldr	r3, [r3, #0]
2401eca0:	2200      	movs	r2, #0
2401eca2:	2100      	movs	r1, #0
2401eca4:	4618      	mov	r0, r3
2401eca6:	f7ff fc5f 	bl	2401e568 <TIM_CCxChannelCmd>


  /* Disable the capture compare Interrupts 1 event */
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2401ecaa:	687b      	ldr	r3, [r7, #4]
2401ecac:	681b      	ldr	r3, [r3, #0]
2401ecae:	68da      	ldr	r2, [r3, #12]
2401ecb0:	687b      	ldr	r3, [r7, #4]
2401ecb2:	681b      	ldr	r3, [r3, #0]
2401ecb4:	f422 7200 	bic.w	r2, r2, #512	; 0x200
2401ecb8:	60da      	str	r2, [r3, #12]

  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2401ecba:	687b      	ldr	r3, [r7, #4]
2401ecbc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401ecbe:	4618      	mov	r0, r3
2401ecc0:	f7e5 fcce 	bl	24004660 <HAL_DMA_Abort_IT>

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401ecc4:	687b      	ldr	r3, [r7, #4]
2401ecc6:	681b      	ldr	r3, [r3, #0]
2401ecc8:	6a1a      	ldr	r2, [r3, #32]
2401ecca:	f241 1311 	movw	r3, #4369	; 0x1111
2401ecce:	4013      	ands	r3, r2
2401ecd0:	2b00      	cmp	r3, #0
2401ecd2:	d10f      	bne.n	2401ecf4 <HAL_TIMEx_HallSensor_Stop_DMA+0x60>
2401ecd4:	687b      	ldr	r3, [r7, #4]
2401ecd6:	681b      	ldr	r3, [r3, #0]
2401ecd8:	6a1a      	ldr	r2, [r3, #32]
2401ecda:	f240 4344 	movw	r3, #1092	; 0x444
2401ecde:	4013      	ands	r3, r2
2401ece0:	2b00      	cmp	r3, #0
2401ece2:	d107      	bne.n	2401ecf4 <HAL_TIMEx_HallSensor_Stop_DMA+0x60>
2401ece4:	687b      	ldr	r3, [r7, #4]
2401ece6:	681b      	ldr	r3, [r3, #0]
2401ece8:	681a      	ldr	r2, [r3, #0]
2401ecea:	687b      	ldr	r3, [r7, #4]
2401ecec:	681b      	ldr	r3, [r3, #0]
2401ecee:	f022 0201 	bic.w	r2, r2, #1
2401ecf2:	601a      	str	r2, [r3, #0]

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401ecf4:	687b      	ldr	r3, [r7, #4]
2401ecf6:	2201      	movs	r2, #1
2401ecf8:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2401ecfc:	687b      	ldr	r3, [r7, #4]
2401ecfe:	2201      	movs	r2, #1
2401ed00:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

  /* Return function status */
  return HAL_OK;
2401ed04:	2300      	movs	r3, #0
}
2401ed06:	4618      	mov	r0, r3
2401ed08:	3708      	adds	r7, #8
2401ed0a:	46bd      	mov	sp, r7
2401ed0c:	bd80      	pop	{r7, pc}
	...

2401ed10 <HAL_TIMEx_OCN_Start>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401ed10:	b580      	push	{r7, lr}
2401ed12:	b084      	sub	sp, #16
2401ed14:	af00      	add	r7, sp, #0
2401ed16:	6078      	str	r0, [r7, #4]
2401ed18:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Check the TIM complementary channel state */
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
2401ed1a:	683b      	ldr	r3, [r7, #0]
2401ed1c:	2b00      	cmp	r3, #0
2401ed1e:	d109      	bne.n	2401ed34 <HAL_TIMEx_OCN_Start+0x24>
2401ed20:	687b      	ldr	r3, [r7, #4]
2401ed22:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401ed26:	b2db      	uxtb	r3, r3
2401ed28:	2b01      	cmp	r3, #1
2401ed2a:	bf14      	ite	ne
2401ed2c:	2301      	movne	r3, #1
2401ed2e:	2300      	moveq	r3, #0
2401ed30:	b2db      	uxtb	r3, r3
2401ed32:	e022      	b.n	2401ed7a <HAL_TIMEx_OCN_Start+0x6a>
2401ed34:	683b      	ldr	r3, [r7, #0]
2401ed36:	2b04      	cmp	r3, #4
2401ed38:	d109      	bne.n	2401ed4e <HAL_TIMEx_OCN_Start+0x3e>
2401ed3a:	687b      	ldr	r3, [r7, #4]
2401ed3c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401ed40:	b2db      	uxtb	r3, r3
2401ed42:	2b01      	cmp	r3, #1
2401ed44:	bf14      	ite	ne
2401ed46:	2301      	movne	r3, #1
2401ed48:	2300      	moveq	r3, #0
2401ed4a:	b2db      	uxtb	r3, r3
2401ed4c:	e015      	b.n	2401ed7a <HAL_TIMEx_OCN_Start+0x6a>
2401ed4e:	683b      	ldr	r3, [r7, #0]
2401ed50:	2b08      	cmp	r3, #8
2401ed52:	d109      	bne.n	2401ed68 <HAL_TIMEx_OCN_Start+0x58>
2401ed54:	687b      	ldr	r3, [r7, #4]
2401ed56:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401ed5a:	b2db      	uxtb	r3, r3
2401ed5c:	2b01      	cmp	r3, #1
2401ed5e:	bf14      	ite	ne
2401ed60:	2301      	movne	r3, #1
2401ed62:	2300      	moveq	r3, #0
2401ed64:	b2db      	uxtb	r3, r3
2401ed66:	e008      	b.n	2401ed7a <HAL_TIMEx_OCN_Start+0x6a>
2401ed68:	687b      	ldr	r3, [r7, #4]
2401ed6a:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401ed6e:	b2db      	uxtb	r3, r3
2401ed70:	2b01      	cmp	r3, #1
2401ed72:	bf14      	ite	ne
2401ed74:	2301      	movne	r3, #1
2401ed76:	2300      	moveq	r3, #0
2401ed78:	b2db      	uxtb	r3, r3
2401ed7a:	2b00      	cmp	r3, #0
2401ed7c:	d001      	beq.n	2401ed82 <HAL_TIMEx_OCN_Start+0x72>
  {
    return HAL_ERROR;
2401ed7e:	2301      	movs	r3, #1
2401ed80:	e073      	b.n	2401ee6a <HAL_TIMEx_OCN_Start+0x15a>
  }

  /* Set the TIM complementary channel state */
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401ed82:	683b      	ldr	r3, [r7, #0]
2401ed84:	2b00      	cmp	r3, #0
2401ed86:	d104      	bne.n	2401ed92 <HAL_TIMEx_OCN_Start+0x82>
2401ed88:	687b      	ldr	r3, [r7, #4]
2401ed8a:	2202      	movs	r2, #2
2401ed8c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401ed90:	e013      	b.n	2401edba <HAL_TIMEx_OCN_Start+0xaa>
2401ed92:	683b      	ldr	r3, [r7, #0]
2401ed94:	2b04      	cmp	r3, #4
2401ed96:	d104      	bne.n	2401eda2 <HAL_TIMEx_OCN_Start+0x92>
2401ed98:	687b      	ldr	r3, [r7, #4]
2401ed9a:	2202      	movs	r2, #2
2401ed9c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401eda0:	e00b      	b.n	2401edba <HAL_TIMEx_OCN_Start+0xaa>
2401eda2:	683b      	ldr	r3, [r7, #0]
2401eda4:	2b08      	cmp	r3, #8
2401eda6:	d104      	bne.n	2401edb2 <HAL_TIMEx_OCN_Start+0xa2>
2401eda8:	687b      	ldr	r3, [r7, #4]
2401edaa:	2202      	movs	r2, #2
2401edac:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401edb0:	e003      	b.n	2401edba <HAL_TIMEx_OCN_Start+0xaa>
2401edb2:	687b      	ldr	r3, [r7, #4]
2401edb4:	2202      	movs	r2, #2
2401edb6:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Enable the Capture compare channel N */
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2401edba:	687b      	ldr	r3, [r7, #4]
2401edbc:	681b      	ldr	r3, [r3, #0]
2401edbe:	2204      	movs	r2, #4
2401edc0:	6839      	ldr	r1, [r7, #0]
2401edc2:	4618      	mov	r0, r3
2401edc4:	f001 ffe5 	bl	24020d92 <TIM_CCxNChannelCmd>

  /* Enable the Main Output */
  __HAL_TIM_MOE_ENABLE(htim);
2401edc8:	687b      	ldr	r3, [r7, #4]
2401edca:	681b      	ldr	r3, [r3, #0]
2401edcc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401edce:	687b      	ldr	r3, [r7, #4]
2401edd0:	681b      	ldr	r3, [r3, #0]
2401edd2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401edd6:	645a      	str	r2, [r3, #68]	; 0x44

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401edd8:	687b      	ldr	r3, [r7, #4]
2401edda:	681b      	ldr	r3, [r3, #0]
2401eddc:	4a25      	ldr	r2, [pc, #148]	; (2401ee74 <HAL_TIMEx_OCN_Start+0x164>)
2401edde:	4293      	cmp	r3, r2
2401ede0:	d022      	beq.n	2401ee28 <HAL_TIMEx_OCN_Start+0x118>
2401ede2:	687b      	ldr	r3, [r7, #4]
2401ede4:	681b      	ldr	r3, [r3, #0]
2401ede6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401edea:	d01d      	beq.n	2401ee28 <HAL_TIMEx_OCN_Start+0x118>
2401edec:	687b      	ldr	r3, [r7, #4]
2401edee:	681b      	ldr	r3, [r3, #0]
2401edf0:	4a21      	ldr	r2, [pc, #132]	; (2401ee78 <HAL_TIMEx_OCN_Start+0x168>)
2401edf2:	4293      	cmp	r3, r2
2401edf4:	d018      	beq.n	2401ee28 <HAL_TIMEx_OCN_Start+0x118>
2401edf6:	687b      	ldr	r3, [r7, #4]
2401edf8:	681b      	ldr	r3, [r3, #0]
2401edfa:	4a20      	ldr	r2, [pc, #128]	; (2401ee7c <HAL_TIMEx_OCN_Start+0x16c>)
2401edfc:	4293      	cmp	r3, r2
2401edfe:	d013      	beq.n	2401ee28 <HAL_TIMEx_OCN_Start+0x118>
2401ee00:	687b      	ldr	r3, [r7, #4]
2401ee02:	681b      	ldr	r3, [r3, #0]
2401ee04:	4a1e      	ldr	r2, [pc, #120]	; (2401ee80 <HAL_TIMEx_OCN_Start+0x170>)
2401ee06:	4293      	cmp	r3, r2
2401ee08:	d00e      	beq.n	2401ee28 <HAL_TIMEx_OCN_Start+0x118>
2401ee0a:	687b      	ldr	r3, [r7, #4]
2401ee0c:	681b      	ldr	r3, [r3, #0]
2401ee0e:	4a1d      	ldr	r2, [pc, #116]	; (2401ee84 <HAL_TIMEx_OCN_Start+0x174>)
2401ee10:	4293      	cmp	r3, r2
2401ee12:	d009      	beq.n	2401ee28 <HAL_TIMEx_OCN_Start+0x118>
2401ee14:	687b      	ldr	r3, [r7, #4]
2401ee16:	681b      	ldr	r3, [r3, #0]
2401ee18:	4a1b      	ldr	r2, [pc, #108]	; (2401ee88 <HAL_TIMEx_OCN_Start+0x178>)
2401ee1a:	4293      	cmp	r3, r2
2401ee1c:	d004      	beq.n	2401ee28 <HAL_TIMEx_OCN_Start+0x118>
2401ee1e:	687b      	ldr	r3, [r7, #4]
2401ee20:	681b      	ldr	r3, [r3, #0]
2401ee22:	4a1a      	ldr	r2, [pc, #104]	; (2401ee8c <HAL_TIMEx_OCN_Start+0x17c>)
2401ee24:	4293      	cmp	r3, r2
2401ee26:	d115      	bne.n	2401ee54 <HAL_TIMEx_OCN_Start+0x144>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401ee28:	687b      	ldr	r3, [r7, #4]
2401ee2a:	681b      	ldr	r3, [r3, #0]
2401ee2c:	689a      	ldr	r2, [r3, #8]
2401ee2e:	4b18      	ldr	r3, [pc, #96]	; (2401ee90 <HAL_TIMEx_OCN_Start+0x180>)
2401ee30:	4013      	ands	r3, r2
2401ee32:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ee34:	68fb      	ldr	r3, [r7, #12]
2401ee36:	2b06      	cmp	r3, #6
2401ee38:	d015      	beq.n	2401ee66 <HAL_TIMEx_OCN_Start+0x156>
2401ee3a:	68fb      	ldr	r3, [r7, #12]
2401ee3c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401ee40:	d011      	beq.n	2401ee66 <HAL_TIMEx_OCN_Start+0x156>
    {
      __HAL_TIM_ENABLE(htim);
2401ee42:	687b      	ldr	r3, [r7, #4]
2401ee44:	681b      	ldr	r3, [r3, #0]
2401ee46:	681a      	ldr	r2, [r3, #0]
2401ee48:	687b      	ldr	r3, [r7, #4]
2401ee4a:	681b      	ldr	r3, [r3, #0]
2401ee4c:	f042 0201 	orr.w	r2, r2, #1
2401ee50:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ee52:	e008      	b.n	2401ee66 <HAL_TIMEx_OCN_Start+0x156>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
2401ee54:	687b      	ldr	r3, [r7, #4]
2401ee56:	681b      	ldr	r3, [r3, #0]
2401ee58:	681a      	ldr	r2, [r3, #0]
2401ee5a:	687b      	ldr	r3, [r7, #4]
2401ee5c:	681b      	ldr	r3, [r3, #0]
2401ee5e:	f042 0201 	orr.w	r2, r2, #1
2401ee62:	601a      	str	r2, [r3, #0]
2401ee64:	e000      	b.n	2401ee68 <HAL_TIMEx_OCN_Start+0x158>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ee66:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
2401ee68:	2300      	movs	r3, #0
}
2401ee6a:	4618      	mov	r0, r3
2401ee6c:	3710      	adds	r7, #16
2401ee6e:	46bd      	mov	sp, r7
2401ee70:	bd80      	pop	{r7, pc}
2401ee72:	bf00      	nop
2401ee74:	40010000 	.word	0x40010000
2401ee78:	40000400 	.word	0x40000400
2401ee7c:	40000800 	.word	0x40000800
2401ee80:	40000c00 	.word	0x40000c00
2401ee84:	40010400 	.word	0x40010400
2401ee88:	40001800 	.word	0x40001800
2401ee8c:	40014000 	.word	0x40014000
2401ee90:	00010007 	.word	0x00010007

2401ee94 <HAL_TIMEx_OCN_Stop>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401ee94:	b580      	push	{r7, lr}
2401ee96:	b082      	sub	sp, #8
2401ee98:	af00      	add	r7, sp, #0
2401ee9a:	6078      	str	r0, [r7, #4]
2401ee9c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Disable the Capture compare channel N */
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2401ee9e:	687b      	ldr	r3, [r7, #4]
2401eea0:	681b      	ldr	r3, [r3, #0]
2401eea2:	2200      	movs	r2, #0
2401eea4:	6839      	ldr	r1, [r7, #0]
2401eea6:	4618      	mov	r0, r3
2401eea8:	f001 ff73 	bl	24020d92 <TIM_CCxNChannelCmd>

  /* Disable the Main Output */
  __HAL_TIM_MOE_DISABLE(htim);
2401eeac:	687b      	ldr	r3, [r7, #4]
2401eeae:	681b      	ldr	r3, [r3, #0]
2401eeb0:	6a1a      	ldr	r2, [r3, #32]
2401eeb2:	f241 1311 	movw	r3, #4369	; 0x1111
2401eeb6:	4013      	ands	r3, r2
2401eeb8:	2b00      	cmp	r3, #0
2401eeba:	d10f      	bne.n	2401eedc <HAL_TIMEx_OCN_Stop+0x48>
2401eebc:	687b      	ldr	r3, [r7, #4]
2401eebe:	681b      	ldr	r3, [r3, #0]
2401eec0:	6a1a      	ldr	r2, [r3, #32]
2401eec2:	f240 4344 	movw	r3, #1092	; 0x444
2401eec6:	4013      	ands	r3, r2
2401eec8:	2b00      	cmp	r3, #0
2401eeca:	d107      	bne.n	2401eedc <HAL_TIMEx_OCN_Stop+0x48>
2401eecc:	687b      	ldr	r3, [r7, #4]
2401eece:	681b      	ldr	r3, [r3, #0]
2401eed0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401eed2:	687b      	ldr	r3, [r7, #4]
2401eed4:	681b      	ldr	r3, [r3, #0]
2401eed6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401eeda:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401eedc:	687b      	ldr	r3, [r7, #4]
2401eede:	681b      	ldr	r3, [r3, #0]
2401eee0:	6a1a      	ldr	r2, [r3, #32]
2401eee2:	f241 1311 	movw	r3, #4369	; 0x1111
2401eee6:	4013      	ands	r3, r2
2401eee8:	2b00      	cmp	r3, #0
2401eeea:	d10f      	bne.n	2401ef0c <HAL_TIMEx_OCN_Stop+0x78>
2401eeec:	687b      	ldr	r3, [r7, #4]
2401eeee:	681b      	ldr	r3, [r3, #0]
2401eef0:	6a1a      	ldr	r2, [r3, #32]
2401eef2:	f240 4344 	movw	r3, #1092	; 0x444
2401eef6:	4013      	ands	r3, r2
2401eef8:	2b00      	cmp	r3, #0
2401eefa:	d107      	bne.n	2401ef0c <HAL_TIMEx_OCN_Stop+0x78>
2401eefc:	687b      	ldr	r3, [r7, #4]
2401eefe:	681b      	ldr	r3, [r3, #0]
2401ef00:	681a      	ldr	r2, [r3, #0]
2401ef02:	687b      	ldr	r3, [r7, #4]
2401ef04:	681b      	ldr	r3, [r3, #0]
2401ef06:	f022 0201 	bic.w	r2, r2, #1
2401ef0a:	601a      	str	r2, [r3, #0]

  /* Set the TIM complementary channel state */
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401ef0c:	683b      	ldr	r3, [r7, #0]
2401ef0e:	2b00      	cmp	r3, #0
2401ef10:	d104      	bne.n	2401ef1c <HAL_TIMEx_OCN_Stop+0x88>
2401ef12:	687b      	ldr	r3, [r7, #4]
2401ef14:	2201      	movs	r2, #1
2401ef16:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401ef1a:	e013      	b.n	2401ef44 <HAL_TIMEx_OCN_Stop+0xb0>
2401ef1c:	683b      	ldr	r3, [r7, #0]
2401ef1e:	2b04      	cmp	r3, #4
2401ef20:	d104      	bne.n	2401ef2c <HAL_TIMEx_OCN_Stop+0x98>
2401ef22:	687b      	ldr	r3, [r7, #4]
2401ef24:	2201      	movs	r2, #1
2401ef26:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401ef2a:	e00b      	b.n	2401ef44 <HAL_TIMEx_OCN_Stop+0xb0>
2401ef2c:	683b      	ldr	r3, [r7, #0]
2401ef2e:	2b08      	cmp	r3, #8
2401ef30:	d104      	bne.n	2401ef3c <HAL_TIMEx_OCN_Stop+0xa8>
2401ef32:	687b      	ldr	r3, [r7, #4]
2401ef34:	2201      	movs	r2, #1
2401ef36:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401ef3a:	e003      	b.n	2401ef44 <HAL_TIMEx_OCN_Stop+0xb0>
2401ef3c:	687b      	ldr	r3, [r7, #4]
2401ef3e:	2201      	movs	r2, #1
2401ef40:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Return function status */
  return HAL_OK;
2401ef44:	2300      	movs	r3, #0
}
2401ef46:	4618      	mov	r0, r3
2401ef48:	3708      	adds	r7, #8
2401ef4a:	46bd      	mov	sp, r7
2401ef4c:	bd80      	pop	{r7, pc}
	...

2401ef50 <HAL_TIMEx_OCN_Start_IT>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401ef50:	b580      	push	{r7, lr}
2401ef52:	b084      	sub	sp, #16
2401ef54:	af00      	add	r7, sp, #0
2401ef56:	6078      	str	r0, [r7, #4]
2401ef58:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401ef5a:	2300      	movs	r3, #0
2401ef5c:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Check the TIM complementary channel state */
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
2401ef5e:	683b      	ldr	r3, [r7, #0]
2401ef60:	2b00      	cmp	r3, #0
2401ef62:	d109      	bne.n	2401ef78 <HAL_TIMEx_OCN_Start_IT+0x28>
2401ef64:	687b      	ldr	r3, [r7, #4]
2401ef66:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401ef6a:	b2db      	uxtb	r3, r3
2401ef6c:	2b01      	cmp	r3, #1
2401ef6e:	bf14      	ite	ne
2401ef70:	2301      	movne	r3, #1
2401ef72:	2300      	moveq	r3, #0
2401ef74:	b2db      	uxtb	r3, r3
2401ef76:	e022      	b.n	2401efbe <HAL_TIMEx_OCN_Start_IT+0x6e>
2401ef78:	683b      	ldr	r3, [r7, #0]
2401ef7a:	2b04      	cmp	r3, #4
2401ef7c:	d109      	bne.n	2401ef92 <HAL_TIMEx_OCN_Start_IT+0x42>
2401ef7e:	687b      	ldr	r3, [r7, #4]
2401ef80:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401ef84:	b2db      	uxtb	r3, r3
2401ef86:	2b01      	cmp	r3, #1
2401ef88:	bf14      	ite	ne
2401ef8a:	2301      	movne	r3, #1
2401ef8c:	2300      	moveq	r3, #0
2401ef8e:	b2db      	uxtb	r3, r3
2401ef90:	e015      	b.n	2401efbe <HAL_TIMEx_OCN_Start_IT+0x6e>
2401ef92:	683b      	ldr	r3, [r7, #0]
2401ef94:	2b08      	cmp	r3, #8
2401ef96:	d109      	bne.n	2401efac <HAL_TIMEx_OCN_Start_IT+0x5c>
2401ef98:	687b      	ldr	r3, [r7, #4]
2401ef9a:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401ef9e:	b2db      	uxtb	r3, r3
2401efa0:	2b01      	cmp	r3, #1
2401efa2:	bf14      	ite	ne
2401efa4:	2301      	movne	r3, #1
2401efa6:	2300      	moveq	r3, #0
2401efa8:	b2db      	uxtb	r3, r3
2401efaa:	e008      	b.n	2401efbe <HAL_TIMEx_OCN_Start_IT+0x6e>
2401efac:	687b      	ldr	r3, [r7, #4]
2401efae:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401efb2:	b2db      	uxtb	r3, r3
2401efb4:	2b01      	cmp	r3, #1
2401efb6:	bf14      	ite	ne
2401efb8:	2301      	movne	r3, #1
2401efba:	2300      	moveq	r3, #0
2401efbc:	b2db      	uxtb	r3, r3
2401efbe:	2b00      	cmp	r3, #0
2401efc0:	d001      	beq.n	2401efc6 <HAL_TIMEx_OCN_Start_IT+0x76>
  {
    return HAL_ERROR;
2401efc2:	2301      	movs	r3, #1
2401efc4:	e0a9      	b.n	2401f11a <HAL_TIMEx_OCN_Start_IT+0x1ca>
  }

  /* Set the TIM complementary channel state */
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401efc6:	683b      	ldr	r3, [r7, #0]
2401efc8:	2b00      	cmp	r3, #0
2401efca:	d104      	bne.n	2401efd6 <HAL_TIMEx_OCN_Start_IT+0x86>
2401efcc:	687b      	ldr	r3, [r7, #4]
2401efce:	2202      	movs	r2, #2
2401efd0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401efd4:	e013      	b.n	2401effe <HAL_TIMEx_OCN_Start_IT+0xae>
2401efd6:	683b      	ldr	r3, [r7, #0]
2401efd8:	2b04      	cmp	r3, #4
2401efda:	d104      	bne.n	2401efe6 <HAL_TIMEx_OCN_Start_IT+0x96>
2401efdc:	687b      	ldr	r3, [r7, #4]
2401efde:	2202      	movs	r2, #2
2401efe0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401efe4:	e00b      	b.n	2401effe <HAL_TIMEx_OCN_Start_IT+0xae>
2401efe6:	683b      	ldr	r3, [r7, #0]
2401efe8:	2b08      	cmp	r3, #8
2401efea:	d104      	bne.n	2401eff6 <HAL_TIMEx_OCN_Start_IT+0xa6>
2401efec:	687b      	ldr	r3, [r7, #4]
2401efee:	2202      	movs	r2, #2
2401eff0:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401eff4:	e003      	b.n	2401effe <HAL_TIMEx_OCN_Start_IT+0xae>
2401eff6:	687b      	ldr	r3, [r7, #4]
2401eff8:	2202      	movs	r2, #2
2401effa:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  switch (Channel)
2401effe:	683b      	ldr	r3, [r7, #0]
2401f000:	2b08      	cmp	r3, #8
2401f002:	d01b      	beq.n	2401f03c <HAL_TIMEx_OCN_Start_IT+0xec>
2401f004:	683b      	ldr	r3, [r7, #0]
2401f006:	2b08      	cmp	r3, #8
2401f008:	d821      	bhi.n	2401f04e <HAL_TIMEx_OCN_Start_IT+0xfe>
2401f00a:	683b      	ldr	r3, [r7, #0]
2401f00c:	2b00      	cmp	r3, #0
2401f00e:	d003      	beq.n	2401f018 <HAL_TIMEx_OCN_Start_IT+0xc8>
2401f010:	683b      	ldr	r3, [r7, #0]
2401f012:	2b04      	cmp	r3, #4
2401f014:	d009      	beq.n	2401f02a <HAL_TIMEx_OCN_Start_IT+0xda>
2401f016:	e01a      	b.n	2401f04e <HAL_TIMEx_OCN_Start_IT+0xfe>
  {
    case TIM_CHANNEL_1:
    {
      /* Enable the TIM Output Compare interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2401f018:	687b      	ldr	r3, [r7, #4]
2401f01a:	681b      	ldr	r3, [r3, #0]
2401f01c:	68da      	ldr	r2, [r3, #12]
2401f01e:	687b      	ldr	r3, [r7, #4]
2401f020:	681b      	ldr	r3, [r3, #0]
2401f022:	f042 0202 	orr.w	r2, r2, #2
2401f026:	60da      	str	r2, [r3, #12]
      break;
2401f028:	e014      	b.n	2401f054 <HAL_TIMEx_OCN_Start_IT+0x104>
    }

    case TIM_CHANNEL_2:
    {
      /* Enable the TIM Output Compare interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2401f02a:	687b      	ldr	r3, [r7, #4]
2401f02c:	681b      	ldr	r3, [r3, #0]
2401f02e:	68da      	ldr	r2, [r3, #12]
2401f030:	687b      	ldr	r3, [r7, #4]
2401f032:	681b      	ldr	r3, [r3, #0]
2401f034:	f042 0204 	orr.w	r2, r2, #4
2401f038:	60da      	str	r2, [r3, #12]
      break;
2401f03a:	e00b      	b.n	2401f054 <HAL_TIMEx_OCN_Start_IT+0x104>
    }

    case TIM_CHANNEL_3:
    {
      /* Enable the TIM Output Compare interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
2401f03c:	687b      	ldr	r3, [r7, #4]
2401f03e:	681b      	ldr	r3, [r3, #0]
2401f040:	68da      	ldr	r2, [r3, #12]
2401f042:	687b      	ldr	r3, [r7, #4]
2401f044:	681b      	ldr	r3, [r3, #0]
2401f046:	f042 0208 	orr.w	r2, r2, #8
2401f04a:	60da      	str	r2, [r3, #12]
      break;
2401f04c:	e002      	b.n	2401f054 <HAL_TIMEx_OCN_Start_IT+0x104>
    }


    default:
      status = HAL_ERROR;
2401f04e:	2301      	movs	r3, #1
2401f050:	73fb      	strb	r3, [r7, #15]
      break;
2401f052:	bf00      	nop
  }

  if (status == HAL_OK)
2401f054:	7bfb      	ldrb	r3, [r7, #15]
2401f056:	2b00      	cmp	r3, #0
2401f058:	d15e      	bne.n	2401f118 <HAL_TIMEx_OCN_Start_IT+0x1c8>
  {
    /* Enable the TIM Break interrupt */
    __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
2401f05a:	687b      	ldr	r3, [r7, #4]
2401f05c:	681b      	ldr	r3, [r3, #0]
2401f05e:	68da      	ldr	r2, [r3, #12]
2401f060:	687b      	ldr	r3, [r7, #4]
2401f062:	681b      	ldr	r3, [r3, #0]
2401f064:	f042 0280 	orr.w	r2, r2, #128	; 0x80
2401f068:	60da      	str	r2, [r3, #12]

    /* Enable the Capture compare channel N */
    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2401f06a:	687b      	ldr	r3, [r7, #4]
2401f06c:	681b      	ldr	r3, [r3, #0]
2401f06e:	2204      	movs	r2, #4
2401f070:	6839      	ldr	r1, [r7, #0]
2401f072:	4618      	mov	r0, r3
2401f074:	f001 fe8d 	bl	24020d92 <TIM_CCxNChannelCmd>

    /* Enable the Main Output */
    __HAL_TIM_MOE_ENABLE(htim);
2401f078:	687b      	ldr	r3, [r7, #4]
2401f07a:	681b      	ldr	r3, [r3, #0]
2401f07c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401f07e:	687b      	ldr	r3, [r7, #4]
2401f080:	681b      	ldr	r3, [r3, #0]
2401f082:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401f086:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401f088:	687b      	ldr	r3, [r7, #4]
2401f08a:	681b      	ldr	r3, [r3, #0]
2401f08c:	4a25      	ldr	r2, [pc, #148]	; (2401f124 <HAL_TIMEx_OCN_Start_IT+0x1d4>)
2401f08e:	4293      	cmp	r3, r2
2401f090:	d022      	beq.n	2401f0d8 <HAL_TIMEx_OCN_Start_IT+0x188>
2401f092:	687b      	ldr	r3, [r7, #4]
2401f094:	681b      	ldr	r3, [r3, #0]
2401f096:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401f09a:	d01d      	beq.n	2401f0d8 <HAL_TIMEx_OCN_Start_IT+0x188>
2401f09c:	687b      	ldr	r3, [r7, #4]
2401f09e:	681b      	ldr	r3, [r3, #0]
2401f0a0:	4a21      	ldr	r2, [pc, #132]	; (2401f128 <HAL_TIMEx_OCN_Start_IT+0x1d8>)
2401f0a2:	4293      	cmp	r3, r2
2401f0a4:	d018      	beq.n	2401f0d8 <HAL_TIMEx_OCN_Start_IT+0x188>
2401f0a6:	687b      	ldr	r3, [r7, #4]
2401f0a8:	681b      	ldr	r3, [r3, #0]
2401f0aa:	4a20      	ldr	r2, [pc, #128]	; (2401f12c <HAL_TIMEx_OCN_Start_IT+0x1dc>)
2401f0ac:	4293      	cmp	r3, r2
2401f0ae:	d013      	beq.n	2401f0d8 <HAL_TIMEx_OCN_Start_IT+0x188>
2401f0b0:	687b      	ldr	r3, [r7, #4]
2401f0b2:	681b      	ldr	r3, [r3, #0]
2401f0b4:	4a1e      	ldr	r2, [pc, #120]	; (2401f130 <HAL_TIMEx_OCN_Start_IT+0x1e0>)
2401f0b6:	4293      	cmp	r3, r2
2401f0b8:	d00e      	beq.n	2401f0d8 <HAL_TIMEx_OCN_Start_IT+0x188>
2401f0ba:	687b      	ldr	r3, [r7, #4]
2401f0bc:	681b      	ldr	r3, [r3, #0]
2401f0be:	4a1d      	ldr	r2, [pc, #116]	; (2401f134 <HAL_TIMEx_OCN_Start_IT+0x1e4>)
2401f0c0:	4293      	cmp	r3, r2
2401f0c2:	d009      	beq.n	2401f0d8 <HAL_TIMEx_OCN_Start_IT+0x188>
2401f0c4:	687b      	ldr	r3, [r7, #4]
2401f0c6:	681b      	ldr	r3, [r3, #0]
2401f0c8:	4a1b      	ldr	r2, [pc, #108]	; (2401f138 <HAL_TIMEx_OCN_Start_IT+0x1e8>)
2401f0ca:	4293      	cmp	r3, r2
2401f0cc:	d004      	beq.n	2401f0d8 <HAL_TIMEx_OCN_Start_IT+0x188>
2401f0ce:	687b      	ldr	r3, [r7, #4]
2401f0d0:	681b      	ldr	r3, [r3, #0]
2401f0d2:	4a1a      	ldr	r2, [pc, #104]	; (2401f13c <HAL_TIMEx_OCN_Start_IT+0x1ec>)
2401f0d4:	4293      	cmp	r3, r2
2401f0d6:	d115      	bne.n	2401f104 <HAL_TIMEx_OCN_Start_IT+0x1b4>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401f0d8:	687b      	ldr	r3, [r7, #4]
2401f0da:	681b      	ldr	r3, [r3, #0]
2401f0dc:	689a      	ldr	r2, [r3, #8]
2401f0de:	4b18      	ldr	r3, [pc, #96]	; (2401f140 <HAL_TIMEx_OCN_Start_IT+0x1f0>)
2401f0e0:	4013      	ands	r3, r2
2401f0e2:	60bb      	str	r3, [r7, #8]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f0e4:	68bb      	ldr	r3, [r7, #8]
2401f0e6:	2b06      	cmp	r3, #6
2401f0e8:	d015      	beq.n	2401f116 <HAL_TIMEx_OCN_Start_IT+0x1c6>
2401f0ea:	68bb      	ldr	r3, [r7, #8]
2401f0ec:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401f0f0:	d011      	beq.n	2401f116 <HAL_TIMEx_OCN_Start_IT+0x1c6>
      {
        __HAL_TIM_ENABLE(htim);
2401f0f2:	687b      	ldr	r3, [r7, #4]
2401f0f4:	681b      	ldr	r3, [r3, #0]
2401f0f6:	681a      	ldr	r2, [r3, #0]
2401f0f8:	687b      	ldr	r3, [r7, #4]
2401f0fa:	681b      	ldr	r3, [r3, #0]
2401f0fc:	f042 0201 	orr.w	r2, r2, #1
2401f100:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f102:	e008      	b.n	2401f116 <HAL_TIMEx_OCN_Start_IT+0x1c6>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
2401f104:	687b      	ldr	r3, [r7, #4]
2401f106:	681b      	ldr	r3, [r3, #0]
2401f108:	681a      	ldr	r2, [r3, #0]
2401f10a:	687b      	ldr	r3, [r7, #4]
2401f10c:	681b      	ldr	r3, [r3, #0]
2401f10e:	f042 0201 	orr.w	r2, r2, #1
2401f112:	601a      	str	r2, [r3, #0]
2401f114:	e000      	b.n	2401f118 <HAL_TIMEx_OCN_Start_IT+0x1c8>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f116:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
2401f118:	7bfb      	ldrb	r3, [r7, #15]
}
2401f11a:	4618      	mov	r0, r3
2401f11c:	3710      	adds	r7, #16
2401f11e:	46bd      	mov	sp, r7
2401f120:	bd80      	pop	{r7, pc}
2401f122:	bf00      	nop
2401f124:	40010000 	.word	0x40010000
2401f128:	40000400 	.word	0x40000400
2401f12c:	40000800 	.word	0x40000800
2401f130:	40000c00 	.word	0x40000c00
2401f134:	40010400 	.word	0x40010400
2401f138:	40001800 	.word	0x40001800
2401f13c:	40014000 	.word	0x40014000
2401f140:	00010007 	.word	0x00010007

2401f144 <HAL_TIMEx_OCN_Stop_IT>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401f144:	b580      	push	{r7, lr}
2401f146:	b084      	sub	sp, #16
2401f148:	af00      	add	r7, sp, #0
2401f14a:	6078      	str	r0, [r7, #4]
2401f14c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401f14e:	2300      	movs	r3, #0
2401f150:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpccer;

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  switch (Channel)
2401f152:	683b      	ldr	r3, [r7, #0]
2401f154:	2b08      	cmp	r3, #8
2401f156:	d01b      	beq.n	2401f190 <HAL_TIMEx_OCN_Stop_IT+0x4c>
2401f158:	683b      	ldr	r3, [r7, #0]
2401f15a:	2b08      	cmp	r3, #8
2401f15c:	d821      	bhi.n	2401f1a2 <HAL_TIMEx_OCN_Stop_IT+0x5e>
2401f15e:	683b      	ldr	r3, [r7, #0]
2401f160:	2b00      	cmp	r3, #0
2401f162:	d003      	beq.n	2401f16c <HAL_TIMEx_OCN_Stop_IT+0x28>
2401f164:	683b      	ldr	r3, [r7, #0]
2401f166:	2b04      	cmp	r3, #4
2401f168:	d009      	beq.n	2401f17e <HAL_TIMEx_OCN_Stop_IT+0x3a>
2401f16a:	e01a      	b.n	2401f1a2 <HAL_TIMEx_OCN_Stop_IT+0x5e>
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Output Compare interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2401f16c:	687b      	ldr	r3, [r7, #4]
2401f16e:	681b      	ldr	r3, [r3, #0]
2401f170:	68da      	ldr	r2, [r3, #12]
2401f172:	687b      	ldr	r3, [r7, #4]
2401f174:	681b      	ldr	r3, [r3, #0]
2401f176:	f022 0202 	bic.w	r2, r2, #2
2401f17a:	60da      	str	r2, [r3, #12]
      break;
2401f17c:	e014      	b.n	2401f1a8 <HAL_TIMEx_OCN_Stop_IT+0x64>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Output Compare interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2401f17e:	687b      	ldr	r3, [r7, #4]
2401f180:	681b      	ldr	r3, [r3, #0]
2401f182:	68da      	ldr	r2, [r3, #12]
2401f184:	687b      	ldr	r3, [r7, #4]
2401f186:	681b      	ldr	r3, [r3, #0]
2401f188:	f022 0204 	bic.w	r2, r2, #4
2401f18c:	60da      	str	r2, [r3, #12]
      break;
2401f18e:	e00b      	b.n	2401f1a8 <HAL_TIMEx_OCN_Stop_IT+0x64>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Output Compare interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
2401f190:	687b      	ldr	r3, [r7, #4]
2401f192:	681b      	ldr	r3, [r3, #0]
2401f194:	68da      	ldr	r2, [r3, #12]
2401f196:	687b      	ldr	r3, [r7, #4]
2401f198:	681b      	ldr	r3, [r3, #0]
2401f19a:	f022 0208 	bic.w	r2, r2, #8
2401f19e:	60da      	str	r2, [r3, #12]
      break;
2401f1a0:	e002      	b.n	2401f1a8 <HAL_TIMEx_OCN_Stop_IT+0x64>
    }

    default:
      status = HAL_ERROR;
2401f1a2:	2301      	movs	r3, #1
2401f1a4:	73fb      	strb	r3, [r7, #15]
      break;
2401f1a6:	bf00      	nop
  }

  if (status == HAL_OK)
2401f1a8:	7bfb      	ldrb	r3, [r7, #15]
2401f1aa:	2b00      	cmp	r3, #0
2401f1ac:	d164      	bne.n	2401f278 <HAL_TIMEx_OCN_Stop_IT+0x134>
  {
    /* Disable the Capture compare channel N */
    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2401f1ae:	687b      	ldr	r3, [r7, #4]
2401f1b0:	681b      	ldr	r3, [r3, #0]
2401f1b2:	2200      	movs	r2, #0
2401f1b4:	6839      	ldr	r1, [r7, #0]
2401f1b6:	4618      	mov	r0, r3
2401f1b8:	f001 fdeb 	bl	24020d92 <TIM_CCxNChannelCmd>

    /* Disable the TIM Break interrupt (only if no more channel is active) */
    tmpccer = htim->Instance->CCER;
2401f1bc:	687b      	ldr	r3, [r7, #4]
2401f1be:	681b      	ldr	r3, [r3, #0]
2401f1c0:	6a1b      	ldr	r3, [r3, #32]
2401f1c2:	60bb      	str	r3, [r7, #8]
    if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
2401f1c4:	68ba      	ldr	r2, [r7, #8]
2401f1c6:	f240 4344 	movw	r3, #1092	; 0x444
2401f1ca:	4013      	ands	r3, r2
2401f1cc:	2b00      	cmp	r3, #0
2401f1ce:	d107      	bne.n	2401f1e0 <HAL_TIMEx_OCN_Stop_IT+0x9c>
    {
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
2401f1d0:	687b      	ldr	r3, [r7, #4]
2401f1d2:	681b      	ldr	r3, [r3, #0]
2401f1d4:	68da      	ldr	r2, [r3, #12]
2401f1d6:	687b      	ldr	r3, [r7, #4]
2401f1d8:	681b      	ldr	r3, [r3, #0]
2401f1da:	f022 0280 	bic.w	r2, r2, #128	; 0x80
2401f1de:	60da      	str	r2, [r3, #12]
    }

    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
2401f1e0:	687b      	ldr	r3, [r7, #4]
2401f1e2:	681b      	ldr	r3, [r3, #0]
2401f1e4:	6a1a      	ldr	r2, [r3, #32]
2401f1e6:	f241 1311 	movw	r3, #4369	; 0x1111
2401f1ea:	4013      	ands	r3, r2
2401f1ec:	2b00      	cmp	r3, #0
2401f1ee:	d10f      	bne.n	2401f210 <HAL_TIMEx_OCN_Stop_IT+0xcc>
2401f1f0:	687b      	ldr	r3, [r7, #4]
2401f1f2:	681b      	ldr	r3, [r3, #0]
2401f1f4:	6a1a      	ldr	r2, [r3, #32]
2401f1f6:	f240 4344 	movw	r3, #1092	; 0x444
2401f1fa:	4013      	ands	r3, r2
2401f1fc:	2b00      	cmp	r3, #0
2401f1fe:	d107      	bne.n	2401f210 <HAL_TIMEx_OCN_Stop_IT+0xcc>
2401f200:	687b      	ldr	r3, [r7, #4]
2401f202:	681b      	ldr	r3, [r3, #0]
2401f204:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401f206:	687b      	ldr	r3, [r7, #4]
2401f208:	681b      	ldr	r3, [r3, #0]
2401f20a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401f20e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
2401f210:	687b      	ldr	r3, [r7, #4]
2401f212:	681b      	ldr	r3, [r3, #0]
2401f214:	6a1a      	ldr	r2, [r3, #32]
2401f216:	f241 1311 	movw	r3, #4369	; 0x1111
2401f21a:	4013      	ands	r3, r2
2401f21c:	2b00      	cmp	r3, #0
2401f21e:	d10f      	bne.n	2401f240 <HAL_TIMEx_OCN_Stop_IT+0xfc>
2401f220:	687b      	ldr	r3, [r7, #4]
2401f222:	681b      	ldr	r3, [r3, #0]
2401f224:	6a1a      	ldr	r2, [r3, #32]
2401f226:	f240 4344 	movw	r3, #1092	; 0x444
2401f22a:	4013      	ands	r3, r2
2401f22c:	2b00      	cmp	r3, #0
2401f22e:	d107      	bne.n	2401f240 <HAL_TIMEx_OCN_Stop_IT+0xfc>
2401f230:	687b      	ldr	r3, [r7, #4]
2401f232:	681b      	ldr	r3, [r3, #0]
2401f234:	681a      	ldr	r2, [r3, #0]
2401f236:	687b      	ldr	r3, [r7, #4]
2401f238:	681b      	ldr	r3, [r3, #0]
2401f23a:	f022 0201 	bic.w	r2, r2, #1
2401f23e:	601a      	str	r2, [r3, #0]

    /* Set the TIM complementary channel state */
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401f240:	683b      	ldr	r3, [r7, #0]
2401f242:	2b00      	cmp	r3, #0
2401f244:	d104      	bne.n	2401f250 <HAL_TIMEx_OCN_Stop_IT+0x10c>
2401f246:	687b      	ldr	r3, [r7, #4]
2401f248:	2201      	movs	r2, #1
2401f24a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401f24e:	e013      	b.n	2401f278 <HAL_TIMEx_OCN_Stop_IT+0x134>
2401f250:	683b      	ldr	r3, [r7, #0]
2401f252:	2b04      	cmp	r3, #4
2401f254:	d104      	bne.n	2401f260 <HAL_TIMEx_OCN_Stop_IT+0x11c>
2401f256:	687b      	ldr	r3, [r7, #4]
2401f258:	2201      	movs	r2, #1
2401f25a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401f25e:	e00b      	b.n	2401f278 <HAL_TIMEx_OCN_Stop_IT+0x134>
2401f260:	683b      	ldr	r3, [r7, #0]
2401f262:	2b08      	cmp	r3, #8
2401f264:	d104      	bne.n	2401f270 <HAL_TIMEx_OCN_Stop_IT+0x12c>
2401f266:	687b      	ldr	r3, [r7, #4]
2401f268:	2201      	movs	r2, #1
2401f26a:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401f26e:	e003      	b.n	2401f278 <HAL_TIMEx_OCN_Stop_IT+0x134>
2401f270:	687b      	ldr	r3, [r7, #4]
2401f272:	2201      	movs	r2, #1
2401f274:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  }

  /* Return function status */
  return status;
2401f278:	7bfb      	ldrb	r3, [r7, #15]
}
2401f27a:	4618      	mov	r0, r3
2401f27c:	3710      	adds	r7, #16
2401f27e:	46bd      	mov	sp, r7
2401f280:	bd80      	pop	{r7, pc}
	...

2401f284 <HAL_TIMEx_OCN_Start_DMA>:
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
                                          uint16_t Length)
{
2401f284:	b580      	push	{r7, lr}
2401f286:	b086      	sub	sp, #24
2401f288:	af00      	add	r7, sp, #0
2401f28a:	60f8      	str	r0, [r7, #12]
2401f28c:	60b9      	str	r1, [r7, #8]
2401f28e:	607a      	str	r2, [r7, #4]
2401f290:	807b      	strh	r3, [r7, #2]
  HAL_StatusTypeDef status = HAL_OK;
2401f292:	2300      	movs	r3, #0
2401f294:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Set the TIM complementary channel state */
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
2401f296:	68bb      	ldr	r3, [r7, #8]
2401f298:	2b00      	cmp	r3, #0
2401f29a:	d109      	bne.n	2401f2b0 <HAL_TIMEx_OCN_Start_DMA+0x2c>
2401f29c:	68fb      	ldr	r3, [r7, #12]
2401f29e:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401f2a2:	b2db      	uxtb	r3, r3
2401f2a4:	2b02      	cmp	r3, #2
2401f2a6:	bf0c      	ite	eq
2401f2a8:	2301      	moveq	r3, #1
2401f2aa:	2300      	movne	r3, #0
2401f2ac:	b2db      	uxtb	r3, r3
2401f2ae:	e022      	b.n	2401f2f6 <HAL_TIMEx_OCN_Start_DMA+0x72>
2401f2b0:	68bb      	ldr	r3, [r7, #8]
2401f2b2:	2b04      	cmp	r3, #4
2401f2b4:	d109      	bne.n	2401f2ca <HAL_TIMEx_OCN_Start_DMA+0x46>
2401f2b6:	68fb      	ldr	r3, [r7, #12]
2401f2b8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401f2bc:	b2db      	uxtb	r3, r3
2401f2be:	2b02      	cmp	r3, #2
2401f2c0:	bf0c      	ite	eq
2401f2c2:	2301      	moveq	r3, #1
2401f2c4:	2300      	movne	r3, #0
2401f2c6:	b2db      	uxtb	r3, r3
2401f2c8:	e015      	b.n	2401f2f6 <HAL_TIMEx_OCN_Start_DMA+0x72>
2401f2ca:	68bb      	ldr	r3, [r7, #8]
2401f2cc:	2b08      	cmp	r3, #8
2401f2ce:	d109      	bne.n	2401f2e4 <HAL_TIMEx_OCN_Start_DMA+0x60>
2401f2d0:	68fb      	ldr	r3, [r7, #12]
2401f2d2:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401f2d6:	b2db      	uxtb	r3, r3
2401f2d8:	2b02      	cmp	r3, #2
2401f2da:	bf0c      	ite	eq
2401f2dc:	2301      	moveq	r3, #1
2401f2de:	2300      	movne	r3, #0
2401f2e0:	b2db      	uxtb	r3, r3
2401f2e2:	e008      	b.n	2401f2f6 <HAL_TIMEx_OCN_Start_DMA+0x72>
2401f2e4:	68fb      	ldr	r3, [r7, #12]
2401f2e6:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401f2ea:	b2db      	uxtb	r3, r3
2401f2ec:	2b02      	cmp	r3, #2
2401f2ee:	bf0c      	ite	eq
2401f2f0:	2301      	moveq	r3, #1
2401f2f2:	2300      	movne	r3, #0
2401f2f4:	b2db      	uxtb	r3, r3
2401f2f6:	2b00      	cmp	r3, #0
2401f2f8:	d001      	beq.n	2401f2fe <HAL_TIMEx_OCN_Start_DMA+0x7a>
  {
    return HAL_BUSY;
2401f2fa:	2302      	movs	r3, #2
2401f2fc:	e12f      	b.n	2401f55e <HAL_TIMEx_OCN_Start_DMA+0x2da>
  }
  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
2401f2fe:	68bb      	ldr	r3, [r7, #8]
2401f300:	2b00      	cmp	r3, #0
2401f302:	d109      	bne.n	2401f318 <HAL_TIMEx_OCN_Start_DMA+0x94>
2401f304:	68fb      	ldr	r3, [r7, #12]
2401f306:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401f30a:	b2db      	uxtb	r3, r3
2401f30c:	2b01      	cmp	r3, #1
2401f30e:	bf0c      	ite	eq
2401f310:	2301      	moveq	r3, #1
2401f312:	2300      	movne	r3, #0
2401f314:	b2db      	uxtb	r3, r3
2401f316:	e022      	b.n	2401f35e <HAL_TIMEx_OCN_Start_DMA+0xda>
2401f318:	68bb      	ldr	r3, [r7, #8]
2401f31a:	2b04      	cmp	r3, #4
2401f31c:	d109      	bne.n	2401f332 <HAL_TIMEx_OCN_Start_DMA+0xae>
2401f31e:	68fb      	ldr	r3, [r7, #12]
2401f320:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401f324:	b2db      	uxtb	r3, r3
2401f326:	2b01      	cmp	r3, #1
2401f328:	bf0c      	ite	eq
2401f32a:	2301      	moveq	r3, #1
2401f32c:	2300      	movne	r3, #0
2401f32e:	b2db      	uxtb	r3, r3
2401f330:	e015      	b.n	2401f35e <HAL_TIMEx_OCN_Start_DMA+0xda>
2401f332:	68bb      	ldr	r3, [r7, #8]
2401f334:	2b08      	cmp	r3, #8
2401f336:	d109      	bne.n	2401f34c <HAL_TIMEx_OCN_Start_DMA+0xc8>
2401f338:	68fb      	ldr	r3, [r7, #12]
2401f33a:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401f33e:	b2db      	uxtb	r3, r3
2401f340:	2b01      	cmp	r3, #1
2401f342:	bf0c      	ite	eq
2401f344:	2301      	moveq	r3, #1
2401f346:	2300      	movne	r3, #0
2401f348:	b2db      	uxtb	r3, r3
2401f34a:	e008      	b.n	2401f35e <HAL_TIMEx_OCN_Start_DMA+0xda>
2401f34c:	68fb      	ldr	r3, [r7, #12]
2401f34e:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401f352:	b2db      	uxtb	r3, r3
2401f354:	2b01      	cmp	r3, #1
2401f356:	bf0c      	ite	eq
2401f358:	2301      	moveq	r3, #1
2401f35a:	2300      	movne	r3, #0
2401f35c:	b2db      	uxtb	r3, r3
2401f35e:	2b00      	cmp	r3, #0
2401f360:	d024      	beq.n	2401f3ac <HAL_TIMEx_OCN_Start_DMA+0x128>
  {
    if ((pData == NULL) || (Length == 0U))
2401f362:	687b      	ldr	r3, [r7, #4]
2401f364:	2b00      	cmp	r3, #0
2401f366:	d002      	beq.n	2401f36e <HAL_TIMEx_OCN_Start_DMA+0xea>
2401f368:	887b      	ldrh	r3, [r7, #2]
2401f36a:	2b00      	cmp	r3, #0
2401f36c:	d101      	bne.n	2401f372 <HAL_TIMEx_OCN_Start_DMA+0xee>
    {
      return HAL_ERROR;
2401f36e:	2301      	movs	r3, #1
2401f370:	e0f5      	b.n	2401f55e <HAL_TIMEx_OCN_Start_DMA+0x2da>
    }
    else
    {
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401f372:	68bb      	ldr	r3, [r7, #8]
2401f374:	2b00      	cmp	r3, #0
2401f376:	d104      	bne.n	2401f382 <HAL_TIMEx_OCN_Start_DMA+0xfe>
2401f378:	68fb      	ldr	r3, [r7, #12]
2401f37a:	2202      	movs	r2, #2
2401f37c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401f380:	e016      	b.n	2401f3b0 <HAL_TIMEx_OCN_Start_DMA+0x12c>
2401f382:	68bb      	ldr	r3, [r7, #8]
2401f384:	2b04      	cmp	r3, #4
2401f386:	d104      	bne.n	2401f392 <HAL_TIMEx_OCN_Start_DMA+0x10e>
2401f388:	68fb      	ldr	r3, [r7, #12]
2401f38a:	2202      	movs	r2, #2
2401f38c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401f390:	e00e      	b.n	2401f3b0 <HAL_TIMEx_OCN_Start_DMA+0x12c>
2401f392:	68bb      	ldr	r3, [r7, #8]
2401f394:	2b08      	cmp	r3, #8
2401f396:	d104      	bne.n	2401f3a2 <HAL_TIMEx_OCN_Start_DMA+0x11e>
2401f398:	68fb      	ldr	r3, [r7, #12]
2401f39a:	2202      	movs	r2, #2
2401f39c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401f3a0:	e006      	b.n	2401f3b0 <HAL_TIMEx_OCN_Start_DMA+0x12c>
2401f3a2:	68fb      	ldr	r3, [r7, #12]
2401f3a4:	2202      	movs	r2, #2
2401f3a6:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
2401f3aa:	e001      	b.n	2401f3b0 <HAL_TIMEx_OCN_Start_DMA+0x12c>
    }
  }
  else
  {
    return HAL_ERROR;
2401f3ac:	2301      	movs	r3, #1
2401f3ae:	e0d6      	b.n	2401f55e <HAL_TIMEx_OCN_Start_DMA+0x2da>
  }

  switch (Channel)
2401f3b0:	68bb      	ldr	r3, [r7, #8]
2401f3b2:	2b08      	cmp	r3, #8
2401f3b4:	d051      	beq.n	2401f45a <HAL_TIMEx_OCN_Start_DMA+0x1d6>
2401f3b6:	68bb      	ldr	r3, [r7, #8]
2401f3b8:	2b08      	cmp	r3, #8
2401f3ba:	d872      	bhi.n	2401f4a2 <HAL_TIMEx_OCN_Start_DMA+0x21e>
2401f3bc:	68bb      	ldr	r3, [r7, #8]
2401f3be:	2b00      	cmp	r3, #0
2401f3c0:	d003      	beq.n	2401f3ca <HAL_TIMEx_OCN_Start_DMA+0x146>
2401f3c2:	68bb      	ldr	r3, [r7, #8]
2401f3c4:	2b04      	cmp	r3, #4
2401f3c6:	d024      	beq.n	2401f412 <HAL_TIMEx_OCN_Start_DMA+0x18e>
2401f3c8:	e06b      	b.n	2401f4a2 <HAL_TIMEx_OCN_Start_DMA+0x21e>
  {
    case TIM_CHANNEL_1:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;
2401f3ca:	68fb      	ldr	r3, [r7, #12]
2401f3cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401f3ce:	4a66      	ldr	r2, [pc, #408]	; (2401f568 <HAL_TIMEx_OCN_Start_DMA+0x2e4>)
2401f3d0:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401f3d2:	68fb      	ldr	r3, [r7, #12]
2401f3d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401f3d6:	4a65      	ldr	r2, [pc, #404]	; (2401f56c <HAL_TIMEx_OCN_Start_DMA+0x2e8>)
2401f3d8:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;
2401f3da:	68fb      	ldr	r3, [r7, #12]
2401f3dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401f3de:	4a64      	ldr	r2, [pc, #400]	; (2401f570 <HAL_TIMEx_OCN_Start_DMA+0x2ec>)
2401f3e0:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
2401f3e2:	68fb      	ldr	r3, [r7, #12]
2401f3e4:	6a58      	ldr	r0, [r3, #36]	; 0x24
2401f3e6:	6879      	ldr	r1, [r7, #4]
2401f3e8:	68fb      	ldr	r3, [r7, #12]
2401f3ea:	681b      	ldr	r3, [r3, #0]
2401f3ec:	3334      	adds	r3, #52	; 0x34
2401f3ee:	461a      	mov	r2, r3
2401f3f0:	887b      	ldrh	r3, [r7, #2]
2401f3f2:	f7e4 fbad 	bl	24003b50 <HAL_DMA_Start_IT>
2401f3f6:	4603      	mov	r3, r0
2401f3f8:	2b00      	cmp	r3, #0
2401f3fa:	d001      	beq.n	2401f400 <HAL_TIMEx_OCN_Start_DMA+0x17c>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401f3fc:	2301      	movs	r3, #1
2401f3fe:	e0ae      	b.n	2401f55e <HAL_TIMEx_OCN_Start_DMA+0x2da>
      }
      /* Enable the TIM Output Compare DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2401f400:	68fb      	ldr	r3, [r7, #12]
2401f402:	681b      	ldr	r3, [r3, #0]
2401f404:	68da      	ldr	r2, [r3, #12]
2401f406:	68fb      	ldr	r3, [r7, #12]
2401f408:	681b      	ldr	r3, [r3, #0]
2401f40a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2401f40e:	60da      	str	r2, [r3, #12]
      break;
2401f410:	e04a      	b.n	2401f4a8 <HAL_TIMEx_OCN_Start_DMA+0x224>
    }

    case TIM_CHANNEL_2:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;
2401f412:	68fb      	ldr	r3, [r7, #12]
2401f414:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401f416:	4a54      	ldr	r2, [pc, #336]	; (2401f568 <HAL_TIMEx_OCN_Start_DMA+0x2e4>)
2401f418:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401f41a:	68fb      	ldr	r3, [r7, #12]
2401f41c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401f41e:	4a53      	ldr	r2, [pc, #332]	; (2401f56c <HAL_TIMEx_OCN_Start_DMA+0x2e8>)
2401f420:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;
2401f422:	68fb      	ldr	r3, [r7, #12]
2401f424:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401f426:	4a52      	ldr	r2, [pc, #328]	; (2401f570 <HAL_TIMEx_OCN_Start_DMA+0x2ec>)
2401f428:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
2401f42a:	68fb      	ldr	r3, [r7, #12]
2401f42c:	6a98      	ldr	r0, [r3, #40]	; 0x28
2401f42e:	6879      	ldr	r1, [r7, #4]
2401f430:	68fb      	ldr	r3, [r7, #12]
2401f432:	681b      	ldr	r3, [r3, #0]
2401f434:	3338      	adds	r3, #56	; 0x38
2401f436:	461a      	mov	r2, r3
2401f438:	887b      	ldrh	r3, [r7, #2]
2401f43a:	f7e4 fb89 	bl	24003b50 <HAL_DMA_Start_IT>
2401f43e:	4603      	mov	r3, r0
2401f440:	2b00      	cmp	r3, #0
2401f442:	d001      	beq.n	2401f448 <HAL_TIMEx_OCN_Start_DMA+0x1c4>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401f444:	2301      	movs	r3, #1
2401f446:	e08a      	b.n	2401f55e <HAL_TIMEx_OCN_Start_DMA+0x2da>
      }
      /* Enable the TIM Output Compare DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2401f448:	68fb      	ldr	r3, [r7, #12]
2401f44a:	681b      	ldr	r3, [r3, #0]
2401f44c:	68da      	ldr	r2, [r3, #12]
2401f44e:	68fb      	ldr	r3, [r7, #12]
2401f450:	681b      	ldr	r3, [r3, #0]
2401f452:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
2401f456:	60da      	str	r2, [r3, #12]
      break;
2401f458:	e026      	b.n	2401f4a8 <HAL_TIMEx_OCN_Start_DMA+0x224>
    }

    case TIM_CHANNEL_3:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;
2401f45a:	68fb      	ldr	r3, [r7, #12]
2401f45c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401f45e:	4a42      	ldr	r2, [pc, #264]	; (2401f568 <HAL_TIMEx_OCN_Start_DMA+0x2e4>)
2401f460:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401f462:	68fb      	ldr	r3, [r7, #12]
2401f464:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401f466:	4a41      	ldr	r2, [pc, #260]	; (2401f56c <HAL_TIMEx_OCN_Start_DMA+0x2e8>)
2401f468:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;
2401f46a:	68fb      	ldr	r3, [r7, #12]
2401f46c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401f46e:	4a40      	ldr	r2, [pc, #256]	; (2401f570 <HAL_TIMEx_OCN_Start_DMA+0x2ec>)
2401f470:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
2401f472:	68fb      	ldr	r3, [r7, #12]
2401f474:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2401f476:	6879      	ldr	r1, [r7, #4]
2401f478:	68fb      	ldr	r3, [r7, #12]
2401f47a:	681b      	ldr	r3, [r3, #0]
2401f47c:	333c      	adds	r3, #60	; 0x3c
2401f47e:	461a      	mov	r2, r3
2401f480:	887b      	ldrh	r3, [r7, #2]
2401f482:	f7e4 fb65 	bl	24003b50 <HAL_DMA_Start_IT>
2401f486:	4603      	mov	r3, r0
2401f488:	2b00      	cmp	r3, #0
2401f48a:	d001      	beq.n	2401f490 <HAL_TIMEx_OCN_Start_DMA+0x20c>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401f48c:	2301      	movs	r3, #1
2401f48e:	e066      	b.n	2401f55e <HAL_TIMEx_OCN_Start_DMA+0x2da>
      }
      /* Enable the TIM Output Compare DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
2401f490:	68fb      	ldr	r3, [r7, #12]
2401f492:	681b      	ldr	r3, [r3, #0]
2401f494:	68da      	ldr	r2, [r3, #12]
2401f496:	68fb      	ldr	r3, [r7, #12]
2401f498:	681b      	ldr	r3, [r3, #0]
2401f49a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
2401f49e:	60da      	str	r2, [r3, #12]
      break;
2401f4a0:	e002      	b.n	2401f4a8 <HAL_TIMEx_OCN_Start_DMA+0x224>
    }

    default:
      status = HAL_ERROR;
2401f4a2:	2301      	movs	r3, #1
2401f4a4:	75fb      	strb	r3, [r7, #23]
      break;
2401f4a6:	bf00      	nop
  }

  if (status == HAL_OK)
2401f4a8:	7dfb      	ldrb	r3, [r7, #23]
2401f4aa:	2b00      	cmp	r3, #0
2401f4ac:	d156      	bne.n	2401f55c <HAL_TIMEx_OCN_Start_DMA+0x2d8>
  {
    /* Enable the Capture compare channel N */
    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2401f4ae:	68fb      	ldr	r3, [r7, #12]
2401f4b0:	681b      	ldr	r3, [r3, #0]
2401f4b2:	2204      	movs	r2, #4
2401f4b4:	68b9      	ldr	r1, [r7, #8]
2401f4b6:	4618      	mov	r0, r3
2401f4b8:	f001 fc6b 	bl	24020d92 <TIM_CCxNChannelCmd>

    /* Enable the Main Output */
    __HAL_TIM_MOE_ENABLE(htim);
2401f4bc:	68fb      	ldr	r3, [r7, #12]
2401f4be:	681b      	ldr	r3, [r3, #0]
2401f4c0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401f4c2:	68fb      	ldr	r3, [r7, #12]
2401f4c4:	681b      	ldr	r3, [r3, #0]
2401f4c6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401f4ca:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401f4cc:	68fb      	ldr	r3, [r7, #12]
2401f4ce:	681b      	ldr	r3, [r3, #0]
2401f4d0:	4a28      	ldr	r2, [pc, #160]	; (2401f574 <HAL_TIMEx_OCN_Start_DMA+0x2f0>)
2401f4d2:	4293      	cmp	r3, r2
2401f4d4:	d022      	beq.n	2401f51c <HAL_TIMEx_OCN_Start_DMA+0x298>
2401f4d6:	68fb      	ldr	r3, [r7, #12]
2401f4d8:	681b      	ldr	r3, [r3, #0]
2401f4da:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401f4de:	d01d      	beq.n	2401f51c <HAL_TIMEx_OCN_Start_DMA+0x298>
2401f4e0:	68fb      	ldr	r3, [r7, #12]
2401f4e2:	681b      	ldr	r3, [r3, #0]
2401f4e4:	4a24      	ldr	r2, [pc, #144]	; (2401f578 <HAL_TIMEx_OCN_Start_DMA+0x2f4>)
2401f4e6:	4293      	cmp	r3, r2
2401f4e8:	d018      	beq.n	2401f51c <HAL_TIMEx_OCN_Start_DMA+0x298>
2401f4ea:	68fb      	ldr	r3, [r7, #12]
2401f4ec:	681b      	ldr	r3, [r3, #0]
2401f4ee:	4a23      	ldr	r2, [pc, #140]	; (2401f57c <HAL_TIMEx_OCN_Start_DMA+0x2f8>)
2401f4f0:	4293      	cmp	r3, r2
2401f4f2:	d013      	beq.n	2401f51c <HAL_TIMEx_OCN_Start_DMA+0x298>
2401f4f4:	68fb      	ldr	r3, [r7, #12]
2401f4f6:	681b      	ldr	r3, [r3, #0]
2401f4f8:	4a21      	ldr	r2, [pc, #132]	; (2401f580 <HAL_TIMEx_OCN_Start_DMA+0x2fc>)
2401f4fa:	4293      	cmp	r3, r2
2401f4fc:	d00e      	beq.n	2401f51c <HAL_TIMEx_OCN_Start_DMA+0x298>
2401f4fe:	68fb      	ldr	r3, [r7, #12]
2401f500:	681b      	ldr	r3, [r3, #0]
2401f502:	4a20      	ldr	r2, [pc, #128]	; (2401f584 <HAL_TIMEx_OCN_Start_DMA+0x300>)
2401f504:	4293      	cmp	r3, r2
2401f506:	d009      	beq.n	2401f51c <HAL_TIMEx_OCN_Start_DMA+0x298>
2401f508:	68fb      	ldr	r3, [r7, #12]
2401f50a:	681b      	ldr	r3, [r3, #0]
2401f50c:	4a1e      	ldr	r2, [pc, #120]	; (2401f588 <HAL_TIMEx_OCN_Start_DMA+0x304>)
2401f50e:	4293      	cmp	r3, r2
2401f510:	d004      	beq.n	2401f51c <HAL_TIMEx_OCN_Start_DMA+0x298>
2401f512:	68fb      	ldr	r3, [r7, #12]
2401f514:	681b      	ldr	r3, [r3, #0]
2401f516:	4a1d      	ldr	r2, [pc, #116]	; (2401f58c <HAL_TIMEx_OCN_Start_DMA+0x308>)
2401f518:	4293      	cmp	r3, r2
2401f51a:	d115      	bne.n	2401f548 <HAL_TIMEx_OCN_Start_DMA+0x2c4>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401f51c:	68fb      	ldr	r3, [r7, #12]
2401f51e:	681b      	ldr	r3, [r3, #0]
2401f520:	689a      	ldr	r2, [r3, #8]
2401f522:	4b1b      	ldr	r3, [pc, #108]	; (2401f590 <HAL_TIMEx_OCN_Start_DMA+0x30c>)
2401f524:	4013      	ands	r3, r2
2401f526:	613b      	str	r3, [r7, #16]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f528:	693b      	ldr	r3, [r7, #16]
2401f52a:	2b06      	cmp	r3, #6
2401f52c:	d015      	beq.n	2401f55a <HAL_TIMEx_OCN_Start_DMA+0x2d6>
2401f52e:	693b      	ldr	r3, [r7, #16]
2401f530:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401f534:	d011      	beq.n	2401f55a <HAL_TIMEx_OCN_Start_DMA+0x2d6>
      {
        __HAL_TIM_ENABLE(htim);
2401f536:	68fb      	ldr	r3, [r7, #12]
2401f538:	681b      	ldr	r3, [r3, #0]
2401f53a:	681a      	ldr	r2, [r3, #0]
2401f53c:	68fb      	ldr	r3, [r7, #12]
2401f53e:	681b      	ldr	r3, [r3, #0]
2401f540:	f042 0201 	orr.w	r2, r2, #1
2401f544:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f546:	e008      	b.n	2401f55a <HAL_TIMEx_OCN_Start_DMA+0x2d6>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
2401f548:	68fb      	ldr	r3, [r7, #12]
2401f54a:	681b      	ldr	r3, [r3, #0]
2401f54c:	681a      	ldr	r2, [r3, #0]
2401f54e:	68fb      	ldr	r3, [r7, #12]
2401f550:	681b      	ldr	r3, [r3, #0]
2401f552:	f042 0201 	orr.w	r2, r2, #1
2401f556:	601a      	str	r2, [r3, #0]
2401f558:	e000      	b.n	2401f55c <HAL_TIMEx_OCN_Start_DMA+0x2d8>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f55a:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
2401f55c:	7dfb      	ldrb	r3, [r7, #23]
}
2401f55e:	4618      	mov	r0, r3
2401f560:	3718      	adds	r7, #24
2401f562:	46bd      	mov	sp, r7
2401f564:	bd80      	pop	{r7, pc}
2401f566:	bf00      	nop
2401f568:	24020c7d 	.word	0x24020c7d
2401f56c:	2401d6f9 	.word	0x2401d6f9
2401f570:	24020d25 	.word	0x24020d25
2401f574:	40010000 	.word	0x40010000
2401f578:	40000400 	.word	0x40000400
2401f57c:	40000800 	.word	0x40000800
2401f580:	40000c00 	.word	0x40000c00
2401f584:	40010400 	.word	0x40010400
2401f588:	40001800 	.word	0x40001800
2401f58c:	40014000 	.word	0x40014000
2401f590:	00010007 	.word	0x00010007

2401f594 <HAL_TIMEx_OCN_Stop_DMA>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401f594:	b580      	push	{r7, lr}
2401f596:	b084      	sub	sp, #16
2401f598:	af00      	add	r7, sp, #0
2401f59a:	6078      	str	r0, [r7, #4]
2401f59c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401f59e:	2300      	movs	r3, #0
2401f5a0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  switch (Channel)
2401f5a2:	683b      	ldr	r3, [r7, #0]
2401f5a4:	2b08      	cmp	r3, #8
2401f5a6:	d025      	beq.n	2401f5f4 <HAL_TIMEx_OCN_Stop_DMA+0x60>
2401f5a8:	683b      	ldr	r3, [r7, #0]
2401f5aa:	2b08      	cmp	r3, #8
2401f5ac:	d830      	bhi.n	2401f610 <HAL_TIMEx_OCN_Stop_DMA+0x7c>
2401f5ae:	683b      	ldr	r3, [r7, #0]
2401f5b0:	2b00      	cmp	r3, #0
2401f5b2:	d003      	beq.n	2401f5bc <HAL_TIMEx_OCN_Stop_DMA+0x28>
2401f5b4:	683b      	ldr	r3, [r7, #0]
2401f5b6:	2b04      	cmp	r3, #4
2401f5b8:	d00e      	beq.n	2401f5d8 <HAL_TIMEx_OCN_Stop_DMA+0x44>
2401f5ba:	e029      	b.n	2401f610 <HAL_TIMEx_OCN_Stop_DMA+0x7c>
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Output Compare DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2401f5bc:	687b      	ldr	r3, [r7, #4]
2401f5be:	681b      	ldr	r3, [r3, #0]
2401f5c0:	68da      	ldr	r2, [r3, #12]
2401f5c2:	687b      	ldr	r3, [r7, #4]
2401f5c4:	681b      	ldr	r3, [r3, #0]
2401f5c6:	f422 7200 	bic.w	r2, r2, #512	; 0x200
2401f5ca:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2401f5cc:	687b      	ldr	r3, [r7, #4]
2401f5ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401f5d0:	4618      	mov	r0, r3
2401f5d2:	f7e5 f845 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401f5d6:	e01e      	b.n	2401f616 <HAL_TIMEx_OCN_Stop_DMA+0x82>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Output Compare DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2401f5d8:	687b      	ldr	r3, [r7, #4]
2401f5da:	681b      	ldr	r3, [r3, #0]
2401f5dc:	68da      	ldr	r2, [r3, #12]
2401f5de:	687b      	ldr	r3, [r7, #4]
2401f5e0:	681b      	ldr	r3, [r3, #0]
2401f5e2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2401f5e6:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2401f5e8:	687b      	ldr	r3, [r7, #4]
2401f5ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401f5ec:	4618      	mov	r0, r3
2401f5ee:	f7e5 f837 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401f5f2:	e010      	b.n	2401f616 <HAL_TIMEx_OCN_Stop_DMA+0x82>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Output Compare DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2401f5f4:	687b      	ldr	r3, [r7, #4]
2401f5f6:	681b      	ldr	r3, [r3, #0]
2401f5f8:	68da      	ldr	r2, [r3, #12]
2401f5fa:	687b      	ldr	r3, [r7, #4]
2401f5fc:	681b      	ldr	r3, [r3, #0]
2401f5fe:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
2401f602:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2401f604:	687b      	ldr	r3, [r7, #4]
2401f606:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401f608:	4618      	mov	r0, r3
2401f60a:	f7e5 f829 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401f60e:	e002      	b.n	2401f616 <HAL_TIMEx_OCN_Stop_DMA+0x82>
    }

    default:
      status = HAL_ERROR;
2401f610:	2301      	movs	r3, #1
2401f612:	73fb      	strb	r3, [r7, #15]
      break;
2401f614:	bf00      	nop
  }

  if (status == HAL_OK)
2401f616:	7bfb      	ldrb	r3, [r7, #15]
2401f618:	2b00      	cmp	r3, #0
2401f61a:	d152      	bne.n	2401f6c2 <HAL_TIMEx_OCN_Stop_DMA+0x12e>
  {
    /* Disable the Capture compare channel N */
    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2401f61c:	687b      	ldr	r3, [r7, #4]
2401f61e:	681b      	ldr	r3, [r3, #0]
2401f620:	2200      	movs	r2, #0
2401f622:	6839      	ldr	r1, [r7, #0]
2401f624:	4618      	mov	r0, r3
2401f626:	f001 fbb4 	bl	24020d92 <TIM_CCxNChannelCmd>

    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
2401f62a:	687b      	ldr	r3, [r7, #4]
2401f62c:	681b      	ldr	r3, [r3, #0]
2401f62e:	6a1a      	ldr	r2, [r3, #32]
2401f630:	f241 1311 	movw	r3, #4369	; 0x1111
2401f634:	4013      	ands	r3, r2
2401f636:	2b00      	cmp	r3, #0
2401f638:	d10f      	bne.n	2401f65a <HAL_TIMEx_OCN_Stop_DMA+0xc6>
2401f63a:	687b      	ldr	r3, [r7, #4]
2401f63c:	681b      	ldr	r3, [r3, #0]
2401f63e:	6a1a      	ldr	r2, [r3, #32]
2401f640:	f240 4344 	movw	r3, #1092	; 0x444
2401f644:	4013      	ands	r3, r2
2401f646:	2b00      	cmp	r3, #0
2401f648:	d107      	bne.n	2401f65a <HAL_TIMEx_OCN_Stop_DMA+0xc6>
2401f64a:	687b      	ldr	r3, [r7, #4]
2401f64c:	681b      	ldr	r3, [r3, #0]
2401f64e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401f650:	687b      	ldr	r3, [r7, #4]
2401f652:	681b      	ldr	r3, [r3, #0]
2401f654:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401f658:	645a      	str	r2, [r3, #68]	; 0x44

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
2401f65a:	687b      	ldr	r3, [r7, #4]
2401f65c:	681b      	ldr	r3, [r3, #0]
2401f65e:	6a1a      	ldr	r2, [r3, #32]
2401f660:	f241 1311 	movw	r3, #4369	; 0x1111
2401f664:	4013      	ands	r3, r2
2401f666:	2b00      	cmp	r3, #0
2401f668:	d10f      	bne.n	2401f68a <HAL_TIMEx_OCN_Stop_DMA+0xf6>
2401f66a:	687b      	ldr	r3, [r7, #4]
2401f66c:	681b      	ldr	r3, [r3, #0]
2401f66e:	6a1a      	ldr	r2, [r3, #32]
2401f670:	f240 4344 	movw	r3, #1092	; 0x444
2401f674:	4013      	ands	r3, r2
2401f676:	2b00      	cmp	r3, #0
2401f678:	d107      	bne.n	2401f68a <HAL_TIMEx_OCN_Stop_DMA+0xf6>
2401f67a:	687b      	ldr	r3, [r7, #4]
2401f67c:	681b      	ldr	r3, [r3, #0]
2401f67e:	681a      	ldr	r2, [r3, #0]
2401f680:	687b      	ldr	r3, [r7, #4]
2401f682:	681b      	ldr	r3, [r3, #0]
2401f684:	f022 0201 	bic.w	r2, r2, #1
2401f688:	601a      	str	r2, [r3, #0]

    /* Set the TIM complementary channel state */
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401f68a:	683b      	ldr	r3, [r7, #0]
2401f68c:	2b00      	cmp	r3, #0
2401f68e:	d104      	bne.n	2401f69a <HAL_TIMEx_OCN_Stop_DMA+0x106>
2401f690:	687b      	ldr	r3, [r7, #4]
2401f692:	2201      	movs	r2, #1
2401f694:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401f698:	e013      	b.n	2401f6c2 <HAL_TIMEx_OCN_Stop_DMA+0x12e>
2401f69a:	683b      	ldr	r3, [r7, #0]
2401f69c:	2b04      	cmp	r3, #4
2401f69e:	d104      	bne.n	2401f6aa <HAL_TIMEx_OCN_Stop_DMA+0x116>
2401f6a0:	687b      	ldr	r3, [r7, #4]
2401f6a2:	2201      	movs	r2, #1
2401f6a4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401f6a8:	e00b      	b.n	2401f6c2 <HAL_TIMEx_OCN_Stop_DMA+0x12e>
2401f6aa:	683b      	ldr	r3, [r7, #0]
2401f6ac:	2b08      	cmp	r3, #8
2401f6ae:	d104      	bne.n	2401f6ba <HAL_TIMEx_OCN_Stop_DMA+0x126>
2401f6b0:	687b      	ldr	r3, [r7, #4]
2401f6b2:	2201      	movs	r2, #1
2401f6b4:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401f6b8:	e003      	b.n	2401f6c2 <HAL_TIMEx_OCN_Stop_DMA+0x12e>
2401f6ba:	687b      	ldr	r3, [r7, #4]
2401f6bc:	2201      	movs	r2, #1
2401f6be:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  }

  /* Return function status */
  return status;
2401f6c2:	7bfb      	ldrb	r3, [r7, #15]
}
2401f6c4:	4618      	mov	r0, r3
2401f6c6:	3710      	adds	r7, #16
2401f6c8:	46bd      	mov	sp, r7
2401f6ca:	bd80      	pop	{r7, pc}

2401f6cc <HAL_TIMEx_PWMN_Start>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401f6cc:	b580      	push	{r7, lr}
2401f6ce:	b084      	sub	sp, #16
2401f6d0:	af00      	add	r7, sp, #0
2401f6d2:	6078      	str	r0, [r7, #4]
2401f6d4:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Check the TIM complementary channel state */
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
2401f6d6:	683b      	ldr	r3, [r7, #0]
2401f6d8:	2b00      	cmp	r3, #0
2401f6da:	d109      	bne.n	2401f6f0 <HAL_TIMEx_PWMN_Start+0x24>
2401f6dc:	687b      	ldr	r3, [r7, #4]
2401f6de:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401f6e2:	b2db      	uxtb	r3, r3
2401f6e4:	2b01      	cmp	r3, #1
2401f6e6:	bf14      	ite	ne
2401f6e8:	2301      	movne	r3, #1
2401f6ea:	2300      	moveq	r3, #0
2401f6ec:	b2db      	uxtb	r3, r3
2401f6ee:	e022      	b.n	2401f736 <HAL_TIMEx_PWMN_Start+0x6a>
2401f6f0:	683b      	ldr	r3, [r7, #0]
2401f6f2:	2b04      	cmp	r3, #4
2401f6f4:	d109      	bne.n	2401f70a <HAL_TIMEx_PWMN_Start+0x3e>
2401f6f6:	687b      	ldr	r3, [r7, #4]
2401f6f8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401f6fc:	b2db      	uxtb	r3, r3
2401f6fe:	2b01      	cmp	r3, #1
2401f700:	bf14      	ite	ne
2401f702:	2301      	movne	r3, #1
2401f704:	2300      	moveq	r3, #0
2401f706:	b2db      	uxtb	r3, r3
2401f708:	e015      	b.n	2401f736 <HAL_TIMEx_PWMN_Start+0x6a>
2401f70a:	683b      	ldr	r3, [r7, #0]
2401f70c:	2b08      	cmp	r3, #8
2401f70e:	d109      	bne.n	2401f724 <HAL_TIMEx_PWMN_Start+0x58>
2401f710:	687b      	ldr	r3, [r7, #4]
2401f712:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401f716:	b2db      	uxtb	r3, r3
2401f718:	2b01      	cmp	r3, #1
2401f71a:	bf14      	ite	ne
2401f71c:	2301      	movne	r3, #1
2401f71e:	2300      	moveq	r3, #0
2401f720:	b2db      	uxtb	r3, r3
2401f722:	e008      	b.n	2401f736 <HAL_TIMEx_PWMN_Start+0x6a>
2401f724:	687b      	ldr	r3, [r7, #4]
2401f726:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401f72a:	b2db      	uxtb	r3, r3
2401f72c:	2b01      	cmp	r3, #1
2401f72e:	bf14      	ite	ne
2401f730:	2301      	movne	r3, #1
2401f732:	2300      	moveq	r3, #0
2401f734:	b2db      	uxtb	r3, r3
2401f736:	2b00      	cmp	r3, #0
2401f738:	d001      	beq.n	2401f73e <HAL_TIMEx_PWMN_Start+0x72>
  {
    return HAL_ERROR;
2401f73a:	2301      	movs	r3, #1
2401f73c:	e073      	b.n	2401f826 <HAL_TIMEx_PWMN_Start+0x15a>
  }

  /* Set the TIM complementary channel state */
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401f73e:	683b      	ldr	r3, [r7, #0]
2401f740:	2b00      	cmp	r3, #0
2401f742:	d104      	bne.n	2401f74e <HAL_TIMEx_PWMN_Start+0x82>
2401f744:	687b      	ldr	r3, [r7, #4]
2401f746:	2202      	movs	r2, #2
2401f748:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401f74c:	e013      	b.n	2401f776 <HAL_TIMEx_PWMN_Start+0xaa>
2401f74e:	683b      	ldr	r3, [r7, #0]
2401f750:	2b04      	cmp	r3, #4
2401f752:	d104      	bne.n	2401f75e <HAL_TIMEx_PWMN_Start+0x92>
2401f754:	687b      	ldr	r3, [r7, #4]
2401f756:	2202      	movs	r2, #2
2401f758:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401f75c:	e00b      	b.n	2401f776 <HAL_TIMEx_PWMN_Start+0xaa>
2401f75e:	683b      	ldr	r3, [r7, #0]
2401f760:	2b08      	cmp	r3, #8
2401f762:	d104      	bne.n	2401f76e <HAL_TIMEx_PWMN_Start+0xa2>
2401f764:	687b      	ldr	r3, [r7, #4]
2401f766:	2202      	movs	r2, #2
2401f768:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401f76c:	e003      	b.n	2401f776 <HAL_TIMEx_PWMN_Start+0xaa>
2401f76e:	687b      	ldr	r3, [r7, #4]
2401f770:	2202      	movs	r2, #2
2401f772:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Enable the complementary PWM output  */
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2401f776:	687b      	ldr	r3, [r7, #4]
2401f778:	681b      	ldr	r3, [r3, #0]
2401f77a:	2204      	movs	r2, #4
2401f77c:	6839      	ldr	r1, [r7, #0]
2401f77e:	4618      	mov	r0, r3
2401f780:	f001 fb07 	bl	24020d92 <TIM_CCxNChannelCmd>

  /* Enable the Main Output */
  __HAL_TIM_MOE_ENABLE(htim);
2401f784:	687b      	ldr	r3, [r7, #4]
2401f786:	681b      	ldr	r3, [r3, #0]
2401f788:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401f78a:	687b      	ldr	r3, [r7, #4]
2401f78c:	681b      	ldr	r3, [r3, #0]
2401f78e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401f792:	645a      	str	r2, [r3, #68]	; 0x44

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401f794:	687b      	ldr	r3, [r7, #4]
2401f796:	681b      	ldr	r3, [r3, #0]
2401f798:	4a25      	ldr	r2, [pc, #148]	; (2401f830 <HAL_TIMEx_PWMN_Start+0x164>)
2401f79a:	4293      	cmp	r3, r2
2401f79c:	d022      	beq.n	2401f7e4 <HAL_TIMEx_PWMN_Start+0x118>
2401f79e:	687b      	ldr	r3, [r7, #4]
2401f7a0:	681b      	ldr	r3, [r3, #0]
2401f7a2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401f7a6:	d01d      	beq.n	2401f7e4 <HAL_TIMEx_PWMN_Start+0x118>
2401f7a8:	687b      	ldr	r3, [r7, #4]
2401f7aa:	681b      	ldr	r3, [r3, #0]
2401f7ac:	4a21      	ldr	r2, [pc, #132]	; (2401f834 <HAL_TIMEx_PWMN_Start+0x168>)
2401f7ae:	4293      	cmp	r3, r2
2401f7b0:	d018      	beq.n	2401f7e4 <HAL_TIMEx_PWMN_Start+0x118>
2401f7b2:	687b      	ldr	r3, [r7, #4]
2401f7b4:	681b      	ldr	r3, [r3, #0]
2401f7b6:	4a20      	ldr	r2, [pc, #128]	; (2401f838 <HAL_TIMEx_PWMN_Start+0x16c>)
2401f7b8:	4293      	cmp	r3, r2
2401f7ba:	d013      	beq.n	2401f7e4 <HAL_TIMEx_PWMN_Start+0x118>
2401f7bc:	687b      	ldr	r3, [r7, #4]
2401f7be:	681b      	ldr	r3, [r3, #0]
2401f7c0:	4a1e      	ldr	r2, [pc, #120]	; (2401f83c <HAL_TIMEx_PWMN_Start+0x170>)
2401f7c2:	4293      	cmp	r3, r2
2401f7c4:	d00e      	beq.n	2401f7e4 <HAL_TIMEx_PWMN_Start+0x118>
2401f7c6:	687b      	ldr	r3, [r7, #4]
2401f7c8:	681b      	ldr	r3, [r3, #0]
2401f7ca:	4a1d      	ldr	r2, [pc, #116]	; (2401f840 <HAL_TIMEx_PWMN_Start+0x174>)
2401f7cc:	4293      	cmp	r3, r2
2401f7ce:	d009      	beq.n	2401f7e4 <HAL_TIMEx_PWMN_Start+0x118>
2401f7d0:	687b      	ldr	r3, [r7, #4]
2401f7d2:	681b      	ldr	r3, [r3, #0]
2401f7d4:	4a1b      	ldr	r2, [pc, #108]	; (2401f844 <HAL_TIMEx_PWMN_Start+0x178>)
2401f7d6:	4293      	cmp	r3, r2
2401f7d8:	d004      	beq.n	2401f7e4 <HAL_TIMEx_PWMN_Start+0x118>
2401f7da:	687b      	ldr	r3, [r7, #4]
2401f7dc:	681b      	ldr	r3, [r3, #0]
2401f7de:	4a1a      	ldr	r2, [pc, #104]	; (2401f848 <HAL_TIMEx_PWMN_Start+0x17c>)
2401f7e0:	4293      	cmp	r3, r2
2401f7e2:	d115      	bne.n	2401f810 <HAL_TIMEx_PWMN_Start+0x144>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401f7e4:	687b      	ldr	r3, [r7, #4]
2401f7e6:	681b      	ldr	r3, [r3, #0]
2401f7e8:	689a      	ldr	r2, [r3, #8]
2401f7ea:	4b18      	ldr	r3, [pc, #96]	; (2401f84c <HAL_TIMEx_PWMN_Start+0x180>)
2401f7ec:	4013      	ands	r3, r2
2401f7ee:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f7f0:	68fb      	ldr	r3, [r7, #12]
2401f7f2:	2b06      	cmp	r3, #6
2401f7f4:	d015      	beq.n	2401f822 <HAL_TIMEx_PWMN_Start+0x156>
2401f7f6:	68fb      	ldr	r3, [r7, #12]
2401f7f8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401f7fc:	d011      	beq.n	2401f822 <HAL_TIMEx_PWMN_Start+0x156>
    {
      __HAL_TIM_ENABLE(htim);
2401f7fe:	687b      	ldr	r3, [r7, #4]
2401f800:	681b      	ldr	r3, [r3, #0]
2401f802:	681a      	ldr	r2, [r3, #0]
2401f804:	687b      	ldr	r3, [r7, #4]
2401f806:	681b      	ldr	r3, [r3, #0]
2401f808:	f042 0201 	orr.w	r2, r2, #1
2401f80c:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f80e:	e008      	b.n	2401f822 <HAL_TIMEx_PWMN_Start+0x156>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
2401f810:	687b      	ldr	r3, [r7, #4]
2401f812:	681b      	ldr	r3, [r3, #0]
2401f814:	681a      	ldr	r2, [r3, #0]
2401f816:	687b      	ldr	r3, [r7, #4]
2401f818:	681b      	ldr	r3, [r3, #0]
2401f81a:	f042 0201 	orr.w	r2, r2, #1
2401f81e:	601a      	str	r2, [r3, #0]
2401f820:	e000      	b.n	2401f824 <HAL_TIMEx_PWMN_Start+0x158>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401f822:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
2401f824:	2300      	movs	r3, #0
}
2401f826:	4618      	mov	r0, r3
2401f828:	3710      	adds	r7, #16
2401f82a:	46bd      	mov	sp, r7
2401f82c:	bd80      	pop	{r7, pc}
2401f82e:	bf00      	nop
2401f830:	40010000 	.word	0x40010000
2401f834:	40000400 	.word	0x40000400
2401f838:	40000800 	.word	0x40000800
2401f83c:	40000c00 	.word	0x40000c00
2401f840:	40010400 	.word	0x40010400
2401f844:	40001800 	.word	0x40001800
2401f848:	40014000 	.word	0x40014000
2401f84c:	00010007 	.word	0x00010007

2401f850 <HAL_TIMEx_PWMN_Stop>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401f850:	b580      	push	{r7, lr}
2401f852:	b082      	sub	sp, #8
2401f854:	af00      	add	r7, sp, #0
2401f856:	6078      	str	r0, [r7, #4]
2401f858:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Disable the complementary PWM output  */
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2401f85a:	687b      	ldr	r3, [r7, #4]
2401f85c:	681b      	ldr	r3, [r3, #0]
2401f85e:	2200      	movs	r2, #0
2401f860:	6839      	ldr	r1, [r7, #0]
2401f862:	4618      	mov	r0, r3
2401f864:	f001 fa95 	bl	24020d92 <TIM_CCxNChannelCmd>

  /* Disable the Main Output */
  __HAL_TIM_MOE_DISABLE(htim);
2401f868:	687b      	ldr	r3, [r7, #4]
2401f86a:	681b      	ldr	r3, [r3, #0]
2401f86c:	6a1a      	ldr	r2, [r3, #32]
2401f86e:	f241 1311 	movw	r3, #4369	; 0x1111
2401f872:	4013      	ands	r3, r2
2401f874:	2b00      	cmp	r3, #0
2401f876:	d10f      	bne.n	2401f898 <HAL_TIMEx_PWMN_Stop+0x48>
2401f878:	687b      	ldr	r3, [r7, #4]
2401f87a:	681b      	ldr	r3, [r3, #0]
2401f87c:	6a1a      	ldr	r2, [r3, #32]
2401f87e:	f240 4344 	movw	r3, #1092	; 0x444
2401f882:	4013      	ands	r3, r2
2401f884:	2b00      	cmp	r3, #0
2401f886:	d107      	bne.n	2401f898 <HAL_TIMEx_PWMN_Stop+0x48>
2401f888:	687b      	ldr	r3, [r7, #4]
2401f88a:	681b      	ldr	r3, [r3, #0]
2401f88c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401f88e:	687b      	ldr	r3, [r7, #4]
2401f890:	681b      	ldr	r3, [r3, #0]
2401f892:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401f896:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2401f898:	687b      	ldr	r3, [r7, #4]
2401f89a:	681b      	ldr	r3, [r3, #0]
2401f89c:	6a1a      	ldr	r2, [r3, #32]
2401f89e:	f241 1311 	movw	r3, #4369	; 0x1111
2401f8a2:	4013      	ands	r3, r2
2401f8a4:	2b00      	cmp	r3, #0
2401f8a6:	d10f      	bne.n	2401f8c8 <HAL_TIMEx_PWMN_Stop+0x78>
2401f8a8:	687b      	ldr	r3, [r7, #4]
2401f8aa:	681b      	ldr	r3, [r3, #0]
2401f8ac:	6a1a      	ldr	r2, [r3, #32]
2401f8ae:	f240 4344 	movw	r3, #1092	; 0x444
2401f8b2:	4013      	ands	r3, r2
2401f8b4:	2b00      	cmp	r3, #0
2401f8b6:	d107      	bne.n	2401f8c8 <HAL_TIMEx_PWMN_Stop+0x78>
2401f8b8:	687b      	ldr	r3, [r7, #4]
2401f8ba:	681b      	ldr	r3, [r3, #0]
2401f8bc:	681a      	ldr	r2, [r3, #0]
2401f8be:	687b      	ldr	r3, [r7, #4]
2401f8c0:	681b      	ldr	r3, [r3, #0]
2401f8c2:	f022 0201 	bic.w	r2, r2, #1
2401f8c6:	601a      	str	r2, [r3, #0]

  /* Set the TIM complementary channel state */
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401f8c8:	683b      	ldr	r3, [r7, #0]
2401f8ca:	2b00      	cmp	r3, #0
2401f8cc:	d104      	bne.n	2401f8d8 <HAL_TIMEx_PWMN_Stop+0x88>
2401f8ce:	687b      	ldr	r3, [r7, #4]
2401f8d0:	2201      	movs	r2, #1
2401f8d2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401f8d6:	e013      	b.n	2401f900 <HAL_TIMEx_PWMN_Stop+0xb0>
2401f8d8:	683b      	ldr	r3, [r7, #0]
2401f8da:	2b04      	cmp	r3, #4
2401f8dc:	d104      	bne.n	2401f8e8 <HAL_TIMEx_PWMN_Stop+0x98>
2401f8de:	687b      	ldr	r3, [r7, #4]
2401f8e0:	2201      	movs	r2, #1
2401f8e2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401f8e6:	e00b      	b.n	2401f900 <HAL_TIMEx_PWMN_Stop+0xb0>
2401f8e8:	683b      	ldr	r3, [r7, #0]
2401f8ea:	2b08      	cmp	r3, #8
2401f8ec:	d104      	bne.n	2401f8f8 <HAL_TIMEx_PWMN_Stop+0xa8>
2401f8ee:	687b      	ldr	r3, [r7, #4]
2401f8f0:	2201      	movs	r2, #1
2401f8f2:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401f8f6:	e003      	b.n	2401f900 <HAL_TIMEx_PWMN_Stop+0xb0>
2401f8f8:	687b      	ldr	r3, [r7, #4]
2401f8fa:	2201      	movs	r2, #1
2401f8fc:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Return function status */
  return HAL_OK;
2401f900:	2300      	movs	r3, #0
}
2401f902:	4618      	mov	r0, r3
2401f904:	3708      	adds	r7, #8
2401f906:	46bd      	mov	sp, r7
2401f908:	bd80      	pop	{r7, pc}
	...

2401f90c <HAL_TIMEx_PWMN_Start_IT>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401f90c:	b580      	push	{r7, lr}
2401f90e:	b084      	sub	sp, #16
2401f910:	af00      	add	r7, sp, #0
2401f912:	6078      	str	r0, [r7, #4]
2401f914:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401f916:	2300      	movs	r3, #0
2401f918:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Check the TIM complementary channel state */
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
2401f91a:	683b      	ldr	r3, [r7, #0]
2401f91c:	2b00      	cmp	r3, #0
2401f91e:	d109      	bne.n	2401f934 <HAL_TIMEx_PWMN_Start_IT+0x28>
2401f920:	687b      	ldr	r3, [r7, #4]
2401f922:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401f926:	b2db      	uxtb	r3, r3
2401f928:	2b01      	cmp	r3, #1
2401f92a:	bf14      	ite	ne
2401f92c:	2301      	movne	r3, #1
2401f92e:	2300      	moveq	r3, #0
2401f930:	b2db      	uxtb	r3, r3
2401f932:	e022      	b.n	2401f97a <HAL_TIMEx_PWMN_Start_IT+0x6e>
2401f934:	683b      	ldr	r3, [r7, #0]
2401f936:	2b04      	cmp	r3, #4
2401f938:	d109      	bne.n	2401f94e <HAL_TIMEx_PWMN_Start_IT+0x42>
2401f93a:	687b      	ldr	r3, [r7, #4]
2401f93c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401f940:	b2db      	uxtb	r3, r3
2401f942:	2b01      	cmp	r3, #1
2401f944:	bf14      	ite	ne
2401f946:	2301      	movne	r3, #1
2401f948:	2300      	moveq	r3, #0
2401f94a:	b2db      	uxtb	r3, r3
2401f94c:	e015      	b.n	2401f97a <HAL_TIMEx_PWMN_Start_IT+0x6e>
2401f94e:	683b      	ldr	r3, [r7, #0]
2401f950:	2b08      	cmp	r3, #8
2401f952:	d109      	bne.n	2401f968 <HAL_TIMEx_PWMN_Start_IT+0x5c>
2401f954:	687b      	ldr	r3, [r7, #4]
2401f956:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401f95a:	b2db      	uxtb	r3, r3
2401f95c:	2b01      	cmp	r3, #1
2401f95e:	bf14      	ite	ne
2401f960:	2301      	movne	r3, #1
2401f962:	2300      	moveq	r3, #0
2401f964:	b2db      	uxtb	r3, r3
2401f966:	e008      	b.n	2401f97a <HAL_TIMEx_PWMN_Start_IT+0x6e>
2401f968:	687b      	ldr	r3, [r7, #4]
2401f96a:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401f96e:	b2db      	uxtb	r3, r3
2401f970:	2b01      	cmp	r3, #1
2401f972:	bf14      	ite	ne
2401f974:	2301      	movne	r3, #1
2401f976:	2300      	moveq	r3, #0
2401f978:	b2db      	uxtb	r3, r3
2401f97a:	2b00      	cmp	r3, #0
2401f97c:	d001      	beq.n	2401f982 <HAL_TIMEx_PWMN_Start_IT+0x76>
  {
    return HAL_ERROR;
2401f97e:	2301      	movs	r3, #1
2401f980:	e0a9      	b.n	2401fad6 <HAL_TIMEx_PWMN_Start_IT+0x1ca>
  }

  /* Set the TIM complementary channel state */
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401f982:	683b      	ldr	r3, [r7, #0]
2401f984:	2b00      	cmp	r3, #0
2401f986:	d104      	bne.n	2401f992 <HAL_TIMEx_PWMN_Start_IT+0x86>
2401f988:	687b      	ldr	r3, [r7, #4]
2401f98a:	2202      	movs	r2, #2
2401f98c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401f990:	e013      	b.n	2401f9ba <HAL_TIMEx_PWMN_Start_IT+0xae>
2401f992:	683b      	ldr	r3, [r7, #0]
2401f994:	2b04      	cmp	r3, #4
2401f996:	d104      	bne.n	2401f9a2 <HAL_TIMEx_PWMN_Start_IT+0x96>
2401f998:	687b      	ldr	r3, [r7, #4]
2401f99a:	2202      	movs	r2, #2
2401f99c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401f9a0:	e00b      	b.n	2401f9ba <HAL_TIMEx_PWMN_Start_IT+0xae>
2401f9a2:	683b      	ldr	r3, [r7, #0]
2401f9a4:	2b08      	cmp	r3, #8
2401f9a6:	d104      	bne.n	2401f9b2 <HAL_TIMEx_PWMN_Start_IT+0xa6>
2401f9a8:	687b      	ldr	r3, [r7, #4]
2401f9aa:	2202      	movs	r2, #2
2401f9ac:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401f9b0:	e003      	b.n	2401f9ba <HAL_TIMEx_PWMN_Start_IT+0xae>
2401f9b2:	687b      	ldr	r3, [r7, #4]
2401f9b4:	2202      	movs	r2, #2
2401f9b6:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  switch (Channel)
2401f9ba:	683b      	ldr	r3, [r7, #0]
2401f9bc:	2b08      	cmp	r3, #8
2401f9be:	d01b      	beq.n	2401f9f8 <HAL_TIMEx_PWMN_Start_IT+0xec>
2401f9c0:	683b      	ldr	r3, [r7, #0]
2401f9c2:	2b08      	cmp	r3, #8
2401f9c4:	d821      	bhi.n	2401fa0a <HAL_TIMEx_PWMN_Start_IT+0xfe>
2401f9c6:	683b      	ldr	r3, [r7, #0]
2401f9c8:	2b00      	cmp	r3, #0
2401f9ca:	d003      	beq.n	2401f9d4 <HAL_TIMEx_PWMN_Start_IT+0xc8>
2401f9cc:	683b      	ldr	r3, [r7, #0]
2401f9ce:	2b04      	cmp	r3, #4
2401f9d0:	d009      	beq.n	2401f9e6 <HAL_TIMEx_PWMN_Start_IT+0xda>
2401f9d2:	e01a      	b.n	2401fa0a <HAL_TIMEx_PWMN_Start_IT+0xfe>
  {
    case TIM_CHANNEL_1:
    {
      /* Enable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2401f9d4:	687b      	ldr	r3, [r7, #4]
2401f9d6:	681b      	ldr	r3, [r3, #0]
2401f9d8:	68da      	ldr	r2, [r3, #12]
2401f9da:	687b      	ldr	r3, [r7, #4]
2401f9dc:	681b      	ldr	r3, [r3, #0]
2401f9de:	f042 0202 	orr.w	r2, r2, #2
2401f9e2:	60da      	str	r2, [r3, #12]
      break;
2401f9e4:	e014      	b.n	2401fa10 <HAL_TIMEx_PWMN_Start_IT+0x104>
    }

    case TIM_CHANNEL_2:
    {
      /* Enable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2401f9e6:	687b      	ldr	r3, [r7, #4]
2401f9e8:	681b      	ldr	r3, [r3, #0]
2401f9ea:	68da      	ldr	r2, [r3, #12]
2401f9ec:	687b      	ldr	r3, [r7, #4]
2401f9ee:	681b      	ldr	r3, [r3, #0]
2401f9f0:	f042 0204 	orr.w	r2, r2, #4
2401f9f4:	60da      	str	r2, [r3, #12]
      break;
2401f9f6:	e00b      	b.n	2401fa10 <HAL_TIMEx_PWMN_Start_IT+0x104>
    }

    case TIM_CHANNEL_3:
    {
      /* Enable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
2401f9f8:	687b      	ldr	r3, [r7, #4]
2401f9fa:	681b      	ldr	r3, [r3, #0]
2401f9fc:	68da      	ldr	r2, [r3, #12]
2401f9fe:	687b      	ldr	r3, [r7, #4]
2401fa00:	681b      	ldr	r3, [r3, #0]
2401fa02:	f042 0208 	orr.w	r2, r2, #8
2401fa06:	60da      	str	r2, [r3, #12]
      break;
2401fa08:	e002      	b.n	2401fa10 <HAL_TIMEx_PWMN_Start_IT+0x104>
    }

    default:
      status = HAL_ERROR;
2401fa0a:	2301      	movs	r3, #1
2401fa0c:	73fb      	strb	r3, [r7, #15]
      break;
2401fa0e:	bf00      	nop
  }

  if (status == HAL_OK)
2401fa10:	7bfb      	ldrb	r3, [r7, #15]
2401fa12:	2b00      	cmp	r3, #0
2401fa14:	d15e      	bne.n	2401fad4 <HAL_TIMEx_PWMN_Start_IT+0x1c8>
  {
    /* Enable the TIM Break interrupt */
    __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
2401fa16:	687b      	ldr	r3, [r7, #4]
2401fa18:	681b      	ldr	r3, [r3, #0]
2401fa1a:	68da      	ldr	r2, [r3, #12]
2401fa1c:	687b      	ldr	r3, [r7, #4]
2401fa1e:	681b      	ldr	r3, [r3, #0]
2401fa20:	f042 0280 	orr.w	r2, r2, #128	; 0x80
2401fa24:	60da      	str	r2, [r3, #12]

    /* Enable the complementary PWM output  */
    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2401fa26:	687b      	ldr	r3, [r7, #4]
2401fa28:	681b      	ldr	r3, [r3, #0]
2401fa2a:	2204      	movs	r2, #4
2401fa2c:	6839      	ldr	r1, [r7, #0]
2401fa2e:	4618      	mov	r0, r3
2401fa30:	f001 f9af 	bl	24020d92 <TIM_CCxNChannelCmd>

    /* Enable the Main Output */
    __HAL_TIM_MOE_ENABLE(htim);
2401fa34:	687b      	ldr	r3, [r7, #4]
2401fa36:	681b      	ldr	r3, [r3, #0]
2401fa38:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401fa3a:	687b      	ldr	r3, [r7, #4]
2401fa3c:	681b      	ldr	r3, [r3, #0]
2401fa3e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401fa42:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401fa44:	687b      	ldr	r3, [r7, #4]
2401fa46:	681b      	ldr	r3, [r3, #0]
2401fa48:	4a25      	ldr	r2, [pc, #148]	; (2401fae0 <HAL_TIMEx_PWMN_Start_IT+0x1d4>)
2401fa4a:	4293      	cmp	r3, r2
2401fa4c:	d022      	beq.n	2401fa94 <HAL_TIMEx_PWMN_Start_IT+0x188>
2401fa4e:	687b      	ldr	r3, [r7, #4]
2401fa50:	681b      	ldr	r3, [r3, #0]
2401fa52:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401fa56:	d01d      	beq.n	2401fa94 <HAL_TIMEx_PWMN_Start_IT+0x188>
2401fa58:	687b      	ldr	r3, [r7, #4]
2401fa5a:	681b      	ldr	r3, [r3, #0]
2401fa5c:	4a21      	ldr	r2, [pc, #132]	; (2401fae4 <HAL_TIMEx_PWMN_Start_IT+0x1d8>)
2401fa5e:	4293      	cmp	r3, r2
2401fa60:	d018      	beq.n	2401fa94 <HAL_TIMEx_PWMN_Start_IT+0x188>
2401fa62:	687b      	ldr	r3, [r7, #4]
2401fa64:	681b      	ldr	r3, [r3, #0]
2401fa66:	4a20      	ldr	r2, [pc, #128]	; (2401fae8 <HAL_TIMEx_PWMN_Start_IT+0x1dc>)
2401fa68:	4293      	cmp	r3, r2
2401fa6a:	d013      	beq.n	2401fa94 <HAL_TIMEx_PWMN_Start_IT+0x188>
2401fa6c:	687b      	ldr	r3, [r7, #4]
2401fa6e:	681b      	ldr	r3, [r3, #0]
2401fa70:	4a1e      	ldr	r2, [pc, #120]	; (2401faec <HAL_TIMEx_PWMN_Start_IT+0x1e0>)
2401fa72:	4293      	cmp	r3, r2
2401fa74:	d00e      	beq.n	2401fa94 <HAL_TIMEx_PWMN_Start_IT+0x188>
2401fa76:	687b      	ldr	r3, [r7, #4]
2401fa78:	681b      	ldr	r3, [r3, #0]
2401fa7a:	4a1d      	ldr	r2, [pc, #116]	; (2401faf0 <HAL_TIMEx_PWMN_Start_IT+0x1e4>)
2401fa7c:	4293      	cmp	r3, r2
2401fa7e:	d009      	beq.n	2401fa94 <HAL_TIMEx_PWMN_Start_IT+0x188>
2401fa80:	687b      	ldr	r3, [r7, #4]
2401fa82:	681b      	ldr	r3, [r3, #0]
2401fa84:	4a1b      	ldr	r2, [pc, #108]	; (2401faf4 <HAL_TIMEx_PWMN_Start_IT+0x1e8>)
2401fa86:	4293      	cmp	r3, r2
2401fa88:	d004      	beq.n	2401fa94 <HAL_TIMEx_PWMN_Start_IT+0x188>
2401fa8a:	687b      	ldr	r3, [r7, #4]
2401fa8c:	681b      	ldr	r3, [r3, #0]
2401fa8e:	4a1a      	ldr	r2, [pc, #104]	; (2401faf8 <HAL_TIMEx_PWMN_Start_IT+0x1ec>)
2401fa90:	4293      	cmp	r3, r2
2401fa92:	d115      	bne.n	2401fac0 <HAL_TIMEx_PWMN_Start_IT+0x1b4>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401fa94:	687b      	ldr	r3, [r7, #4]
2401fa96:	681b      	ldr	r3, [r3, #0]
2401fa98:	689a      	ldr	r2, [r3, #8]
2401fa9a:	4b18      	ldr	r3, [pc, #96]	; (2401fafc <HAL_TIMEx_PWMN_Start_IT+0x1f0>)
2401fa9c:	4013      	ands	r3, r2
2401fa9e:	60bb      	str	r3, [r7, #8]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401faa0:	68bb      	ldr	r3, [r7, #8]
2401faa2:	2b06      	cmp	r3, #6
2401faa4:	d015      	beq.n	2401fad2 <HAL_TIMEx_PWMN_Start_IT+0x1c6>
2401faa6:	68bb      	ldr	r3, [r7, #8]
2401faa8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401faac:	d011      	beq.n	2401fad2 <HAL_TIMEx_PWMN_Start_IT+0x1c6>
      {
        __HAL_TIM_ENABLE(htim);
2401faae:	687b      	ldr	r3, [r7, #4]
2401fab0:	681b      	ldr	r3, [r3, #0]
2401fab2:	681a      	ldr	r2, [r3, #0]
2401fab4:	687b      	ldr	r3, [r7, #4]
2401fab6:	681b      	ldr	r3, [r3, #0]
2401fab8:	f042 0201 	orr.w	r2, r2, #1
2401fabc:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401fabe:	e008      	b.n	2401fad2 <HAL_TIMEx_PWMN_Start_IT+0x1c6>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
2401fac0:	687b      	ldr	r3, [r7, #4]
2401fac2:	681b      	ldr	r3, [r3, #0]
2401fac4:	681a      	ldr	r2, [r3, #0]
2401fac6:	687b      	ldr	r3, [r7, #4]
2401fac8:	681b      	ldr	r3, [r3, #0]
2401faca:	f042 0201 	orr.w	r2, r2, #1
2401face:	601a      	str	r2, [r3, #0]
2401fad0:	e000      	b.n	2401fad4 <HAL_TIMEx_PWMN_Start_IT+0x1c8>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401fad2:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
2401fad4:	7bfb      	ldrb	r3, [r7, #15]
}
2401fad6:	4618      	mov	r0, r3
2401fad8:	3710      	adds	r7, #16
2401fada:	46bd      	mov	sp, r7
2401fadc:	bd80      	pop	{r7, pc}
2401fade:	bf00      	nop
2401fae0:	40010000 	.word	0x40010000
2401fae4:	40000400 	.word	0x40000400
2401fae8:	40000800 	.word	0x40000800
2401faec:	40000c00 	.word	0x40000c00
2401faf0:	40010400 	.word	0x40010400
2401faf4:	40001800 	.word	0x40001800
2401faf8:	40014000 	.word	0x40014000
2401fafc:	00010007 	.word	0x00010007

2401fb00 <HAL_TIMEx_PWMN_Stop_IT>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401fb00:	b580      	push	{r7, lr}
2401fb02:	b084      	sub	sp, #16
2401fb04:	af00      	add	r7, sp, #0
2401fb06:	6078      	str	r0, [r7, #4]
2401fb08:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401fb0a:	2300      	movs	r3, #0
2401fb0c:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpccer;

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  switch (Channel)
2401fb0e:	683b      	ldr	r3, [r7, #0]
2401fb10:	2b08      	cmp	r3, #8
2401fb12:	d01b      	beq.n	2401fb4c <HAL_TIMEx_PWMN_Stop_IT+0x4c>
2401fb14:	683b      	ldr	r3, [r7, #0]
2401fb16:	2b08      	cmp	r3, #8
2401fb18:	d821      	bhi.n	2401fb5e <HAL_TIMEx_PWMN_Stop_IT+0x5e>
2401fb1a:	683b      	ldr	r3, [r7, #0]
2401fb1c:	2b00      	cmp	r3, #0
2401fb1e:	d003      	beq.n	2401fb28 <HAL_TIMEx_PWMN_Stop_IT+0x28>
2401fb20:	683b      	ldr	r3, [r7, #0]
2401fb22:	2b04      	cmp	r3, #4
2401fb24:	d009      	beq.n	2401fb3a <HAL_TIMEx_PWMN_Stop_IT+0x3a>
2401fb26:	e01a      	b.n	2401fb5e <HAL_TIMEx_PWMN_Stop_IT+0x5e>
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2401fb28:	687b      	ldr	r3, [r7, #4]
2401fb2a:	681b      	ldr	r3, [r3, #0]
2401fb2c:	68da      	ldr	r2, [r3, #12]
2401fb2e:	687b      	ldr	r3, [r7, #4]
2401fb30:	681b      	ldr	r3, [r3, #0]
2401fb32:	f022 0202 	bic.w	r2, r2, #2
2401fb36:	60da      	str	r2, [r3, #12]
      break;
2401fb38:	e014      	b.n	2401fb64 <HAL_TIMEx_PWMN_Stop_IT+0x64>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2401fb3a:	687b      	ldr	r3, [r7, #4]
2401fb3c:	681b      	ldr	r3, [r3, #0]
2401fb3e:	68da      	ldr	r2, [r3, #12]
2401fb40:	687b      	ldr	r3, [r7, #4]
2401fb42:	681b      	ldr	r3, [r3, #0]
2401fb44:	f022 0204 	bic.w	r2, r2, #4
2401fb48:	60da      	str	r2, [r3, #12]
      break;
2401fb4a:	e00b      	b.n	2401fb64 <HAL_TIMEx_PWMN_Stop_IT+0x64>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
2401fb4c:	687b      	ldr	r3, [r7, #4]
2401fb4e:	681b      	ldr	r3, [r3, #0]
2401fb50:	68da      	ldr	r2, [r3, #12]
2401fb52:	687b      	ldr	r3, [r7, #4]
2401fb54:	681b      	ldr	r3, [r3, #0]
2401fb56:	f022 0208 	bic.w	r2, r2, #8
2401fb5a:	60da      	str	r2, [r3, #12]
      break;
2401fb5c:	e002      	b.n	2401fb64 <HAL_TIMEx_PWMN_Stop_IT+0x64>
    }

    default:
      status = HAL_ERROR;
2401fb5e:	2301      	movs	r3, #1
2401fb60:	73fb      	strb	r3, [r7, #15]
      break;
2401fb62:	bf00      	nop
  }

  if (status == HAL_OK)
2401fb64:	7bfb      	ldrb	r3, [r7, #15]
2401fb66:	2b00      	cmp	r3, #0
2401fb68:	d164      	bne.n	2401fc34 <HAL_TIMEx_PWMN_Stop_IT+0x134>
  {
    /* Disable the complementary PWM output  */
    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2401fb6a:	687b      	ldr	r3, [r7, #4]
2401fb6c:	681b      	ldr	r3, [r3, #0]
2401fb6e:	2200      	movs	r2, #0
2401fb70:	6839      	ldr	r1, [r7, #0]
2401fb72:	4618      	mov	r0, r3
2401fb74:	f001 f90d 	bl	24020d92 <TIM_CCxNChannelCmd>

    /* Disable the TIM Break interrupt (only if no more channel is active) */
    tmpccer = htim->Instance->CCER;
2401fb78:	687b      	ldr	r3, [r7, #4]
2401fb7a:	681b      	ldr	r3, [r3, #0]
2401fb7c:	6a1b      	ldr	r3, [r3, #32]
2401fb7e:	60bb      	str	r3, [r7, #8]
    if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
2401fb80:	68ba      	ldr	r2, [r7, #8]
2401fb82:	f240 4344 	movw	r3, #1092	; 0x444
2401fb86:	4013      	ands	r3, r2
2401fb88:	2b00      	cmp	r3, #0
2401fb8a:	d107      	bne.n	2401fb9c <HAL_TIMEx_PWMN_Stop_IT+0x9c>
    {
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
2401fb8c:	687b      	ldr	r3, [r7, #4]
2401fb8e:	681b      	ldr	r3, [r3, #0]
2401fb90:	68da      	ldr	r2, [r3, #12]
2401fb92:	687b      	ldr	r3, [r7, #4]
2401fb94:	681b      	ldr	r3, [r3, #0]
2401fb96:	f022 0280 	bic.w	r2, r2, #128	; 0x80
2401fb9a:	60da      	str	r2, [r3, #12]
    }

    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
2401fb9c:	687b      	ldr	r3, [r7, #4]
2401fb9e:	681b      	ldr	r3, [r3, #0]
2401fba0:	6a1a      	ldr	r2, [r3, #32]
2401fba2:	f241 1311 	movw	r3, #4369	; 0x1111
2401fba6:	4013      	ands	r3, r2
2401fba8:	2b00      	cmp	r3, #0
2401fbaa:	d10f      	bne.n	2401fbcc <HAL_TIMEx_PWMN_Stop_IT+0xcc>
2401fbac:	687b      	ldr	r3, [r7, #4]
2401fbae:	681b      	ldr	r3, [r3, #0]
2401fbb0:	6a1a      	ldr	r2, [r3, #32]
2401fbb2:	f240 4344 	movw	r3, #1092	; 0x444
2401fbb6:	4013      	ands	r3, r2
2401fbb8:	2b00      	cmp	r3, #0
2401fbba:	d107      	bne.n	2401fbcc <HAL_TIMEx_PWMN_Stop_IT+0xcc>
2401fbbc:	687b      	ldr	r3, [r7, #4]
2401fbbe:	681b      	ldr	r3, [r3, #0]
2401fbc0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401fbc2:	687b      	ldr	r3, [r7, #4]
2401fbc4:	681b      	ldr	r3, [r3, #0]
2401fbc6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2401fbca:	645a      	str	r2, [r3, #68]	; 0x44

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
2401fbcc:	687b      	ldr	r3, [r7, #4]
2401fbce:	681b      	ldr	r3, [r3, #0]
2401fbd0:	6a1a      	ldr	r2, [r3, #32]
2401fbd2:	f241 1311 	movw	r3, #4369	; 0x1111
2401fbd6:	4013      	ands	r3, r2
2401fbd8:	2b00      	cmp	r3, #0
2401fbda:	d10f      	bne.n	2401fbfc <HAL_TIMEx_PWMN_Stop_IT+0xfc>
2401fbdc:	687b      	ldr	r3, [r7, #4]
2401fbde:	681b      	ldr	r3, [r3, #0]
2401fbe0:	6a1a      	ldr	r2, [r3, #32]
2401fbe2:	f240 4344 	movw	r3, #1092	; 0x444
2401fbe6:	4013      	ands	r3, r2
2401fbe8:	2b00      	cmp	r3, #0
2401fbea:	d107      	bne.n	2401fbfc <HAL_TIMEx_PWMN_Stop_IT+0xfc>
2401fbec:	687b      	ldr	r3, [r7, #4]
2401fbee:	681b      	ldr	r3, [r3, #0]
2401fbf0:	681a      	ldr	r2, [r3, #0]
2401fbf2:	687b      	ldr	r3, [r7, #4]
2401fbf4:	681b      	ldr	r3, [r3, #0]
2401fbf6:	f022 0201 	bic.w	r2, r2, #1
2401fbfa:	601a      	str	r2, [r3, #0]

    /* Set the TIM complementary channel state */
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
2401fbfc:	683b      	ldr	r3, [r7, #0]
2401fbfe:	2b00      	cmp	r3, #0
2401fc00:	d104      	bne.n	2401fc0c <HAL_TIMEx_PWMN_Stop_IT+0x10c>
2401fc02:	687b      	ldr	r3, [r7, #4]
2401fc04:	2201      	movs	r2, #1
2401fc06:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401fc0a:	e013      	b.n	2401fc34 <HAL_TIMEx_PWMN_Stop_IT+0x134>
2401fc0c:	683b      	ldr	r3, [r7, #0]
2401fc0e:	2b04      	cmp	r3, #4
2401fc10:	d104      	bne.n	2401fc1c <HAL_TIMEx_PWMN_Stop_IT+0x11c>
2401fc12:	687b      	ldr	r3, [r7, #4]
2401fc14:	2201      	movs	r2, #1
2401fc16:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401fc1a:	e00b      	b.n	2401fc34 <HAL_TIMEx_PWMN_Stop_IT+0x134>
2401fc1c:	683b      	ldr	r3, [r7, #0]
2401fc1e:	2b08      	cmp	r3, #8
2401fc20:	d104      	bne.n	2401fc2c <HAL_TIMEx_PWMN_Stop_IT+0x12c>
2401fc22:	687b      	ldr	r3, [r7, #4]
2401fc24:	2201      	movs	r2, #1
2401fc26:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401fc2a:	e003      	b.n	2401fc34 <HAL_TIMEx_PWMN_Stop_IT+0x134>
2401fc2c:	687b      	ldr	r3, [r7, #4]
2401fc2e:	2201      	movs	r2, #1
2401fc30:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  }

  /* Return function status */
  return status;
2401fc34:	7bfb      	ldrb	r3, [r7, #15]
}
2401fc36:	4618      	mov	r0, r3
2401fc38:	3710      	adds	r7, #16
2401fc3a:	46bd      	mov	sp, r7
2401fc3c:	bd80      	pop	{r7, pc}
	...

2401fc40 <HAL_TIMEx_PWMN_Start_DMA>:
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
                                           uint16_t Length)
{
2401fc40:	b580      	push	{r7, lr}
2401fc42:	b086      	sub	sp, #24
2401fc44:	af00      	add	r7, sp, #0
2401fc46:	60f8      	str	r0, [r7, #12]
2401fc48:	60b9      	str	r1, [r7, #8]
2401fc4a:	607a      	str	r2, [r7, #4]
2401fc4c:	807b      	strh	r3, [r7, #2]
  HAL_StatusTypeDef status = HAL_OK;
2401fc4e:	2300      	movs	r3, #0
2401fc50:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Set the TIM complementary channel state */
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
2401fc52:	68bb      	ldr	r3, [r7, #8]
2401fc54:	2b00      	cmp	r3, #0
2401fc56:	d109      	bne.n	2401fc6c <HAL_TIMEx_PWMN_Start_DMA+0x2c>
2401fc58:	68fb      	ldr	r3, [r7, #12]
2401fc5a:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401fc5e:	b2db      	uxtb	r3, r3
2401fc60:	2b02      	cmp	r3, #2
2401fc62:	bf0c      	ite	eq
2401fc64:	2301      	moveq	r3, #1
2401fc66:	2300      	movne	r3, #0
2401fc68:	b2db      	uxtb	r3, r3
2401fc6a:	e022      	b.n	2401fcb2 <HAL_TIMEx_PWMN_Start_DMA+0x72>
2401fc6c:	68bb      	ldr	r3, [r7, #8]
2401fc6e:	2b04      	cmp	r3, #4
2401fc70:	d109      	bne.n	2401fc86 <HAL_TIMEx_PWMN_Start_DMA+0x46>
2401fc72:	68fb      	ldr	r3, [r7, #12]
2401fc74:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401fc78:	b2db      	uxtb	r3, r3
2401fc7a:	2b02      	cmp	r3, #2
2401fc7c:	bf0c      	ite	eq
2401fc7e:	2301      	moveq	r3, #1
2401fc80:	2300      	movne	r3, #0
2401fc82:	b2db      	uxtb	r3, r3
2401fc84:	e015      	b.n	2401fcb2 <HAL_TIMEx_PWMN_Start_DMA+0x72>
2401fc86:	68bb      	ldr	r3, [r7, #8]
2401fc88:	2b08      	cmp	r3, #8
2401fc8a:	d109      	bne.n	2401fca0 <HAL_TIMEx_PWMN_Start_DMA+0x60>
2401fc8c:	68fb      	ldr	r3, [r7, #12]
2401fc8e:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401fc92:	b2db      	uxtb	r3, r3
2401fc94:	2b02      	cmp	r3, #2
2401fc96:	bf0c      	ite	eq
2401fc98:	2301      	moveq	r3, #1
2401fc9a:	2300      	movne	r3, #0
2401fc9c:	b2db      	uxtb	r3, r3
2401fc9e:	e008      	b.n	2401fcb2 <HAL_TIMEx_PWMN_Start_DMA+0x72>
2401fca0:	68fb      	ldr	r3, [r7, #12]
2401fca2:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401fca6:	b2db      	uxtb	r3, r3
2401fca8:	2b02      	cmp	r3, #2
2401fcaa:	bf0c      	ite	eq
2401fcac:	2301      	moveq	r3, #1
2401fcae:	2300      	movne	r3, #0
2401fcb0:	b2db      	uxtb	r3, r3
2401fcb2:	2b00      	cmp	r3, #0
2401fcb4:	d001      	beq.n	2401fcba <HAL_TIMEx_PWMN_Start_DMA+0x7a>
  {
    return HAL_BUSY;
2401fcb6:	2302      	movs	r3, #2
2401fcb8:	e12f      	b.n	2401ff1a <HAL_TIMEx_PWMN_Start_DMA+0x2da>
  }
  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
2401fcba:	68bb      	ldr	r3, [r7, #8]
2401fcbc:	2b00      	cmp	r3, #0
2401fcbe:	d109      	bne.n	2401fcd4 <HAL_TIMEx_PWMN_Start_DMA+0x94>
2401fcc0:	68fb      	ldr	r3, [r7, #12]
2401fcc2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2401fcc6:	b2db      	uxtb	r3, r3
2401fcc8:	2b01      	cmp	r3, #1
2401fcca:	bf0c      	ite	eq
2401fccc:	2301      	moveq	r3, #1
2401fcce:	2300      	movne	r3, #0
2401fcd0:	b2db      	uxtb	r3, r3
2401fcd2:	e022      	b.n	2401fd1a <HAL_TIMEx_PWMN_Start_DMA+0xda>
2401fcd4:	68bb      	ldr	r3, [r7, #8]
2401fcd6:	2b04      	cmp	r3, #4
2401fcd8:	d109      	bne.n	2401fcee <HAL_TIMEx_PWMN_Start_DMA+0xae>
2401fcda:	68fb      	ldr	r3, [r7, #12]
2401fcdc:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
2401fce0:	b2db      	uxtb	r3, r3
2401fce2:	2b01      	cmp	r3, #1
2401fce4:	bf0c      	ite	eq
2401fce6:	2301      	moveq	r3, #1
2401fce8:	2300      	movne	r3, #0
2401fcea:	b2db      	uxtb	r3, r3
2401fcec:	e015      	b.n	2401fd1a <HAL_TIMEx_PWMN_Start_DMA+0xda>
2401fcee:	68bb      	ldr	r3, [r7, #8]
2401fcf0:	2b08      	cmp	r3, #8
2401fcf2:	d109      	bne.n	2401fd08 <HAL_TIMEx_PWMN_Start_DMA+0xc8>
2401fcf4:	68fb      	ldr	r3, [r7, #12]
2401fcf6:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
2401fcfa:	b2db      	uxtb	r3, r3
2401fcfc:	2b01      	cmp	r3, #1
2401fcfe:	bf0c      	ite	eq
2401fd00:	2301      	moveq	r3, #1
2401fd02:	2300      	movne	r3, #0
2401fd04:	b2db      	uxtb	r3, r3
2401fd06:	e008      	b.n	2401fd1a <HAL_TIMEx_PWMN_Start_DMA+0xda>
2401fd08:	68fb      	ldr	r3, [r7, #12]
2401fd0a:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
2401fd0e:	b2db      	uxtb	r3, r3
2401fd10:	2b01      	cmp	r3, #1
2401fd12:	bf0c      	ite	eq
2401fd14:	2301      	moveq	r3, #1
2401fd16:	2300      	movne	r3, #0
2401fd18:	b2db      	uxtb	r3, r3
2401fd1a:	2b00      	cmp	r3, #0
2401fd1c:	d024      	beq.n	2401fd68 <HAL_TIMEx_PWMN_Start_DMA+0x128>
  {
    if ((pData == NULL) || (Length == 0U))
2401fd1e:	687b      	ldr	r3, [r7, #4]
2401fd20:	2b00      	cmp	r3, #0
2401fd22:	d002      	beq.n	2401fd2a <HAL_TIMEx_PWMN_Start_DMA+0xea>
2401fd24:	887b      	ldrh	r3, [r7, #2]
2401fd26:	2b00      	cmp	r3, #0
2401fd28:	d101      	bne.n	2401fd2e <HAL_TIMEx_PWMN_Start_DMA+0xee>
    {
      return HAL_ERROR;
2401fd2a:	2301      	movs	r3, #1
2401fd2c:	e0f5      	b.n	2401ff1a <HAL_TIMEx_PWMN_Start_DMA+0x2da>
    }
    else
    {
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
2401fd2e:	68bb      	ldr	r3, [r7, #8]
2401fd30:	2b00      	cmp	r3, #0
2401fd32:	d104      	bne.n	2401fd3e <HAL_TIMEx_PWMN_Start_DMA+0xfe>
2401fd34:	68fb      	ldr	r3, [r7, #12]
2401fd36:	2202      	movs	r2, #2
2401fd38:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
2401fd3c:	e016      	b.n	2401fd6c <HAL_TIMEx_PWMN_Start_DMA+0x12c>
2401fd3e:	68bb      	ldr	r3, [r7, #8]
2401fd40:	2b04      	cmp	r3, #4
2401fd42:	d104      	bne.n	2401fd4e <HAL_TIMEx_PWMN_Start_DMA+0x10e>
2401fd44:	68fb      	ldr	r3, [r7, #12]
2401fd46:	2202      	movs	r2, #2
2401fd48:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
2401fd4c:	e00e      	b.n	2401fd6c <HAL_TIMEx_PWMN_Start_DMA+0x12c>
2401fd4e:	68bb      	ldr	r3, [r7, #8]
2401fd50:	2b08      	cmp	r3, #8
2401fd52:	d104      	bne.n	2401fd5e <HAL_TIMEx_PWMN_Start_DMA+0x11e>
2401fd54:	68fb      	ldr	r3, [r7, #12]
2401fd56:	2202      	movs	r2, #2
2401fd58:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
2401fd5c:	e006      	b.n	2401fd6c <HAL_TIMEx_PWMN_Start_DMA+0x12c>
2401fd5e:	68fb      	ldr	r3, [r7, #12]
2401fd60:	2202      	movs	r2, #2
2401fd62:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
2401fd66:	e001      	b.n	2401fd6c <HAL_TIMEx_PWMN_Start_DMA+0x12c>
    }
  }
  else
  {
    return HAL_ERROR;
2401fd68:	2301      	movs	r3, #1
2401fd6a:	e0d6      	b.n	2401ff1a <HAL_TIMEx_PWMN_Start_DMA+0x2da>
  }

  switch (Channel)
2401fd6c:	68bb      	ldr	r3, [r7, #8]
2401fd6e:	2b08      	cmp	r3, #8
2401fd70:	d051      	beq.n	2401fe16 <HAL_TIMEx_PWMN_Start_DMA+0x1d6>
2401fd72:	68bb      	ldr	r3, [r7, #8]
2401fd74:	2b08      	cmp	r3, #8
2401fd76:	d872      	bhi.n	2401fe5e <HAL_TIMEx_PWMN_Start_DMA+0x21e>
2401fd78:	68bb      	ldr	r3, [r7, #8]
2401fd7a:	2b00      	cmp	r3, #0
2401fd7c:	d003      	beq.n	2401fd86 <HAL_TIMEx_PWMN_Start_DMA+0x146>
2401fd7e:	68bb      	ldr	r3, [r7, #8]
2401fd80:	2b04      	cmp	r3, #4
2401fd82:	d024      	beq.n	2401fdce <HAL_TIMEx_PWMN_Start_DMA+0x18e>
2401fd84:	e06b      	b.n	2401fe5e <HAL_TIMEx_PWMN_Start_DMA+0x21e>
  {
    case TIM_CHANNEL_1:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;
2401fd86:	68fb      	ldr	r3, [r7, #12]
2401fd88:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401fd8a:	4a66      	ldr	r2, [pc, #408]	; (2401ff24 <HAL_TIMEx_PWMN_Start_DMA+0x2e4>)
2401fd8c:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401fd8e:	68fb      	ldr	r3, [r7, #12]
2401fd90:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401fd92:	4a65      	ldr	r2, [pc, #404]	; (2401ff28 <HAL_TIMEx_PWMN_Start_DMA+0x2e8>)
2401fd94:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;
2401fd96:	68fb      	ldr	r3, [r7, #12]
2401fd98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401fd9a:	4a64      	ldr	r2, [pc, #400]	; (2401ff2c <HAL_TIMEx_PWMN_Start_DMA+0x2ec>)
2401fd9c:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
2401fd9e:	68fb      	ldr	r3, [r7, #12]
2401fda0:	6a58      	ldr	r0, [r3, #36]	; 0x24
2401fda2:	6879      	ldr	r1, [r7, #4]
2401fda4:	68fb      	ldr	r3, [r7, #12]
2401fda6:	681b      	ldr	r3, [r3, #0]
2401fda8:	3334      	adds	r3, #52	; 0x34
2401fdaa:	461a      	mov	r2, r3
2401fdac:	887b      	ldrh	r3, [r7, #2]
2401fdae:	f7e3 fecf 	bl	24003b50 <HAL_DMA_Start_IT>
2401fdb2:	4603      	mov	r3, r0
2401fdb4:	2b00      	cmp	r3, #0
2401fdb6:	d001      	beq.n	2401fdbc <HAL_TIMEx_PWMN_Start_DMA+0x17c>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401fdb8:	2301      	movs	r3, #1
2401fdba:	e0ae      	b.n	2401ff1a <HAL_TIMEx_PWMN_Start_DMA+0x2da>
      }
      /* Enable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2401fdbc:	68fb      	ldr	r3, [r7, #12]
2401fdbe:	681b      	ldr	r3, [r3, #0]
2401fdc0:	68da      	ldr	r2, [r3, #12]
2401fdc2:	68fb      	ldr	r3, [r7, #12]
2401fdc4:	681b      	ldr	r3, [r3, #0]
2401fdc6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2401fdca:	60da      	str	r2, [r3, #12]
      break;
2401fdcc:	e04a      	b.n	2401fe64 <HAL_TIMEx_PWMN_Start_DMA+0x224>
    }

    case TIM_CHANNEL_2:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;
2401fdce:	68fb      	ldr	r3, [r7, #12]
2401fdd0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401fdd2:	4a54      	ldr	r2, [pc, #336]	; (2401ff24 <HAL_TIMEx_PWMN_Start_DMA+0x2e4>)
2401fdd4:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401fdd6:	68fb      	ldr	r3, [r7, #12]
2401fdd8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401fdda:	4a53      	ldr	r2, [pc, #332]	; (2401ff28 <HAL_TIMEx_PWMN_Start_DMA+0x2e8>)
2401fddc:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;
2401fdde:	68fb      	ldr	r3, [r7, #12]
2401fde0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401fde2:	4a52      	ldr	r2, [pc, #328]	; (2401ff2c <HAL_TIMEx_PWMN_Start_DMA+0x2ec>)
2401fde4:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
2401fde6:	68fb      	ldr	r3, [r7, #12]
2401fde8:	6a98      	ldr	r0, [r3, #40]	; 0x28
2401fdea:	6879      	ldr	r1, [r7, #4]
2401fdec:	68fb      	ldr	r3, [r7, #12]
2401fdee:	681b      	ldr	r3, [r3, #0]
2401fdf0:	3338      	adds	r3, #56	; 0x38
2401fdf2:	461a      	mov	r2, r3
2401fdf4:	887b      	ldrh	r3, [r7, #2]
2401fdf6:	f7e3 feab 	bl	24003b50 <HAL_DMA_Start_IT>
2401fdfa:	4603      	mov	r3, r0
2401fdfc:	2b00      	cmp	r3, #0
2401fdfe:	d001      	beq.n	2401fe04 <HAL_TIMEx_PWMN_Start_DMA+0x1c4>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401fe00:	2301      	movs	r3, #1
2401fe02:	e08a      	b.n	2401ff1a <HAL_TIMEx_PWMN_Start_DMA+0x2da>
      }
      /* Enable the TIM Capture/Compare 2 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2401fe04:	68fb      	ldr	r3, [r7, #12]
2401fe06:	681b      	ldr	r3, [r3, #0]
2401fe08:	68da      	ldr	r2, [r3, #12]
2401fe0a:	68fb      	ldr	r3, [r7, #12]
2401fe0c:	681b      	ldr	r3, [r3, #0]
2401fe0e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
2401fe12:	60da      	str	r2, [r3, #12]
      break;
2401fe14:	e026      	b.n	2401fe64 <HAL_TIMEx_PWMN_Start_DMA+0x224>
    }

    case TIM_CHANNEL_3:
    {
      /* Set the DMA compare callbacks */
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;
2401fe16:	68fb      	ldr	r3, [r7, #12]
2401fe18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401fe1a:	4a42      	ldr	r2, [pc, #264]	; (2401ff24 <HAL_TIMEx_PWMN_Start_DMA+0x2e4>)
2401fe1c:	63da      	str	r2, [r3, #60]	; 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2401fe1e:	68fb      	ldr	r3, [r7, #12]
2401fe20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401fe22:	4a41      	ldr	r2, [pc, #260]	; (2401ff28 <HAL_TIMEx_PWMN_Start_DMA+0x2e8>)
2401fe24:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;
2401fe26:	68fb      	ldr	r3, [r7, #12]
2401fe28:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401fe2a:	4a40      	ldr	r2, [pc, #256]	; (2401ff2c <HAL_TIMEx_PWMN_Start_DMA+0x2ec>)
2401fe2c:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Enable the DMA stream */
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
2401fe2e:	68fb      	ldr	r3, [r7, #12]
2401fe30:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2401fe32:	6879      	ldr	r1, [r7, #4]
2401fe34:	68fb      	ldr	r3, [r7, #12]
2401fe36:	681b      	ldr	r3, [r3, #0]
2401fe38:	333c      	adds	r3, #60	; 0x3c
2401fe3a:	461a      	mov	r2, r3
2401fe3c:	887b      	ldrh	r3, [r7, #2]
2401fe3e:	f7e3 fe87 	bl	24003b50 <HAL_DMA_Start_IT>
2401fe42:	4603      	mov	r3, r0
2401fe44:	2b00      	cmp	r3, #0
2401fe46:	d001      	beq.n	2401fe4c <HAL_TIMEx_PWMN_Start_DMA+0x20c>
                           Length) != HAL_OK)
      {
        /* Return error status */
        return HAL_ERROR;
2401fe48:	2301      	movs	r3, #1
2401fe4a:	e066      	b.n	2401ff1a <HAL_TIMEx_PWMN_Start_DMA+0x2da>
      }
      /* Enable the TIM Capture/Compare 3 DMA request */
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
2401fe4c:	68fb      	ldr	r3, [r7, #12]
2401fe4e:	681b      	ldr	r3, [r3, #0]
2401fe50:	68da      	ldr	r2, [r3, #12]
2401fe52:	68fb      	ldr	r3, [r7, #12]
2401fe54:	681b      	ldr	r3, [r3, #0]
2401fe56:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
2401fe5a:	60da      	str	r2, [r3, #12]
      break;
2401fe5c:	e002      	b.n	2401fe64 <HAL_TIMEx_PWMN_Start_DMA+0x224>
    }

    default:
      status = HAL_ERROR;
2401fe5e:	2301      	movs	r3, #1
2401fe60:	75fb      	strb	r3, [r7, #23]
      break;
2401fe62:	bf00      	nop
  }

  if (status == HAL_OK)
2401fe64:	7dfb      	ldrb	r3, [r7, #23]
2401fe66:	2b00      	cmp	r3, #0
2401fe68:	d156      	bne.n	2401ff18 <HAL_TIMEx_PWMN_Start_DMA+0x2d8>
  {
    /* Enable the complementary PWM output  */
    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2401fe6a:	68fb      	ldr	r3, [r7, #12]
2401fe6c:	681b      	ldr	r3, [r3, #0]
2401fe6e:	2204      	movs	r2, #4
2401fe70:	68b9      	ldr	r1, [r7, #8]
2401fe72:	4618      	mov	r0, r3
2401fe74:	f000 ff8d 	bl	24020d92 <TIM_CCxNChannelCmd>

    /* Enable the Main Output */
    __HAL_TIM_MOE_ENABLE(htim);
2401fe78:	68fb      	ldr	r3, [r7, #12]
2401fe7a:	681b      	ldr	r3, [r3, #0]
2401fe7c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401fe7e:	68fb      	ldr	r3, [r7, #12]
2401fe80:	681b      	ldr	r3, [r3, #0]
2401fe82:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2401fe86:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2401fe88:	68fb      	ldr	r3, [r7, #12]
2401fe8a:	681b      	ldr	r3, [r3, #0]
2401fe8c:	4a28      	ldr	r2, [pc, #160]	; (2401ff30 <HAL_TIMEx_PWMN_Start_DMA+0x2f0>)
2401fe8e:	4293      	cmp	r3, r2
2401fe90:	d022      	beq.n	2401fed8 <HAL_TIMEx_PWMN_Start_DMA+0x298>
2401fe92:	68fb      	ldr	r3, [r7, #12]
2401fe94:	681b      	ldr	r3, [r3, #0]
2401fe96:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401fe9a:	d01d      	beq.n	2401fed8 <HAL_TIMEx_PWMN_Start_DMA+0x298>
2401fe9c:	68fb      	ldr	r3, [r7, #12]
2401fe9e:	681b      	ldr	r3, [r3, #0]
2401fea0:	4a24      	ldr	r2, [pc, #144]	; (2401ff34 <HAL_TIMEx_PWMN_Start_DMA+0x2f4>)
2401fea2:	4293      	cmp	r3, r2
2401fea4:	d018      	beq.n	2401fed8 <HAL_TIMEx_PWMN_Start_DMA+0x298>
2401fea6:	68fb      	ldr	r3, [r7, #12]
2401fea8:	681b      	ldr	r3, [r3, #0]
2401feaa:	4a23      	ldr	r2, [pc, #140]	; (2401ff38 <HAL_TIMEx_PWMN_Start_DMA+0x2f8>)
2401feac:	4293      	cmp	r3, r2
2401feae:	d013      	beq.n	2401fed8 <HAL_TIMEx_PWMN_Start_DMA+0x298>
2401feb0:	68fb      	ldr	r3, [r7, #12]
2401feb2:	681b      	ldr	r3, [r3, #0]
2401feb4:	4a21      	ldr	r2, [pc, #132]	; (2401ff3c <HAL_TIMEx_PWMN_Start_DMA+0x2fc>)
2401feb6:	4293      	cmp	r3, r2
2401feb8:	d00e      	beq.n	2401fed8 <HAL_TIMEx_PWMN_Start_DMA+0x298>
2401feba:	68fb      	ldr	r3, [r7, #12]
2401febc:	681b      	ldr	r3, [r3, #0]
2401febe:	4a20      	ldr	r2, [pc, #128]	; (2401ff40 <HAL_TIMEx_PWMN_Start_DMA+0x300>)
2401fec0:	4293      	cmp	r3, r2
2401fec2:	d009      	beq.n	2401fed8 <HAL_TIMEx_PWMN_Start_DMA+0x298>
2401fec4:	68fb      	ldr	r3, [r7, #12]
2401fec6:	681b      	ldr	r3, [r3, #0]
2401fec8:	4a1e      	ldr	r2, [pc, #120]	; (2401ff44 <HAL_TIMEx_PWMN_Start_DMA+0x304>)
2401feca:	4293      	cmp	r3, r2
2401fecc:	d004      	beq.n	2401fed8 <HAL_TIMEx_PWMN_Start_DMA+0x298>
2401fece:	68fb      	ldr	r3, [r7, #12]
2401fed0:	681b      	ldr	r3, [r3, #0]
2401fed2:	4a1d      	ldr	r2, [pc, #116]	; (2401ff48 <HAL_TIMEx_PWMN_Start_DMA+0x308>)
2401fed4:	4293      	cmp	r3, r2
2401fed6:	d115      	bne.n	2401ff04 <HAL_TIMEx_PWMN_Start_DMA+0x2c4>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2401fed8:	68fb      	ldr	r3, [r7, #12]
2401feda:	681b      	ldr	r3, [r3, #0]
2401fedc:	689a      	ldr	r2, [r3, #8]
2401fede:	4b1b      	ldr	r3, [pc, #108]	; (2401ff4c <HAL_TIMEx_PWMN_Start_DMA+0x30c>)
2401fee0:	4013      	ands	r3, r2
2401fee2:	613b      	str	r3, [r7, #16]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401fee4:	693b      	ldr	r3, [r7, #16]
2401fee6:	2b06      	cmp	r3, #6
2401fee8:	d015      	beq.n	2401ff16 <HAL_TIMEx_PWMN_Start_DMA+0x2d6>
2401feea:	693b      	ldr	r3, [r7, #16]
2401feec:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401fef0:	d011      	beq.n	2401ff16 <HAL_TIMEx_PWMN_Start_DMA+0x2d6>
      {
        __HAL_TIM_ENABLE(htim);
2401fef2:	68fb      	ldr	r3, [r7, #12]
2401fef4:	681b      	ldr	r3, [r3, #0]
2401fef6:	681a      	ldr	r2, [r3, #0]
2401fef8:	68fb      	ldr	r3, [r7, #12]
2401fefa:	681b      	ldr	r3, [r3, #0]
2401fefc:	f042 0201 	orr.w	r2, r2, #1
2401ff00:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ff02:	e008      	b.n	2401ff16 <HAL_TIMEx_PWMN_Start_DMA+0x2d6>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
2401ff04:	68fb      	ldr	r3, [r7, #12]
2401ff06:	681b      	ldr	r3, [r3, #0]
2401ff08:	681a      	ldr	r2, [r3, #0]
2401ff0a:	68fb      	ldr	r3, [r7, #12]
2401ff0c:	681b      	ldr	r3, [r3, #0]
2401ff0e:	f042 0201 	orr.w	r2, r2, #1
2401ff12:	601a      	str	r2, [r3, #0]
2401ff14:	e000      	b.n	2401ff18 <HAL_TIMEx_PWMN_Start_DMA+0x2d8>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2401ff16:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
2401ff18:	7dfb      	ldrb	r3, [r7, #23]
}
2401ff1a:	4618      	mov	r0, r3
2401ff1c:	3718      	adds	r7, #24
2401ff1e:	46bd      	mov	sp, r7
2401ff20:	bd80      	pop	{r7, pc}
2401ff22:	bf00      	nop
2401ff24:	24020c7d 	.word	0x24020c7d
2401ff28:	2401d6f9 	.word	0x2401d6f9
2401ff2c:	24020d25 	.word	0x24020d25
2401ff30:	40010000 	.word	0x40010000
2401ff34:	40000400 	.word	0x40000400
2401ff38:	40000800 	.word	0x40000800
2401ff3c:	40000c00 	.word	0x40000c00
2401ff40:	40010400 	.word	0x40010400
2401ff44:	40001800 	.word	0x40001800
2401ff48:	40014000 	.word	0x40014000
2401ff4c:	00010007 	.word	0x00010007

2401ff50 <HAL_TIMEx_PWMN_Stop_DMA>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
{
2401ff50:	b580      	push	{r7, lr}
2401ff52:	b084      	sub	sp, #16
2401ff54:	af00      	add	r7, sp, #0
2401ff56:	6078      	str	r0, [r7, #4]
2401ff58:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401ff5a:	2300      	movs	r3, #0
2401ff5c:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  switch (Channel)
2401ff5e:	683b      	ldr	r3, [r7, #0]
2401ff60:	2b08      	cmp	r3, #8
2401ff62:	d025      	beq.n	2401ffb0 <HAL_TIMEx_PWMN_Stop_DMA+0x60>
2401ff64:	683b      	ldr	r3, [r7, #0]
2401ff66:	2b08      	cmp	r3, #8
2401ff68:	d830      	bhi.n	2401ffcc <HAL_TIMEx_PWMN_Stop_DMA+0x7c>
2401ff6a:	683b      	ldr	r3, [r7, #0]
2401ff6c:	2b00      	cmp	r3, #0
2401ff6e:	d003      	beq.n	2401ff78 <HAL_TIMEx_PWMN_Stop_DMA+0x28>
2401ff70:	683b      	ldr	r3, [r7, #0]
2401ff72:	2b04      	cmp	r3, #4
2401ff74:	d00e      	beq.n	2401ff94 <HAL_TIMEx_PWMN_Stop_DMA+0x44>
2401ff76:	e029      	b.n	2401ffcc <HAL_TIMEx_PWMN_Stop_DMA+0x7c>
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2401ff78:	687b      	ldr	r3, [r7, #4]
2401ff7a:	681b      	ldr	r3, [r3, #0]
2401ff7c:	68da      	ldr	r2, [r3, #12]
2401ff7e:	687b      	ldr	r3, [r7, #4]
2401ff80:	681b      	ldr	r3, [r3, #0]
2401ff82:	f422 7200 	bic.w	r2, r2, #512	; 0x200
2401ff86:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2401ff88:	687b      	ldr	r3, [r7, #4]
2401ff8a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401ff8c:	4618      	mov	r0, r3
2401ff8e:	f7e4 fb67 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401ff92:	e01e      	b.n	2401ffd2 <HAL_TIMEx_PWMN_Stop_DMA+0x82>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2401ff94:	687b      	ldr	r3, [r7, #4]
2401ff96:	681b      	ldr	r3, [r3, #0]
2401ff98:	68da      	ldr	r2, [r3, #12]
2401ff9a:	687b      	ldr	r3, [r7, #4]
2401ff9c:	681b      	ldr	r3, [r3, #0]
2401ff9e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2401ffa2:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2401ffa4:	687b      	ldr	r3, [r7, #4]
2401ffa6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401ffa8:	4618      	mov	r0, r3
2401ffaa:	f7e4 fb59 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401ffae:	e010      	b.n	2401ffd2 <HAL_TIMEx_PWMN_Stop_DMA+0x82>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 DMA request */
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2401ffb0:	687b      	ldr	r3, [r7, #4]
2401ffb2:	681b      	ldr	r3, [r3, #0]
2401ffb4:	68da      	ldr	r2, [r3, #12]
2401ffb6:	687b      	ldr	r3, [r7, #4]
2401ffb8:	681b      	ldr	r3, [r3, #0]
2401ffba:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
2401ffbe:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2401ffc0:	687b      	ldr	r3, [r7, #4]
2401ffc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401ffc4:	4618      	mov	r0, r3
2401ffc6:	f7e4 fb4b 	bl	24004660 <HAL_DMA_Abort_IT>
      break;
2401ffca:	e002      	b.n	2401ffd2 <HAL_TIMEx_PWMN_Stop_DMA+0x82>
    }

    default:
      status = HAL_ERROR;
2401ffcc:	2301      	movs	r3, #1
2401ffce:	73fb      	strb	r3, [r7, #15]
      break;
2401ffd0:	bf00      	nop
  }

  if (status == HAL_OK)
2401ffd2:	7bfb      	ldrb	r3, [r7, #15]
2401ffd4:	2b00      	cmp	r3, #0
2401ffd6:	d152      	bne.n	2402007e <HAL_TIMEx_PWMN_Stop_DMA+0x12e>
  {
    /* Disable the complementary PWM output */
    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2401ffd8:	687b      	ldr	r3, [r7, #4]
2401ffda:	681b      	ldr	r3, [r3, #0]
2401ffdc:	2200      	movs	r2, #0
2401ffde:	6839      	ldr	r1, [r7, #0]
2401ffe0:	4618      	mov	r0, r3
2401ffe2:	f000 fed6 	bl	24020d92 <TIM_CCxNChannelCmd>

    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
2401ffe6:	687b      	ldr	r3, [r7, #4]
2401ffe8:	681b      	ldr	r3, [r3, #0]
2401ffea:	6a1a      	ldr	r2, [r3, #32]
2401ffec:	f241 1311 	movw	r3, #4369	; 0x1111
2401fff0:	4013      	ands	r3, r2
2401fff2:	2b00      	cmp	r3, #0
2401fff4:	d10f      	bne.n	24020016 <HAL_TIMEx_PWMN_Stop_DMA+0xc6>
2401fff6:	687b      	ldr	r3, [r7, #4]
2401fff8:	681b      	ldr	r3, [r3, #0]
2401fffa:	6a1a      	ldr	r2, [r3, #32]
2401fffc:	f240 4344 	movw	r3, #1092	; 0x444
24020000:	4013      	ands	r3, r2
24020002:	2b00      	cmp	r3, #0
24020004:	d107      	bne.n	24020016 <HAL_TIMEx_PWMN_Stop_DMA+0xc6>
24020006:	687b      	ldr	r3, [r7, #4]
24020008:	681b      	ldr	r3, [r3, #0]
2402000a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2402000c:	687b      	ldr	r3, [r7, #4]
2402000e:	681b      	ldr	r3, [r3, #0]
24020010:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24020014:	645a      	str	r2, [r3, #68]	; 0x44

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
24020016:	687b      	ldr	r3, [r7, #4]
24020018:	681b      	ldr	r3, [r3, #0]
2402001a:	6a1a      	ldr	r2, [r3, #32]
2402001c:	f241 1311 	movw	r3, #4369	; 0x1111
24020020:	4013      	ands	r3, r2
24020022:	2b00      	cmp	r3, #0
24020024:	d10f      	bne.n	24020046 <HAL_TIMEx_PWMN_Stop_DMA+0xf6>
24020026:	687b      	ldr	r3, [r7, #4]
24020028:	681b      	ldr	r3, [r3, #0]
2402002a:	6a1a      	ldr	r2, [r3, #32]
2402002c:	f240 4344 	movw	r3, #1092	; 0x444
24020030:	4013      	ands	r3, r2
24020032:	2b00      	cmp	r3, #0
24020034:	d107      	bne.n	24020046 <HAL_TIMEx_PWMN_Stop_DMA+0xf6>
24020036:	687b      	ldr	r3, [r7, #4]
24020038:	681b      	ldr	r3, [r3, #0]
2402003a:	681a      	ldr	r2, [r3, #0]
2402003c:	687b      	ldr	r3, [r7, #4]
2402003e:	681b      	ldr	r3, [r3, #0]
24020040:	f022 0201 	bic.w	r2, r2, #1
24020044:	601a      	str	r2, [r3, #0]

    /* Set the TIM complementary channel state */
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
24020046:	683b      	ldr	r3, [r7, #0]
24020048:	2b00      	cmp	r3, #0
2402004a:	d104      	bne.n	24020056 <HAL_TIMEx_PWMN_Stop_DMA+0x106>
2402004c:	687b      	ldr	r3, [r7, #4]
2402004e:	2201      	movs	r2, #1
24020050:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24020054:	e013      	b.n	2402007e <HAL_TIMEx_PWMN_Stop_DMA+0x12e>
24020056:	683b      	ldr	r3, [r7, #0]
24020058:	2b04      	cmp	r3, #4
2402005a:	d104      	bne.n	24020066 <HAL_TIMEx_PWMN_Stop_DMA+0x116>
2402005c:	687b      	ldr	r3, [r7, #4]
2402005e:	2201      	movs	r2, #1
24020060:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24020064:	e00b      	b.n	2402007e <HAL_TIMEx_PWMN_Stop_DMA+0x12e>
24020066:	683b      	ldr	r3, [r7, #0]
24020068:	2b08      	cmp	r3, #8
2402006a:	d104      	bne.n	24020076 <HAL_TIMEx_PWMN_Stop_DMA+0x126>
2402006c:	687b      	ldr	r3, [r7, #4]
2402006e:	2201      	movs	r2, #1
24020070:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
24020074:	e003      	b.n	2402007e <HAL_TIMEx_PWMN_Stop_DMA+0x12e>
24020076:	687b      	ldr	r3, [r7, #4]
24020078:	2201      	movs	r2, #1
2402007a:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  }

  /* Return function status */
  return status;
2402007e:	7bfb      	ldrb	r3, [r7, #15]
}
24020080:	4618      	mov	r0, r3
24020082:	3710      	adds	r7, #16
24020084:	46bd      	mov	sp, r7
24020086:	bd80      	pop	{r7, pc}

24020088 <HAL_TIMEx_OnePulseN_Start>:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
24020088:	b580      	push	{r7, lr}
2402008a:	b084      	sub	sp, #16
2402008c:	af00      	add	r7, sp, #0
2402008e:	6078      	str	r0, [r7, #4]
24020090:	6039      	str	r1, [r7, #0]
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
24020092:	683b      	ldr	r3, [r7, #0]
24020094:	2b00      	cmp	r3, #0
24020096:	d101      	bne.n	2402009c <HAL_TIMEx_OnePulseN_Start+0x14>
24020098:	2304      	movs	r3, #4
2402009a:	e000      	b.n	2402009e <HAL_TIMEx_OnePulseN_Start+0x16>
2402009c:	2300      	movs	r3, #0
2402009e:	60fb      	str	r3, [r7, #12]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
240200a0:	687b      	ldr	r3, [r7, #4]
240200a2:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
240200a6:	72fb      	strb	r3, [r7, #11]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
240200a8:	687b      	ldr	r3, [r7, #4]
240200aa:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
240200ae:	72bb      	strb	r3, [r7, #10]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
240200b0:	687b      	ldr	r3, [r7, #4]
240200b2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
240200b6:	727b      	strb	r3, [r7, #9]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
240200b8:	687b      	ldr	r3, [r7, #4]
240200ba:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
240200be:	723b      	strb	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));

  /* Check the TIM channels state */
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
240200c0:	7afb      	ldrb	r3, [r7, #11]
240200c2:	2b01      	cmp	r3, #1
240200c4:	d108      	bne.n	240200d8 <HAL_TIMEx_OnePulseN_Start+0x50>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
240200c6:	7abb      	ldrb	r3, [r7, #10]
240200c8:	2b01      	cmp	r3, #1
240200ca:	d105      	bne.n	240200d8 <HAL_TIMEx_OnePulseN_Start+0x50>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
240200cc:	7a7b      	ldrb	r3, [r7, #9]
240200ce:	2b01      	cmp	r3, #1
240200d0:	d102      	bne.n	240200d8 <HAL_TIMEx_OnePulseN_Start+0x50>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
240200d2:	7a3b      	ldrb	r3, [r7, #8]
240200d4:	2b01      	cmp	r3, #1
240200d6:	d001      	beq.n	240200dc <HAL_TIMEx_OnePulseN_Start+0x54>
  {
    return HAL_ERROR;
240200d8:	2301      	movs	r3, #1
240200da:	e026      	b.n	2402012a <HAL_TIMEx_OnePulseN_Start+0xa2>
  }

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
240200dc:	687b      	ldr	r3, [r7, #4]
240200de:	2202      	movs	r2, #2
240200e0:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
240200e4:	687b      	ldr	r3, [r7, #4]
240200e6:	2202      	movs	r2, #2
240200e8:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
240200ec:	687b      	ldr	r3, [r7, #4]
240200ee:	2202      	movs	r2, #2
240200f0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
240200f4:	687b      	ldr	r3, [r7, #4]
240200f6:	2202      	movs	r2, #2
240200f8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Enable the complementary One Pulse output channel and the Input Capture channel */
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
240200fc:	687b      	ldr	r3, [r7, #4]
240200fe:	681b      	ldr	r3, [r3, #0]
24020100:	2204      	movs	r2, #4
24020102:	6839      	ldr	r1, [r7, #0]
24020104:	4618      	mov	r0, r3
24020106:	f000 fe44 	bl	24020d92 <TIM_CCxNChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);
2402010a:	687b      	ldr	r3, [r7, #4]
2402010c:	681b      	ldr	r3, [r3, #0]
2402010e:	2201      	movs	r2, #1
24020110:	68f9      	ldr	r1, [r7, #12]
24020112:	4618      	mov	r0, r3
24020114:	f7fe fa28 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Enable the Main Output */
  __HAL_TIM_MOE_ENABLE(htim);
24020118:	687b      	ldr	r3, [r7, #4]
2402011a:	681b      	ldr	r3, [r3, #0]
2402011c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2402011e:	687b      	ldr	r3, [r7, #4]
24020120:	681b      	ldr	r3, [r3, #0]
24020122:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24020126:	645a      	str	r2, [r3, #68]	; 0x44

  /* Return function status */
  return HAL_OK;
24020128:	2300      	movs	r3, #0
}
2402012a:	4618      	mov	r0, r3
2402012c:	3710      	adds	r7, #16
2402012e:	46bd      	mov	sp, r7
24020130:	bd80      	pop	{r7, pc}

24020132 <HAL_TIMEx_OnePulseN_Stop>:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
24020132:	b580      	push	{r7, lr}
24020134:	b084      	sub	sp, #16
24020136:	af00      	add	r7, sp, #0
24020138:	6078      	str	r0, [r7, #4]
2402013a:	6039      	str	r1, [r7, #0]
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
2402013c:	683b      	ldr	r3, [r7, #0]
2402013e:	2b00      	cmp	r3, #0
24020140:	d101      	bne.n	24020146 <HAL_TIMEx_OnePulseN_Stop+0x14>
24020142:	2304      	movs	r3, #4
24020144:	e000      	b.n	24020148 <HAL_TIMEx_OnePulseN_Stop+0x16>
24020146:	2300      	movs	r3, #0
24020148:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));

  /* Disable the complementary One Pulse output channel and the Input Capture channel */
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
2402014a:	687b      	ldr	r3, [r7, #4]
2402014c:	681b      	ldr	r3, [r3, #0]
2402014e:	2200      	movs	r2, #0
24020150:	6839      	ldr	r1, [r7, #0]
24020152:	4618      	mov	r0, r3
24020154:	f000 fe1d 	bl	24020d92 <TIM_CCxNChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);
24020158:	687b      	ldr	r3, [r7, #4]
2402015a:	681b      	ldr	r3, [r3, #0]
2402015c:	2200      	movs	r2, #0
2402015e:	68f9      	ldr	r1, [r7, #12]
24020160:	4618      	mov	r0, r3
24020162:	f7fe fa01 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Disable the Main Output */
  __HAL_TIM_MOE_DISABLE(htim);
24020166:	687b      	ldr	r3, [r7, #4]
24020168:	681b      	ldr	r3, [r3, #0]
2402016a:	6a1a      	ldr	r2, [r3, #32]
2402016c:	f241 1311 	movw	r3, #4369	; 0x1111
24020170:	4013      	ands	r3, r2
24020172:	2b00      	cmp	r3, #0
24020174:	d10f      	bne.n	24020196 <HAL_TIMEx_OnePulseN_Stop+0x64>
24020176:	687b      	ldr	r3, [r7, #4]
24020178:	681b      	ldr	r3, [r3, #0]
2402017a:	6a1a      	ldr	r2, [r3, #32]
2402017c:	f240 4344 	movw	r3, #1092	; 0x444
24020180:	4013      	ands	r3, r2
24020182:	2b00      	cmp	r3, #0
24020184:	d107      	bne.n	24020196 <HAL_TIMEx_OnePulseN_Stop+0x64>
24020186:	687b      	ldr	r3, [r7, #4]
24020188:	681b      	ldr	r3, [r3, #0]
2402018a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2402018c:	687b      	ldr	r3, [r7, #4]
2402018e:	681b      	ldr	r3, [r3, #0]
24020190:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24020194:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
24020196:	687b      	ldr	r3, [r7, #4]
24020198:	681b      	ldr	r3, [r3, #0]
2402019a:	6a1a      	ldr	r2, [r3, #32]
2402019c:	f241 1311 	movw	r3, #4369	; 0x1111
240201a0:	4013      	ands	r3, r2
240201a2:	2b00      	cmp	r3, #0
240201a4:	d10f      	bne.n	240201c6 <HAL_TIMEx_OnePulseN_Stop+0x94>
240201a6:	687b      	ldr	r3, [r7, #4]
240201a8:	681b      	ldr	r3, [r3, #0]
240201aa:	6a1a      	ldr	r2, [r3, #32]
240201ac:	f240 4344 	movw	r3, #1092	; 0x444
240201b0:	4013      	ands	r3, r2
240201b2:	2b00      	cmp	r3, #0
240201b4:	d107      	bne.n	240201c6 <HAL_TIMEx_OnePulseN_Stop+0x94>
240201b6:	687b      	ldr	r3, [r7, #4]
240201b8:	681b      	ldr	r3, [r3, #0]
240201ba:	681a      	ldr	r2, [r3, #0]
240201bc:	687b      	ldr	r3, [r7, #4]
240201be:	681b      	ldr	r3, [r3, #0]
240201c0:	f022 0201 	bic.w	r2, r2, #1
240201c4:	601a      	str	r2, [r3, #0]

  /* Set the TIM  channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
240201c6:	687b      	ldr	r3, [r7, #4]
240201c8:	2201      	movs	r2, #1
240201ca:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
240201ce:	687b      	ldr	r3, [r7, #4]
240201d0:	2201      	movs	r2, #1
240201d2:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
240201d6:	687b      	ldr	r3, [r7, #4]
240201d8:	2201      	movs	r2, #1
240201da:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
240201de:	687b      	ldr	r3, [r7, #4]
240201e0:	2201      	movs	r2, #1
240201e2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Return function status */
  return HAL_OK;
240201e6:	2300      	movs	r3, #0
}
240201e8:	4618      	mov	r0, r3
240201ea:	3710      	adds	r7, #16
240201ec:	46bd      	mov	sp, r7
240201ee:	bd80      	pop	{r7, pc}

240201f0 <HAL_TIMEx_OnePulseN_Start_IT>:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
240201f0:	b580      	push	{r7, lr}
240201f2:	b084      	sub	sp, #16
240201f4:	af00      	add	r7, sp, #0
240201f6:	6078      	str	r0, [r7, #4]
240201f8:	6039      	str	r1, [r7, #0]
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
240201fa:	683b      	ldr	r3, [r7, #0]
240201fc:	2b00      	cmp	r3, #0
240201fe:	d101      	bne.n	24020204 <HAL_TIMEx_OnePulseN_Start_IT+0x14>
24020200:	2304      	movs	r3, #4
24020202:	e000      	b.n	24020206 <HAL_TIMEx_OnePulseN_Start_IT+0x16>
24020204:	2300      	movs	r3, #0
24020206:	60fb      	str	r3, [r7, #12]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
24020208:	687b      	ldr	r3, [r7, #4]
2402020a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
2402020e:	72fb      	strb	r3, [r7, #11]
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
24020210:	687b      	ldr	r3, [r7, #4]
24020212:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
24020216:	72bb      	strb	r3, [r7, #10]
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
24020218:	687b      	ldr	r3, [r7, #4]
2402021a:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
2402021e:	727b      	strb	r3, [r7, #9]
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
24020220:	687b      	ldr	r3, [r7, #4]
24020222:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
24020226:	723b      	strb	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));

  /* Check the TIM channels state */
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
24020228:	7afb      	ldrb	r3, [r7, #11]
2402022a:	2b01      	cmp	r3, #1
2402022c:	d108      	bne.n	24020240 <HAL_TIMEx_OnePulseN_Start_IT+0x50>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
2402022e:	7abb      	ldrb	r3, [r7, #10]
24020230:	2b01      	cmp	r3, #1
24020232:	d105      	bne.n	24020240 <HAL_TIMEx_OnePulseN_Start_IT+0x50>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
24020234:	7a7b      	ldrb	r3, [r7, #9]
24020236:	2b01      	cmp	r3, #1
24020238:	d102      	bne.n	24020240 <HAL_TIMEx_OnePulseN_Start_IT+0x50>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
2402023a:	7a3b      	ldrb	r3, [r7, #8]
2402023c:	2b01      	cmp	r3, #1
2402023e:	d001      	beq.n	24020244 <HAL_TIMEx_OnePulseN_Start_IT+0x54>
  {
    return HAL_ERROR;
24020240:	2301      	movs	r3, #1
24020242:	e036      	b.n	240202b2 <HAL_TIMEx_OnePulseN_Start_IT+0xc2>
  }

  /* Set the TIM channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
24020244:	687b      	ldr	r3, [r7, #4]
24020246:	2202      	movs	r2, #2
24020248:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2402024c:	687b      	ldr	r3, [r7, #4]
2402024e:	2202      	movs	r2, #2
24020250:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
24020254:	687b      	ldr	r3, [r7, #4]
24020256:	2202      	movs	r2, #2
24020258:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
2402025c:	687b      	ldr	r3, [r7, #4]
2402025e:	2202      	movs	r2, #2
24020260:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Enable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
24020264:	687b      	ldr	r3, [r7, #4]
24020266:	681b      	ldr	r3, [r3, #0]
24020268:	68da      	ldr	r2, [r3, #12]
2402026a:	687b      	ldr	r3, [r7, #4]
2402026c:	681b      	ldr	r3, [r3, #0]
2402026e:	f042 0202 	orr.w	r2, r2, #2
24020272:	60da      	str	r2, [r3, #12]

  /* Enable the TIM Capture/Compare 2 interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
24020274:	687b      	ldr	r3, [r7, #4]
24020276:	681b      	ldr	r3, [r3, #0]
24020278:	68da      	ldr	r2, [r3, #12]
2402027a:	687b      	ldr	r3, [r7, #4]
2402027c:	681b      	ldr	r3, [r3, #0]
2402027e:	f042 0204 	orr.w	r2, r2, #4
24020282:	60da      	str	r2, [r3, #12]

  /* Enable the complementary One Pulse output channel and the Input Capture channel */
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
24020284:	687b      	ldr	r3, [r7, #4]
24020286:	681b      	ldr	r3, [r3, #0]
24020288:	2204      	movs	r2, #4
2402028a:	6839      	ldr	r1, [r7, #0]
2402028c:	4618      	mov	r0, r3
2402028e:	f000 fd80 	bl	24020d92 <TIM_CCxNChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);
24020292:	687b      	ldr	r3, [r7, #4]
24020294:	681b      	ldr	r3, [r3, #0]
24020296:	2201      	movs	r2, #1
24020298:	68f9      	ldr	r1, [r7, #12]
2402029a:	4618      	mov	r0, r3
2402029c:	f7fe f964 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Enable the Main Output */
  __HAL_TIM_MOE_ENABLE(htim);
240202a0:	687b      	ldr	r3, [r7, #4]
240202a2:	681b      	ldr	r3, [r3, #0]
240202a4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
240202a6:	687b      	ldr	r3, [r7, #4]
240202a8:	681b      	ldr	r3, [r3, #0]
240202aa:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
240202ae:	645a      	str	r2, [r3, #68]	; 0x44

  /* Return function status */
  return HAL_OK;
240202b0:	2300      	movs	r3, #0
}
240202b2:	4618      	mov	r0, r3
240202b4:	3710      	adds	r7, #16
240202b6:	46bd      	mov	sp, r7
240202b8:	bd80      	pop	{r7, pc}

240202ba <HAL_TIMEx_OnePulseN_Stop_IT>:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
240202ba:	b580      	push	{r7, lr}
240202bc:	b084      	sub	sp, #16
240202be:	af00      	add	r7, sp, #0
240202c0:	6078      	str	r0, [r7, #4]
240202c2:	6039      	str	r1, [r7, #0]
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
240202c4:	683b      	ldr	r3, [r7, #0]
240202c6:	2b00      	cmp	r3, #0
240202c8:	d101      	bne.n	240202ce <HAL_TIMEx_OnePulseN_Stop_IT+0x14>
240202ca:	2304      	movs	r3, #4
240202cc:	e000      	b.n	240202d0 <HAL_TIMEx_OnePulseN_Stop_IT+0x16>
240202ce:	2300      	movs	r3, #0
240202d0:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));

  /* Disable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
240202d2:	687b      	ldr	r3, [r7, #4]
240202d4:	681b      	ldr	r3, [r3, #0]
240202d6:	68da      	ldr	r2, [r3, #12]
240202d8:	687b      	ldr	r3, [r7, #4]
240202da:	681b      	ldr	r3, [r3, #0]
240202dc:	f022 0202 	bic.w	r2, r2, #2
240202e0:	60da      	str	r2, [r3, #12]

  /* Disable the TIM Capture/Compare 2 interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
240202e2:	687b      	ldr	r3, [r7, #4]
240202e4:	681b      	ldr	r3, [r3, #0]
240202e6:	68da      	ldr	r2, [r3, #12]
240202e8:	687b      	ldr	r3, [r7, #4]
240202ea:	681b      	ldr	r3, [r3, #0]
240202ec:	f022 0204 	bic.w	r2, r2, #4
240202f0:	60da      	str	r2, [r3, #12]

  /* Disable the complementary One Pulse output channel and the Input Capture channel */
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
240202f2:	687b      	ldr	r3, [r7, #4]
240202f4:	681b      	ldr	r3, [r3, #0]
240202f6:	2200      	movs	r2, #0
240202f8:	6839      	ldr	r1, [r7, #0]
240202fa:	4618      	mov	r0, r3
240202fc:	f000 fd49 	bl	24020d92 <TIM_CCxNChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);
24020300:	687b      	ldr	r3, [r7, #4]
24020302:	681b      	ldr	r3, [r3, #0]
24020304:	2200      	movs	r2, #0
24020306:	68f9      	ldr	r1, [r7, #12]
24020308:	4618      	mov	r0, r3
2402030a:	f7fe f92d 	bl	2401e568 <TIM_CCxChannelCmd>

  /* Disable the Main Output */
  __HAL_TIM_MOE_DISABLE(htim);
2402030e:	687b      	ldr	r3, [r7, #4]
24020310:	681b      	ldr	r3, [r3, #0]
24020312:	6a1a      	ldr	r2, [r3, #32]
24020314:	f241 1311 	movw	r3, #4369	; 0x1111
24020318:	4013      	ands	r3, r2
2402031a:	2b00      	cmp	r3, #0
2402031c:	d10f      	bne.n	2402033e <HAL_TIMEx_OnePulseN_Stop_IT+0x84>
2402031e:	687b      	ldr	r3, [r7, #4]
24020320:	681b      	ldr	r3, [r3, #0]
24020322:	6a1a      	ldr	r2, [r3, #32]
24020324:	f240 4344 	movw	r3, #1092	; 0x444
24020328:	4013      	ands	r3, r2
2402032a:	2b00      	cmp	r3, #0
2402032c:	d107      	bne.n	2402033e <HAL_TIMEx_OnePulseN_Stop_IT+0x84>
2402032e:	687b      	ldr	r3, [r7, #4]
24020330:	681b      	ldr	r3, [r3, #0]
24020332:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24020334:	687b      	ldr	r3, [r7, #4]
24020336:	681b      	ldr	r3, [r3, #0]
24020338:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2402033c:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
2402033e:	687b      	ldr	r3, [r7, #4]
24020340:	681b      	ldr	r3, [r3, #0]
24020342:	6a1a      	ldr	r2, [r3, #32]
24020344:	f241 1311 	movw	r3, #4369	; 0x1111
24020348:	4013      	ands	r3, r2
2402034a:	2b00      	cmp	r3, #0
2402034c:	d10f      	bne.n	2402036e <HAL_TIMEx_OnePulseN_Stop_IT+0xb4>
2402034e:	687b      	ldr	r3, [r7, #4]
24020350:	681b      	ldr	r3, [r3, #0]
24020352:	6a1a      	ldr	r2, [r3, #32]
24020354:	f240 4344 	movw	r3, #1092	; 0x444
24020358:	4013      	ands	r3, r2
2402035a:	2b00      	cmp	r3, #0
2402035c:	d107      	bne.n	2402036e <HAL_TIMEx_OnePulseN_Stop_IT+0xb4>
2402035e:	687b      	ldr	r3, [r7, #4]
24020360:	681b      	ldr	r3, [r3, #0]
24020362:	681a      	ldr	r2, [r3, #0]
24020364:	687b      	ldr	r3, [r7, #4]
24020366:	681b      	ldr	r3, [r3, #0]
24020368:	f022 0201 	bic.w	r2, r2, #1
2402036c:	601a      	str	r2, [r3, #0]

  /* Set the TIM  channels state */
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2402036e:	687b      	ldr	r3, [r7, #4]
24020370:	2201      	movs	r2, #1
24020372:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
24020376:	687b      	ldr	r3, [r7, #4]
24020378:	2201      	movs	r2, #1
2402037a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
2402037e:	687b      	ldr	r3, [r7, #4]
24020380:	2201      	movs	r2, #1
24020382:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
24020386:	687b      	ldr	r3, [r7, #4]
24020388:	2201      	movs	r2, #1
2402038a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Return function status */
  return HAL_OK;
2402038e:	2300      	movs	r3, #0
}
24020390:	4618      	mov	r0, r3
24020392:	3710      	adds	r7, #16
24020394:	46bd      	mov	sp, r7
24020396:	bd80      	pop	{r7, pc}

24020398 <HAL_TIMEx_ConfigCommutEvent>:
  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
                                              uint32_t  CommutationSource)
{
24020398:	b480      	push	{r7}
2402039a:	b085      	sub	sp, #20
2402039c:	af00      	add	r7, sp, #0
2402039e:	60f8      	str	r0, [r7, #12]
240203a0:	60b9      	str	r1, [r7, #8]
240203a2:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));

  __HAL_LOCK(htim);
240203a4:	68fb      	ldr	r3, [r7, #12]
240203a6:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
240203aa:	2b01      	cmp	r3, #1
240203ac:	d101      	bne.n	240203b2 <HAL_TIMEx_ConfigCommutEvent+0x1a>
240203ae:	2302      	movs	r3, #2
240203b0:	e054      	b.n	2402045c <HAL_TIMEx_ConfigCommutEvent+0xc4>
240203b2:	68fb      	ldr	r3, [r7, #12]
240203b4:	2201      	movs	r2, #1
240203b6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
240203ba:	68bb      	ldr	r3, [r7, #8]
240203bc:	2b00      	cmp	r3, #0
240203be:	d010      	beq.n	240203e2 <HAL_TIMEx_ConfigCommutEvent+0x4a>
240203c0:	68bb      	ldr	r3, [r7, #8]
240203c2:	2b10      	cmp	r3, #16
240203c4:	d00d      	beq.n	240203e2 <HAL_TIMEx_ConfigCommutEvent+0x4a>
240203c6:	68bb      	ldr	r3, [r7, #8]
240203c8:	2b20      	cmp	r3, #32
240203ca:	d00a      	beq.n	240203e2 <HAL_TIMEx_ConfigCommutEvent+0x4a>
      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
240203cc:	68bb      	ldr	r3, [r7, #8]
240203ce:	2b30      	cmp	r3, #48	; 0x30
240203d0:	d007      	beq.n	240203e2 <HAL_TIMEx_ConfigCommutEvent+0x4a>
240203d2:	68bb      	ldr	r3, [r7, #8]
240203d4:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240203d8:	d003      	beq.n	240203e2 <HAL_TIMEx_ConfigCommutEvent+0x4a>
      (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))
240203da:	68bb      	ldr	r3, [r7, #8]
240203dc:	4a22      	ldr	r2, [pc, #136]	; (24020468 <HAL_TIMEx_ConfigCommutEvent+0xd0>)
240203de:	4293      	cmp	r3, r2
240203e0:	d10f      	bne.n	24020402 <HAL_TIMEx_ConfigCommutEvent+0x6a>
  {
    /* Select the Input trigger */
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
240203e2:	68fb      	ldr	r3, [r7, #12]
240203e4:	681b      	ldr	r3, [r3, #0]
240203e6:	6899      	ldr	r1, [r3, #8]
240203e8:	68fb      	ldr	r3, [r7, #12]
240203ea:	681a      	ldr	r2, [r3, #0]
240203ec:	4b1f      	ldr	r3, [pc, #124]	; (2402046c <HAL_TIMEx_ConfigCommutEvent+0xd4>)
240203ee:	400b      	ands	r3, r1
240203f0:	6093      	str	r3, [r2, #8]
    htim->Instance->SMCR |= InputTrigger;
240203f2:	68fb      	ldr	r3, [r7, #12]
240203f4:	681b      	ldr	r3, [r3, #0]
240203f6:	6899      	ldr	r1, [r3, #8]
240203f8:	68fb      	ldr	r3, [r7, #12]
240203fa:	681b      	ldr	r3, [r3, #0]
240203fc:	68ba      	ldr	r2, [r7, #8]
240203fe:	430a      	orrs	r2, r1
24020400:	609a      	str	r2, [r3, #8]
  }

  /* Select the Capture Compare preload feature */
  htim->Instance->CR2 |= TIM_CR2_CCPC;
24020402:	68fb      	ldr	r3, [r7, #12]
24020404:	681b      	ldr	r3, [r3, #0]
24020406:	685a      	ldr	r2, [r3, #4]
24020408:	68fb      	ldr	r3, [r7, #12]
2402040a:	681b      	ldr	r3, [r3, #0]
2402040c:	f042 0201 	orr.w	r2, r2, #1
24020410:	605a      	str	r2, [r3, #4]
  /* Select the Commutation event source */
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
24020412:	68fb      	ldr	r3, [r7, #12]
24020414:	681b      	ldr	r3, [r3, #0]
24020416:	685a      	ldr	r2, [r3, #4]
24020418:	68fb      	ldr	r3, [r7, #12]
2402041a:	681b      	ldr	r3, [r3, #0]
2402041c:	f022 0204 	bic.w	r2, r2, #4
24020420:	605a      	str	r2, [r3, #4]
  htim->Instance->CR2 |= CommutationSource;
24020422:	68fb      	ldr	r3, [r7, #12]
24020424:	681b      	ldr	r3, [r3, #0]
24020426:	6859      	ldr	r1, [r3, #4]
24020428:	68fb      	ldr	r3, [r7, #12]
2402042a:	681b      	ldr	r3, [r3, #0]
2402042c:	687a      	ldr	r2, [r7, #4]
2402042e:	430a      	orrs	r2, r1
24020430:	605a      	str	r2, [r3, #4]

  /* Disable Commutation Interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
24020432:	68fb      	ldr	r3, [r7, #12]
24020434:	681b      	ldr	r3, [r3, #0]
24020436:	68da      	ldr	r2, [r3, #12]
24020438:	68fb      	ldr	r3, [r7, #12]
2402043a:	681b      	ldr	r3, [r3, #0]
2402043c:	f022 0220 	bic.w	r2, r2, #32
24020440:	60da      	str	r2, [r3, #12]

  /* Disable Commutation DMA request */
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
24020442:	68fb      	ldr	r3, [r7, #12]
24020444:	681b      	ldr	r3, [r3, #0]
24020446:	68da      	ldr	r2, [r3, #12]
24020448:	68fb      	ldr	r3, [r7, #12]
2402044a:	681b      	ldr	r3, [r3, #0]
2402044c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
24020450:	60da      	str	r2, [r3, #12]

  __HAL_UNLOCK(htim);
24020452:	68fb      	ldr	r3, [r7, #12]
24020454:	2200      	movs	r2, #0
24020456:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2402045a:	2300      	movs	r3, #0
}
2402045c:	4618      	mov	r0, r3
2402045e:	3714      	adds	r7, #20
24020460:	46bd      	mov	sp, r7
24020462:	f85d 7b04 	ldr.w	r7, [sp], #4
24020466:	4770      	bx	lr
24020468:	00200010 	.word	0x00200010
2402046c:	ffcfff8f 	.word	0xffcfff8f

24020470 <HAL_TIMEx_ConfigCommutEvent_IT>:
  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
                                                 uint32_t  CommutationSource)
{
24020470:	b480      	push	{r7}
24020472:	b085      	sub	sp, #20
24020474:	af00      	add	r7, sp, #0
24020476:	60f8      	str	r0, [r7, #12]
24020478:	60b9      	str	r1, [r7, #8]
2402047a:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));

  __HAL_LOCK(htim);
2402047c:	68fb      	ldr	r3, [r7, #12]
2402047e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
24020482:	2b01      	cmp	r3, #1
24020484:	d101      	bne.n	2402048a <HAL_TIMEx_ConfigCommutEvent_IT+0x1a>
24020486:	2302      	movs	r3, #2
24020488:	e054      	b.n	24020534 <HAL_TIMEx_ConfigCommutEvent_IT+0xc4>
2402048a:	68fb      	ldr	r3, [r7, #12]
2402048c:	2201      	movs	r2, #1
2402048e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
24020492:	68bb      	ldr	r3, [r7, #8]
24020494:	2b00      	cmp	r3, #0
24020496:	d010      	beq.n	240204ba <HAL_TIMEx_ConfigCommutEvent_IT+0x4a>
24020498:	68bb      	ldr	r3, [r7, #8]
2402049a:	2b10      	cmp	r3, #16
2402049c:	d00d      	beq.n	240204ba <HAL_TIMEx_ConfigCommutEvent_IT+0x4a>
2402049e:	68bb      	ldr	r3, [r7, #8]
240204a0:	2b20      	cmp	r3, #32
240204a2:	d00a      	beq.n	240204ba <HAL_TIMEx_ConfigCommutEvent_IT+0x4a>
      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
240204a4:	68bb      	ldr	r3, [r7, #8]
240204a6:	2b30      	cmp	r3, #48	; 0x30
240204a8:	d007      	beq.n	240204ba <HAL_TIMEx_ConfigCommutEvent_IT+0x4a>
240204aa:	68bb      	ldr	r3, [r7, #8]
240204ac:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240204b0:	d003      	beq.n	240204ba <HAL_TIMEx_ConfigCommutEvent_IT+0x4a>
      (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))
240204b2:	68bb      	ldr	r3, [r7, #8]
240204b4:	4a22      	ldr	r2, [pc, #136]	; (24020540 <HAL_TIMEx_ConfigCommutEvent_IT+0xd0>)
240204b6:	4293      	cmp	r3, r2
240204b8:	d10f      	bne.n	240204da <HAL_TIMEx_ConfigCommutEvent_IT+0x6a>
  {
    /* Select the Input trigger */
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
240204ba:	68fb      	ldr	r3, [r7, #12]
240204bc:	681b      	ldr	r3, [r3, #0]
240204be:	6899      	ldr	r1, [r3, #8]
240204c0:	68fb      	ldr	r3, [r7, #12]
240204c2:	681a      	ldr	r2, [r3, #0]
240204c4:	4b1f      	ldr	r3, [pc, #124]	; (24020544 <HAL_TIMEx_ConfigCommutEvent_IT+0xd4>)
240204c6:	400b      	ands	r3, r1
240204c8:	6093      	str	r3, [r2, #8]
    htim->Instance->SMCR |= InputTrigger;
240204ca:	68fb      	ldr	r3, [r7, #12]
240204cc:	681b      	ldr	r3, [r3, #0]
240204ce:	6899      	ldr	r1, [r3, #8]
240204d0:	68fb      	ldr	r3, [r7, #12]
240204d2:	681b      	ldr	r3, [r3, #0]
240204d4:	68ba      	ldr	r2, [r7, #8]
240204d6:	430a      	orrs	r2, r1
240204d8:	609a      	str	r2, [r3, #8]
  }

  /* Select the Capture Compare preload feature */
  htim->Instance->CR2 |= TIM_CR2_CCPC;
240204da:	68fb      	ldr	r3, [r7, #12]
240204dc:	681b      	ldr	r3, [r3, #0]
240204de:	685a      	ldr	r2, [r3, #4]
240204e0:	68fb      	ldr	r3, [r7, #12]
240204e2:	681b      	ldr	r3, [r3, #0]
240204e4:	f042 0201 	orr.w	r2, r2, #1
240204e8:	605a      	str	r2, [r3, #4]
  /* Select the Commutation event source */
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
240204ea:	68fb      	ldr	r3, [r7, #12]
240204ec:	681b      	ldr	r3, [r3, #0]
240204ee:	685a      	ldr	r2, [r3, #4]
240204f0:	68fb      	ldr	r3, [r7, #12]
240204f2:	681b      	ldr	r3, [r3, #0]
240204f4:	f022 0204 	bic.w	r2, r2, #4
240204f8:	605a      	str	r2, [r3, #4]
  htim->Instance->CR2 |= CommutationSource;
240204fa:	68fb      	ldr	r3, [r7, #12]
240204fc:	681b      	ldr	r3, [r3, #0]
240204fe:	6859      	ldr	r1, [r3, #4]
24020500:	68fb      	ldr	r3, [r7, #12]
24020502:	681b      	ldr	r3, [r3, #0]
24020504:	687a      	ldr	r2, [r7, #4]
24020506:	430a      	orrs	r2, r1
24020508:	605a      	str	r2, [r3, #4]

  /* Disable Commutation DMA request */
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
2402050a:	68fb      	ldr	r3, [r7, #12]
2402050c:	681b      	ldr	r3, [r3, #0]
2402050e:	68da      	ldr	r2, [r3, #12]
24020510:	68fb      	ldr	r3, [r7, #12]
24020512:	681b      	ldr	r3, [r3, #0]
24020514:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
24020518:	60da      	str	r2, [r3, #12]

  /* Enable the Commutation Interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
2402051a:	68fb      	ldr	r3, [r7, #12]
2402051c:	681b      	ldr	r3, [r3, #0]
2402051e:	68da      	ldr	r2, [r3, #12]
24020520:	68fb      	ldr	r3, [r7, #12]
24020522:	681b      	ldr	r3, [r3, #0]
24020524:	f042 0220 	orr.w	r2, r2, #32
24020528:	60da      	str	r2, [r3, #12]

  __HAL_UNLOCK(htim);
2402052a:	68fb      	ldr	r3, [r7, #12]
2402052c:	2200      	movs	r2, #0
2402052e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24020532:	2300      	movs	r3, #0
}
24020534:	4618      	mov	r0, r3
24020536:	3714      	adds	r7, #20
24020538:	46bd      	mov	sp, r7
2402053a:	f85d 7b04 	ldr.w	r7, [sp], #4
2402053e:	4770      	bx	lr
24020540:	00200010 	.word	0x00200010
24020544:	ffcfff8f 	.word	0xffcfff8f

24020548 <HAL_TIMEx_ConfigCommutEvent_DMA>:
  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
                                                  uint32_t  CommutationSource)
{
24020548:	b480      	push	{r7}
2402054a:	b085      	sub	sp, #20
2402054c:	af00      	add	r7, sp, #0
2402054e:	60f8      	str	r0, [r7, #12]
24020550:	60b9      	str	r1, [r7, #8]
24020552:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));

  __HAL_LOCK(htim);
24020554:	68fb      	ldr	r3, [r7, #12]
24020556:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2402055a:	2b01      	cmp	r3, #1
2402055c:	d101      	bne.n	24020562 <HAL_TIMEx_ConfigCommutEvent_DMA+0x1a>
2402055e:	2302      	movs	r3, #2
24020560:	e060      	b.n	24020624 <HAL_TIMEx_ConfigCommutEvent_DMA+0xdc>
24020562:	68fb      	ldr	r3, [r7, #12]
24020564:	2201      	movs	r2, #1
24020566:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
2402056a:	68bb      	ldr	r3, [r7, #8]
2402056c:	2b00      	cmp	r3, #0
2402056e:	d010      	beq.n	24020592 <HAL_TIMEx_ConfigCommutEvent_DMA+0x4a>
24020570:	68bb      	ldr	r3, [r7, #8]
24020572:	2b10      	cmp	r3, #16
24020574:	d00d      	beq.n	24020592 <HAL_TIMEx_ConfigCommutEvent_DMA+0x4a>
24020576:	68bb      	ldr	r3, [r7, #8]
24020578:	2b20      	cmp	r3, #32
2402057a:	d00a      	beq.n	24020592 <HAL_TIMEx_ConfigCommutEvent_DMA+0x4a>
      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
2402057c:	68bb      	ldr	r3, [r7, #8]
2402057e:	2b30      	cmp	r3, #48	; 0x30
24020580:	d007      	beq.n	24020592 <HAL_TIMEx_ConfigCommutEvent_DMA+0x4a>
24020582:	68bb      	ldr	r3, [r7, #8]
24020584:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24020588:	d003      	beq.n	24020592 <HAL_TIMEx_ConfigCommutEvent_DMA+0x4a>
      (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))
2402058a:	68bb      	ldr	r3, [r7, #8]
2402058c:	4a28      	ldr	r2, [pc, #160]	; (24020630 <HAL_TIMEx_ConfigCommutEvent_DMA+0xe8>)
2402058e:	4293      	cmp	r3, r2
24020590:	d10f      	bne.n	240205b2 <HAL_TIMEx_ConfigCommutEvent_DMA+0x6a>
  {
    /* Select the Input trigger */
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
24020592:	68fb      	ldr	r3, [r7, #12]
24020594:	681b      	ldr	r3, [r3, #0]
24020596:	6899      	ldr	r1, [r3, #8]
24020598:	68fb      	ldr	r3, [r7, #12]
2402059a:	681a      	ldr	r2, [r3, #0]
2402059c:	4b25      	ldr	r3, [pc, #148]	; (24020634 <HAL_TIMEx_ConfigCommutEvent_DMA+0xec>)
2402059e:	400b      	ands	r3, r1
240205a0:	6093      	str	r3, [r2, #8]
    htim->Instance->SMCR |= InputTrigger;
240205a2:	68fb      	ldr	r3, [r7, #12]
240205a4:	681b      	ldr	r3, [r3, #0]
240205a6:	6899      	ldr	r1, [r3, #8]
240205a8:	68fb      	ldr	r3, [r7, #12]
240205aa:	681b      	ldr	r3, [r3, #0]
240205ac:	68ba      	ldr	r2, [r7, #8]
240205ae:	430a      	orrs	r2, r1
240205b0:	609a      	str	r2, [r3, #8]
  }

  /* Select the Capture Compare preload feature */
  htim->Instance->CR2 |= TIM_CR2_CCPC;
240205b2:	68fb      	ldr	r3, [r7, #12]
240205b4:	681b      	ldr	r3, [r3, #0]
240205b6:	685a      	ldr	r2, [r3, #4]
240205b8:	68fb      	ldr	r3, [r7, #12]
240205ba:	681b      	ldr	r3, [r3, #0]
240205bc:	f042 0201 	orr.w	r2, r2, #1
240205c0:	605a      	str	r2, [r3, #4]
  /* Select the Commutation event source */
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
240205c2:	68fb      	ldr	r3, [r7, #12]
240205c4:	681b      	ldr	r3, [r3, #0]
240205c6:	685a      	ldr	r2, [r3, #4]
240205c8:	68fb      	ldr	r3, [r7, #12]
240205ca:	681b      	ldr	r3, [r3, #0]
240205cc:	f022 0204 	bic.w	r2, r2, #4
240205d0:	605a      	str	r2, [r3, #4]
  htim->Instance->CR2 |= CommutationSource;
240205d2:	68fb      	ldr	r3, [r7, #12]
240205d4:	681b      	ldr	r3, [r3, #0]
240205d6:	6859      	ldr	r1, [r3, #4]
240205d8:	68fb      	ldr	r3, [r7, #12]
240205da:	681b      	ldr	r3, [r3, #0]
240205dc:	687a      	ldr	r2, [r7, #4]
240205de:	430a      	orrs	r2, r1
240205e0:	605a      	str	r2, [r3, #4]

  /* Enable the Commutation DMA Request */
  /* Set the DMA Commutation Callback */
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
240205e2:	68fb      	ldr	r3, [r7, #12]
240205e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240205e6:	4a14      	ldr	r2, [pc, #80]	; (24020638 <HAL_TIMEx_ConfigCommutEvent_DMA+0xf0>)
240205e8:	63da      	str	r2, [r3, #60]	; 0x3c
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;
240205ea:	68fb      	ldr	r3, [r7, #12]
240205ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240205ee:	4a13      	ldr	r2, [pc, #76]	; (2402063c <HAL_TIMEx_ConfigCommutEvent_DMA+0xf4>)
240205f0:	641a      	str	r2, [r3, #64]	; 0x40
  /* Set the DMA error callback */
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
240205f2:	68fb      	ldr	r3, [r7, #12]
240205f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240205f6:	4a12      	ldr	r2, [pc, #72]	; (24020640 <HAL_TIMEx_ConfigCommutEvent_DMA+0xf8>)
240205f8:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Disable Commutation Interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
240205fa:	68fb      	ldr	r3, [r7, #12]
240205fc:	681b      	ldr	r3, [r3, #0]
240205fe:	68da      	ldr	r2, [r3, #12]
24020600:	68fb      	ldr	r3, [r7, #12]
24020602:	681b      	ldr	r3, [r3, #0]
24020604:	f022 0220 	bic.w	r2, r2, #32
24020608:	60da      	str	r2, [r3, #12]

  /* Enable the Commutation DMA Request */
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
2402060a:	68fb      	ldr	r3, [r7, #12]
2402060c:	681b      	ldr	r3, [r3, #0]
2402060e:	68da      	ldr	r2, [r3, #12]
24020610:	68fb      	ldr	r3, [r7, #12]
24020612:	681b      	ldr	r3, [r3, #0]
24020614:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
24020618:	60da      	str	r2, [r3, #12]

  __HAL_UNLOCK(htim);
2402061a:	68fb      	ldr	r3, [r7, #12]
2402061c:	2200      	movs	r2, #0
2402061e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24020622:	2300      	movs	r3, #0
}
24020624:	4618      	mov	r0, r3
24020626:	3714      	adds	r7, #20
24020628:	46bd      	mov	sp, r7
2402062a:	f85d 7b04 	ldr.w	r7, [sp], #4
2402062e:	4770      	bx	lr
24020630:	00200010 	.word	0x00200010
24020634:	ffcfff8f 	.word	0xffcfff8f
24020638:	24020c35 	.word	0x24020c35
2402063c:	24020c59 	.word	0x24020c59
24020640:	2401d5bf 	.word	0x2401d5bf

24020644 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        const TIM_MasterConfigTypeDef *sMasterConfig)
{
24020644:	b480      	push	{r7}
24020646:	b085      	sub	sp, #20
24020648:	af00      	add	r7, sp, #0
2402064a:	6078      	str	r0, [r7, #4]
2402064c:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
2402064e:	687b      	ldr	r3, [r7, #4]
24020650:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
24020654:	2b01      	cmp	r3, #1
24020656:	d101      	bne.n	2402065c <HAL_TIMEx_MasterConfigSynchronization+0x18>
24020658:	2302      	movs	r3, #2
2402065a:	e06d      	b.n	24020738 <HAL_TIMEx_MasterConfigSynchronization+0xf4>
2402065c:	687b      	ldr	r3, [r7, #4]
2402065e:	2201      	movs	r2, #1
24020660:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
24020664:	687b      	ldr	r3, [r7, #4]
24020666:	2202      	movs	r2, #2
24020668:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
2402066c:	687b      	ldr	r3, [r7, #4]
2402066e:	681b      	ldr	r3, [r3, #0]
24020670:	685b      	ldr	r3, [r3, #4]
24020672:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
24020674:	687b      	ldr	r3, [r7, #4]
24020676:	681b      	ldr	r3, [r3, #0]
24020678:	689b      	ldr	r3, [r3, #8]
2402067a:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
2402067c:	687b      	ldr	r3, [r7, #4]
2402067e:	681b      	ldr	r3, [r3, #0]
24020680:	4a30      	ldr	r2, [pc, #192]	; (24020744 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
24020682:	4293      	cmp	r3, r2
24020684:	d004      	beq.n	24020690 <HAL_TIMEx_MasterConfigSynchronization+0x4c>
24020686:	687b      	ldr	r3, [r7, #4]
24020688:	681b      	ldr	r3, [r3, #0]
2402068a:	4a2f      	ldr	r2, [pc, #188]	; (24020748 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
2402068c:	4293      	cmp	r3, r2
2402068e:	d108      	bne.n	240206a2 <HAL_TIMEx_MasterConfigSynchronization+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
24020690:	68fb      	ldr	r3, [r7, #12]
24020692:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
24020696:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
24020698:	683b      	ldr	r3, [r7, #0]
2402069a:	685b      	ldr	r3, [r3, #4]
2402069c:	68fa      	ldr	r2, [r7, #12]
2402069e:	4313      	orrs	r3, r2
240206a0:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
240206a2:	68fb      	ldr	r3, [r7, #12]
240206a4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
240206a8:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
240206aa:	683b      	ldr	r3, [r7, #0]
240206ac:	681b      	ldr	r3, [r3, #0]
240206ae:	68fa      	ldr	r2, [r7, #12]
240206b0:	4313      	orrs	r3, r2
240206b2:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
240206b4:	687b      	ldr	r3, [r7, #4]
240206b6:	681b      	ldr	r3, [r3, #0]
240206b8:	68fa      	ldr	r2, [r7, #12]
240206ba:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
240206bc:	687b      	ldr	r3, [r7, #4]
240206be:	681b      	ldr	r3, [r3, #0]
240206c0:	4a20      	ldr	r2, [pc, #128]	; (24020744 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
240206c2:	4293      	cmp	r3, r2
240206c4:	d022      	beq.n	2402070c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
240206c6:	687b      	ldr	r3, [r7, #4]
240206c8:	681b      	ldr	r3, [r3, #0]
240206ca:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240206ce:	d01d      	beq.n	2402070c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
240206d0:	687b      	ldr	r3, [r7, #4]
240206d2:	681b      	ldr	r3, [r3, #0]
240206d4:	4a1d      	ldr	r2, [pc, #116]	; (2402074c <HAL_TIMEx_MasterConfigSynchronization+0x108>)
240206d6:	4293      	cmp	r3, r2
240206d8:	d018      	beq.n	2402070c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
240206da:	687b      	ldr	r3, [r7, #4]
240206dc:	681b      	ldr	r3, [r3, #0]
240206de:	4a1c      	ldr	r2, [pc, #112]	; (24020750 <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
240206e0:	4293      	cmp	r3, r2
240206e2:	d013      	beq.n	2402070c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
240206e4:	687b      	ldr	r3, [r7, #4]
240206e6:	681b      	ldr	r3, [r3, #0]
240206e8:	4a1a      	ldr	r2, [pc, #104]	; (24020754 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
240206ea:	4293      	cmp	r3, r2
240206ec:	d00e      	beq.n	2402070c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
240206ee:	687b      	ldr	r3, [r7, #4]
240206f0:	681b      	ldr	r3, [r3, #0]
240206f2:	4a15      	ldr	r2, [pc, #84]	; (24020748 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
240206f4:	4293      	cmp	r3, r2
240206f6:	d009      	beq.n	2402070c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
240206f8:	687b      	ldr	r3, [r7, #4]
240206fa:	681b      	ldr	r3, [r3, #0]
240206fc:	4a16      	ldr	r2, [pc, #88]	; (24020758 <HAL_TIMEx_MasterConfigSynchronization+0x114>)
240206fe:	4293      	cmp	r3, r2
24020700:	d004      	beq.n	2402070c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
24020702:	687b      	ldr	r3, [r7, #4]
24020704:	681b      	ldr	r3, [r3, #0]
24020706:	4a15      	ldr	r2, [pc, #84]	; (2402075c <HAL_TIMEx_MasterConfigSynchronization+0x118>)
24020708:	4293      	cmp	r3, r2
2402070a:	d10c      	bne.n	24020726 <HAL_TIMEx_MasterConfigSynchronization+0xe2>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
2402070c:	68bb      	ldr	r3, [r7, #8]
2402070e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
24020712:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
24020714:	683b      	ldr	r3, [r7, #0]
24020716:	689b      	ldr	r3, [r3, #8]
24020718:	68ba      	ldr	r2, [r7, #8]
2402071a:	4313      	orrs	r3, r2
2402071c:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
2402071e:	687b      	ldr	r3, [r7, #4]
24020720:	681b      	ldr	r3, [r3, #0]
24020722:	68ba      	ldr	r2, [r7, #8]
24020724:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
24020726:	687b      	ldr	r3, [r7, #4]
24020728:	2201      	movs	r2, #1
2402072a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
2402072e:	687b      	ldr	r3, [r7, #4]
24020730:	2200      	movs	r2, #0
24020732:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24020736:	2300      	movs	r3, #0
}
24020738:	4618      	mov	r0, r3
2402073a:	3714      	adds	r7, #20
2402073c:	46bd      	mov	sp, r7
2402073e:	f85d 7b04 	ldr.w	r7, [sp], #4
24020742:	4770      	bx	lr
24020744:	40010000 	.word	0x40010000
24020748:	40010400 	.word	0x40010400
2402074c:	40000400 	.word	0x40000400
24020750:	40000800 	.word	0x40000800
24020754:	40000c00 	.word	0x40000c00
24020758:	40001800 	.word	0x40001800
2402075c:	40014000 	.word	0x40014000

24020760 <HAL_TIMEx_ConfigBreakDeadTime>:
  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                const TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
24020760:	b480      	push	{r7}
24020762:	b085      	sub	sp, #20
24020764:	af00      	add	r7, sp, #0
24020766:	6078      	str	r0, [r7, #4]
24020768:	6039      	str	r1, [r7, #0]
  /* Keep this variable initialized to 0 as it is used to configure BDTR register */
  uint32_t tmpbdtr = 0U;
2402076a:	2300      	movs	r3, #0
2402076c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
2402076e:	687b      	ldr	r3, [r7, #4]
24020770:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
24020774:	2b01      	cmp	r3, #1
24020776:	d101      	bne.n	2402077c <HAL_TIMEx_ConfigBreakDeadTime+0x1c>
24020778:	2302      	movs	r3, #2
2402077a:	e065      	b.n	24020848 <HAL_TIMEx_ConfigBreakDeadTime+0xe8>
2402077c:	687b      	ldr	r3, [r7, #4]
2402077e:	2201      	movs	r2, #1
24020780:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
24020784:	68fb      	ldr	r3, [r7, #12]
24020786:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
2402078a:	683b      	ldr	r3, [r7, #0]
2402078c:	68db      	ldr	r3, [r3, #12]
2402078e:	4313      	orrs	r3, r2
24020790:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
24020792:	68fb      	ldr	r3, [r7, #12]
24020794:	f423 7240 	bic.w	r2, r3, #768	; 0x300
24020798:	683b      	ldr	r3, [r7, #0]
2402079a:	689b      	ldr	r3, [r3, #8]
2402079c:	4313      	orrs	r3, r2
2402079e:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
240207a0:	68fb      	ldr	r3, [r7, #12]
240207a2:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
240207a6:	683b      	ldr	r3, [r7, #0]
240207a8:	685b      	ldr	r3, [r3, #4]
240207aa:	4313      	orrs	r3, r2
240207ac:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
240207ae:	68fb      	ldr	r3, [r7, #12]
240207b0:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
240207b4:	683b      	ldr	r3, [r7, #0]
240207b6:	681b      	ldr	r3, [r3, #0]
240207b8:	4313      	orrs	r3, r2
240207ba:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
240207bc:	68fb      	ldr	r3, [r7, #12]
240207be:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
240207c2:	683b      	ldr	r3, [r7, #0]
240207c4:	691b      	ldr	r3, [r3, #16]
240207c6:	4313      	orrs	r3, r2
240207c8:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
240207ca:	68fb      	ldr	r3, [r7, #12]
240207cc:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
240207d0:	683b      	ldr	r3, [r7, #0]
240207d2:	695b      	ldr	r3, [r3, #20]
240207d4:	4313      	orrs	r3, r2
240207d6:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
240207d8:	68fb      	ldr	r3, [r7, #12]
240207da:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
240207de:	683b      	ldr	r3, [r7, #0]
240207e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240207e2:	4313      	orrs	r3, r2
240207e4:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
240207e6:	68fb      	ldr	r3, [r7, #12]
240207e8:	f423 2270 	bic.w	r2, r3, #983040	; 0xf0000
240207ec:	683b      	ldr	r3, [r7, #0]
240207ee:	699b      	ldr	r3, [r3, #24]
240207f0:	041b      	lsls	r3, r3, #16
240207f2:	4313      	orrs	r3, r2
240207f4:	60fb      	str	r3, [r7, #12]
    /* Set BREAK AF mode */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
  }

#endif /* TIM_BDTR_BKBID */
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
240207f6:	687b      	ldr	r3, [r7, #4]
240207f8:	681b      	ldr	r3, [r3, #0]
240207fa:	4a16      	ldr	r2, [pc, #88]	; (24020854 <HAL_TIMEx_ConfigBreakDeadTime+0xf4>)
240207fc:	4293      	cmp	r3, r2
240207fe:	d004      	beq.n	2402080a <HAL_TIMEx_ConfigBreakDeadTime+0xaa>
24020800:	687b      	ldr	r3, [r7, #4]
24020802:	681b      	ldr	r3, [r3, #0]
24020804:	4a14      	ldr	r2, [pc, #80]	; (24020858 <HAL_TIMEx_ConfigBreakDeadTime+0xf8>)
24020806:	4293      	cmp	r3, r2
24020808:	d115      	bne.n	24020836 <HAL_TIMEx_ConfigBreakDeadTime+0xd6>
    assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));

    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
2402080a:	68fb      	ldr	r3, [r7, #12]
2402080c:	f423 0270 	bic.w	r2, r3, #15728640	; 0xf00000
24020810:	683b      	ldr	r3, [r7, #0]
24020812:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24020814:	051b      	lsls	r3, r3, #20
24020816:	4313      	orrs	r3, r2
24020818:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
2402081a:	68fb      	ldr	r3, [r7, #12]
2402081c:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
24020820:	683b      	ldr	r3, [r7, #0]
24020822:	69db      	ldr	r3, [r3, #28]
24020824:	4313      	orrs	r3, r2
24020826:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
24020828:	68fb      	ldr	r3, [r7, #12]
2402082a:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
2402082e:	683b      	ldr	r3, [r7, #0]
24020830:	6a1b      	ldr	r3, [r3, #32]
24020832:	4313      	orrs	r3, r2
24020834:	60fb      	str	r3, [r7, #12]
    }
#endif /* TIM_BDTR_BKBID */
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
24020836:	687b      	ldr	r3, [r7, #4]
24020838:	681b      	ldr	r3, [r3, #0]
2402083a:	68fa      	ldr	r2, [r7, #12]
2402083c:	645a      	str	r2, [r3, #68]	; 0x44

  __HAL_UNLOCK(htim);
2402083e:	687b      	ldr	r3, [r7, #4]
24020840:	2200      	movs	r2, #0
24020842:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24020846:	2300      	movs	r3, #0
}
24020848:	4618      	mov	r0, r3
2402084a:	3714      	adds	r7, #20
2402084c:	46bd      	mov	sp, r7
2402084e:	f85d 7b04 	ldr.w	r7, [sp], #4
24020852:	4770      	bx	lr
24020854:	40010000 	.word	0x40010000
24020858:	40010400 	.word	0x40010400

2402085c <HAL_TIMEx_ConfigBreakInput>:
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,
                                             uint32_t BreakInput,
                                             const TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)

{
2402085c:	b480      	push	{r7}
2402085e:	b08b      	sub	sp, #44	; 0x2c
24020860:	af00      	add	r7, sp, #0
24020862:	60f8      	str	r0, [r7, #12]
24020864:	60b9      	str	r1, [r7, #8]
24020866:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24020868:	2300      	movs	r3, #0
2402086a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  {
    assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));
  }

  /* Check input state */
  __HAL_LOCK(htim);
2402086e:	68fb      	ldr	r3, [r7, #12]
24020870:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
24020874:	2b01      	cmp	r3, #1
24020876:	d101      	bne.n	2402087c <HAL_TIMEx_ConfigBreakInput+0x20>
24020878:	2302      	movs	r3, #2
2402087a:	e0af      	b.n	240209dc <HAL_TIMEx_ConfigBreakInput+0x180>
2402087c:	68fb      	ldr	r3, [r7, #12]
2402087e:	2201      	movs	r2, #1
24020880:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  switch (sBreakInputConfig->Source)
24020884:	687b      	ldr	r3, [r7, #4]
24020886:	681b      	ldr	r3, [r3, #0]
24020888:	3b01      	subs	r3, #1
2402088a:	2b07      	cmp	r3, #7
2402088c:	d83a      	bhi.n	24020904 <HAL_TIMEx_ConfigBreakInput+0xa8>
2402088e:	a201      	add	r2, pc, #4	; (adr r2, 24020894 <HAL_TIMEx_ConfigBreakInput+0x38>)
24020890:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24020894:	240208b5 	.word	0x240208b5
24020898:	240208c9 	.word	0x240208c9
2402089c:	24020905 	.word	0x24020905
240208a0:	240208dd 	.word	0x240208dd
240208a4:	24020905 	.word	0x24020905
240208a8:	24020905 	.word	0x24020905
240208ac:	24020905 	.word	0x24020905
240208b0:	240208f1 	.word	0x240208f1
  {
    case TIM_BREAKINPUTSOURCE_BKIN:
    {
      bkin_enable_mask = TIM1_AF1_BKINE;
240208b4:	2301      	movs	r3, #1
240208b6:	61fb      	str	r3, [r7, #28]
      bkin_enable_bitpos = TIM1_AF1_BKINE_Pos;
240208b8:	2300      	movs	r3, #0
240208ba:	617b      	str	r3, [r7, #20]
      bkin_polarity_mask = TIM1_AF1_BKINP;
240208bc:	f44f 7300 	mov.w	r3, #512	; 0x200
240208c0:	61bb      	str	r3, [r7, #24]
      bkin_polarity_bitpos = TIM1_AF1_BKINP_Pos;
240208c2:	2309      	movs	r3, #9
240208c4:	613b      	str	r3, [r7, #16]
      break;
240208c6:	e026      	b.n	24020916 <HAL_TIMEx_ConfigBreakInput+0xba>
    }
    case TIM_BREAKINPUTSOURCE_COMP1:
    {
      bkin_enable_mask = TIM1_AF1_BKCMP1E;
240208c8:	2302      	movs	r3, #2
240208ca:	61fb      	str	r3, [r7, #28]
      bkin_enable_bitpos = TIM1_AF1_BKCMP1E_Pos;
240208cc:	2301      	movs	r3, #1
240208ce:	617b      	str	r3, [r7, #20]
      bkin_polarity_mask = TIM1_AF1_BKCMP1P;
240208d0:	f44f 6380 	mov.w	r3, #1024	; 0x400
240208d4:	61bb      	str	r3, [r7, #24]
      bkin_polarity_bitpos = TIM1_AF1_BKCMP1P_Pos;
240208d6:	230a      	movs	r3, #10
240208d8:	613b      	str	r3, [r7, #16]
      break;
240208da:	e01c      	b.n	24020916 <HAL_TIMEx_ConfigBreakInput+0xba>
    }
    case TIM_BREAKINPUTSOURCE_COMP2:
    {
      bkin_enable_mask = TIM1_AF1_BKCMP2E;
240208dc:	2304      	movs	r3, #4
240208de:	61fb      	str	r3, [r7, #28]
      bkin_enable_bitpos = TIM1_AF1_BKCMP2E_Pos;
240208e0:	2302      	movs	r3, #2
240208e2:	617b      	str	r3, [r7, #20]
      bkin_polarity_mask = TIM1_AF1_BKCMP2P;
240208e4:	f44f 6300 	mov.w	r3, #2048	; 0x800
240208e8:	61bb      	str	r3, [r7, #24]
      bkin_polarity_bitpos = TIM1_AF1_BKCMP2P_Pos;
240208ea:	230b      	movs	r3, #11
240208ec:	613b      	str	r3, [r7, #16]
      break;
240208ee:	e012      	b.n	24020916 <HAL_TIMEx_ConfigBreakInput+0xba>
    }
    case TIM_BREAKINPUTSOURCE_DFSDM1:
    {
      bkin_enable_mask = TIM1_AF1_BKDF1BK0E;
240208f0:	f44f 7380 	mov.w	r3, #256	; 0x100
240208f4:	61fb      	str	r3, [r7, #28]
      bkin_enable_bitpos = TIM1_AF1_BKDF1BK0E_Pos;
240208f6:	2308      	movs	r3, #8
240208f8:	617b      	str	r3, [r7, #20]
      bkin_polarity_mask = 0U;
240208fa:	2300      	movs	r3, #0
240208fc:	61bb      	str	r3, [r7, #24]
      bkin_polarity_bitpos = 0U;
240208fe:	2300      	movs	r3, #0
24020900:	613b      	str	r3, [r7, #16]
      break;
24020902:	e008      	b.n	24020916 <HAL_TIMEx_ConfigBreakInput+0xba>
    }

    default:
    {
      bkin_enable_mask = 0U;
24020904:	2300      	movs	r3, #0
24020906:	61fb      	str	r3, [r7, #28]
      bkin_polarity_mask = 0U;
24020908:	2300      	movs	r3, #0
2402090a:	61bb      	str	r3, [r7, #24]
      bkin_enable_bitpos = 0U;
2402090c:	2300      	movs	r3, #0
2402090e:	617b      	str	r3, [r7, #20]
      bkin_polarity_bitpos = 0U;
24020910:	2300      	movs	r3, #0
24020912:	613b      	str	r3, [r7, #16]
      break;
24020914:	bf00      	nop
    }
  }

  switch (BreakInput)
24020916:	68bb      	ldr	r3, [r7, #8]
24020918:	2b01      	cmp	r3, #1
2402091a:	d003      	beq.n	24020924 <HAL_TIMEx_ConfigBreakInput+0xc8>
2402091c:	68bb      	ldr	r3, [r7, #8]
2402091e:	2b02      	cmp	r3, #2
24020920:	d029      	beq.n	24020976 <HAL_TIMEx_ConfigBreakInput+0x11a>
24020922:	e051      	b.n	240209c8 <HAL_TIMEx_ConfigBreakInput+0x16c>
  {
    case TIM_BREAKINPUT_BRK:
    {
      /* Get the TIMx_AF1 register value */
      tmporx = htim->Instance->AF1;
24020924:	68fb      	ldr	r3, [r7, #12]
24020926:	681b      	ldr	r3, [r3, #0]
24020928:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2402092a:	623b      	str	r3, [r7, #32]

      /* Enable the break input */
      tmporx &= ~bkin_enable_mask;
2402092c:	69fb      	ldr	r3, [r7, #28]
2402092e:	43db      	mvns	r3, r3
24020930:	6a3a      	ldr	r2, [r7, #32]
24020932:	4013      	ands	r3, r2
24020934:	623b      	str	r3, [r7, #32]
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
24020936:	687b      	ldr	r3, [r7, #4]
24020938:	685a      	ldr	r2, [r3, #4]
2402093a:	697b      	ldr	r3, [r7, #20]
2402093c:	409a      	lsls	r2, r3
2402093e:	69fb      	ldr	r3, [r7, #28]
24020940:	4013      	ands	r3, r2
24020942:	6a3a      	ldr	r2, [r7, #32]
24020944:	4313      	orrs	r3, r2
24020946:	623b      	str	r3, [r7, #32]

      /* Set the break input polarity */
      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
24020948:	687b      	ldr	r3, [r7, #4]
2402094a:	681b      	ldr	r3, [r3, #0]
2402094c:	2b08      	cmp	r3, #8
2402094e:	d00d      	beq.n	2402096c <HAL_TIMEx_ConfigBreakInput+0x110>
      {
        tmporx &= ~bkin_polarity_mask;
24020950:	69bb      	ldr	r3, [r7, #24]
24020952:	43db      	mvns	r3, r3
24020954:	6a3a      	ldr	r2, [r7, #32]
24020956:	4013      	ands	r3, r2
24020958:	623b      	str	r3, [r7, #32]
        tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
2402095a:	687b      	ldr	r3, [r7, #4]
2402095c:	689a      	ldr	r2, [r3, #8]
2402095e:	693b      	ldr	r3, [r7, #16]
24020960:	409a      	lsls	r2, r3
24020962:	69bb      	ldr	r3, [r7, #24]
24020964:	4013      	ands	r3, r2
24020966:	6a3a      	ldr	r2, [r7, #32]
24020968:	4313      	orrs	r3, r2
2402096a:	623b      	str	r3, [r7, #32]
      }

      /* Set TIMx_AF1 */
      htim->Instance->AF1 = tmporx;
2402096c:	68fb      	ldr	r3, [r7, #12]
2402096e:	681b      	ldr	r3, [r3, #0]
24020970:	6a3a      	ldr	r2, [r7, #32]
24020972:	661a      	str	r2, [r3, #96]	; 0x60
      break;
24020974:	e02c      	b.n	240209d0 <HAL_TIMEx_ConfigBreakInput+0x174>
    }
    case TIM_BREAKINPUT_BRK2:
    {
      /* Get the TIMx_AF2 register value */
      tmporx = htim->Instance->AF2;
24020976:	68fb      	ldr	r3, [r7, #12]
24020978:	681b      	ldr	r3, [r3, #0]
2402097a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2402097c:	623b      	str	r3, [r7, #32]

      /* Enable the break input */
      tmporx &= ~bkin_enable_mask;
2402097e:	69fb      	ldr	r3, [r7, #28]
24020980:	43db      	mvns	r3, r3
24020982:	6a3a      	ldr	r2, [r7, #32]
24020984:	4013      	ands	r3, r2
24020986:	623b      	str	r3, [r7, #32]
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
24020988:	687b      	ldr	r3, [r7, #4]
2402098a:	685a      	ldr	r2, [r3, #4]
2402098c:	697b      	ldr	r3, [r7, #20]
2402098e:	409a      	lsls	r2, r3
24020990:	69fb      	ldr	r3, [r7, #28]
24020992:	4013      	ands	r3, r2
24020994:	6a3a      	ldr	r2, [r7, #32]
24020996:	4313      	orrs	r3, r2
24020998:	623b      	str	r3, [r7, #32]

      /* Set the break input polarity */
      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
2402099a:	687b      	ldr	r3, [r7, #4]
2402099c:	681b      	ldr	r3, [r3, #0]
2402099e:	2b08      	cmp	r3, #8
240209a0:	d00d      	beq.n	240209be <HAL_TIMEx_ConfigBreakInput+0x162>
      {
        tmporx &= ~bkin_polarity_mask;
240209a2:	69bb      	ldr	r3, [r7, #24]
240209a4:	43db      	mvns	r3, r3
240209a6:	6a3a      	ldr	r2, [r7, #32]
240209a8:	4013      	ands	r3, r2
240209aa:	623b      	str	r3, [r7, #32]
        tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
240209ac:	687b      	ldr	r3, [r7, #4]
240209ae:	689a      	ldr	r2, [r3, #8]
240209b0:	693b      	ldr	r3, [r7, #16]
240209b2:	409a      	lsls	r2, r3
240209b4:	69bb      	ldr	r3, [r7, #24]
240209b6:	4013      	ands	r3, r2
240209b8:	6a3a      	ldr	r2, [r7, #32]
240209ba:	4313      	orrs	r3, r2
240209bc:	623b      	str	r3, [r7, #32]
      }

      /* Set TIMx_AF2 */
      htim->Instance->AF2 = tmporx;
240209be:	68fb      	ldr	r3, [r7, #12]
240209c0:	681b      	ldr	r3, [r3, #0]
240209c2:	6a3a      	ldr	r2, [r7, #32]
240209c4:	665a      	str	r2, [r3, #100]	; 0x64
      break;
240209c6:	e003      	b.n	240209d0 <HAL_TIMEx_ConfigBreakInput+0x174>
    }
    default:
      status = HAL_ERROR;
240209c8:	2301      	movs	r3, #1
240209ca:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      break;
240209ce:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
240209d0:	68fb      	ldr	r3, [r7, #12]
240209d2:	2200      	movs	r2, #0
240209d4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
240209d8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
240209dc:	4618      	mov	r0, r3
240209de:	372c      	adds	r7, #44	; 0x2c
240209e0:	46bd      	mov	sp, r7
240209e2:	f85d 7b04 	ldr.w	r7, [sp], #4
240209e6:	4770      	bx	lr

240209e8 <HAL_TIMEx_RemapConfig>:
  *         (*)  Value not defined in all devices.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
{
240209e8:	b480      	push	{r7}
240209ea:	b083      	sub	sp, #12
240209ec:	af00      	add	r7, sp, #0
240209ee:	6078      	str	r0, [r7, #4]
240209f0:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
  assert_param(IS_TIM_REMAP(Remap));

  __HAL_LOCK(htim);
240209f2:	687b      	ldr	r3, [r7, #4]
240209f4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
240209f8:	2b01      	cmp	r3, #1
240209fa:	d101      	bne.n	24020a00 <HAL_TIMEx_RemapConfig+0x18>
240209fc:	2302      	movs	r3, #2
240209fe:	e012      	b.n	24020a26 <HAL_TIMEx_RemapConfig+0x3e>
24020a00:	687b      	ldr	r3, [r7, #4]
24020a02:	2201      	movs	r2, #1
24020a04:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  MODIFY_REG(htim->Instance->AF1, TIM1_AF1_ETRSEL_Msk, Remap);
24020a08:	687b      	ldr	r3, [r7, #4]
24020a0a:	681b      	ldr	r3, [r3, #0]
24020a0c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24020a0e:	f423 3170 	bic.w	r1, r3, #245760	; 0x3c000
24020a12:	687b      	ldr	r3, [r7, #4]
24020a14:	681b      	ldr	r3, [r3, #0]
24020a16:	683a      	ldr	r2, [r7, #0]
24020a18:	430a      	orrs	r2, r1
24020a1a:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(htim);
24020a1c:	687b      	ldr	r3, [r7, #4]
24020a1e:	2200      	movs	r2, #0
24020a20:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24020a24:	2300      	movs	r3, #0
}
24020a26:	4618      	mov	r0, r3
24020a28:	370c      	adds	r7, #12
24020a2a:	46bd      	mov	sp, r7
24020a2c:	f85d 7b04 	ldr.w	r7, [sp], #4
24020a30:	4770      	bx	lr
	...

24020a34 <HAL_TIMEx_TISelection>:
  *
  *         (*)  Value not defined in all devices. \n
  * @retval HAL status
  */
HAL_StatusTypeDef  HAL_TIMEx_TISelection(TIM_HandleTypeDef *htim, uint32_t TISelection, uint32_t Channel)
{
24020a34:	b480      	push	{r7}
24020a36:	b087      	sub	sp, #28
24020a38:	af00      	add	r7, sp, #0
24020a3a:	60f8      	str	r0, [r7, #12]
24020a3c:	60b9      	str	r1, [r7, #8]
24020a3e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24020a40:	2300      	movs	r3, #0
24020a42:	75fb      	strb	r3, [r7, #23]

  /* Check parameters */
  assert_param(IS_TIM_TISEL_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TISEL(TISelection));

  __HAL_LOCK(htim);
24020a44:	68fb      	ldr	r3, [r7, #12]
24020a46:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
24020a4a:	2b01      	cmp	r3, #1
24020a4c:	d101      	bne.n	24020a52 <HAL_TIMEx_TISelection+0x1e>
24020a4e:	2302      	movs	r3, #2
24020a50:	e058      	b.n	24020b04 <HAL_TIMEx_TISelection+0xd0>
24020a52:	68fb      	ldr	r3, [r7, #12]
24020a54:	2201      	movs	r2, #1
24020a56:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  switch (Channel)
24020a5a:	687b      	ldr	r3, [r7, #4]
24020a5c:	2b0c      	cmp	r3, #12
24020a5e:	d849      	bhi.n	24020af4 <HAL_TIMEx_TISelection+0xc0>
24020a60:	a201      	add	r2, pc, #4	; (adr r2, 24020a68 <HAL_TIMEx_TISelection+0x34>)
24020a62:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24020a66:	bf00      	nop
24020a68:	24020a9d 	.word	0x24020a9d
24020a6c:	24020af5 	.word	0x24020af5
24020a70:	24020af5 	.word	0x24020af5
24020a74:	24020af5 	.word	0x24020af5
24020a78:	24020ab3 	.word	0x24020ab3
24020a7c:	24020af5 	.word	0x24020af5
24020a80:	24020af5 	.word	0x24020af5
24020a84:	24020af5 	.word	0x24020af5
24020a88:	24020ac9 	.word	0x24020ac9
24020a8c:	24020af5 	.word	0x24020af5
24020a90:	24020af5 	.word	0x24020af5
24020a94:	24020af5 	.word	0x24020af5
24020a98:	24020adf 	.word	0x24020adf
  {
    case TIM_CHANNEL_1:
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI1SEL, TISelection);
24020a9c:	68fb      	ldr	r3, [r7, #12]
24020a9e:	681b      	ldr	r3, [r3, #0]
24020aa0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24020aa2:	f023 010f 	bic.w	r1, r3, #15
24020aa6:	68fb      	ldr	r3, [r7, #12]
24020aa8:	681b      	ldr	r3, [r3, #0]
24020aaa:	68ba      	ldr	r2, [r7, #8]
24020aac:	430a      	orrs	r2, r1
24020aae:	669a      	str	r2, [r3, #104]	; 0x68
      break;
24020ab0:	e023      	b.n	24020afa <HAL_TIMEx_TISelection+0xc6>
    case TIM_CHANNEL_2:
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI2SEL, TISelection);
24020ab2:	68fb      	ldr	r3, [r7, #12]
24020ab4:	681b      	ldr	r3, [r3, #0]
24020ab6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24020ab8:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
24020abc:	68fb      	ldr	r3, [r7, #12]
24020abe:	681b      	ldr	r3, [r3, #0]
24020ac0:	68ba      	ldr	r2, [r7, #8]
24020ac2:	430a      	orrs	r2, r1
24020ac4:	669a      	str	r2, [r3, #104]	; 0x68
      break;
24020ac6:	e018      	b.n	24020afa <HAL_TIMEx_TISelection+0xc6>
    case TIM_CHANNEL_3:
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI3SEL, TISelection);
24020ac8:	68fb      	ldr	r3, [r7, #12]
24020aca:	681b      	ldr	r3, [r3, #0]
24020acc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24020ace:	f423 2170 	bic.w	r1, r3, #983040	; 0xf0000
24020ad2:	68fb      	ldr	r3, [r7, #12]
24020ad4:	681b      	ldr	r3, [r3, #0]
24020ad6:	68ba      	ldr	r2, [r7, #8]
24020ad8:	430a      	orrs	r2, r1
24020ada:	669a      	str	r2, [r3, #104]	; 0x68
      break;
24020adc:	e00d      	b.n	24020afa <HAL_TIMEx_TISelection+0xc6>
    case TIM_CHANNEL_4:
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI4SEL, TISelection);
24020ade:	68fb      	ldr	r3, [r7, #12]
24020ae0:	681b      	ldr	r3, [r3, #0]
24020ae2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24020ae4:	f023 6170 	bic.w	r1, r3, #251658240	; 0xf000000
24020ae8:	68fb      	ldr	r3, [r7, #12]
24020aea:	681b      	ldr	r3, [r3, #0]
24020aec:	68ba      	ldr	r2, [r7, #8]
24020aee:	430a      	orrs	r2, r1
24020af0:	669a      	str	r2, [r3, #104]	; 0x68
      break;
24020af2:	e002      	b.n	24020afa <HAL_TIMEx_TISelection+0xc6>
    default:
      status = HAL_ERROR;
24020af4:	2301      	movs	r3, #1
24020af6:	75fb      	strb	r3, [r7, #23]
      break;
24020af8:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
24020afa:	68fb      	ldr	r3, [r7, #12]
24020afc:	2200      	movs	r2, #0
24020afe:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
24020b02:	7dfb      	ldrb	r3, [r7, #23]
}
24020b04:	4618      	mov	r0, r3
24020b06:	371c      	adds	r7, #28
24020b08:	46bd      	mov	sp, r7
24020b0a:	f85d 7b04 	ldr.w	r7, [sp], #4
24020b0e:	4770      	bx	lr

24020b10 <HAL_TIMEx_GroupChannel5>:
  *         TIM_GROUPCH5_OC2REFC: OC2REFC is the logical AND of OC2REFC and OC5REF
  *         TIM_GROUPCH5_OC3REFC: OC3REFC is the logical AND of OC3REFC and OC5REF
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t Channels)
{
24020b10:	b480      	push	{r7}
24020b12:	b083      	sub	sp, #12
24020b14:	af00      	add	r7, sp, #0
24020b16:	6078      	str	r0, [r7, #4]
24020b18:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_GROUPCH5(Channels));

  /* Process Locked */
  __HAL_LOCK(htim);
24020b1a:	687b      	ldr	r3, [r7, #4]
24020b1c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
24020b20:	2b01      	cmp	r3, #1
24020b22:	d101      	bne.n	24020b28 <HAL_TIMEx_GroupChannel5+0x18>
24020b24:	2302      	movs	r3, #2
24020b26:	e020      	b.n	24020b6a <HAL_TIMEx_GroupChannel5+0x5a>
24020b28:	687b      	ldr	r3, [r7, #4]
24020b2a:	2201      	movs	r2, #1
24020b2c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
24020b30:	687b      	ldr	r3, [r7, #4]
24020b32:	2202      	movs	r2, #2
24020b34:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Clear GC5Cx bit fields */
  htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1);
24020b38:	687b      	ldr	r3, [r7, #4]
24020b3a:	681b      	ldr	r3, [r3, #0]
24020b3c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
24020b3e:	687b      	ldr	r3, [r7, #4]
24020b40:	681b      	ldr	r3, [r3, #0]
24020b42:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
24020b46:	659a      	str	r2, [r3, #88]	; 0x58

  /* Set GC5Cx bit fields */
  htim->Instance->CCR5 |= Channels;
24020b48:	687b      	ldr	r3, [r7, #4]
24020b4a:	681b      	ldr	r3, [r3, #0]
24020b4c:	6d99      	ldr	r1, [r3, #88]	; 0x58
24020b4e:	687b      	ldr	r3, [r7, #4]
24020b50:	681b      	ldr	r3, [r3, #0]
24020b52:	683a      	ldr	r2, [r7, #0]
24020b54:	430a      	orrs	r2, r1
24020b56:	659a      	str	r2, [r3, #88]	; 0x58

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
24020b58:	687b      	ldr	r3, [r7, #4]
24020b5a:	2201      	movs	r2, #1
24020b5c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
24020b60:	687b      	ldr	r3, [r7, #4]
24020b62:	2200      	movs	r2, #0
24020b64:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
24020b68:	2300      	movs	r3, #0
}
24020b6a:	4618      	mov	r0, r3
24020b6c:	370c      	adds	r7, #12
24020b6e:	46bd      	mov	sp, r7
24020b70:	f85d 7b04 	ldr.w	r7, [sp], #4
24020b74:	4770      	bx	lr

24020b76 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
24020b76:	b480      	push	{r7}
24020b78:	b083      	sub	sp, #12
24020b7a:	af00      	add	r7, sp, #0
24020b7c:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
24020b7e:	bf00      	nop
24020b80:	370c      	adds	r7, #12
24020b82:	46bd      	mov	sp, r7
24020b84:	f85d 7b04 	ldr.w	r7, [sp], #4
24020b88:	4770      	bx	lr

24020b8a <HAL_TIMEx_CommutHalfCpltCallback>:
  * @brief  Hall commutation changed half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)
{
24020b8a:	b480      	push	{r7}
24020b8c:	b083      	sub	sp, #12
24020b8e:	af00      	add	r7, sp, #0
24020b90:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file
   */
}
24020b92:	bf00      	nop
24020b94:	370c      	adds	r7, #12
24020b96:	46bd      	mov	sp, r7
24020b98:	f85d 7b04 	ldr.w	r7, [sp], #4
24020b9c:	4770      	bx	lr

24020b9e <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
24020b9e:	b480      	push	{r7}
24020ba0:	b083      	sub	sp, #12
24020ba2:	af00      	add	r7, sp, #0
24020ba4:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
24020ba6:	bf00      	nop
24020ba8:	370c      	adds	r7, #12
24020baa:	46bd      	mov	sp, r7
24020bac:	f85d 7b04 	ldr.w	r7, [sp], #4
24020bb0:	4770      	bx	lr

24020bb2 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
24020bb2:	b480      	push	{r7}
24020bb4:	b083      	sub	sp, #12
24020bb6:	af00      	add	r7, sp, #0
24020bb8:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
24020bba:	bf00      	nop
24020bbc:	370c      	adds	r7, #12
24020bbe:	46bd      	mov	sp, r7
24020bc0:	f85d 7b04 	ldr.w	r7, [sp], #4
24020bc4:	4770      	bx	lr

24020bc6 <HAL_TIMEx_HallSensor_GetState>:
  * @brief  Return the TIM Hall Sensor interface handle state.
  * @param  htim TIM Hall Sensor handle
  * @retval HAL state
  */
HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(const TIM_HandleTypeDef *htim)
{
24020bc6:	b480      	push	{r7}
24020bc8:	b083      	sub	sp, #12
24020bca:	af00      	add	r7, sp, #0
24020bcc:	6078      	str	r0, [r7, #4]
  return htim->State;
24020bce:	687b      	ldr	r3, [r7, #4]
24020bd0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24020bd4:	b2db      	uxtb	r3, r3
}
24020bd6:	4618      	mov	r0, r3
24020bd8:	370c      	adds	r7, #12
24020bda:	46bd      	mov	sp, r7
24020bdc:	f85d 7b04 	ldr.w	r7, [sp], #4
24020be0:	4770      	bx	lr

24020be2 <HAL_TIMEx_GetChannelNState>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2
  *            @arg TIM_CHANNEL_3: TIM Channel 3
  * @retval TIM Complementary channel state
  */
HAL_TIM_ChannelStateTypeDef HAL_TIMEx_GetChannelNState(const TIM_HandleTypeDef *htim,  uint32_t ChannelN)
{
24020be2:	b480      	push	{r7}
24020be4:	b085      	sub	sp, #20
24020be6:	af00      	add	r7, sp, #0
24020be8:	6078      	str	r0, [r7, #4]
24020bea:	6039      	str	r1, [r7, #0]
  HAL_TIM_ChannelStateTypeDef channel_state;

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, ChannelN));

  channel_state = TIM_CHANNEL_N_STATE_GET(htim, ChannelN);
24020bec:	683b      	ldr	r3, [r7, #0]
24020bee:	2b00      	cmp	r3, #0
24020bf0:	d104      	bne.n	24020bfc <HAL_TIMEx_GetChannelNState+0x1a>
24020bf2:	687b      	ldr	r3, [r7, #4]
24020bf4:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
24020bf8:	b2db      	uxtb	r3, r3
24020bfa:	e013      	b.n	24020c24 <HAL_TIMEx_GetChannelNState+0x42>
24020bfc:	683b      	ldr	r3, [r7, #0]
24020bfe:	2b04      	cmp	r3, #4
24020c00:	d104      	bne.n	24020c0c <HAL_TIMEx_GetChannelNState+0x2a>
24020c02:	687b      	ldr	r3, [r7, #4]
24020c04:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
24020c08:	b2db      	uxtb	r3, r3
24020c0a:	e00b      	b.n	24020c24 <HAL_TIMEx_GetChannelNState+0x42>
24020c0c:	683b      	ldr	r3, [r7, #0]
24020c0e:	2b08      	cmp	r3, #8
24020c10:	d104      	bne.n	24020c1c <HAL_TIMEx_GetChannelNState+0x3a>
24020c12:	687b      	ldr	r3, [r7, #4]
24020c14:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
24020c18:	b2db      	uxtb	r3, r3
24020c1a:	e003      	b.n	24020c24 <HAL_TIMEx_GetChannelNState+0x42>
24020c1c:	687b      	ldr	r3, [r7, #4]
24020c1e:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
24020c22:	b2db      	uxtb	r3, r3
24020c24:	73fb      	strb	r3, [r7, #15]

  return channel_state;
24020c26:	7bfb      	ldrb	r3, [r7, #15]
}
24020c28:	4618      	mov	r0, r3
24020c2a:	3714      	adds	r7, #20
24020c2c:	46bd      	mov	sp, r7
24020c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
24020c32:	4770      	bx	lr

24020c34 <TIMEx_DMACommutationCplt>:
  * @brief  TIM DMA Commutation callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
{
24020c34:	b580      	push	{r7, lr}
24020c36:	b084      	sub	sp, #16
24020c38:	af00      	add	r7, sp, #0
24020c3a:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
24020c3c:	687b      	ldr	r3, [r7, #4]
24020c3e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24020c40:	60fb      	str	r3, [r7, #12]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
24020c42:	68fb      	ldr	r3, [r7, #12]
24020c44:	2201      	movs	r2, #1
24020c46:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->CommutationCallback(htim);
#else
  HAL_TIMEx_CommutCallback(htim);
24020c4a:	68f8      	ldr	r0, [r7, #12]
24020c4c:	f7ff ff93 	bl	24020b76 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
}
24020c50:	bf00      	nop
24020c52:	3710      	adds	r7, #16
24020c54:	46bd      	mov	sp, r7
24020c56:	bd80      	pop	{r7, pc}

24020c58 <TIMEx_DMACommutationHalfCplt>:
  * @brief  TIM DMA Commutation half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
void TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)
{
24020c58:	b580      	push	{r7, lr}
24020c5a:	b084      	sub	sp, #16
24020c5c:	af00      	add	r7, sp, #0
24020c5e:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
24020c60:	687b      	ldr	r3, [r7, #4]
24020c62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24020c64:	60fb      	str	r3, [r7, #12]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
24020c66:	68fb      	ldr	r3, [r7, #12]
24020c68:	2201      	movs	r2, #1
24020c6a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->CommutationHalfCpltCallback(htim);
#else
  HAL_TIMEx_CommutHalfCpltCallback(htim);
24020c6e:	68f8      	ldr	r0, [r7, #12]
24020c70:	f7ff ff8b 	bl	24020b8a <HAL_TIMEx_CommutHalfCpltCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
}
24020c74:	bf00      	nop
24020c76:	3710      	adds	r7, #16
24020c78:	46bd      	mov	sp, r7
24020c7a:	bd80      	pop	{r7, pc}

24020c7c <TIM_DMADelayPulseNCplt>:
  * @brief  TIM DMA Delay Pulse complete callback (complementary channel).
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
static void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma)
{
24020c7c:	b580      	push	{r7, lr}
24020c7e:	b084      	sub	sp, #16
24020c80:	af00      	add	r7, sp, #0
24020c82:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
24020c84:	687b      	ldr	r3, [r7, #4]
24020c86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24020c88:	60fb      	str	r3, [r7, #12]

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
24020c8a:	68fb      	ldr	r3, [r7, #12]
24020c8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24020c8e:	687a      	ldr	r2, [r7, #4]
24020c90:	429a      	cmp	r2, r3
24020c92:	d10b      	bne.n	24020cac <TIM_DMADelayPulseNCplt+0x30>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
24020c94:	68fb      	ldr	r3, [r7, #12]
24020c96:	2201      	movs	r2, #1
24020c98:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
24020c9a:	687b      	ldr	r3, [r7, #4]
24020c9c:	69db      	ldr	r3, [r3, #28]
24020c9e:	2b00      	cmp	r3, #0
24020ca0:	d136      	bne.n	24020d10 <TIM_DMADelayPulseNCplt+0x94>
    {
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
24020ca2:	68fb      	ldr	r3, [r7, #12]
24020ca4:	2201      	movs	r2, #1
24020ca6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24020caa:	e031      	b.n	24020d10 <TIM_DMADelayPulseNCplt+0x94>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
24020cac:	68fb      	ldr	r3, [r7, #12]
24020cae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24020cb0:	687a      	ldr	r2, [r7, #4]
24020cb2:	429a      	cmp	r2, r3
24020cb4:	d10b      	bne.n	24020cce <TIM_DMADelayPulseNCplt+0x52>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
24020cb6:	68fb      	ldr	r3, [r7, #12]
24020cb8:	2202      	movs	r2, #2
24020cba:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
24020cbc:	687b      	ldr	r3, [r7, #4]
24020cbe:	69db      	ldr	r3, [r3, #28]
24020cc0:	2b00      	cmp	r3, #0
24020cc2:	d125      	bne.n	24020d10 <TIM_DMADelayPulseNCplt+0x94>
    {
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
24020cc4:	68fb      	ldr	r3, [r7, #12]
24020cc6:	2201      	movs	r2, #1
24020cc8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24020ccc:	e020      	b.n	24020d10 <TIM_DMADelayPulseNCplt+0x94>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
24020cce:	68fb      	ldr	r3, [r7, #12]
24020cd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24020cd2:	687a      	ldr	r2, [r7, #4]
24020cd4:	429a      	cmp	r2, r3
24020cd6:	d10b      	bne.n	24020cf0 <TIM_DMADelayPulseNCplt+0x74>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
24020cd8:	68fb      	ldr	r3, [r7, #12]
24020cda:	2204      	movs	r2, #4
24020cdc:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
24020cde:	687b      	ldr	r3, [r7, #4]
24020ce0:	69db      	ldr	r3, [r3, #28]
24020ce2:	2b00      	cmp	r3, #0
24020ce4:	d114      	bne.n	24020d10 <TIM_DMADelayPulseNCplt+0x94>
    {
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
24020ce6:	68fb      	ldr	r3, [r7, #12]
24020ce8:	2201      	movs	r2, #1
24020cea:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
24020cee:	e00f      	b.n	24020d10 <TIM_DMADelayPulseNCplt+0x94>
    }
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
24020cf0:	68fb      	ldr	r3, [r7, #12]
24020cf2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24020cf4:	687a      	ldr	r2, [r7, #4]
24020cf6:	429a      	cmp	r2, r3
24020cf8:	d10a      	bne.n	24020d10 <TIM_DMADelayPulseNCplt+0x94>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
24020cfa:	68fb      	ldr	r3, [r7, #12]
24020cfc:	2208      	movs	r2, #8
24020cfe:	771a      	strb	r2, [r3, #28]

    if (hdma->Init.Mode == DMA_NORMAL)
24020d00:	687b      	ldr	r3, [r7, #4]
24020d02:	69db      	ldr	r3, [r3, #28]
24020d04:	2b00      	cmp	r3, #0
24020d06:	d103      	bne.n	24020d10 <TIM_DMADelayPulseNCplt+0x94>
    {
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
24020d08:	68fb      	ldr	r3, [r7, #12]
24020d0a:	2201      	movs	r2, #1
24020d0c:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->PWM_PulseFinishedCallback(htim);
#else
  HAL_TIM_PWM_PulseFinishedCallback(htim);
24020d10:	68f8      	ldr	r0, [r7, #12]
24020d12:	f7fc fb7b 	bl	2401d40c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
24020d16:	68fb      	ldr	r3, [r7, #12]
24020d18:	2200      	movs	r2, #0
24020d1a:	771a      	strb	r2, [r3, #28]
}
24020d1c:	bf00      	nop
24020d1e:	3710      	adds	r7, #16
24020d20:	46bd      	mov	sp, r7
24020d22:	bd80      	pop	{r7, pc}

24020d24 <TIM_DMAErrorCCxN>:
  * @brief  TIM DMA error callback (complementary channel)
  * @param  hdma pointer to DMA handle.
  * @retval None
  */
static void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma)
{
24020d24:	b580      	push	{r7, lr}
24020d26:	b084      	sub	sp, #16
24020d28:	af00      	add	r7, sp, #0
24020d2a:	6078      	str	r0, [r7, #4]
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
24020d2c:	687b      	ldr	r3, [r7, #4]
24020d2e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24020d30:	60fb      	str	r3, [r7, #12]

  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
24020d32:	68fb      	ldr	r3, [r7, #12]
24020d34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24020d36:	687a      	ldr	r2, [r7, #4]
24020d38:	429a      	cmp	r2, r3
24020d3a:	d107      	bne.n	24020d4c <TIM_DMAErrorCCxN+0x28>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
24020d3c:	68fb      	ldr	r3, [r7, #12]
24020d3e:	2201      	movs	r2, #1
24020d40:	771a      	strb	r2, [r3, #28]
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
24020d42:	68fb      	ldr	r3, [r7, #12]
24020d44:	2201      	movs	r2, #1
24020d46:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
24020d4a:	e018      	b.n	24020d7e <TIM_DMAErrorCCxN+0x5a>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
24020d4c:	68fb      	ldr	r3, [r7, #12]
24020d4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24020d50:	687a      	ldr	r2, [r7, #4]
24020d52:	429a      	cmp	r2, r3
24020d54:	d107      	bne.n	24020d66 <TIM_DMAErrorCCxN+0x42>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
24020d56:	68fb      	ldr	r3, [r7, #12]
24020d58:	2202      	movs	r2, #2
24020d5a:	771a      	strb	r2, [r3, #28]
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
24020d5c:	68fb      	ldr	r3, [r7, #12]
24020d5e:	2201      	movs	r2, #1
24020d60:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
24020d64:	e00b      	b.n	24020d7e <TIM_DMAErrorCCxN+0x5a>
  }
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
24020d66:	68fb      	ldr	r3, [r7, #12]
24020d68:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24020d6a:	687a      	ldr	r2, [r7, #4]
24020d6c:	429a      	cmp	r2, r3
24020d6e:	d106      	bne.n	24020d7e <TIM_DMAErrorCCxN+0x5a>
  {
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
24020d70:	68fb      	ldr	r3, [r7, #12]
24020d72:	2204      	movs	r2, #4
24020d74:	771a      	strb	r2, [r3, #28]
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
24020d76:	68fb      	ldr	r3, [r7, #12]
24020d78:	2201      	movs	r2, #1
24020d7a:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
  }

#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
  htim->ErrorCallback(htim);
#else
  HAL_TIM_ErrorCallback(htim);
24020d7e:	68f8      	ldr	r0, [r7, #12]
24020d80:	f7fc fb6c 	bl	2401d45c <HAL_TIM_ErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
24020d84:	68fb      	ldr	r3, [r7, #12]
24020d86:	2200      	movs	r2, #0
24020d88:	771a      	strb	r2, [r3, #28]
}
24020d8a:	bf00      	nop
24020d8c:	3710      	adds	r7, #16
24020d8e:	46bd      	mov	sp, r7
24020d90:	bd80      	pop	{r7, pc}

24020d92 <TIM_CCxNChannelCmd>:
  * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
  * @retval None
  */
static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)
{
24020d92:	b480      	push	{r7}
24020d94:	b087      	sub	sp, #28
24020d96:	af00      	add	r7, sp, #0
24020d98:	60f8      	str	r0, [r7, #12]
24020d9a:	60b9      	str	r1, [r7, #8]
24020d9c:	607a      	str	r2, [r7, #4]
  uint32_t tmp;

  tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
24020d9e:	68bb      	ldr	r3, [r7, #8]
24020da0:	f003 031f 	and.w	r3, r3, #31
24020da4:	2204      	movs	r2, #4
24020da6:	fa02 f303 	lsl.w	r3, r2, r3
24020daa:	617b      	str	r3, [r7, #20]

  /* Reset the CCxNE Bit */
  TIMx->CCER &=  ~tmp;
24020dac:	68fb      	ldr	r3, [r7, #12]
24020dae:	6a1a      	ldr	r2, [r3, #32]
24020db0:	697b      	ldr	r3, [r7, #20]
24020db2:	43db      	mvns	r3, r3
24020db4:	401a      	ands	r2, r3
24020db6:	68fb      	ldr	r3, [r7, #12]
24020db8:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxNE Bit */
  TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
24020dba:	68fb      	ldr	r3, [r7, #12]
24020dbc:	6a1a      	ldr	r2, [r3, #32]
24020dbe:	68bb      	ldr	r3, [r7, #8]
24020dc0:	f003 031f 	and.w	r3, r3, #31
24020dc4:	6879      	ldr	r1, [r7, #4]
24020dc6:	fa01 f303 	lsl.w	r3, r1, r3
24020dca:	431a      	orrs	r2, r3
24020dcc:	68fb      	ldr	r3, [r7, #12]
24020dce:	621a      	str	r2, [r3, #32]
}
24020dd0:	bf00      	nop
24020dd2:	371c      	adds	r7, #28
24020dd4:	46bd      	mov	sp, r7
24020dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
24020dda:	4770      	bx	lr

24020ddc <__errno>:
24020ddc:	4b01      	ldr	r3, [pc, #4]	; (24020de4 <__errno+0x8>)
24020dde:	6818      	ldr	r0, [r3, #0]
24020de0:	4770      	bx	lr
24020de2:	bf00      	nop
24020de4:	240004c0 	.word	0x240004c0

24020de8 <exit>:
24020de8:	b508      	push	{r3, lr}
24020dea:	4b07      	ldr	r3, [pc, #28]	; (24020e08 <exit+0x20>)
24020dec:	4604      	mov	r4, r0
24020dee:	b113      	cbz	r3, 24020df6 <exit+0xe>
24020df0:	2100      	movs	r1, #0
24020df2:	f3af 8000 	nop.w
24020df6:	4b05      	ldr	r3, [pc, #20]	; (24020e0c <exit+0x24>)
24020df8:	6818      	ldr	r0, [r3, #0]
24020dfa:	6a83      	ldr	r3, [r0, #40]	; 0x28
24020dfc:	b103      	cbz	r3, 24020e00 <exit+0x18>
24020dfe:	4798      	blx	r3
24020e00:	4620      	mov	r0, r4
24020e02:	f7e0 fccc 	bl	2400179e <_exit>
24020e06:	bf00      	nop
24020e08:	00000000 	.word	0x00000000
24020e0c:	24020fac 	.word	0x24020fac

24020e10 <__libc_init_array>:
24020e10:	b570      	push	{r4, r5, r6, lr}
24020e12:	4d0d      	ldr	r5, [pc, #52]	; (24020e48 <__libc_init_array+0x38>)
24020e14:	4c0d      	ldr	r4, [pc, #52]	; (24020e4c <__libc_init_array+0x3c>)
24020e16:	1b64      	subs	r4, r4, r5
24020e18:	10a4      	asrs	r4, r4, #2
24020e1a:	2600      	movs	r6, #0
24020e1c:	42a6      	cmp	r6, r4
24020e1e:	d109      	bne.n	24020e34 <__libc_init_array+0x24>
24020e20:	4d0b      	ldr	r5, [pc, #44]	; (24020e50 <__libc_init_array+0x40>)
24020e22:	4c0c      	ldr	r4, [pc, #48]	; (24020e54 <__libc_init_array+0x44>)
24020e24:	f000 f822 	bl	24020e6c <_init>
24020e28:	1b64      	subs	r4, r4, r5
24020e2a:	10a4      	asrs	r4, r4, #2
24020e2c:	2600      	movs	r6, #0
24020e2e:	42a6      	cmp	r6, r4
24020e30:	d105      	bne.n	24020e3e <__libc_init_array+0x2e>
24020e32:	bd70      	pop	{r4, r5, r6, pc}
24020e34:	f855 3b04 	ldr.w	r3, [r5], #4
24020e38:	4798      	blx	r3
24020e3a:	3601      	adds	r6, #1
24020e3c:	e7ee      	b.n	24020e1c <__libc_init_array+0xc>
24020e3e:	f855 3b04 	ldr.w	r3, [r5], #4
24020e42:	4798      	blx	r3
24020e44:	3601      	adds	r6, #1
24020e46:	e7f2      	b.n	24020e2e <__libc_init_array+0x1e>
24020e48:	240004a0 	.word	0x240004a0
24020e4c:	240004a0 	.word	0x240004a0
24020e50:	240004a0 	.word	0x240004a0
24020e54:	240004a4 	.word	0x240004a4

24020e58 <memset>:
24020e58:	4402      	add	r2, r0
24020e5a:	4603      	mov	r3, r0
24020e5c:	4293      	cmp	r3, r2
24020e5e:	d100      	bne.n	24020e62 <memset+0xa>
24020e60:	4770      	bx	lr
24020e62:	f803 1b01 	strb.w	r1, [r3], #1
24020e66:	e7f9      	b.n	24020e5c <memset+0x4>

24020e68 <__EH_FRAME_BEGIN__>:
24020e68:	0000 0000                                   ....

24020e6c <_init>:
24020e6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24020e6e:	bf00      	nop
24020e70:	bcf8      	pop	{r3, r4, r5, r6, r7}
24020e72:	bc08      	pop	{r3}
24020e74:	469e      	mov	lr, r3
24020e76:	4770      	bx	lr

24020e78 <_fini>:
24020e78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24020e7a:	bf00      	nop
24020e7c:	bcf8      	pop	{r3, r4, r5, r6, r7}
24020e7e:	bc08      	pop	{r3}
24020e80:	469e      	mov	lr, r3
24020e82:	4770      	bx	lr
